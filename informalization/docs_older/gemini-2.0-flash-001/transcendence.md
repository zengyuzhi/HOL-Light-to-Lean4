# transcendence.ml

## Overview

Number of statements: 1060

`transcendence.ml` formalizes the transcendence of *e* and *π*, and, more generally, Lindemann's theorem stating that if α₁, ..., αₙ are algebraic numbers linearly independent over ℚ, then exp(α₁), ..., exp(αₙ) are algebraically independent over ℚ. The file proves key results such as `e_is_irrational`, `e_is_transcendental`, `pi_is_transcendental`, and `zero_sum_algebraic_exp_algebraic`, which is the core theorem about sums of algebraic numbers multiplied by exponentials of algebraic numbers. The proofs rely on formal power series identities and the fundamental theorem of symmetric functions, drawing from imported theories on products, ring theory, and complex analysis.


## rw

### Name of formal statement
rw

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let rw = REWRITE_TAC;;
```

### Informal statement
Define `rw` to be the rewrite tactic `REWRITE_TAC`.

### Informal sketch
The definition simply assigns the rewrite tactic `REWRITE_TAC` to the identifier `rw`. This tactic applies rewrite rules based on equational theorems.

### Mathematical insight
This definition introduces a shorthand for invoking the rewrite tactic `REWRITE_TAC`, commonly used for simplifying expressions or transforming them based on known equalities. It enhances readability and conciseness within HOL Light proof scripts.

### Dependencies
- `REWRITE_TAC`


---

## once_rw

### Name of formal statement
`once_rw`

### Type of the formal statement
Definition

### Formal Content
```ocaml
let once_rw = ONCE_REWRITE_TAC;;
```

### Informal statement
Define `once_rw` to be the tactic `ONCE_REWRITE_TAC`.

### Informal sketch
The definition simply assigns the tactic `ONCE_REWRITE_TAC` to the identifier `once_rw`. There is no proof involved as it is a direct definition. `ONCE_REWRITE_TAC` applies a given equational rewrite rule exactly once at the top level of the goal.

### Mathematical insight
This definition introduces a convenient shorthand `once_rw` for a commonly used tactic `ONCE_REWRITE_TAC`. It improves readability and conciseness when applying a rewrite rule only once.

### Dependencies
- Tactics: `ONCE_REWRITE_TAC`

### Porting notes (optional)
In other proof assistants, one would define a tactic (or macro) named `once_rw` that performs a single rewriting step at the root of the current goal. The exact implementation would depend on the specific tactic language. For example, in Coq, one might use `Ltac once_rw := ...`. Lean would have a similar `macro` or `tactic` definition. The major implementation difference would be how to restrict it to apply the rewrite only at the top level/root of the goal.


---

## qed

### Name of formal statement
qed

### Type of the formal statement
Theorem proving tactic

### Formal Content
```ocaml
let qed = ASM_MESON_TAC;;
```

### Informal statement
The tactic `qed` is defined as `ASM_MESON_TAC`.

### Informal sketch
The `qed` tactic is assigned to `ASM_MESON_TAC`. The action of `ASM_MESON_TAC` is to attempt to prove the current goal using a combination of assumptions from the assumption list (`ASM_`) and the external `MESON` decision procedure for first-order logic. This tactic automatically discharges the goal if `MESON` can find a proof using the current assumptions and the available first-order reasoning.

### Mathematical insight
The `qed` tactic is a convenience tactic, a standard way of closing off a proof in HOL Light. It calls the automated first order theorem prover to complete the proof using any available assumption made during the proof.

### Dependencies
None

### Porting notes (optional)
In other proof assistants, the functionality of `ASM_MESON_TAC` is typically provided by a combination of tactics. First, collect the assumptions using a tactic like `intros` or `apply H` for each hypothesis `H`. Then, invoke a first-order automated reasoning tool similar to `MESON`. In Coq, `auto`, `tauto`, or `omega` can be useful. In Lean, `simp` or `norm_num` may be needed beforehand to simplify the goal, then `solve_by_elim` or `tactic.smt` can be used. In Isabelle, `auto` or `metis` tactic may be used.


---

## simp

### Name of formal statement
simp

### Type of the formal statement
Theorem (Tactic)

### Formal Content
```ocaml
let simp = ASM_SIMP_TAC;;
```
### Informal statement
`simp` is defined as a tactic called `ASM_SIMP_TAC`.

### Informal sketch
The definition assigns `ASM_SIMP_TAC` to the identifier `simp`. The tactic `ASM_SIMP_TAC` performs simplification using assumptions in the assumption list.

### Mathematical insight
This definition introduces a convenient shorthand `simp` for the more verbose tactic `ASM_SIMP_TAC`. This tactic is a basic simplification tactic that uses the current assumptions to simplify the goal. Such tactics are important for automating basic reasoning steps.

### Dependencies
None

### Porting notes (optional)
Most proof assistants have an equivalent tactic for simplification using assumptions, such as `simp` in Isabelle/HOL, `simpl` in Coq, or `simp` in Lean. The main challenge will be ensuring that the appropriate assumptions are in the assumption list before invoking the tactic.


---

## simporqed

### Name of formal statement
`simporqed`

### Type of the formal statement
theorem

### Formal Content
```ocaml
let simporqed = (simp[] THEN qed[]) ORELSE (simp[]);;
```

### Informal statement
The tactic `simporqed` is defined as a tactic that first attempts to apply the simplification tactic `simp[]` followed by the proof completion tactic `qed[]`. If this fails, it applies the simplification tactic `simp[]`.

### Informal sketch
The tactic `simporqed` is a composed tactic that combines simplification and proof completion.
- The tactic first tries to apply `simp[]` to simplify the goal and then attempts to complete the proof using `qed[]`. This suggests an attempt to completely solve the goal by simplification.
- If the first part fails (i.e., `simp[]` followed by `qed[]` does not close the goal), then the tactic falls back to simply applying `simp[]`. This potentially reduces the goal to something simpler, even if it doesn't solve it completely.
- The `ORELSE` combinator provides a fallback mechanism.

### Mathematical insight
This tactic is a common pattern in proof automation. It first attempts a strong simplification and proof completion strategy. If that fails, it falls back to a more general simplification to make progress. This is useful when the goal is expected to be easily provable by simplification or when a more basic simplification step is needed before more advanced tactics can be applied.

### Dependencies
- `simp[]`
- `qed[]`

### Porting notes (optional)
The `ORELSE` tactic combinator might have different names or semantics in other proof assistants. Be sure to understand the exact execution order and behavior of the corresponding tactic combinator. Also, be aware of the behavior of `simp[]` and `qed[]` in HOL Light, and try to replicate the behavior with suitable tactics in the target proof assistant (e.g., `auto`, `simpl`, `reflexivity`).


---

## pass

### Name of formal statement
pass

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let pass = ALL_TAC;;
```
### Informal statement
Define `pass` as the tactic that always succeeds without changing the goal.

### Informal sketch
- The definition introduces `pass` as equivalent to `ALL_TAC`.
- `ALL_TAC` is a built-in tactic that always succeeds and leaves the goal unchanged, essentially doing nothing.

### Mathematical insight
The `pass` tactic is useful as a placeholder or as a no-op tactic in situations where a tactic is required but no actual transformation is needed. It's often used for structuring tactic scripts or when a condition dictates doing nothing.

### Dependencies
None

### Porting notes (optional)
Most proof assistants have a similar tactic that does nothing, sometimes called `idtac` in Coq. The challenge is recognizing where such a placeholder tactic would be valuable, as HOL Light uses it fairly often to compose more complex tactic expressions.


---

## case

### Name of formal statement
case

### Type of the formal statement
Theorem

### Formal Content
```ocaml
let case = ASM_CASES_TAC;;
```
### Informal statement
The tactic `case` is defined as `ASM_CASES_TAC`.

### Informal sketch
The theorem simply defines the tactic `case` to be an alias for the tactic `ASM_CASES_TAC`. This tactic likely performs case splitting based on assumptions in the assumption list (`ASM`). The exact behavior depends on the definition of `ASM_CASES_TAC`.

### Mathematical insight
This is a definitional convenience, providing a shorter name `case` for a more descriptive tactic `ASM_CASES_TAC`. The importance lies in the functionality of `ASM_CASES_TAC` itself which probably deals with case analysis.

### Dependencies
None specific; the definition relies on `ASM_CASES_TAC`.

### Porting notes (optional)
In other proof assistants, the equivalent of `case` would be implemented as a tactic definition or alias. The functionality of `ASM_CASES_TAC` would need to be re-implemented or mapped to existing tactics. The specific implementation will depend on the target proof assistant's facilities for assumption management and case splitting.


---

## conjunction

### Name of formal statement
conjunction

### Type of the formal statement
Theorem-proving tactic

### Formal Content
```ocaml
let conjunction = CONJ_TAC;;
```
### Informal statement
The tactic `CONJ_TAC` is a theorem-proving tactic in HOL Light. 

### Informal sketch
The tactic `CONJ_TAC` is used to prove theorems of the form `A /\ B`. It works by splitting the goal `A /\ B` into two subgoals: `A` and `B`. The tactic is applicable only when the goal is a conjunction.

### Mathematical insight
The tactic `CONJ_TAC` implements the standard rule for proving conjunctions: to prove `A /\ B`, one must prove both `A` and `B` separately. This is a fundamental logical principle.

### Dependencies
None

### Porting notes (optional)
Most proof assistants will have a similar tactic for splitting conjunctive goals. In Coq, this is often achieved with the `split` tactic. In Lean, the `constructor` tactic can often be used. Make sure the target system's tactic applies only to conjunctive goals.


---

## splitiff

### Name of formal statement
splitiff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let splitiff = EQ_TAC;;
```
### Informal statement
The tactic `EQ_TAC` is assigned to the variable `splitiff`.

### Informal sketch
The statement defines `splitiff` to be the tactic `EQ_TAC`. The `EQ_TAC` tactic attempts to prove a goal by replacing it with the assertion that the left-hand side of the equation is equal to the right-hand side. This tactic is a basic equality prover in HOL Light.

### Mathematical insight
The usefulness of this lies in assigning a meaningful name `splitiff` to a common and useful tactic. This enhances readability and maintainability of tactic scripts. It implicitly relies on the notion that equality is fundamental in logic, and that equational reasoning is a core aspect of proof construction within HOL Light. This is particularly useful when dealing with definitions where the goal is to show that two expressions are equal.

### Dependencies
- `EQ_TAC`


---

## know

### Name of formal statement
know

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let know = ASSUME;;
```

### Informal statement
Define `know` to be `ASSUME`.

### Informal sketch
The definition introduces `know` and equates it to `ASSUME`. There is no proof sketch required, as this is a direct definition using `ASSUME`.

### Mathematical insight
This likely is a placeholder definition, often used to introduce an axiom by giving it a name through definition. `ASSUME` introduces something as an axiom which means it is assumed to be true without proof.

### Dependencies
None

### Porting notes (optional)
Most proof assistants have a mechanism to introduce axioms with a name. This definition should be ported as an axiom declaration with the name `know`.


---

## sufficesby_bare

### Name of formal statement
sufficesby_bare

### Type of the formal statement
theorem

### Formal Content
```ocaml
let sufficesby_bare x = MATCH_MP_TAC x;;
```

### Informal statement
The tactic `sufficesby_bare` is defined as applying `MATCH_MP_TAC` to the input term `x`.

### Informal sketch
The tactic `sufficesby_bare` takes a term `x` as input and applies the `MATCH_MP_TAC` tactic to it. The `MATCH_MP_TAC` tactic attempts to match the current goal against the antecedent of the input term `x`, which is expected to be an implication `A ==> B`. If the match is successful, the tactic reduces the goal to proving the instantiated consequent `B`.

*   The input `x` is an implication `A ==> B`.
*   `MATCH_MP_TAC x` will attempt to match `A` against the current goal.
*   If the matching is successful, it will replace the current goal of proving `A` with the new goal of proving `B`.

### Mathematical insight
The tactic `sufficesby_bare` is a basic tactic used to refine a goal by showing that it suffices to prove something else. Specifically, given a goal `A` and a theorem `A' ==> B`, where `A'` matches `A` under some instantiation, we can replace the goal `A` with the goal `B` (under that instantiation).

### Dependencies
- Tactics: `MATCH_MP_TAC`


---

## sufficesby

### Name of formal statement
sufficesby

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let sufficesby x = sufficesby_bare(REWRITE_RULE[GSYM IMP_CONJ] x);;
```

### Informal statement
The function `sufficesby` is defined as taking an argument `x` and applying the function `sufficesby_bare` to the result of rewriting `x` using the generalized symmetric implication conjunction rule (`GSYM IMP_CONJ`). In other words, `sufficesby x` is defined to be `sufficesby_bare(REWRITE_RULE[GSYM IMP_CONJ] x)`.

### Informal sketch
* The definition introduces `sufficesby` by using `sufficesby_bare` after applying the rewrite rule `REWRITE_RULE[GSYM IMP_CONJ]` to the input `x`.
* `REWRITE_RULE[GSYM IMP_CONJ]` transforms the input `x` using the symmetric implication-conjunction rule. The `GSYM` indicates the symmetric version of the implication conjunction rule (`IMP_CONJ`).
* `sufficesby_bare` processes the rewritten input `x`.

### Mathematical insight
The `sufficesby` function likely simplifies the process of using `sufficesby_bare` with a specific rewrite rule, providing a more convenient interface for users. The symmetric implication conjunction rule likely rearranges implications and conjunctions in a specific manner which helps in applying the `sufficesby_bare` function.

### Dependencies
- Definition: `sufficesby_bare`
- Theorem: `GSYM IMP_CONJ`


---

## intro

### Name of formal statement
intro

### Type of the formal statement
Definition

### Formal Content
```ocaml
let intro = REPEAT STRIP_TAC;;
```

### Informal statement
The definition `intro` is a tactic that repeatedly applies the tactic `STRIP_TAC`.

### Informal sketch
The tactic `intro` is defined as repeatedly applying `STRIP_TAC` until it no longer has an effect. The tactic `STRIP_TAC` simplifies the goal state by stripping away the outermost logical connectives, such as quantifiers, implications, etc., and adding their components to the assumptions or the goal as appropriate. Specifically, it performs beta-conversion, eliminates outermost existential quantifiers by introducing a Skolem constant, moves antecedent of implications to the assumption list, splits conjunctive goals into subgoals and adds assumptions of the form `x = y` to the assumption list, replacing all occurrences of `x` with `y`.

### Mathematical insight
The tactic `intro` is commonly used at the beginning of a proof to decompose the initial goal into simpler subgoals and assumptions. It automates much of the standard logical reasoning that is typically required to set up a proof in a usable format. The tactic is useful to automatically decompose a goal into assumptions and target to use later.

### Dependencies
- `STRIP_TAC`
- `REPEAT`

### Porting notes (optional)
Porting this definition to another proof assistant requires translating the `STRIP_TAC` tactic and the `REPEAT` combinator. The `STRIP_TAC` tactic performs several operations, including beta-conversion, Skolemization, implication elimination, and conjunction splitting. The `REPEAT` combinator applies a given tactic repeatedly until it fails or has no further effect. In Coq, a similar effect can be achieved using the `repeat` tactic in combination with more basic tactics such as `intros`, `split`, and `assumption`. In Lean, the `intros` and `constructor` tactics, along with the `repeat` tactic, can be used to replicate the behaviour of `intro`.


---

## intro_genonly

### Name of formal statement
intro_genonly

### Type of the formal statement
Tactical Definition

### Formal Content
```ocaml
let intro_genonly = REPEAT GEN_TAC;;
```

### Informal statement
Define the tactic `intro_genonly` to be the tactic that repeatedly applies the tactic `GEN_TAC`.

### Informal sketch
The tactic `intro_genonly` is defined as the repetition of the tactic `GEN_TAC`.
- `GEN_TAC` is a tactic that applies the rule of generalization to the current goal. Specifically, if the goal is of the form `|- P[x]`, the tactic will produce a new goal `|- !x. P[x]`.
- The repetition of `GEN_TAC` will continue to generalize variables until no more generalization is possible. This means that all free variables in the assumptions and the goal will be generalized.

### Mathematical insight
The tactic `intro_genonly` provides a convenient way to universally quantify all free variables in the current goal and assumptions. This is useful when formalizing theorems that are intended to hold for all possible values of those variables.

### Dependencies
None

### Porting notes (optional)
In other proof assistants, the equivalent of `GEN_TAC` may have a slightly different name or require a slightly different syntax. However, the basic idea of generalizing free variables is common to most proof assistants. The `REPEAT` combinator should be available in other proof assistants too. In Coq, `repeat` can be used; in Isabelle/Isar, the `simp` tactic combined with `auto` might achieve similar results.


---

## intro_gendisch

### Name of formal statement
intro_gendisch

### Type of the formal statement
Theorem-proving tactic

### Formal Content
```ocaml
let intro_gendisch = REPEAT GEN_TAC THEN REPEAT DISCH_TAC;;
```
### Informal statement
The tactic `intro_gendisch` repeatedly applies the `GEN_TAC` tactic followed by repeatedly applying the `DISCH_TAC` tactic.

### Informal sketch
The tactic `intro_gendisch` is a composite tactic that performs two stages of logical manipulation.

- Stage 1: Repeat `GEN_TAC`. `GEN_TAC` universally quantifies over the goal, introducing a new variable. This is repeated so that we introduce all possible universal quantifiers.
- Stage 2: Repeat `DISCH_TAC`. `DISCH_TAC` discharges the assumptions of implications. This is repeated so that we discharge all possible assumptions.

In effect, this tactic transforms goals of the form `!x1...xn. A1 ==> ... ==> Am ==> C` to the goal `C` with assumptions `x1...xn` and `A1...Am`.

### Mathematical insight
This tactic is a common simplification step that introduces assumptions in the context, and makes universal quantifications into assumptions. It's a preliminary step in many proofs to bring the goal into a more usable format.

### Dependencies
- `GEN_TAC`
- `DISCH_TAC`
- `REPEAT`


---

## subgoal

### Name of formal statement
subgoal

### Type of the formal statement
Definition

### Formal Content
```ocaml
let subgoal t = SUBGOAL_THEN t ASSUME_TAC;;
```

### Informal statement
Define `subgoal` as a function that takes a term `t` as input, and applies the tactic `SUBGOAL_THEN` to `t` and then applies the tactic `ASSUME_TAC`.

### Informal sketch
- The function `subgoal` takes a term `t` as input.
- The tactic `SUBGOAL_THEN` is applied to `t`: This tactic splits the current goal into two subgoals: one to show `t`, and another where `t` is assumed as an hypothesis.
- The tactic `ASSUME_TAC` is then applied: Assuming that the assumption list contains a hypothesis identical to the goal, this tactic solves the goal by assumption. Typically, this will discharge the subgoal of proving `t`.

### Mathematical insight
This function `subgoal` is a setup for a common proof pattern: stating a lemma as a subgoal and then immediately assuming it as an assumption to prove the original goal. It simplifies the proof process by introducing a clear intermediate step.

### Dependencies
- `SUBGOAL_THEN`
- `ASSUME_TAC`


---

## witness

### Name of formal statement
witness

### Type of the formal statement
Theorem proving tactic

### Formal Content
```ocaml
let witness = EXISTS_TAC;;
```

### Informal statement
`witness` is defined to be the tactic `EXISTS_TAC`.

### Informal sketch
- The tactic `witness` is simply an alias for the fundamental tactic `EXISTS_TAC`. When applied to a goal, `EXISTS_TAC` attempts to discharge it by instantiating an existentially quantified variable with a witness term. For a goal of the form `|- ?x. P x`, `EXISTS_TAC` prompts for a term `t` and replaces the goal with `|- P t`.

### Mathematical insight
The `EXISTS_TAC` tactic is a core tactic in interactive theorem proving for discharging goals where existentially quantified variables need to be instantiated with concrete terms, thereby reducing the existential statement to a concrete propositional statement. The definition of `witness` makes `EXISTS_TAC` accesible by a shorter and more math-like name.

### Dependencies
None

### Porting notes (optional)
In other proof assistants, the functionality of `EXISTS_TAC` is usually available with similar effect, but may be named differently or integrated into more general instantiation mechanisms. In Coq, `exists` does something similar. In Lean, you can use `existsi`. In Isabelle/HOL, you may use `exI`. The main point is to make sure that the tactic allows the user to provide the witness to be used to instantiate the existential quantifier.


---

## proven_if

### Name of formal statement
proven_if

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let proven_if t why = case t THENL
[qed why;
  pass];;
```

### Informal statement
Define `proven_if` as a function that takes a boolean term `t` and a proof `why` as input. If `t` is true, then the function succeeds, and the proof `why` proves `t`. If `t` is false, the function also succeeds and simply proceeds without making any changes (i.e., `pass`).

### Informal sketch
- The definition of `proven_if` uses a case split on the boolean term `t`.
- If `t` is true, then the supplied proof `why` is used to justify the truth of `t` via the `qed` tactic in HOL Light. 
- If `t` is false, then the `pass` tactic is used, which does nothing. Thus, no progress is made in proving anything when the boolean condition is false.

### Mathematical insight
The function `proven_if` allows the inclusion of a proof term as part of a conditional statement. It essentially checks, at the level of formal proof, that if a boolean term `t` is true, then a separate proof `why` of that term is available and valid. If the condition `t` is false, the function does nothing, reflecting the logical structure of implication or conditional proof. This can be useful for incorporating external proof obligations into a larger proof, or for structuring proofs based on boolean conditions.

### Dependencies
None

### Porting notes (optional)
In proof assistants like Coq or Lean, an analogous function would likely involve an `if ... then ... else` construct, where the `then` branch would require a proof of the condition, and the `else` branch might simply proceed with a trivial or `reflexivity` proof depending on the desired behavior. The main challenge might lie in adapting the `qed` tactic; in Coq, one might supply the given proof term to the `exact` tactic, whereas in Lean, one could use `exact` or `assumption` with suitable term elaboration.


---

## labelhavetac

### Name of formal statement
labelhavetac

### Type of the formal statement
Definition

### Formal Content
```ocaml
let labelhavetac L t tac = SUBGOAL_THEN t MP_TAC THENL
[tac;
  pass] THEN
DISCH_THEN(fun th -> LABEL_TAC L th);;
```

### Informal statement
The function `labelhavetac` takes a label `L` (of type string), a term `t`, and a tactic `tac` as input. It applies the tactic `SUBGOAL_THEN` with the term `t` and the tactic `MP_TAC`. Next, it applies the tactic combinator `THENL` with the list of tactics `[tac; pass]`. Finally, it discharges the assumption resulting from `SUBGOAL_THEN` using `DISCH_THEN`, and labels the discharged theorem with the given label `L` using `LABEL_TAC`.

### Informal sketch
- The tactic `labelhavetac L t tac` refines a goal by introducing a subgoal `t` and an assumption `t --> original_goal`.
- `SUBGOAL_THEN t MP_TAC` focuses on proving the subgoal `t` and, upon success, uses Modus Ponens (`MP_TAC`) to reduce the original goal to proving `t --> original_goal`.
- `THENL [tac; pass]` applies `tac` to the subgoal `t`. If `tac` solves the subgoal `t`, then `pass` effectively does nothing, successfully discharging the first subgoal.
- `DISCH_THEN` discharges the assumption `t --> original_goal`, creating the theorem `t --> original_goal`. The function passed to `DISCH_THEN` takes this theorem and applies `LABEL_TAC L` to label it with `L`.

### Mathematical insight
This tactic provides a way to introduce a lemma into a proof, solve it using a given tactic, and then label the implication that connects the lemma to the original goal. The labeling is crucial for later reference and manipulation of this specific step in the proof. This pattern is useful for structuring proofs and making them more manageable.

### Dependencies
- `SUBGOAL_THEN`
- `MP_TAC`
- `THENL`
- `DISCH_THEN`
- `LABEL_TAC`
- `pass`


---

## havetac

### Name of formal statement
havetac

### Type of the formal statement
Definition

### Formal Content
```ocaml
let havetac = labelhavetac "";;
```

### Informal statement
Define `havetac` to be `labelhavetac` applied to the empty string "".

### Informal sketch
- The definition simply assigns the result of `labelhavetac` called with the empty string to `havetac`. The function `labelhavetac` is presumably a tactic constructor or modifier that allows a label to be associated with the tactic.

### Mathematical insight
`havetac` is likely a standard tactic that might be used frequently. Giving it a short name makes it easier to use. It is expected that `labelhavetac` is used to provide labels to tactics, allowing them to be uniquely identified, which is useful during debugging and proof maintenance. In this case, the empty label is used, suggesting this is the default or unlabeled version of some tactic.

### Dependencies
Definitions:
- `labelhavetac`


---

## labelhave

### Name of formal statement
labelhave

### Type of the formal statement
theorem

### Formal Content
```ocaml
let labelhave L t why = labelhavetac L t(qed why);;
```
### Informal statement
The theorem `labelhave` states that given a label `L`, a term `t`, and a proof term `why`, the application of the tactic `labelhavetac` to `L` and `t`, followed by applying the tactic `qed` to `why`, is a valid tactic application.

### Informal sketch
This theorem defines a specific form of tactic application. It essentially combines the `labelhavetac` tactic (which introduces a labelled hypothesis) with the `qed` tactic (which completes a proof using a given proof term).

*   The `labelhavetac L t` introduces a hypothesis labelled `L` with term `t`.
*   The `qed why` uses `why` as a proof term to complete the proof attempt made by `labelhavetac L t`.

### Mathematical insight
The theorem essentially combines the introduction of a labelled hypothesis with the immediate proof of that hypothesis, using a supplied proof term. This is a convenient way to complete a proof step within a larger proof.

### Dependencies
- Definition: `labelhavetac`
- Definition: `qed`


---

## have

### Name of formal statement
have

### Type of the formal statement
Definition

### Formal Content
```ocaml
let have t why = havetac t(qed why);;
```

### Informal statement
Define a function `have` that takes a term `t` and a proof `why` as input, and applies the tactic `havetac t` to the goal, followed by applying the tactic `qed why`.

### Informal sketch
The function `have` is defined to introduce a new assumption `t` into the current goal.
- The tactic `havetac t` adds the assertion `t` as an assumption to the goal, creating a new subgoal that requires proving `t`.
- The tactic `qed why` then solves this new subgoal by using the supplied proof `why`, which must be a proof of the term `t`.

### Mathematical insight
This function encapsulates the common pattern of adding an intermediate result as an assumption within a larger proof. It combines the introduction of the assumption with its immediate discharge using a supplied proof. Essentially, it allows one to assert and immediately prove an intermediate step, making it available for subsequent reasoning in the main goal.

### Dependencies
- `havetac`
- `qed`


---

## have_rw

### Name of formal statement
have_rw

### Type of the formal statement
Definition

### Formal Content
```ocaml
let have_rw t why = have t why THEN once_rw[know t];;
```

### Informal statement
Define a function `have_rw` that takes a term `t` and a justification `why` as input. The function asserts that `t` holds, justified by `why`, and then rewrites the goal using the assumption `t` exactly once.

### Informal sketch
The definition of `have_rw` introduces a derived rule.
- Assert the term `t` holds, justified by `why` which can be a proof or another theorem.
- Then, rewrite the current goal using the assumption `t` exactly once using the `once_rw` tactic, which applies rewriting rules from a supplied list of theorems (in this case `know t`) exactly once.

### Mathematical insight
This tactic combines the introduction of a new assumption (`have`) with a single rewriting using that assumption. This is useful for structuring proofs where an intermediate result is established and then immediately used to simplify the goal.

### Dependencies
- `have`
- `once_rw`
- `know`

### Porting notes (optional)
The `have` tactic is common across many proof assistants, but the `once_rw` tactic might need to be implemented using existing rewriting capabilities in the target proof assistant to rewrite using assumption `t` exactly once. The `know` tactic is HOL Light-specific, but its function is to extract the theorem `t` representing what is known, which is typically automatically managed in other assistants when introducing a hypothesis `t`.


---

## labelspecialize

### Name of formal statement
`labelspecialize`

### Type of the formal statement
Theorem-proving definition

### Formal Content
```ocaml
let labelspecialize L v th = LABEL_TAC L (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL v th)));;
```

### Informal statement
The function `labelspecialize` takes a string `L`, a term `v`, and a theorem `th` as input. It applies the tactic `LABEL_TAC` with label `L` to the result of specializing the theorem `th` with the term `v` and then rewriting using the theorem `IMP_CONJ` after discharging all assumptions

### Informal sketch
The function `labelspecialize` applies a tactic derived from a series of operations to a theorem.
- First, the theorem `th` is specialized using `ISPECL v th`, which substitutes the term `v` for the outermost universally quantified variable in `th`.
- Then, the theorem `IMP_CONJ` (which states `!p q. (p ==> q) <=> (~p \/ q)`) is used to rewrite the specialized theorem using `REWRITE_RULE`.
- The assumptions of the rewritten theorem are discharged by `UNDISCH_ALL`.
- Finally, the tactic `LABEL_TAC L` is applied to label the resulting goal with the string `L`.

### Mathematical insight
This function provides a convenient way to apply a specialization to a theorem, rewrite it using implication/conjunction equivalence, discharge the assumptions and finally label the result. This is a fairly standard sequence of operations in automated theorem proving, useful for organizing lemmas and proof states.

### Dependencies
- Definitions: `IMP_CONJ`, `ISPECL`, `REWRITE_RULE`, `UNDISCH_ALL`, `LABEL_TAC`


---

## specialize

### Name of formal statement
specialize

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let specialize = labelspecialize "";;
```

### Informal statement
Define `specialize` to be `labelspecialize` applied to the empty string.

### Informal sketch
The definition introduces `specialize` as a specific instance of the more general function `labelspecialize`, where the label is the empty string. This amounts to creating a version of `labelspecialize` with a default "no label" argument, possibly for notational convenience or to integrate with other parts of the library.

### Mathematical insight
The function `labelspecialize` likely generates specialized versions or configurations of a function or data structure based on a label. By setting the label to the empty string, the definition likely provides a default or unlabelled specialisation mechanism. This may be useful when dealing with a situation where specializations are optional.

### Dependencies
- `labelspecialize`

### Porting notes (optional)
The function `labelspecialize` must be ported first. In other proof assistants, consider if there is a built-in function application facility for the equivalent of `labelspecialize ""`. In systems with dependent types, the type could carry around the string, rather than having it as a separate "label".


---

## specialize_assuming

### Name of formal statement
specialize_assuming

### Type of the formal statement
Theorem Definition

### Formal Content
```ocaml
let specialize_assuming v th = ASSUME_TAC(REWRITE_RULE [IMP_CONJ] (ISPECL v th));;
```

### Informal statement
Define a tactic `specialize_assuming` that takes a term `v` and a theorem `th` as input. This tactic assumes the theorem `th` as an assumption in the current goal. Then, it rewrites the assumed theorem and the goal using the implication-conjunction equivalence (`IMP_CONJ`) followed by instantiating the assumed theorem with the term `v` using `ISPECL`.

### Informal sketch
The tactic `specialize_assuming v th` performs the following steps:
- Add the theorem `th` as an assumption to the current goal via `ASSUME_TAC`. Thus the current goal `g` becomes `th ==> g`.
- Rewrite using the `IMP_CONJ` rule, which likely transforms implications to conjunctive form, although exact behavior depends on the form of the assumption `th`.
- Instantiate the assumption `th` with the term `v` using `ISPECL v th`. This involves finding the leftmost universally quantified variable in `th` and specializing it to the term `v`.

### Mathematical insight
This tactic provides a way to specialize a general theorem in the assumption list. It leverages the `ISPECL` tactic to instantiate a universally quantified variable in an assumption. The rewrite with `IMP_CONJ` aims to put the assumption in a form conducive to the instantiation via `ISPECL`, by moving conjunctions to the top level.

### Dependencies
- `IMP_CONJ`
- `ISPECL`
- `ASSUME_TAC`
- `REWRITE_RULE`


---

## specialize_assuming_nosplit

### Name of formal statement
specialize_assuming_nosplit

### Type of the formal statement
Theorem tactic

### Formal Content
```ocaml
let specialize_assuming_nosplit v th = ASSUME_TAC(UNDISCH_ALL(ISPECL v th));;
```

### Informal statement
The tactic `specialize_assuming_nosplit` applied to a variable `v` and a theorem `th` performs the following: It assumes `UNDISCH_ALL(ISPECL v th)` using `ASSUME_TAC`. Here `ISPECL v th` instantiates the universally quantified variable `v` in the theorem `th`, and `UNDISCH_ALL` discharges all assumptions in the resulting theorem.

### Informal sketch
The tactic `specialize_assuming_nosplit` operates on a theorem `th`.
- It first instantiates a universally quantified variable `v` within `th` using `ISPECL v th`.
- It then discharges all assumptions of the result `ISPECL v th` by repeated application of modus ponens until no assumptions are left; this is done using `UNDISCH_ALL`. The result is a theorem with no assumptions whose conclusion is the instantiated and discharged version of the original theorem.
- Finally, it adds the conclusion of `UNDISCH_ALL (ISPECL v th)` as an assumption to the current goal using `ASSUME_TAC`. `ASSUME_TAC` decomposes the goal `|- a` into two goals `a |- a` and `|- a`, and solves the `a |- a` subgoal.

### Mathematical insight
This tactic is useful for introducing specialized versions of existing theorems as assumptions in the current proof state. The variable `v` typically represents a type variable or a term variable occurring under a universal quantifier in the original theorem `th`. By specializing and discharging all assumptions from the resulting discharge theorem, it introduces a simplified assumption to the goal.

### Dependencies
- `ASSUME_TAC`
- `UNDISCH_ALL`
- `ISPECL`

### Porting notes (optional)
- The tactic `ASSUME_TAC` is equivalent to first proving the assumption using `REFL_TAC` and then resolving with it. This might be useful to know if the target system has no equivalent.
- `UNDISCH_ALL t` keeps eliminating the assumptions by discharging via modus ponens until all assumptions are moved into the conclusion of `t`.
  The porting of tactic requires a similar facility to be available in the destination proof assistant.


---

## specialize_forward

### Name of formal statement
specialize_forward

### Type of the formal statement
theorem

### Formal Content
```ocaml
let specialize_forward v th = ASSUME_TAC(UNDISCH_ALL (fst (EQ_IMP_RULE (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL v th))))));;
```

### Informal statement
Given a term `v` and a theorem `th`, the tactic `specialize_forward` applies the following procedure: it specializes the theorem `th` with term `v` using `ISPECL`, rewrites the result using `IMP_CONJ`, discharges all assumptions from the resulting implication by universally quantifying them, applies `EQ_IMP_RULE` to convert the universally quantified implication into an equality, takes the first element of the pair resulting from `EQ_IMP_RULE`, removes all assumptions from the resulting theorem by discharging them, and then performs an assumption tactic `ASSUME_TAC` on the resulting theorem.

### Informal sketch
The goal is to specialize a theorem `th` with a term `v` and then use the result to make progress by assumption.

- Specialize the theorem `th` at term `v` using `ISPECL v th`. This replaces the outermost universally quantified variable in `th` with `v`.
- Rewrite the obtained theorem using `IMP_CONJ`, in order to put it into a suitable form.
- Discharge all assumptions from the rewritten theorem using `UNDISCH_ALL`.
- Apply `EQ_IMP_RULE`, transforming an implication into an equality `A <=> B` into two implications. Take the first of these implications using `fst`.
- Discharge all remaining assumptions of the transformed theorem, again universally quantifying over them using `UNDISCH_ALL`.
- Finally, apply the assumption tactic `ASSUME_TAC` to solve goal.

### Mathematical insight
This tactic takes a theorem, specializes it, converts an equality into an implication, discharges all the assumptions and then tries to solve the goal by assumption. It is useful for applying specialized versions of general theorems in forward reasoning style.

### Dependencies
- `ASSUME_TAC`
- `UNDISCH_ALL`
- `EQ_IMP_RULE`
- `REWRITE_RULE`
- `IMP_CONJ`
- `ISPECL`


---

## specialize_reverse

### Name of formal statement
specialize_reverse

### Type of the formal statement
Theorem-proving tactic

### Formal Content
```ocaml
let specialize_reverse v th = ASSUME_TAC(UNDISCH_ALL (snd (EQ_IMP_RULE (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL v th))))));;
```

### Informal statement
Given a term `v` and a theorem `th`, the tactic `specialize_reverse` assumes the result of specializing the hypothesis of `th` on the term `v`. The theorem `th` must be of the form `!x1...xn. A ==> B = C`, where `A` is the assumption being specialized.

### Informal sketch
The tactic `specialize_reverse v th` proceeds as follows:
- `ISPECL v th`: Instantiates the theorem `th` (which has the form `!x1...xn. A ==> B = C`) with term `v`. This results in a theorem of the form `[v/x1]A ==> [v/x1]B = [v/x1]C`.
- `REWRITE_RULE [IMP_CONJ] ...`: Rewrites using the theorem `IMP_CONJ`, which is `!p q. (p ==> q) = (~p \/ q)`. This is applied to transform the implication to a disjunction.
- `UNDISCH_ALL ...`: Discharge all remaining assumptions. From `~A \/ (B = C)`, derive `!hyp1 ... hypn. ~A \/ (B = C)`
- `EQ_IMP_RULE ...`: Transforms the equation `!hyp1 ... hypn. ~A \/ (B = C)` into an implication of the form `!hyp1 ... hypn. (B = C) ==> A`. More precisely, it transforms `!hyp1 ... hypn. ~A \/ (B = C)` to `!hyp1 ... hypn. ~(B = C) ==> ~A` and then to (by contraposition) `!hyp1 ... hypn. A ==> (B = C)`.
- `snd ...`: Takes the second component of the resulting theorem (i.e., the implication described above).
- `UNDISCH_ALL ...`: Discharge all remaining assumptions.
- `ASSUME_TAC ...`: Assumes the resulting formula as a goal and attempts to solve it with assumption.

### Mathematical insight
The tactic `specialize_reverse` is used to propagate information from the conclusion of a universally quantified equation into its assumption. It effectively "solves for" the assumption, given the equation. The `IMP_CONJ` rewrite followed by manipulations using equality and implication are essential steps in transforming `assumption ==> conclusion` to `conclusion ==> assumption`.

### Dependencies
- `IMP_CONJ`
- `ISPECL`
- `EQ_IMP_RULE`
- `UNDISCH_ALL`
- `REWRITE_RULE`
- `ASSUME_TAC`


---

## recall

### Name of formal statement
recall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let recall = specialize[];;
```
### Informal statement
The theorem `recall` states that the result of specializing a term is the same as the term itself.

### Informal sketch
- The theorem `recall` is automatically proven by the simplifier. This effectively means that specializing a term and then simplifying is equivalent to the original term without specialization. Specializing a term means replacing its type variables with concrete types. The result of replacing type variables with concrete types, where it is already done, is the same as the original term.

### Mathematical insight
The theorem `recall` asserts that the `specialize` function in HOL Light has no effect when applied to a term. This is a trivial theorem.

### Dependencies
None

### Porting notes (optional)
This result should hold trivially in most proof assistants. In some proof assistants, the operation of specializing a term might be implicit, in which case this theorem becomes a tautology.


---

## complex_field_fact

### Name of formal statement
complex_field_fact

### Type of the formal statement
Theorem

### Formal Content
```ocaml
let complex_field_fact t = recall(COMPLEX_FIELD t);;
```
### Informal statement
For any term `t`, `complex_field_fact t` recalls the theorem `COMPLEX_FIELD t`.

### Informal sketch
The function `complex_field_fact` simply retrieves a previously proven theorem named `COMPLEX_FIELD t` for an arbitrary term `t`. It does not involve any proof construction itself, but rather serves as a convenient way to access a pre-existing result. The proof of `COMPLEX_FIELD t` would have previously established that the complex numbers form a field.

### Mathematical insight
This statement serves as a lookup or retrieval mechanism for the pre-proven theorem `COMPLEX_FIELD t`, reflecting the established field structure of complex numbers within the formal system. This is important because many subsequent theorems and proofs may rely on the fact that complex numbers satisfy the field axioms.

### Dependencies
- Theorem: `COMPLEX_FIELD`


---

## real_field_fact

### Name of formal statement
real_field_fact

### Type of the formal statement
theorem

### Formal Content
```ocaml
let real_field_fact t = recall(REAL_FIELD t);;
```
### Informal statement
For any term `t`, `real_field_fact t` recalls the theorem associated with the field properties of real numbers, based on the tag `REAL_FIELD t`.

### Informal sketch
The theorem `real_field_fact` is constructed by recalling a previously stored theorem that embodies the field axioms of real numbers. The theorem recalled is tagged with `REAL_FIELD t`. In essence, this theorem re-asserts the standard axioms that define the real numbers as a field when applied to a specific term `t`.

### Mathematical insight
This statement is designed to retrieve and utilize the fundamental algebraic properties of real numbers that have already been established and stored under the `REAL_FIELD` tag. It encapsulates the standard field axioms (associativity, commutativity, distributivity, existence of identity elements, and existence of inverses) for real numbers. The use of tagging enables the system to associate these axioms with a particular term `t` representing the real numbers in a specific context. This is a standard mechanism in HOL Light for organizing and retrieving theorems.

### Dependencies
- Axiom: `REAL_FIELD` (used as tag for recall).
- Function: `recall`


---

## real_linear_fact

### Name of formal statement
real_linear_fact

### Type of the formal statement
Theorem

### Formal Content
```ocaml
let real_linear_fact t = recall(REAL_ARITH t);;
```

### Informal statement
The theorem `real_linear_fact` states that for a given term `t`, it can be proven by recalling the result of the `REAL_ARITH` tactic applied to `t`.

### Informal sketch
The proof of `real_linear_fact t` involves the following steps:
- The `recall` function is used to retrieve a previously proven theorem that matches the goal `t` after applying the `REAL_ARITH` tactic.
- The retrieved theorem, if it exists, is then used to solve goal `t`.
- Effectively, this checks if the `REAL_ARITH` tactic can directly prove the term `t`.

### Mathematical insight
The `REAL_ARITH` tactic is an automated tactic in HOL Light for proving theorems in real arithmetic. This theorem abstracts the process of recalling and applying a pre-computed result of `REAL_ARITH` to a specific term `t`, signifying that `REAL_ARITH` is capable of proving `t`.

### Dependencies
- Tactics: `REAL_ARITH`
- Functions: `recall`

### Porting notes (optional)
In other proof assistants, translating this would involve ensuring the existence of a comparable real arithmetic decision procedure and a mechanism to recall previously proven results. The `recall` function's behavior should be emulated by a caching or database mechanism that stores the results of applying the real arithmetic procedure to various terms. One would need to verify or recreate the decision procedure `REAL_ARITH` with a similar tactic available within the target proof assistant.


---

## int_linear_fact

### Name of formal statement
int_linear_fact

### Type of the formal statement
Theorem

### Formal Content
```ocaml
let int_linear_fact t = recall(INT_ARITH t);;
```

### Informal statement
The function `int_linear_fact` takes a term `t` as input and attempts to prove it using the linear integer arithmetic decision procedure `INT_ARITH`. Specifically, it recalls a previously proven theorem matching `INT_ARITH t`.

### Informal sketch
- The function `int_linear_fact` retrieves a theorem whose conclusion is equivalent to the supplied term `t`, as determined by the `INT_ARITH` decision procedure. Essentially `INT_ARITH` performs linear arithmetic reasoning and `recall` retrieves a corresponding previously-proven result.

### Mathematical insight
This theorem encapsulates the action of recalling facts that can be decided by linear integer arithmetic. It provides a more structured way to access the `INT_ARITH` decision procedure in HOL Light. Theorems like this are part of building a library of proven facts that can be efficiently retrieved.

### Dependencies
- `INT_ARITH`
- `recall`


---

## num_linear_fact

### Name of formal statement
num_linear_fact

### Type of the formal statement
theorem

### Formal Content
```ocaml
let num_linear_fact t = recall(ARITH_RULE t);;
```

### Informal statement
The theorem `num_linear_fact` is defined to recall the theorem associated with the arithmetic rule `ARITH_RULE t`.

### Informal sketch
The definition of `num_linear_fact` involves recalling a pre-existing theorem that results from the application of the arithmetic rule `ARITH_RULE t`. The function `recall` retrieves a previously proven theorem. The argument `t` is likely a term triggering application of some arithmetic simplification or normalization rules that have already been encoded in the system. The theorem that `ARITH_RULE t` generates is looked up and becomes the theorem proved by `num_linear_fact t`. The purpose is to easily access arithmetic simplification results available as theorems.

### Mathematical insight
This function provides a mechanism to access and reuse pre-proven arithmetic simplification theorems within the HOL Light environment. It encapsulates the application of an arithmetic rule to a term and retrieves the corresponding theorem. The use of `recall` suggests that the theorem associated with `ARITH_RULE t` is cached or precomputed for efficiency.

### Dependencies
- Definition: `ARITH_RULE`
- Function: `recall`


---

## set_fact_using

### Name of formal statement
set_fact_using

### Type of the formal statement
Tactical Definition

### Formal Content
```ocaml
let set_fact_using t why = havetac t(SET_TAC why);;
```
### Informal statement
Define a tactical `set_fact_using` that, when given a term `t` and a term `why`, applies the tactic `havetac t(SET_TAC why)`. The tactic `SET_TAC why` introduces `why` as a fact usable in subsequent proofs.

### Informal sketch
The tactical `set_fact_using` is defined as follows:

- Given a term `t` representing the goal to be proven, and a term `why` representing a fact to be introduced.
- Apply `SET_TAC why` to add `why` as an assumption to the goal state and makes it available during tactic application.
- Then solves `t` by using the new assumptions `why`, using `havetac t`.

### Mathematical insight
The tactic `set_fact_using` is a way of introducing assumptions or intermediate results into a goal state. It combines the functionality of introducing a premise using `SET_TAC` and attempting to prove the goal directly with `havetac`. This is a common pattern in proof engineering where a complex goal is simplified by introducing intermediate lemmas or known facts.

### Dependencies
- `havetac`
- `SET_TAC`

### Porting notes (optional)
In other proof assistants, one would need to find equivalents for `havetac` and `SET_TAC`. `SET_TAC` corresponds to introducing a hypothesis, perhaps as a forward-style reasoning step (`assert` in Coq or `have` in Lean). `havetac` represents the attempt to solve a goal based on the current assumptions; this may require a more general tactic mechanism or a custom-built procedure.


---

## set_fact

### Name of formal statement
set_fact

### Type of the formal statement
theorem

### Formal Content
```ocaml
let set_fact t = recall(SET_RULE t);;
```
### Informal statement
The theorem `set_fact` states that for any term `t`, the result of applying the function `set_fact` to `t` is equivalent to recalling the theorem `SET_RULE t`.

### Informal sketch
The theorem follows directly by expanding the definition of `set_fact`. It simply provides a named alias for recalling the term instantiation of the axiom schema `SET_RULE`.
- Unfold the definition of `set_fact`.
- Recall the instance of the axiom schema `SET_RULE` with term `t`.

### Mathematical insight
This theorem is a simple wrapper around the `SET_RULE` axiom schema, allowing it to be referenced by name in subsequent proofs or definitions within the HOL Light system. It essentially provides a more convenient, named reference to particular instances of `SET_RULE`. The underlying intuition being that using `set_fact` improves readability and maintainability.

### Dependencies
- Axiom: `SET_RULE`


---

## set_fact_assuming

### Name of formal statement
set_fact_assuming

### Type of the formal statement
Theorem

### Formal Content
```ocaml
let set_fact_assuming t = specialize_assuming[](SET_RULE t);;
```

### Informal statement
The theorem `set_fact_assuming` takes a term `t`  as input and specializes the assumptions in the theorem associated with the rewriting rule `SET_RULE` by applying the term `t`.

### Informal sketch
- The function `set_fact_assuming` applies the rewriting rule associated with `SET_RULE` to the current goal and then specializes the result by assuming the term `t`.
- `specialize_assuming` is a tactic that specializes a theorem's assumptions.
- `SET_RULE` is a rule used to modify expressions with a set theory context (likely converting assumptions on function sets).

### Mathematical insight
This theorem appears to be related to the application of set theory rewriting rules, specifically one named `SET_RULE`. The tactic `specialize_assuming` is then used to specialize the assumptions of a generated theorem regarding a particular variable or term `t`. This process simplifies the proof by incorporating specific assumptions.

### Dependencies
- `SET_RULE`
- `specialize_assuming`


---

## def

### Name of formal statement
def

### Type of the formal statement
Definition

### Formal Content
```ocaml
let def n d = X_CHOOSE_TAC n(MESON [] (mk_exists (n, mk_eq (n, d))));;
```
### Informal statement
Define `def n d` to be the tactic that applies `X_CHOOSE_TAC n` to the theorem derived by using `MESON` with an empty assumption list on the proposition that there exists an `n` such that `n` equals `d`.

### Informal sketch
The definition constructs a tactic `def` that attempts to prove the existence of a variable equal to a given term using the `X_CHOOSE_TAC` tactic.
- First, `mk_exists (n, mk_eq (n, d))` creates the term `?n. n = d`.
- Next, `MESON [] (mk_exists (n, mk_eq (n, d)))` tries to prove this existential statement using the `MESON` automated theorem prover with no assumptions.
- Finally, `X_CHOOSE_TAC n` is applied to the resulting theorem. This specializes the existential to a particular choice, using the internal choice operator represented by `X_CHOOSE`. This choice term is named `n` so that it can be referred to later.

### Mathematical insight
This definition creates a tactic that essentially instantiates an existential quantifier where the term being instantiated is already known. The tactic automatically finds a variable `n` equal to `d`, proving the existence of such an `n`. This is useful when a user wants to introduce a definition to a new variable, where a value is already known to equal to the variable. The `X_CHOOSE_TAC` introduces a Skolem constant representing the witness to the existential statement.

### Dependencies
- `X_CHOOSE_TAC`
- `MESON`
- `mk_exists`
- `mk_eq`


---

## removelabeled

### Name of formal statement
- removelabeled

### Type of the formal statement
- new_definition

### Formal Content
- Placeholder: 
```ocaml
let removelabeled L = REMOVE_THEN L (fun th -> ALL_TAC);;
```
### Informal statement
- Define `removelabeled` for a list of theorems `L` to be the result of applying `REMOVE_THEN` to `L` with a tactic that always succeeds (`ALL_TAC`). This means that for each theorem in `L`, attempt to remove it from the theorem database, and always proceed to the next theorem regardless of whether the removal succeeded.

### Informal sketch
- The definition of `removelabeled` is straightforward:
    - Apply the higher-order function `REMOVE_THEN` to the list of theorems `L`.
    - The function passed to `REMOVE_THEN` is always `ALL_TAC`, which effectively causes the removal attempt to continue regardless of whether the theorem was actually removed or not.

### Mathematical insight
- The `removelabeled` function is a utility for removing a list of theorems from the HOL Light environment, such that the removal process continues even if some of the theorems are not present in the environment or cannot be removed for some reason. It is designed for scenarios where you want to ensure the removal of a set of theorems without being interrupted by exceptions if some theorems are missing.

### Dependencies
- Definitions: `REMOVE_THEN`
- Tactics: `ALL_TAC`

### Porting notes (optional)
- In other proof assistants, ensure that the equivalent of `REMOVE_THEN` allows for the specification of a tactic that is always executed regardless of the success of the removal attempt. The `ALL_TAC` is the HOL Light tactic which always succeeds, so the port should use the equivalent of a "succeed always" or "continue after error" tactic.


---

## choose

### Name of formal statement
choose

### Type of the formal statement
theorem

### Formal Content
```ocaml
let choose n p why =
  labelhave "choosetmp" (mk_exists (n, p)) why THEN
  X_CHOOSE_TAC n(UNDISCH (TAUT (mk_imp (mk_exists (n, p), mk_exists (n, p))))) THEN
  removelabeled "choosetmp";;
```

### Informal statement
Given a term `n`, a term `p`, and a goal `why`, if we can prove `exists n. p`, then the goal `why` is provable.

### Informal sketch
The theorem `choose` states that if `exists n. p` is provable, then a goal `why` is provable.
*   First, label the assumption `exists n. p` with the label `"choosetmp"`. This is achieved with `labelhave "choosetmp" (mk_exists (n, p)) why`.
*   Then, apply the tactic `X_CHOOSE_TAC` to the labeled assumption.  `X_CHOOSE_TAC` introduces a witness `n` satisfying `p` based on the existence assumption. The tactic uses `UNDISCH (TAUT (mk_imp (mk_exists (n, p), mk_exists (n, p))))` to discharge trivial implications like `exists n. p ==> exists n. p`.
*   Finally, remove the labeled assumption `"choosetmp"` from the assumptions list, using `removelabeled "choosetmp"`.

### Mathematical insight
The `choose` theorem encapsulates the common logical step in constructive proofs where one has established the existence of some object and then proceeds to use an arbitrary witness of that object in further reasoning. This corresponds to using existential elimination in natural deduction. The labeling is used to manage the scope of the existential.

### Dependencies
None

### Porting notes (optional)
This theorem might be easily trasladable to other proof assistants. The key idea is to have an equivalent of `X_CHOOSE_TAC` that performs existential elimination. Also, the way assumptions are handled in HOL Light might differ from other proof assistants.


---

## choose2

### Name of formal statement
`choose2`

### Type of the formal statement
`new_definition`

### Formal Content
```ocaml
let choose2 n1 n2 p why =
  choose n1 (mk_exists (n2, p)) why THEN
  choose n2 p []
;;
```

### Informal statement
Define `choose2` such that, given natural numbers `n1` and `n2`, a boolean term `p` possibly depending on `n2`, and a witness term `why`, the tactic `choose2 n1 n2 p why` is equivalent to applying the tactic `choose n1 (mk_exists (n2, p)) why` followed by the tactic `choose n2 p []`.

### Informal sketch
The definition of `choose2` combines two applications of the `choose` tactic.
- First, the tactic `choose n1 (mk_exists (n2, p)) why` instantiates the existential `mk_exists (n2, p)` with witness term `why`, introducing a new assumption `n1 = why` where `n1` is a variable.
- Second, the tactic `choose n2 p []` introduces another assumption, with witness term automatically chosen, satisfying `p` under the previous assumption `n1 = why`.
The combined tactic `choose2 n1 n2 p why` thus performs two successive instantiations of existentials.

### Mathematical insight
The tactic `choose2` is a derived rule that simplifies the process of choosing witnesses for nested existential quantifiers. This is a common pattern especially when reasoning about relations or functions where the existence of related elements needs to be established. This tactic captures a common pattern in interactive proof.

### Dependencies
- `choose`
- `mk_exists`


---

## subset_y

### Name of formal statement
subset_y

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subset_y = prove(`
  !S U:X->bool.
  S SUBSET U <=>
  (!y. y IN S ==> y IN U)
`,
  qed[SUBSET]
);;
```
### Informal statement
For all sets `S` and `U` of type `X->bool`, `S` is a subset of `U` if and only if for all `y`, if `y` is in `S`, then `y` is in `U`.

### Informal sketch
The proof `qed[SUBSET]` indicates that the theorem is proved directly from the definition of subset (`SUBSET`). The definition states that `S SUBSET U` is equivalent to `!y. y IN S ==> y IN U`. Thus, the theorem directly reflects the definition and requires no further proof steps beyond appealing to that definition.

### Mathematical insight
This theorem provides the fundamental characterization of the subset relation in terms of element membership. It is a direct restatement of the definition of the subset relation, making it easy to work with in proofs involving sets.

### Dependencies
- Definitions: `SUBSET`, `IN`


---

## extension_z

### Name of formal statement
extension_z

### Type of the formal statement
theorem

### Formal Content
```ocaml
let extension_z = prove(`
  !S:X->bool T.
  S = T <=>
  (!z. z IN S <=> z IN T)
`,
  qed[EXTENSION]
);;
```
### Informal statement
For all sets `S` of type `X->bool` and `T` of type `X->bool`, `S` is equal to `T` if and only if for all `z` it is the case that `z` is in `S` if and only if `z` is in `T`.

### Informal sketch
The proof relies on the axiom of extensionality (`EXTENSION`). The basic idea is to prove equality of the sets `S` and `T` by showing that they have the same members. By extensionality, two sets are equal if and only if they contain the same elements.

### Mathematical insight
This is the principle of extensionality for sets. It states that two sets are equal if and only if they have the same elements. This is a fundamental axiom in set theory and is used to define equality of sets. In HOL Light, sets are represented as characteristic functions of type `X->bool`, where `X` is the type of the elements in the set, so it can be considered that it is the extensionality axiom on boolean functions.

### Dependencies
- Axioms: `EXTENSION`

### Porting notes (optional)
In many proof assistants, the axiom of extensionality either for sets or for boolean functions may already be built in. In such a case, it might be necessary to ensure that any port matches this provided equational definition. Differences in automation levels in various provers can impact how easily this theorem can be established.


---

## insert_delete_nonmember

### Name of formal statement
insert_delete_nonmember

### Type of the formal statement
theorem

### Formal Content
```ocaml
let insert_delete_nonmember = prove(`
  !(x:X) S.
  ~(x IN S) ==>
  (x INSERT S) DELETE x = S
`,
  SET_TAC[]
);;
```
### Informal statement
For all sets `S` of type `X`, and for all `x` of type `X`, if `x` is not a member of `S`, then deleting `x` from the set obtained by inserting `x` into `S` results in the original set `S`.

### Informal sketch
The proof proceeds by considering sets and elements such that the element is not in the set. We wish to demonstrate that inserting the element and then deleting it recovers the original set. The proof uses general set tactics (`SET_TAC`) to simplify and resolve the set operations.

### Mathematical insight
The theorem expresses a fundamental property of set insertion and deletion: if an element is inserted into a set and then deleted, and the element was *not* originally a member of the set, then the resulting set is identical to the original set. This highlights the behavior of insertion and deletion as nearly inverse operations under specific conditions.

### Dependencies
None

### Porting notes (optional)
This theorem should be straightforward to port. Most proof assistants have similar set theory libraries with analogous `insert` and `delete` operations. The main challenge, if any, might be in matching the exact names and argument order of the set functions. The `SET_TAC` automation may need to be emulated by unfolding definitions or by using equivalent automation tactics in the target proof assistant.


---

## surjective_finite

### Name of formal statement
surjective_finite

### Type of the formal statement
theorem

### Formal Content
```ocaml
let surjective_finite = prove(`
  !f p:T->bool.
  (!t:T. ?s:S. f(s) = t) ==>
  FINITE {s | p(f(s))} ==>
  FINITE {t | p(t)}
`,
  intro THEN
  specialize[`f:S->T`;`{s:S | p(f(s):T)}`]FINITE_IMAGE_EXPAND THEN
  subgoal `{t:T | p t} SUBSET {t | ?s:S. s IN {x | p(f(x))} /\ t = f s}` THENL [
    rw[SUBSET;IN_ELIM_THM] THEN
    qed[]
  ;
    qed[FINITE_SUBSET]
  ]
);;
```
### Informal statement
For any function `f` from type `S` to type `T`, and any predicate `p` on type `T`, if `f` is surjective (i.e., for every `t` of type `T`, there exists an `s` of type `S` such that `f(s) = t`), and if the set `{s | p(f(s))}` is finite, then the set `{t | p(t)}` is also finite.

### Informal sketch
The proof proceeds as follows:
- Assume that every element `t` in type `T` has a pre-image `s` in type `S` under the function `f`. Assume also that `{s | p(f(s))}` is finite.
- Show that `{t | p(t)}` is a subset of `{t | ?s. s IN {x | p(f(x))} /\ t = f s}`. This is done by rewriting using `SUBSET` and `IN_ELIM_THM`.
- Show that `{t | ?s. s IN {x | p(f(x))} /\ t = f s}` is finite. This follows since `{s | p(f(s))}` is finite and `{t | ?s. s IN {x | p(f(x))} /\ t = f s}` is contained in the image of `{x | p(f(x))}` under `f`. The finiteness is then proved using `FINITE_SUBSET`.

### Mathematical insight
The theorem states that if a function `f` is surjective, and the pre-image of any finite set under `f` is finite, then the image of any set is finite.  This captures the idea that surjectivity, combined with a finiteness condition on the pre-images under `p` , implies finiteness on the image under `f`.

### Dependencies
- `FINITE_IMAGE_EXPAND`
- `SUBSET`
- `IN_ELIM_THM`
- `FINITE_SUBSET`


---

## is_inters

### Name of formal statement
is_inters

### Type of the formal statement
theorem

### Formal Content
```ocaml
let is_inters = prove(`
  !(x:X->bool) u.
  x IN u /\
  (!s. s IN u ==> x SUBSET s) ==>
  x = INTERS u
`,
  SET_TAC[]
);;
```
### Informal statement
For any function `x` from a type `X` to boolean values (representing a subset of `X`), and for any set `u` of subsets of `X`, if `x` is an element of `u`, and if for all sets `s`, if `s` is an element of `u`, then `x` is a subset of `s`, then `x` is equal to the intersection of all sets in `u` (i.e., `INTERS u`).

### Informal sketch
The theorem states that if a set `x` is an element of a set of sets `u`, and `x` is a subset of every element of `u`, then `x` must be the intersection of all sets in `u`.
- The proof uses `SET_TAC[]` to simplify and prove the goal. This likely involves unfolding the definition of `INTERS` and using set-theoretic reasoning to show the equivalence.
- The hypothesis `x IN u /\ (!s. s IN u ==> x SUBSET s)` shows that `x` is a subset of every set contained in `u`.
- The goal `x = INTERS u` means `x` is the intersection of all sets in `u`. Since `x` is a member of `u` and a subset of any other element in `u`, it effectively acts as the intersection set.

### Mathematical insight
This theorem provides a characterization of the intersection of a set of sets. It states that if a set `x` belongs to a family of sets `u` and is also a subset of every set in `u`, then `x` must be the intersection of all sets in `u`. This provides a way to identify the intersection without directly appealing to its definition, but through the property of being the smallest such subset.

### Dependencies
- `INTERS` (definition of set intersection)
- `IN` (set membership)
- `SUBSET` (subset relation)


---

## card_empty

### Name of formal statement
card_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_empty = prove(`
  CARD ({}:X->bool) = 0
`,
  qed[CARD_CLAUSES]
);;
```
### Informal statement
The cardinality of the empty set, represented as a predicate over a type `X`, is equal to 0.

### Informal sketch
The proof uses the theorem `CARD_CLAUSES`, which provides clauses defining the cardinality of a set represented as a boolean predicate.
- `CARD_CLAUSES` likely contains a clause asserting that the cardinality of a set defined by a constantly false predicate is 0.
- The proof applies this clause to the empty set, represented as a function from type `X` to `bool` that always returns false.

### Mathematical insight
This theorem formalizes the fundamental concept that the empty set contains no elements, hence its cardinality is zero. It is a basic result in set theory and is essential for reasoning about the size of sets.

### Dependencies
- Theorems: `CARD_CLAUSES`


---

## card_insert

### Name of formal statement
card_insert

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_insert = prove(`
  !x:X S.
  FINITE S ==>
  CARD(x INSERT S)
  = (if x IN S then CARD S else CARD S + 1)
`,
  simp[CARD_CLAUSES] THEN
  ARITH_TAC
);;
```
### Informal statement
For all sets `x` of type `X` and `S`, if `S` is a finite set, then the cardinality of the set formed by inserting `x` into `S` is equal to the cardinality of `S` if `x` is already an element of `S`; otherwise, it is the cardinality of `S` plus 1.

### Informal sketch
The proof proceeds as follows:
- Start with the theorem statement `!x:X S. FINITE S ==> CARD(x INSERT S) = (if x IN S then CARD S else CARD S + 1)`.
- Apply simplification using the clauses defining `CARD` (cardinality).
- Use `ARITH_TAC` to automatically prove the arithmetic equality based on the cases resulting from the `CARD` clauses and the conditional statement.

### Mathematical insight
This theorem establishes how the cardinality of a finite set changes when a new element is inserted. If the element is already in the set, the cardinality remains the same. Otherwise, the cardinality increases by one. This is a fundamental property of cardinality and set insertion. This theorem is important because it relates a basic set operation (`INSERT`) to a fundamental property of sets (`CARD`) and provides a mechanism to calculate cardinality after inserting a new element.

### Dependencies
- Definitions: `CARD`
- Theorems: `CARD_CLAUSES`


---

## subset_full_card

### Name of formal statement
subset_full_card

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subset_full_card = prove(`
  !S:X->bool U.
  FINITE S ==>
  ( (U SUBSET S /\ CARD U = CARD S)
    <=> U = S
  )
`,
  intro THEN
  qed[SUBSET_REFL;CARD_SUBSET_EQ]
);;
```
### Informal statement
For any set `S` of type `X->bool`, if `S` is finite, then for any set `U` of type `X->bool`, `U` is a subset of `S` and the cardinality of `U` equals the cardinality of `S` if and only if `U` equals `S`.

### Informal sketch
The proof proceeds by:
- Introduction: Introduce the universally quantified variables `S` and `U` and the assumption `FINITE S`.
- `SUBSET_REFL`: Reflexivity of subset relation.
- `CARD_SUBSET_EQ`: A lemma stating that if `U` is a subset of a finite set `S`, and the cardinality of `U` is equal to the cardinality of `S` then `U = S`

### Mathematical insight
This theorem expresses a fundamental property of finite sets: if a subset has the same cardinality as the original set, then the subset must be equal to the original set. This theorem is useful in situations where one wants to prove the equality of two finite sets. Instead of directly proving that every element of one set is an element of the other, it suffices to show that one is a subset of the other and that they have the same number of elements.

### Dependencies
- Theorems:
  - `SUBSET_REFL`
  - `CARD_SUBSET_EQ`


---

## finite_subsets_card

### Name of formal statement
finite_subsets_card

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_subsets_card = prove(`
  !S:X->bool n.
  FINITE S ==>
  FINITE {U | U SUBSET S /\ CARD U = n}
`,
  intro THEN
  set_fact `{U:X->bool | U SUBSET S /\ CARD U = n} SUBSET {U:X->bool | U SUBSET S}` THEN
  qed[FINITE_POWERSET;FINITE_SUBSET]
);;
```
### Informal statement
For any set `S` of type `X->bool`, and any natural number `n`, if `S` is finite, then the set of all subsets `U` of `S` that have cardinality `n` is also finite.

### Informal sketch
The proof proceeds by:
- Assuming `FINITE S`.
- Showing that `{U | U SUBSET S /\ CARD U = n}` is a subset of the powerset of `S`, `{U | U SUBSET S}`.
- Applying the theorems `FINITE_POWERSET` (the powerset of a finite set is finite) and `FINITE_SUBSET` (a subset of a finite set is finite) to conclude that `{U | U SUBSET S /\ CARD U = n}` is finite.

### Mathematical insight
The theorem states a basic fact about finite sets: if a set is finite, then the set of all its subsets of a given cardinality is also finite. This is a useful result when reasoning about combinatorics and finiteness. It connects the notion of finiteness, subsets, and cardinality.

### Dependencies
- Theorems:
    - `FINITE_POWERSET`
    - `FINITE_SUBSET`


---

## subsets_full_card

### Name of formal statement
subsets_full_card

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subsets_full_card = prove(`
  !S:X->bool.
  FINITE S ==>
  {U | U SUBSET S /\ CARD U = CARD S}
  = {S}
`,
  rw[EXTENSION;IN_ELIM_THM] THEN
  rw[IN_SING] THEN
  qed[subset_full_card]
);;
```
### Informal statement
For any set `S` of type `X->bool`, if `S` is finite, then the set of all subsets `U` of `S` such that the cardinality of `U` equals the cardinality of `S` is equal to the singleton set containing `S`.

### Informal sketch
The proof proceeds by:
- Rewriting with `EXTENSION` to reduce set equality to element-wise equivalence.
- Rewriting with `IN_ELIM_THM` to express set membership in terms of the subset relation and cardinality equality.
- Rewriting with `IN_SING` which states that `x IN {y}` is logically equivalent to `x = y`.
- Using `subset_full_card` to prove the equivalence.

### Mathematical insight
The theorem states that if you have a finite set `S`, the only subset of `S` that has the same cardinality as `S` is `S` itself. This is a fundamental property of finite sets and cardinality. It is a direct consequence of the properties of cardinality and subsets. Any proper subset must have a strictly smaller cardinality.

### Dependencies
- Theorems:
  - `EXTENSION`
  - `IN_ELIM_THM`
  - `IN_SING`
  - `subset_full_card`


---

## subsets_card_0

### Name of formal statement
subsets_card_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subsets_card_0 = prove(`
  !S:X->bool.
  FINITE S ==>
  {U | U SUBSET S /\ CARD U = 0}
  = {{}}
`,
  rw[EXTENSION;IN_ELIM_THM] THEN
  rw[IN_SING] THEN
  intro THEN
  qed[CARD_EQ_0;FINITE_SUBSET;EMPTY_SUBSET;card_empty]
);;
```
### Informal statement
For any set `S` of type `X->bool`, if `S` is finite, then the set of all subsets `U` of `S` such that the cardinality of `U` is 0, is equal to the singleton set containing the empty set.

### Informal sketch
*   The proof starts by rewriting using `EXTENSION` and `IN_ELIM_THM` to expand the set comprehension.
*   Then, `rw[IN_SING]` rewrites the right-hand side which simplifies the goal and uses `intro` to introduce the variable `S` into the assumptions.
*   The proof follows from `CARD_EQ_0` to show that a set has cardinality 0 if and only if it is the empty set, `FINITE_SUBSET` to show that any subset of a finite set is finite, `EMPTY_SUBSET` to show that the empty set is a subset of any set and `card_empty` to show that the cardinality of the empty set in zero.

### Mathematical insight
This theorem states a fundamental property of sets and cardinality: given a finite set `S`, the only subset of `S` with cardinality 0 is the empty set. This is important because it connects the concepts of cardinality, subsets, and the empty set, and is used in many proofs involving counting and set theory.

### Dependencies
*   Rewriting: `EXTENSION`, `IN_ELIM_THM`, `IN_SING`
*   Theorems: `CARD_EQ_0`, `FINITE_SUBSET`, `EMPTY_SUBSET`, `card_empty`



---

## subsets_full_card_empty

### Name of formal statement
subsets_full_card_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subsets_full_card_empty = prove(`
  {U:X->bool | U SUBSET {} /\ CARD U = 0}
  = {{}}
`,
  have `FINITE({}:X->bool)` [FINITE_EMPTY] THEN
  specialize[`{}:X->bool`]subsets_card_0 THEN
  qed[]
);;
```
### Informal statement
The set of all sets `U` such that `U` is a subset of the empty set and the cardinality of `U` is 0, is equal to the set containing only the empty set, i.e., `{{}}`.

### Informal sketch
The proof proceeds as follows:
- First, establish that the empty set is finite, using the theorem `FINITE_EMPTY`.
- Specialize the theorem `subsets_card_0` to the empty set. The theorem `subsets_card_0` states that for any finite set `S`, the set of all subsets `U` of `S` such that the cardinality of `U` is 0, is equal to the set containing only the empty set.
- Conclude that the set of all sets `U` such that `U` is a subset of the empty set and the cardinality of `U` is 0, is equal to the set containing only the empty set.

### Mathematical insight
This theorem states that the only subset of the empty set with cardinality 0 is the empty set itself. This is a basic result in set theory.

### Dependencies
- Theorems:
  - `FINITE_EMPTY`
  - `subsets_card_0`


---

## subsets_card_toobig

### Name of formal statement
subsets_card_toobig

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subsets_card_toobig = prove(`
  !S:X->bool n.
  FINITE S ==>
  ~(n <= CARD S) ==>
  {U | U SUBSET S /\ CARD U = n} = {}
`,
  rw[EXTENSION;IN_ELIM_THM;EMPTY] THEN
  intro THEN
  qed[CARD_SUBSET]
);;
```
### Informal statement
For any set `S` of type `X->bool` and any natural number `n`, if `S` is finite and `n` is not less than or equal to the cardinality of `S`, then the set of subsets `U` of `S` such that the cardinality of `U` equals `n` is the empty set.

### Informal sketch
The proof proceeds as follows:
- Rewrite using `EXTENSION`, `IN_ELIM_THM`, and `EMPTY` to transform the goal into `!U. U SUBSET S /\ CARD U = n ==> F`.
- Introduce `U` to obtain `U SUBSET S /\ CARD U = n |- F`.
- Apply the theorem `CARD_SUBSET` which states that if `U` is a subset of a finite set `S`, then the cardinality of `U` is less than or equal to the cardinality of `S`. Since we have `n = CARD U` and `U SUBSET S`, it follows that `n <= CARD S`. This contradicts the assumption `~(n <= CARD S)`, leading to a contradiction `F`.

### Mathematical insight
This theorem states a basic property of finite sets: if you try to form a subset of a finite set `S` with cardinality `n` that is strictly greater than the cardinality of `S`, you will always end up with the empty set of possibilities. This is because no such subset can exist.

### Dependencies
- Theorems:
  - `EXTENSION`
  - `IN_ELIM_THM`
  - `EMPTY`
  - `CARD_SUBSET`


---

## powerset_insert_disjoint

### Name of formal statement
powerset_insert_disjoint

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powerset_insert_disjoint = prove(`
  !S:X->bool t.
  ~(t IN S) ==>
  DISJOINT
    {A | A SUBSET S}
    (IMAGE (\A. t INSERT A) {A | A SUBSET S})
`,
  intro THEN
  rw[DISJOINT] THEN
  once_rw[EXTENSION] THEN
  rw[INTER;IMAGE;IN_ELIM_THM;EMPTY] THEN
  intro THEN
  qed[IN_INSERT;SUBSET]
);;
```
### Informal statement
For any set `S` of type `X->bool` and any element `t` of type `X`, if `t` is not in `S`, then the powerset of `S` and the image of the powerset under the function that inserts `t` into each set are disjoint.

### Informal sketch
The proof proceeds as follows:
- Assume `t` is not in `S`.
- Rewrite the definition of `DISJOINT`.
- Expand the definition of `EXTENSION`.
- Rewrite using the definitions of `INTER`, `IMAGE`, the elimination theorem for `IN`, and `EMPTY`.
- Assume an element is in the intersection of the two sets.  Then, the proof concludes by showing a contradiction using `IN_INSERT` and `SUBSET`.

### Mathematical insight
This theorem states that if we take the powerset of a set `S`, and then insert a new element `t` (which is not already in `S`) into every element of the powerset, the resulting set of sets will be disjoint from the original powerset. This is useful when reasoning about inductive constructions on sets.

### Dependencies
- Definitions:
  - `DISJOINT`
  - `INTER`
  - `IMAGE`
  - `EMPTY`
  - `EXTENSION`
- Theorems:
  - `IN_ELIM_THM`
  - `IN_INSERT`
  - `SUBSET`


---

## image_card_powerset

### Name of formal statement
image_card_powerset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_card_powerset = prove(`
  !S:X->bool.
  FINITE S ==>
  IMAGE CARD {A | A SUBSET S} = (0..CARD S)
`,
  intro THEN
  rw[EXTENSION;IN_ELIM_THM;IN_IMAGE;IN_NUMSEG_0] THEN
  intro THEN
  splitiff THENL [
    qed[CARD_SUBSET]
  ;
    intro THEN
    have `{} SUBSET S:X->bool` [EMPTY_SUBSET] THEN
    have `FINITE({}:X->bool)` [FINITE_EMPTY] THEN
    have `CARD({}:X->bool) <= x` [card_empty;ARITH_RULE `0 <= n`] THEN
    have `FINITE S ==> x <= CARD(S:X->bool)` [] THEN
    specialize[
      `x:num`;
      `{}:X->bool`;
      `S:X->bool`
    ]CHOOSE_SUBSET_BETWEEN THEN
    choose `t:X->bool` `{}:X->bool SUBSET t /\ t SUBSET S /\ t HAS_SIZE x` [] THEN
    witness `t:X->bool` THEN
    qed[HAS_SIZE]
  ]
);;
```
### Informal statement
For any set `S` of type X->bool, if `S` is finite, then the image of the cardinality function applied to the powerset of `S` is equal to the set of numbers from 0 to the cardinality of `S`.

### Informal sketch
The proof proceeds by showing that if `S` is finite, then the image of the cardinality of the powerset of `S` is equal to the set consisting of the numbers from 0 to the cardinality of `S`. The proof splits into two directions:

*   **Showing that the image is included in the set of numbers from 0 to the cardinality of `S`**: Given that `A` is a subset of `S`, we need to show that `CARD A` is in the range `0..CARD S`. This follows directly from `CARD_SUBSET`, which states exactly this fact.

*   **Showing that the set of numbers from 0 to the cardinality of `S` is included in the image**: We are given a number `x` such that `x` is in the range `0..CARD S`. We must show that there exists a subset `t` of `S` such that `CARD t = x`. First, note that the empty set is a subset of `S`, and therefore `CARD {} <= x` since `0 <= x`. Next, since `x <= CARD S`, we can use `CHOOSE_SUBSET_BETWEEN` to choose a subset `t` of `S` such that `t` has cardinality `x`.

### Mathematical insight
This theorem formalizes the intuitive idea that if you take all possible subsets of a finite set `S` and compute the cardinalities of these subsets, you will obtain every number from 0 up to the cardinality of `S` exactly once. The theorem makes a claim, about sets, cardinality, and powersets. It proves that the set of cardinalities of all subsets of `S` is exactly the numerical interval from 0 to `CARD S`.

### Dependencies
*   `EXTENSION`
*   `IN_ELIM_THM`
*   `IN_IMAGE`
*   `IN_NUMSEG_0`
*   `CARD_SUBSET`
*   `EMPTY_SUBSET`
*   `FINITE_EMPTY`
*   `card_empty`
*   `ARITH_RULE`
*   `CHOOSE_SUBSET_BETWEEN`
*   `HAS_SIZE`


---

## le_lt_numseg

### Name of formal statement
le_lt_numseg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let le_lt_numseg = prove(`
  !a b.
  {i:num | a <= i /\ i < b}
  = if a < b then (a..b-1) else {}
`,
  rw[numseg;EXTENSION;EMPTY;IN_ELIM_THM;COND_RAND] THEN
  ARITH_TAC
);;
```
### Informal statement
For all natural numbers `a` and `b`, the set of natural numbers `i` such that `a` is less than or equal to `i` and `i` is strictly less than `b` is equal to the numerical segment from `a` to `b-1` if `a` is strictly less than `b`, and is equal to the empty set otherwise.

### Informal sketch
*   The proof proceeds by rewriting the left-hand side of the equation to match the right-hand side, using equational reasoning.
*   First, the definition of `numseg` is used to expand the term `(a..b-1)`.
*   Next, `EXTENSION` is applied, justifying the reduction of set equality to element-wise equality.
*   The definition of the empty set `EMPTY` is then used.
*   The theorem `IN_ELIM_THM` is applied to eliminate set membership.
*   The conditional randomiser `COND_RAND` is applied.
*   Finally, `ARITH_TAC` is used to automatically discharge the arithmetic goals.

### Mathematical insight
This theorem provides a connection between set comprehension notation (`{i:num | P i}`) and the `numseg` notation `a..b`, expressing that the set of integers `i` satisfying `a <= i < b` is precisely the numerical segment `a..b-1` if `a < b`, and is empty otherwise. This is a standard and useful property for reasoning about numerical segments in formalized mathematics.

### Dependencies
- Definition: `numseg`
- Theorem: `EXTENSION`
- Definition: `EMPTY`
- Theorem: `IN_ELIM_THM`
- Theorem: `COND_RAND`
- Tactic: `ARITH_TAC`


---

## finite_le_lt

### Name of formal statement
finite_le_lt

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_le_lt = prove(`
  !a b.
  FINITE {i:num | a <= i /\ i < b}
`,
  rw[le_lt_numseg;COND_RAND] THEN
  rw[FINITE_EMPTY;FINITE_NUMSEG] THEN
  qed[]
);;
```

### Informal statement
For all natural numbers `a` and `b`, the set of natural numbers `i` such that `a` is less than or equal to `i` and `i` is strictly less than `b` is finite.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the set `{i:num | a <= i /\ i < b}` using `le_lt_numseg` to the segment `numseg a b`. The `COND_RAND` ensures the rewriting happens even if the set is empty, or not of the appropriate form for the rewrite.
- Then, rewrite the finiteness of the segment using the definition of `FINITE_NUMSEG` and `FINITE_EMPTY` to handle the cases where the segment is empty.
- The `FINITE_NUMSEG` theorem states the sets of natural numbers `numseg a b` are always finite, which completes the proof that `{i:num | a <= i /\ i < b}` is finite.

### Mathematical insight
This theorem establishes the finiteness of a bounded integer interval, representing a fundamental property used in many contexts. It shows that any set of natural numbers constrained by a lower and upper bound will always be a finite set. This is a basic result in set theory and arithmetic, underpinning induction arguments and cardinality reasoning.

### Dependencies
- `le_lt_numseg`
- `FINITE_EMPTY`
- `FINITE_NUMSEG`


---

## card_le_lt

### Name of formal statement
card_le_lt

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_le_lt = prove(`
  !a b.
  CARD {i:num | a <= i /\ i < b} = b-a
`,
  rw[le_lt_numseg;COND_RAND] THEN
  rw[CARD_CLAUSES;CARD_NUMSEG] THEN
  rw[GSYM COND_RAND] THEN
  ARITH_TAC
);;
```
### Informal statement
For all natural numbers `a` and `b`, the cardinality of the set of natural numbers `i` such that `a` is less than or equal to `i` and `i` is less than `b` is equal to `b` minus `a`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the interval `{i:num | a <= i /\ i < b}` to its equivalent representation using `le_lt_numseg`.
- Simplify the cardinality of the set using `CARD_CLAUSES` and `CARD_NUMSEG`.
- Rewrite to prepare for arithmetic simplification.
- Apply arithmetic tactics to complete the proof.

### Mathematical insight
This theorem gives a formula for computing the cardinality of a semi-open interval of natural numbers. This is a fundamental result in basic set theory and arithmetic. The condition `a <= b` could be checked elsewhere, but if `a > b` then we expect the interval to be empty, and so the formula should be interpreted as 0 in that case. This needs to be explicitly checked during the proof.

### Dependencies
- Theorems: `le_lt_numseg`, `CARD_CLAUSES`, `CARD_NUMSEG`


---

## insert_empty

### Name of formal statement
insert_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let insert_empty = prove(`
  !x:X.
  x INSERT {} = {x}
`,
  SET_TAC[]
);;
```
### Informal statement
For all `x` of type `X`, inserting `x` into the empty set `{}` results in the singleton set `{x}`.

### Informal sketch
The theorem `insert_empty` is proven using the tactic `SET_TAC[]`, which handles basic set-theoretic reasoning. The statement asserts that inserting an element `x` into the empty set results in the set containing only `x`. The `SET_TAC` tactic likely uses the definition of set insertion and the properties of the empty set to simplify the left-hand side `x INSERT {}` to `{x}`, proving the equality.

### Mathematical insight
This theorem establishes a fundamental relationship between set insertion and the empty set. It formalizes the basic understanding that adding an element to an empty set creates a singleton set containing that element. This is a basic building block for reasoning about sets and is used extensively.

### Dependencies
- Definitions: `INSERT` (set insertion), `{}` (empty set), `{x}` (singleton set)


---

## max_finite

### Name of formal statement
max_finite

### Type of the formal statement
theorem

### Formal Content
```ocaml
let max_finite = prove(`
  !S:num->bool.
  FINITE S ==>
  (
    S = {} \/
    (?m. m IN S /\ (!n. m < n ==> ~(n IN S)))
  )
`,
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    qed[]
  ;
    DISJ2_TAC THEN
    witness `x:num` THEN
    simp[insert_empty;IN_SING] THEN
    ARITH_TAC
  ;
    DISJ2_TAC THEN
    rw[IN_INSERT] THEN
    case `x <= m:num` THENL [
      witness `m:num` THEN
      intro THENL [
        qed[]
      ;
        ASM_ARITH_TAC
      ;
        qed[]
      ]
    ;
      witness `x:num` THEN
      intro THENL [
        qed[]
      ;
        ASM_ARITH_TAC
      ;
        num_linear_fact `~(x <= m:num) ==> x < n ==> m < n` THEN
        qed[]
      ]
    ]
  ]
);;
```

### Informal statement
For all sets `S` of natural numbers, if `S` is finite, then either `S` is empty, or there exists a natural number `m` such that `m` is in `S` and for all natural numbers `n`, if `m` is less than `n`, then `n` is not in `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, the first disjunct `S = {}` is trivially true.
- Inductive step: Assume `S` is finite and non-empty. We split into cases based on whether a given element `x` is less than or equal to a presumed maximum `m`.
  - If `x <= m`, we continue with `m` as the proposed maximum.
  - If `~(x <= m)` (i.e., `x > m`), then we use `x` as the proposed new maximum.
The proof uses arithmetic reasoning to show maximality in both cases.

### Mathematical insight
This theorem states that any finite set of natural numbers has a maximum element. This is a fundamental property of finite sets and the ordering of natural numbers. It's essential for many other theorems involving finite sets and arithmetic.

### Dependencies
- Theorems:
  - `FINITE_INDUCT_STRONG`
- Definitions:
  - `FINITE`, `IN`, `empty`, `insert_empty`, `IN_SING`, `IN_INSERT`


---

## image_surj

### Name of formal statement
image_surj

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_surj = prove(`
  !f:X->Y A B.
  SURJ f A B ==>
  IMAGE f A = B
`,
  rw[SURJ;IMAGE;EXTENSION;IN_ELIM_THM] THEN
  qed[]
);;
```
### Informal statement
For all functions `f` from `X` to `Y` and all sets `A` and `B`, if `f` is surjective from `A` to `B`, then the image of `A` under `f` equals `B`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the goal using the definitions of `SURJ`, `IMAGE`, `EXTENSION` and the theorem `IN_ELIM_THM` in order to reduce the goal to a simpler form that HOL Light can prove automatically.
- Apply `qed[]`, which automatically discharges the simplified goal.

### Mathematical insight
This theorem `image_surj` formalizes a fundamental property of surjective functions. Namely, a function being surjective from A to B means that every element in B has a pre-image in A under `f`. The image of a set A under a function `f` is the set of all `f(x)` where x is an element in A. Thus if `f` is surjective from A to B, this implies the image of `A` is `B`.

### Dependencies
Definitions:
- `SURJ`
- `IMAGE`
- `EXTENSION`

Theorems:
- `IN_ELIM_THM`


---

## elim_image_subset_u

### Name of formal statement
elim_image_subset_u

### Type of the formal statement
theorem

### Formal Content
```ocaml
let elim_image_subset_u = prove(`
  !A B f:X->Y.
  IMAGE f A SUBSET B <=>
  (!u. u IN A ==> f u IN B)
`,
  SET_TAC[]
);;
```
### Informal statement
For all sets `A` and `B`, and for all functions `f` from `X` to `Y`, the image of `A` under `f` is a subset of `B` if and only if for all `u`, if `u` is an element of `A`, then `f u` is an element of `B`.

### Informal sketch
The proof demonstrates the equivalence between the subset relation of the image of a set under a function and the universal quantification over elements of the set.
- The `IMAGE f A SUBSET B` is equivalent to `!u. u IN A ==> f u IN B`.
- The theorem is proved by expanding definitions related to sets.
- The tactic `SET_TAC` is applied, suggesting a set-theoretic reasoning style is sufficient.

### Mathematical insight
This theorem expresses a standard property of functions and sets, namely the connection between the image of a set being a subset of another set, and the pointwise condition. It's a fundamental result when reasoning about functions acting on sets.

### Dependencies
- `SET_TAC`


---

## elim_image_subset_v

### Name of formal statement
elim_image_subset_v

### Type of the formal statement
theorem

### Formal Content
```ocaml
let elim_image_subset_v = prove(`
  !A B f:X->Y.
  IMAGE f A SUBSET B <=>
  (!v. v IN A ==> f v IN B)
`,
  SET_TAC[]
);;
```
### Informal statement
For all sets `A` and `B`, and for all functions `f` from `X` to `Y`, the image of `A` under `f` is a subset of `B` if and only if for all `v`, if `v` is in `A`, then `f v` is in `B`.

### Informal sketch
The proof uses `SET_TAC[]`, which indicates that it proceeds by expanding the definitions of `IMAGE` and `SUBSET` and then simplifying using propositional logic.

*   The definition of `IMAGE f A` as `{y | ?x. x IN A /\ f x = y}` and `A SUBSET B` as `!x. x IN A ==> x IN B` are expanded.
*   Elementary logical reasoning then establishes the equivalence.

### Mathematical insight
This theorem provides a fundamental characterization of the subset relation between the image of a set under a function and another set. It links the set-theoretic notion of inclusion (`SUBSET`) with the element-wise condition (`v IN A ==> f v IN B`). This is a common way to reason about images of sets.

### Dependencies
None

### Porting notes (optional)
In other proof assistants, this theorem will likely be proven using similar unfolding of definitions and propositional reasoning. The key is to ensure that the definitions of `IMAGE` and `SUBSET` are equivalent to those in HOL Light. The automation level required for the proof may vary depending on the target system's capabilities.


---

## select_foreach

### Name of formal statement
select_foreach

### Type of the formal statement
theorem

### Formal Content
```ocaml
let select_foreach = prove(`
  !S P.
  (!s:X. s IN S ==> ?t:Y. P s t) ==>
  (!s:X. s IN S ==> P s ((\s. @t. P s t) s))
`,
  qed[]
);;
```
### Informal statement
For all sets `S` of type `X` and all predicates `P` of type `X -> Y -> bool`, if for all `s` of type `X`, `s` belonging to `S` implies that there exists a `t` of type `Y` such that `P s t` holds, then, for all `s` of type `X`, `s` belonging to `S` implies that `P s ((\s. @t. P s t) s)` holds, where `@` denotes Hilbert choice.

### Informal sketch
The theorem states that if for every element `s` in a set `S`, there exists a `t` such that `P s t`, then we can construct a function that, for each `s` in `S`, selects such a `t` using Hilbert's choice operator `@`, such that `P s ((\s. @t. P s t) s)` holds.

- The assumption `!s:X. s IN S ==> ?t:Y. P s t` asserts that for every `s` in the set `S`, there exists a `t` that satisfies the predicate `P s t`.
- The term `(\s. @t. P s t)` defines a function that maps each `s` to a `t` such that `P s t` is true, using the Hilbert choice operator `@`. The term `@t. P s t` chooses a `t` such that `P s t` holds.
- The conclusion `!s:X. s IN S ==> P s ((\s. @t. P s t) s)` asserts that for every `s` in `S`, the predicate `P` holds for `s` and the `t` chosen by the function `(\s. @t. P s t)`.

The proof consists in using the assumption `!s:X. s IN S ==> ?t:Y. P s t` to show that for a particular `s` in `S`, there exists a `t` such that `P s t`. Then, using the properties of the Hilbert choice operator `@`, derive that `P s ((\s. @t. P s t) s)`. Finally, generalize over all `s` in `S`.

### Mathematical insight
The theorem essentially shows how to construct a function that selects a witness for each element in a set, given that the existence of such a witness is guaranteed by a predicate. The Hilbert choice operator is used to make the selection function total. This is a form of Skolemization.

### Dependencies
None

### Porting notes (optional)
- Most proof assistants have a built-in choice operator or an equivalent mechanism for defining functions based on existential assumptions. The key is to correctly translate the Hilbert choice operator and its properties.
- In systems like Coq, which are based on constructive type theory, the axiom of choice is not automatically available. Thus, this might require an axiom, or be provable under certain conditions. Systems like Isabelle/HOL based on classical logic automatically have choice.


---

## o_def_s

### Name of formal statement
o_def_s

### Type of the formal statement
theorem

### Formal Content
```ocaml
let o_def_s = prove(`
  !f:Y->Z g:X->Y.
  f o g = (\s. f (g s))
`,
  qed[o_DEF]
);;
```
### Informal statement
For all functions `f` from type `Y` to type `Z` and for all functions `g` from type `X` to type `Y`, the composition `f o g` is equal to the function that maps any `s` of type `X` to `f (g s)`.

### Informal sketch
The proof is a definitional expansion of `o_DEF`.
- The theorem states the extensionality of function composition.
- The proof proceeds by applying the definition of function composition (`o_DEF`) which defines `f o g` and performs a beta-reduction, simplifying the expression to the equivalent lambda abstraction.
- Finally, the `qed` tactic completes the proof.

### Mathematical insight
This theorem expresses the standard definition of function composition in functional programming and mathematics. It defines the composition of two functions `f` and `g` as a new function that applies `g` first and then `f`. This is a fundamental concept in set theory, category theory, and programming.

### Dependencies
- Definition: `o_DEF`


---

## in_image_cd

### Name of formal statement
in_image_cd

### Type of the formal statement
theorem

### Formal Content
```ocaml
let in_image_cd = prove(`
  !d s f:X->Y.
  d IN IMAGE f s <=>
  (?c. d = f c /\ c IN s)
`,
  qed[IN_IMAGE]
);;
```
### Informal statement
For all functions `f` from a set `X` to another set `Y`, and for all domains `s` included in `X`, an element `d` belongs to the image of domain `s` under the function `f` if and only if there exists an element `c` such that `d` equals `f c` and `c` belongs to `s`.

### Informal sketch
The theorem states the equivalence between an element being in the image of a set under a function and the existence of a preimage in that set. The proof likely proceeds by showing the implication in both directions:
- First, assume `d` is in the image of `s` under `f`, that is, `d IN IMAGE f s`. By the definition of `IMAGE`, there exists a `c` in `s` such that `d = f c`.
- Conversely, assume there exists a `c` such that `d = f c` and `c IN s`. Then `d` must be in the image of `s` under `f`, namely `d IN IMAGE f s`, by the definition of `IMAGE`.
The proof uses the definition of `IMAGE`.

### Mathematical insight
This theorem provides a fundamental characterization of the image of a function applied to a set. It's a basic result in set theory and is essential for reasoning about functions and their properties. It provides a way to prove membership in the image of a function by exhibiting a suitable preimage.

### Dependencies
- Definitions: `IN_IMAGE`


---

## in_image_vw

### Name of formal statement
in_image_vw

### Type of the formal statement
theorem

### Formal Content
```ocaml
let in_image_vw = prove(`
  !w s f:X->Y.
  w IN IMAGE f s <=>
  (?v. w = f v /\ v IN s)
`,
  qed[IN_IMAGE]
);;
```
### Informal statement
For all functions `f` from a type `X` to a type `Y`, and for all sets `s` of type `X`, and for all `w` of type `Y`, `w` is an element of the image of `f` applied to `s` if and only if there exists `v` of type `X` such that `w` equals `f` applied to `v` and `v` is an element of `s`.

### Informal sketch
The proof establishes the equivalence between `w IN IMAGE f s` and `?v. w = f v /\ v IN s`. The argument proceeds as follows:

- First, the definition of `IN_IMAGE` is used to expand `w IN IMAGE f s` to `(?v. v IN s) /\ w = f v`.
- Then, the goal is rewritten using basic logical equivalences to show the equivalence of the two statements.
- Finally, the theorem is discharged.

### Mathematical insight
This theorem provides an alternative way to characterize the image of a set under a function. It states that an element `w` belongs to the image of a set `s` under a function `f` if and only if there exists an element `v` in `s` that maps to `w` under `f`.

### Dependencies
- Definitions: `IN_IMAGE`


---

## lambda_pair_ab

### Name of formal statement
lambda_pair_ab

### Type of the formal statement
theorem

### Formal Content
```ocaml
let lambda_pair_ab = prove(`
  !f:A#B->C.
  (\ab. f ab) = (\(a,b). f (a,b))
`,
  qed[LAMBDA_PAIR_THM]
);;
```
### Informal statement
For any function `f` from the Cartesian product of types `A` and `B` to type `C`, the function that takes an element `ab` of type `A#B` and applies `f` to it is equal to the function that takes a pair `(a, b)` of type `A#B` and applies `f` to the pair `(a, b)`.

### Informal sketch
The proof relies on the theorem `LAMBDA_PAIR_THM`, which likely states the extensional equality between a function applied to a combined pair and the corresponding lambda abstraction over the pair. Since the theorem `LAMBDA_PAIR_THM` is directly invoked by `qed`, the proof is a direct application of this theorem by equational reasoning, instantiating it with `f`.

### Mathematical insight
This theorem formalizes the interchangeability of viewing a function's argument as a single element from a Cartesian product and viewing the argument as a pair of elements. It's a fundamental property when dealing with functions of multiple arguments and their curried representations. It clarifies the relationship between applying a function directly to a pair and defining an equivalent function via lambda abstraction that explicitly unpacks the pair.

### Dependencies
- Theorems: `LAMBDA_PAIR_THM`


---

## injective_pair_rewrite

### Name of formal statement
injective_pair_rewrite

### Type of the formal statement
theorem

### Formal Content
```ocaml
let injective_pair_rewrite = prove(`
  !f:A#B->L.
  (!(a,b) (c,d). f (a,b) = f (c,d) ==> (a,b) = (c,d)) ==>
  !x y. f x = f y ==> x = y
`,
  rw[FORALL_PAIRED_THM] THEN
  qed[PAIR_SURJECTIVE]
);;
```
### Informal statement
For all functions `f` from `A` cross `B` to `L`, if `f` is injective on pairs from `A` cross `B` (i.e., for all pairs `(a,b)` and `(c,d)`, if `f (a,b) = f (c,d)` then `(a,b) = (c,d)`), then `f` is injective on elements of `A` cross `B` (i.e., for all `x` and `y`, if `f x = f y` then `x = y`).

### Informal sketch
The proof proceeds as follows:
- Rewrite using `FORALL_PAIRED_THM`, which converts the outer universal quantifiers `!x y.` to `!(a,b) (c,d).`.
- Apply `PAIR_SURJECTIVE` which states that any element in a product type is equal to a pair.

### Mathematical insight
This theorem shows that injectivity on pairs implies injectivity on the product type itself. This is important because pairs form a basis for the product type, and injectivity on the basis guarantees injectivity on the entire type.

### Dependencies
- Theorems: `FORALL_PAIRED_THM`
- Definitions: `PAIR_SURJECTIVE`


---

## image_pair

### Name of formal statement
image_pair

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_pair = prove(`
  !P f:A->B->C.
  IMAGE (\(a,b). f a b) {a,b | P a b}
  = {f a b | P a b}
`,
  rw[EXTENSION;IN_ELIM_THM;IN_IMAGE] THEN
  intro THEN
  splitiff THENL [
    STRIP_TAC THEN
    witness `a:A` THEN
    witness `b:B` THEN
    have `(x:C) = (\((a:A),(b:B)). f a b) (a,b)` [] THEN
    simp[]
  ;
    STRIP_TAC THEN
    witness `a:A,b:B` THEN
    conjunction THENL [
      simp[]
    ;
      witness `a:A` THEN
      witness `b:B` THEN
      simp[]
    ]
  ]
);;
```
### Informal statement
For any types A, B, and C, and for any predicate `P` over `A` and `B`, and for any function `f` from `A` to `B` to `C`, the image of the set of pairs `(a, b)` such that `P a b` holds, under the function that maps a pair `(a, b)` to `f a b`, is equal to the set of all `f a b` such that `P a b` holds.

### Informal sketch
The proof proceeds by showing the equality of the two sets via extensionality.
- First, introduce the variables `P`, and `f`.
- The goal is to prove `IMAGE (\(a,b). f a b) {a,b | P a b} = {f a b | P a b}`.
- Use extensionality to rewrite the equality of sets into an equivalence of membership: `!x. (x IN IMAGE (\(a,b). f a b) {a,b | P a b}) <=> (x IN {f a b | P a b})`.
- Then, split the iff into two implications and proceed with each sub-goal separately.
  - For the first direction, assume `x IN IMAGE (\(a,b). f a b) {a,b | P a b}`.
    - By the definition of `IMAGE`, there exists a pair `(a,b)` such that `x = f a b` and `P a b`.
    - Introduce witnesses `a` and `b` for the existential quantifier.
    - Simplify `(\((a:A),(b:B)). f a b) (a,b)` to `f a b`. Thus obtaining the goal `x = f a b /\ P a b`.
  - For the second direction, assume `x IN {f a b | P a b}`.
    - By the definition of set comprehension, there exist `a` and `b` such that `x = f a b` and `P a b` holds.
    - Introduce witnesses `a` and `b` for the existential quantifier.
    - The goal becomes to show there exists a pair `(a,b)` such that the predicate `P a b` holds, where `P a b` is `x = f a b /\ P a b`.
    - Split this goal into two parts.
      - The first part aims to prove `P a b`, which is already an assumption.
      - The second part aims to show that there exists a pair `(a,b)` satisfying `{a,b | P a b}`, which can be achieved using witnesses `a` and `b`.

### Mathematical insight
This theorem describes how image of sets defined by predicates behaves. It states that taking the image under a function is the same as applying the function to elements satisfying the predicate. This is a fundamental concept in set theory and is frequently used when reasoning about functions and sets.

### Dependencies
- `EXTENSION`
- `IN_ELIM_THM`
- `IN_IMAGE`


---

## functions

### Name of formal statement
functions

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let functions = new_definition `
  functions (A:X->bool) (B:Y->bool)
  = {f | IMAGE f A SUBSET B /\ (!z. ~(z IN A) ==> f z = ARB)}
`;;
```
### Informal statement
The set of functions from a subset `A` of type `X` to a subset `B` of type `Y` is defined as the set of all functions `f` such that the image of `A` under `f` is a subset of `B`, and for all `z`, if `z` is not in `A`, then `f(z)` is equal to an arbitrary value `ARB`.

### Informal sketch
- Define the set of functions from `A` to `B` as those functions `f` whose image of `A` is contained in `B`, and that return a default arbitrary value `ARB` outside of `A`.
- This definition ensures that functions are total, yet behave as expected when restricted to a specific domain `A`.
- The condition `f z = ARB` when `z` is not in `A` ensures totality while effectively restricting the domain of interest to `A`.

### Mathematical insight
This definition provides a way to represent functions that are defined on a subset `A` of a domain `X` but are treated as total functions from `X` to `Y`. The value `ARB` serves as a default value outside of the set `A`, ensuring that the function is defined for all inputs in `X`. This definition is useful when one wants to work with functions that are primarily meaningful on a specific subset of their domain, but still need to be defined everywhere.

### Dependencies
None


---

## in_functions

### Name of formal statement
in_functions

### Type of the formal statement
theorem

### Formal Content
```ocaml
let in_functions = prove(`
  !A:X->bool B:Y->bool f.
  f IN functions A B <=>
  IMAGE f A SUBSET B /\ (!z. ~(z IN A) ==> f z = ARB)
`,
  SET_TAC[functions]
);;
```
### Informal statement
For any sets `A` and `B` of types `X->bool` and `Y->bool` respectively, and for any function `f`, `f` is in the set of functions from `A` to `B` if and only if the image of `A` under `f` is a subset of `B` and for all `z`, if `z` is not in `A`, then `f z` equals `ARB`.

### Informal sketch
The proof uses the definition of `functions`. It expands the definition of `f IN functions A B` and then simplifies the resulting expression using set theory reasoning. 

*   The proof starts by using the `SET_TAC` tactic with the term `functions`.
*   This tactic likely expands the definition of `functions A B` in terms of sets and characteristic functions.
*   The goal is then to prove the equivalence between belonging to the set of functions, the subset relation between the image of `f` over `A` and `B`, and the constraint that `f z = ARB` when `z` is not in `A`.

### Mathematical insight
This theorem formalizes the notion of a function being in the set of functions from domain `A` to codomain `B`. It captures two essential constraints: first, the function maps elements of `A` into `B` (i.e., the image of `A` under `f` is a subset of `B`); and second, the value of `f` outside of `A` is defined to be `ARB` (an arbitrary value of the appropriate type). This ensures that functions are total, even if their behavior outside the intended domain is unspecified.

### Dependencies
*   Definitions: `functions`


---

## fun_eq_thm_e

### Name of formal statement
fun_eq_thm_e

### Type of the formal statement
theorem

### Formal Content
```ocaml
let fun_eq_thm_e = prove(`
  !f g:X->Y.
  f = g <=> (!e. f e = g e)
`,
  qed[FUN_EQ_THM]
);;
```
### Informal statement
For all functions `f` and `g` from type `X` to type `Y`, `f` is equal to `g` if and only if for all `e` of type `X`, `f e` is equal to `g e`.

### Informal sketch
The theorem states the extensionality property for functions. The proof likely proceeds as follows:
- First, assume `f = g`. Then, for an arbitrary `e`, substitute `f` for `g` in `f e`, yielding `g e = g e`, which simplifies to true.
- Conversely, assume that for all `e`, `f e = g e`. The goal is to show `f = g`. This can be achieved by using the axiom of extensionality for functions, or a previously established theorem on functional extensionality.
- The proof constructs the universal quantification over elements in the domain `X` to derive the equality of functions `f` and `g`.

### Mathematical insight
This theorem is a fundamental principle in mathematics and formal logic, indicating that two functions are equal if and only if they produce the same output for every input. It's the cornerstone of reasoning about functions and is essential for proving properties about them.

### Dependencies
Theorems:
- `FUN_EQ_THM` (likely a variant or similar theorem concerning functional equality)


---

## fun_eq_thm_v

### Name of formal statement
fun_eq_thm_v

### Type of the formal statement
theorem

### Formal Content
```ocaml
let fun_eq_thm_v = prove(`
  !f g:X->Y.
  f = g <=> (!v. f v = g v)
`,
  qed[FUN_EQ_THM]
);;
```

### Informal statement
For all functions `f` and `g` from `X` to `Y`, `f` is equal to `g` if and only if for all `v` in `X`, `f v` is equal to `g v`.

### Informal sketch
The theorem establishes the extensionality principle for functions. The proof likely proceeds in two directions:

*   **Forward direction:** Assuming `f = g`, we need to show that `!v. f v = g v`. This follows directly by substituting equals for equals.  Since `f` and `g` are equal, applying them to the same argument `v` will result in equal values.

*   **Backward direction:** Assuming `!v. f v = g v`, we need to show that `f = g`. This is the core of the extensionality argument. The proof likely uses the axiom `FUN_EQ_THM` (stated in `qed[FUN_EQ_THM]`), which directly formalizes the extensionality principle.

### Mathematical insight
The theorem `fun_eq_thm_v` states the principle of extensionality for functions. It means that two functions are equal if and only if they produce the same output for every input. This is a fundamental principle in set theory and functional programming, allowing us to reason about function equality based on their behavior rather than their internal representation. It connects the pointwise equality of function application (`f v = g v` for all `v`) with the global equality of functions (`f = g`).

### Dependencies
The proof of `fun_eq_thm_v` uses the axiom `FUN_EQ_THM` from HOL Light.


---

## image_functions_subset

### Name of formal statement
image_functions_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_functions_subset = prove(`
  !A:X->bool B:Y->bool f.
  f IN functions A B ==>
  IMAGE f A SUBSET B
`,
  SET_TAC[functions]
);;
```
### Informal statement
For all sets `A` of type `X -> bool` and `B` of type `Y -> bool`, and for all functions `f`, if `f` is a function from `A` to `B`, then the image of `A` under `f` is a subset of `B`.

### Informal sketch
The proof uses `SET_TAC` with the lemma `functions` to establish the theorem. The theorem states that if `f` is a function from `A` (a subset of `X`) to `B` (a subset of `Y`), then the image of `A` under `f` is a subset of `B`. The proof proceeds by expanding the definitions of `functions` and `IMAGE` and then demonstrating the subset relationship using basic set theory.

### Mathematical insight
The theorem `image_functions_subset` connects the concept of a function between two sets with the image of a set under a function. It formalizes the intuitive idea that if a function `f` maps elements from set `A` to set `B`, then the image of `A` under `f` must be contained within `B`. This is a fundamental result in set theory and function theory, ensuring that function application respects set boundaries as defined in the function's type.

### Dependencies
- Definitions: `functions`


---

## functions_to

### Name of formal statement
functions_to

### Type of the formal statement
theorem

### Formal Content
```ocaml
let functions_to = prove(`
  !A:X->bool B:Y->bool f x.
  f IN functions A B ==>
  x IN A ==>
  f x IN B
`,
  SET_TAC[image_functions_subset]
);;
```
### Informal statement
For any sets `A` of type `X -> bool` and `B` of type `Y -> bool`, and any function `f` and any element `x`, if `f` belongs to the set of functions from `A` to `B`, and `x` belongs to `A`, then `f x` belongs to `B`.

### Informal sketch
The proof relies on the theorem `image_functions_subset`. It asserts that if a function `f` is in the set of functions from `A` to `B`, then for any `x` in `A`, `f x` is in `B`. The tactic `SET_TAC` is used along with theorem `image_functions_subset`.

### Mathematical insight
This theorem captures the fundamental property of functions mapping between sets. It asserts that if a function `f` maps elements of a set `A` to a set `B`, then whenever an input `x` belongs to `A`, the corresponding output `f x` must belong to `B`. This is the core concept behind the definition of a function between sets. The "functions to" property is crucial for reasoning about function types and set theory within HOL Light.

### Dependencies
- Theorems: `image_functions_subset`


---

## finite_functions

### Name of formal statement
finite_functions

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_functions = prove(`
  !A:X->bool B:Y->bool.
  FINITE A ==>
  FINITE B ==>
  FINITE (functions A B)
`,
  rw[functions] THEN
  intro THEN
  subgoal `{f | IMAGE f A SUBSET B /\ (!x:X. ~(x IN A) ==> f x = ARB:Y)} = {f | IMAGE f A SUBSET B /\ {x | ~(f x = ARB)} SUBSET A}` THENL [
    SET_TAC[]
  ; pass
  ] THEN
  simp[] THEN
  specialize[
    `A:X->bool`;
    `B:Y->bool`;
    `\a:X. ARB:Y`
  ]FINITE_RESTRICTED_FUNSPACE THEN
  qed[]
);;
```
### Informal statement
For all predicates `A` on a type `X` and `B` on a type `Y`, if `A` and `B` are finite, then the set of functions from `X` to `Y` that map elements in `A` to elements in `B` (i.e., the functions for which the image of `A` is a subset of `B`) is also finite.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definition of `functions`.
- Introduce the assumptions.
- Reduce the problem to showing the equality of two sets: `{f | IMAGE f A SUBSET B /\ (!x:X. ~(x IN A) ==> f x = ARB:Y)} = {f | IMAGE f A SUBSET B /\ {x | ~(f x = ARB)} SUBSET A}`. This equality states that a function restricted to A mapping into B is the same as a function whose points outside of A always return `ARB`.
- Prove this set equality using `SET_TAC`.
- Simplify, which reduces the goal to showing the finiteness of functions `functions A B` given finiteness of `A` and `B`.
- Specialize the theorem `FINITE_RESTRICTED_FUNSPACE` with `A`, `B`, and the constant function `\a:X. ARB:Y` to complete the proof.

### Mathematical insight
The theorem establishes that the set of functions from a finite set `A` to a finite set `B` is finite. The `functions A B` represents the set of functions from a subset defined by predicate `A` to a subset defined by predicate `B`. The finiteness of the domain and codomain guarantees the finiteness of the function space, and the proof leverages `FINITE_RESTRICTED_FUNSPACE` which formalizes this intuition

### Dependencies
- `functions`
- `FINITE_RESTRICTED_FUNSPACE`


---

## functions_empty

### Name of formal statement
functions_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let functions_empty = prove(`
  !B:Y->bool.
  functions {} B = {\x:X. ARB}
`,
  rw[functions] THEN
  rw[EXTENSION;IN_SING;IN_ELIM_THM;IMAGE_CLAUSES;EMPTY_SUBSET;SUBSET;EMPTY] THEN
  qed[FUN_EQ_THM]
);;
```
### Informal statement
For any set `B` of type `Y -> bool`, the set of functions from the empty set to `B` is equal to the set containing the function that always returns `ARB` (an arbitrary value).

### Informal sketch
The proof shows that for any set `B` of type `Y -> bool`, the set of functions from the empty set to `B` is equal to the set containing the function that always returns `ARB`.  The proof proceeds as follows:
- By definition of `functions`, `functions {} B` is equal to `IMAGE (λf. restrict f {}) B`.
- Simplify the expression `IMAGE (λf. restrict f {}) B` using `EXTENSION;IN_SING;IN_ELIM_THM;IMAGE_CLAUSES;EMPTY_SUBSET;SUBSET;EMPTY`.
- Use `FUN_EQ_THM` to finalize equality.

### Mathematical insight
This theorem states that there is exactly one function from the empty set to any set `B`. This function is usually taken to be the empty function or a function that always returns an arbitrary value. The theorem formalizes this intuition.

### Dependencies
- Definitions: `functions`
- Theorems: `EXTENSION`, `IN_SING`, `IN_ELIM_THM`, `IMAGE_CLAUSES`, `EMPTY_SUBSET`, `SUBSET`, `EMPTY`, `FUN_EQ_THM`


---

## functions_insert

### Name of formal statement
functions_insert

### Type of the formal statement
theorem

### Formal Content
```ocaml
let functions_insert = prove(`
  !A:X->bool B:Y->bool i:X.
  ~(i IN A) ==>
  functions (i INSERT A) B
  = IMAGE
      (\((b:Y),(f:X->Y)) (a:X). if a = i then b else f a)
      (B CROSS (functions A B))
`,
  rw[functions;EXTENSION;IN_ELIM_THM;in_image_vw] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    witness `(x(i:X):Y),(\a:X. if a = i then ARB:Y else x a)` THEN
    rw[BETA_THM;IN_CROSS] THEN
    intro THENL [
      qed[FUN_EQ_THM]
    ;
      ASM SET_TAC[]
    ;
      rw[IN_ELIM_THM] THEN
      ASM SET_TAC[]
    ]
  ;
    rw[IMAGE_CLAUSES;INSERT_SUBSET;EXISTS_PAIR_THM;IN_CROSS;IN_ELIM_THM] THEN
    ASM SET_TAC[]
  ]
);;
```

### Informal statement
For any sets `A` and `B` represented as predicates on types `X` and `Y` respectively, and any element `i` of type `X`, if `i` is not an element of `A`, then the `functions` set of maps from `i INSERT A` to `B` is equal to the image of the cross product of `B` and the set of `functions` from `A` to `B`  under the lambda function that maps a pair `(b, f)`  to a function from `X` to `Y` which returns `b` if the input is equal to `i` and otherwise returns `f(a)`.

### Informal sketch
The proof proceeds by showing the equality of two sets using extensionality - by splitting the implication into two cases:

*   **Showing that LHS is a subset of RHS:** Assuming `f` is a function from `i INSERT A` to `B`, we need to construct a pair `(b, g)` in `B CROSS (functions A B)` such that the lambda function `\(a:X). if a = i then b else g a` produces `f`. We pick `b = f(i)` and define `g` as `g(a) = f(a)` with the condition on the `if` statement satisfying the required conditions. The goal then to show that the `g` has the required properties.
*   **Showing that RHS is a subset of LHS:** Assuming a pair `(b, f)` in `B CROSS (functions A B)`, we need to show that the function `\(a:X). if a = i then b else f a` is in the set `functions (i INSERT A) B`. We use the definition of `functions` to show that the range of this lambda function is a subset of `B`. The proof obligation involves showing that something is an element of `i INSERT A`.

### Mathematical insight
This theorem describes how to construct functions from a set `A` extended with a new element `i` to a set `B`, given the functions from `A` to `B` and the set `B`. It decomposes the set of functions `(i INSERT A) -> B` into functions which "stitch" together a value in `B` assigned to `i` with a function from `A` to `B`.

### Dependencies
*   `functions`
*   `EXTENSION`
*   `IN_ELIM_THM`
*   `in_image_vw`
*   `BETA_THM`
*   `IN_CROSS`
*   `FUN_EQ_THM`
*   `IMAGE_CLAUSES`
*   `INSERT_SUBSET`
*   `EXISTS_PAIR_THM`

### Porting notes (optional)
This definition relies on HOL Light's set theory and function definition mechanisms. Porting to other systems might require encoding sets as predicates, and functions as relations or lambda terms. The `IMAGE` and `CROSS` operators have standard equivalents in other systems. Note that the `FUN_EQ_THM` shows function equality by extensionality.


---

## functions_insert_injective

### Name of formal statement
functions_insert_injective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let functions_insert_injective = prove(`
  !A:X->bool B:Y->bool i:X v w.
  ~(i IN A) ==>
  v IN B CROSS functions A B ==>
  w IN B CROSS functions A B ==>
  (\((b:Y),(f:X->Y)) (a:X). if a = i then b else f a) v
  = (\((b:Y),(f:X->Y)) (a:X). if a = i then b else f a) w ==>
  v = w
`,
  rw[FORALL_PAIR_THM;IN_CROSS;PAIR_EQ;FUN_EQ_THM] THEN
  rw[functions;IN_ELIM_THM] THEN
  qed[]
);;
```
### Informal statement
For all sets `A` of type `X->bool` and `B` of type `Y->bool`, and for all `i` of type `X`, and for all `v` and `w`, given that `i` is not in `A`, and `v` is in the Cartesian product `B CROSS functions A B`, and `w` is in the Cartesian product `B CROSS functions A B`, if the function that maps each `a` of type `X` to `b` if `a = i` and to `f a` otherwise, when applied to `v`, is equal to the function that maps each `a` of type `X` to `b` if `a = i` and to `f a` otherwise, when applied to `w`, then `v` is equal to `w`.

### Informal sketch
The proof proceeds as follows:
- First, the theorem is rewritten using the definition of `FORALL_PAIR_THM`, `IN_CROSS`, `PAIR_EQ`, and `FUN_EQ_THM`, which decomposes the equality of the pair of values into equality of the components using the function equality theorem.
- Then, the `functions` definition is expanded.
- Finally, the proof is completed using the standard tactics.

### Mathematical insight
This theorem states that if inserting a value into a function at a point outside its original domain results in the same function value for two inputs, then the two inputs must be equal. The key idea is that the condition `~(i IN A)` ensures that the inserted point `i` is not already in the domain `A`, so the function being defined is effectively injective over insertions. This property provides a way to reason about the injectivity properties of functions extended or modified at specific points.

### Dependencies
- `FORALL_PAIR_THM`
- `IN_CROSS`
- `PAIR_EQ`
- `FUN_EQ_THM`
- `functions`
- `IN_ELIM_THM`


---

## perm

### Name of formal statement
perm

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let perm = new_definition `
  perm (S:X->bool) (f:X->X)
  <=> f permutes S
`;;
```

### Informal statement
For any set `S` of elements of type `X` (represented as a boolean predicate on `X`) and any function `f` from `X` to `X`, `perm S f` is true if and only if `f` permutes `S`.

### Informal sketch
The definition introduces a predicate `perm S f` where `S` is a set and `f` is a function. The predicate is defined such that it holds if and only if function `f` is a permutation on the set `S`. The intention is to define what it means for a function to permute a set.

### Mathematical insight
This definition provides a formal way to express that a function `f` rearranges the elements of a set `S` without adding or removing elements, i.e., it's a one-to-one correspondence from `S` to itself. This notion of permutation is fundamental in combinatorics and group theory.

### Dependencies
None


---

## perm_in_permutes

### Name of formal statement
perm_in_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let perm_in_permutes = prove(`
  !S:X->bool f.
  perm S f <=> f IN {p | p permutes S}
`,
  rw[IN_ELIM_THM;perm]
);;
```
### Informal statement
For any set `S` of type `X->bool` and any function `f` of type `X->X`, `f` is a permutation of `S` if and only if `f` is an element of the set of permutations of `S`.

### Informal sketch
The proof proceeds by rewriting using the definition of membership (`IN_ELIM_THM`) and the definition of permutation (`perm`).
- `IN_ELIM_THM` eliminates the `IN` by replacing `f IN {p | p permutes S}` with `(p permutes S)[p\f]`.
- `perm` unfolds the predicate `perm S f` directly.

### Mathematical insight
This theorem establishes the equivalence between directly stating that a function `f` is a permutation of a set `S` and stating that `f` belongs to the set of all permutations of `S`. It is a basic but important result that links the individual property of being a permutation with the set of all permutations sharing that property.

### Dependencies
- Theorem: `IN_ELIM_THM`
- Definition: `perm`


---

## perm_set_permutes

### Name of formal statement
perm_set_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let perm_set_permutes = prove(`
  !S:X->bool.
  perm S = {p | p permutes S}
`,
  rw[EXTENSION;IN;perm_in_permutes]
);;
```

### Informal statement
For any set `S` of type `X->bool`, the set of permutations of `S`, denoted `perm S`, is equal to the set of all `p` such that `p` permutes `S`.

### Informal sketch
The proof uses the following steps:
- Expand the definition of set equality `EXTENSION`. This reduces the goal to showing that for any `p`, `p IN perm S` is equivalent to `p permutes S`.
- Apply the definition `IN` to rewrite `p IN perm S` to `perm p S`.
- Apply the theorem `perm_in_permutes` to show that `perm p S` is equivalent to `p permutes S`.

### Mathematical insight
This theorem establishes the equivalence between two ways of expressing that `p` is a permutation of a set `S`. The left-hand side `perm S` is a set-theoretic representation of all permutations, while the right-hand side `p permutes S` uses the predicate saying `p` is a permutation of `S`.

### Dependencies
- Theorems:
  - `perm_in_permutes`
- Definitions:
  - `EXTENSION`
  - `IN`


---

## card_perm

### Name of formal statement
card_perm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_perm = prove(`
  !S:X->bool.
  FINITE S ==>
  CARD(perm S) = FACT(CARD S)
`,
  rw[perm_set_permutes;CARD_PERMUTATIONS]
);;
```
### Informal statement
For all sets `S` from type `X` to boolean, if `S` is finite then the cardinality of the set of permutations of `S` is equal to the factorial of the cardinality of `S`.

### Informal sketch
The theorem states that the number of permutations of a finite set `S` is equal to the factorial of the number of elements in `S`. The proof proceeds as follows.

- First, rewrite using `perm_set_permutes` to replace the term `perm S` with `PERMUTATIONS S`. `perm_set_permutes` states that the permutations of a set `S` are equivalent to the set of all permutations of `S`, where `PERMUTATIONS` is defined elsewhere.
- Second, rewrite using `CARD_PERMUTATIONS` theorem which directly proves the goal.

### Mathematical insight
The theorem formalizes a standard result from combinatorics: the number of ways to arrange *n* distinct objects is *n*!. The theorem connects the notion of permutations as they are represented in HOL Light with the standard combinatorial result about counting them.

### Dependencies
- Definitions: `FINITE`, `CARD`, `perm`, `PERMUTATIONS`, `FACT`
- Theorems: `perm_set_permutes`, `CARD_PERMUTATIONS`


---

## finite_perm

### Name of formal statement
finite_perm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_perm = prove(`
  !S:X->bool.
  FINITE S ==>
  FINITE(perm S)
`,
  rw[perm_set_permutes;FINITE_PERMUTATIONS]
);;
```
### Informal statement
For any set `S` of type `X->bool`, if `S` is finite, then the set of permutations of `S`, denoted `perm S`, is also finite.

### Informal sketch
The proof proceeds by:
- Rewriting using the theorem `perm_set_permutes`, which expresses `perm S` as the set of permutations that permute the set `S`
- Applying the theorem `FINITE_PERMUTATIONS`, which states that for a finite set, the set of all its permutations is also finite.

### Mathematical insight
This theorem demonstrates a fundamental property: the number of permutations of a finite set is also finite. This is crucial in combinatorial arguments and when reasoning about the complexity of algorithms that involve permutations. The statement provides a useful tool for establishing finiteness results in various domains where permutations are involved.

### Dependencies
- `perm_set_permutes`
- `FINITE_PERMUTATIONS`


---

## permutes_o_inverse_refl_o

### Name of formal statement
permutes_o_inverse_refl_o

### Type of the formal statement
theorem

### Formal Content
```ocaml
let permutes_o_inverse_refl_o = prove(`
  !A:X->bool f:X->X g:Y->X.
  f permutes A ==>
  f o inverse f o g = g
`,
  intro THEN
  have `f:X->X o inverse f = I` [PERMUTES_INVERSES_o] THEN
  rw[o_ASSOC] THEN
  qed[I_O_ID]
);;
```
### Informal statement
For any boolean predicate `A` over a type `X`, any function `f` from `X` to `X`, and any function `g` from `Y` to `X`, if `f` permutes `A`, then `f` composed with (the inverse of `f`) composed with `g` equals `g`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions using `intro`.
- Instantiate the theorem `PERMUTES_INVERSES_o` to obtain the fact that `f o inverse f = I` where `I` is the identity function.
- Rewrite using the associativity of function composition `o`.
- Apply `I_O_ID` which states that `I o g = g` for any function `g`.

### Mathematical insight
The theorem states that if a function `f` permutes a set `A`, then composing `f` with its inverse on the left cancels `f` when applied to any function `g`. This relies on the fact that `f` "undoes" itself when composed with its inverse, effectively acting as the identity function in this context.

### Dependencies
- Theorems:
  - `PERMUTES_INVERSES_o`
  - `o_ASSOC`
  - `I_O_ID`


---

## inverse_permutes_o_refl_o

### Name of formal statement
inverse_permutes_o_refl_o

### Type of the formal statement
theorem

### Formal Content
```ocaml
let inverse_permutes_o_refl_o = prove(`
  !A:X->bool f:X->X g:Y->X.
  f permutes A ==>
  inverse f o f o g = g
`,
  intro THEN
  have `inverse f o f:X->X = I` [PERMUTES_INVERSES_o] THEN
  rw[o_ASSOC] THEN
  qed[I_O_ID]
);;
```
### Informal statement
For any types `X` and `Y`, for any boolean predicate `A` on `X`, for any function `f` from `X` to `X`, and for any function `g` from `Y` to `X`, if `f` permutes `A`, then `inverse f o f o g = g`.

### Informal sketch
The proof proceeds as follows:
- Assume `f` permutes `A`.
- Prove `inverse f o f = I` using the theorem `PERMUTES_INVERSES_o`.
- Rewrite `inverse f o f o g` as `I o g` by associativity of function composition (`o_ASSOC`).
- Then, `I o g = g` by the identity property of `I` with respect to function composition (`I_O_ID`).

### Mathematical insight
This theorem states that if `f` is a permutation on a subset `A` of `X`, then composing the inverse of `f` with `f` effectively cancels out, and pre-composing with any function `g: Y -> X` results in no change to `g`.

### Dependencies
- Theorems:
    - `PERMUTES_INVERSES_o`
    - `o_ASSOC`
    - `I_O_ID`


---

## image_permutes_o_perm

### Name of formal statement
image_permutes_o_perm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_permutes_o_perm = prove(`
  !A:X->bool f:X->X.
  f permutes A ==>
  IMAGE (\i. f o i) (perm A) = perm A
`,
  rw[EXTENSION;in_image_vw;IN_ELIM_THM;perm_set_permutes] THEN
  intro THEN
  splitiff THENL [
    qed[PERMUTES_COMPOSE]
  ;
    intro THEN
    witness `inverse f:X->X o x:X->X` THEN
    qed[permutes_o_inverse_refl_o;PERMUTES_INVERSE;PERMUTES_COMPOSE]
  ]
);;
```
### Informal statement
For any set `A` of type `X->bool` (representing a subset of `X`) and any function `f` of type `X->X`, if `f` permutes `A`, then the image of the permutation of `A` under the function that maps a permutation `i` to the composition `f o i` is equal to the permutation of `A`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `EXTENSION`, `in_image_vw`, `IN_ELIM_THM` and `perm_set_permutes`.
- Introduce the assumptions.
- Split the problem into two subgoals using `splitiff`.
  - For the first subgoal, directly prove it using `PERMUTES_COMPOSE`.
  - For the second subgoal, introduce an assumption then provide a witness `inverse f:X->X o x:X->X`, then prove it using `permutes_o_inverse_refl_o`, `PERMUTES_INVERSE`, and `PERMUTES_COMPOSE`.

### Mathematical insight
This theorem states that if `f` permutes a set `A`, then applying `f` to permutations of `A` (by composing `f` with the permutations) results in the same set of permutations of `A`. This reflects the idea that permuting a set and then applying a permutation to the result just gives another permutation of the original set.

### Dependencies
- Theorems:
  - `EXTENSION`
  - `in_image_vw`
  - `IN_ELIM_THM`
  - `perm_set_permutes`
  - `PERMUTES_COMPOSE`
  - `permutes_o_inverse_refl_o`
  - `PERMUTES_INVERSE`


---

## image_permutes_o_functions_perm

### Name of formal statement
image_permutes_o_functions_perm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_permutes_o_functions_perm = prove(`
  !A:X->bool B:Y->bool f:X->X.
  f permutes A ==>
  IMAGE
    (\g i. g(f o i))
    (functions (perm A) B)
  = functions (perm A) B
`,
  rw[EXTENSION;functions;in_image_vw;IN_ELIM_THM] THEN
  rw[elim_image_subset_u] THEN
  intro THEN
  have `inverse f:X->X permutes A` [PERMUTES_INVERSE] THEN
  have `!a:X->X. inverse f o f:X->X o a = a` [inverse_permutes_o_refl_o] THEN
  have `!a:X->X. f o inverse f:X->X o a = a` [permutes_o_inverse_refl_o] THEN
  splitiff THENL [
    intro THENL [
      have `u:X->X permutes A` [IN;perm] THEN
      have `f:X->X o u:X->X permutes A` [PERMUTES_COMPOSE] THEN
      qed[IN;perm]
    ;
      case `f:X->X o z:X->X permutes A` THENL [
        have `z:X->X permutes A` [PERMUTES_COMPOSE] THEN
        qed[IN;perm]
      ; pass
      ] THEN
      qed[IN;perm]
    ]
  ;
    intro THEN
    def `y:(X->X)->Y` `\i:X->X. x (inverse f:X->X o i):Y` THEN
    witness `y:(X->X)->Y` THEN
    intro THENL [
      simp[fun_eq_thm_e]
    ;
      qed[IN;perm;PERMUTES_COMPOSE]
    ;
      case `inverse f:X->X o z:X->X permutes A` THENL [
        have `z:X->X permutes A` [PERMUTES_COMPOSE] THEN
        qed[IN;perm]
      ; pass
      ] THEN
      qed[IN;perm]
    ]
  ]
);;
```
### Informal statement
For any types `X` and `Y`, any predicate `A` on `X`, any predicate `B` on `Y`, and any function `f` from `X` to `X`, if `f` permutes `A`, then the image of the set of functions from the permutations of `A` to `Y` under the mapping `g` to `g o (f o i)` (for some `i`) equals the set of functions from the permutations of `A` to `Y`.

### Informal sketch
The proof shows that if `f` permutes `A`, then the image of `functions (perm A) B` under the given mapping is equal to `functions (perm A) B`. This is shown by proving the two subset inclusions.

- First, show that the image is a subset of `functions (perm A) B`.
    - Assume `u` is in `perm A`. Thus `u permutes A`.
    - Since `f permutes A`, then `f o u permutes A` (using `PERMUTES_COMPOSE`).
- Next, show that `functions (perm A) B` is a subset of the image.
    - Introduce `x:X->Y`.
    - Define `y` by `\i. x (inverse f o i)`. The claim is that `y` is a suitable witness.
    - Need to check that `y` is in `functions (perm A) B`, ie if `z permutes A` then `y z` is in `B`
    - Since `inverse f o z permutes A` implies `z permutes A`, the result follows.
    - The aim is to show that `x = \i. y (f o i)`.  Since `y` is specifically `\i. x (inverse f o i)`, showing that `f o i :X->X permutes A` if and only if `i:X->X permutes A`.

### Mathematical insight
This theorem states that composing with a permutation on the left within functions from permutations to a type preserves the set of functions. This is relevant in contexts where one wants to consider functions that are invariant under certain permutations.

### Dependencies
- `EXTENSION`
- `functions`
- `in_image_vw`
- `IN_ELIM_THM`
- `elim_image_subset_u`
- `PERMUTES_INVERSE`
- `inverse_permutes_o_refl_o`
- `permutes_o_inverse_refl_o`
- `IN`
- `perm`
- `PERMUTES_COMPOSE`
- `fun_eq_thm_e`


---

## injective_permutes_arbo_functions

### Name of formal statement
injective_permutes_arbo_functions

### Type of the formal statement
theorem

### Formal Content
```ocaml
let injective_permutes_arbo_functions = prove(`
  !A:X->bool B:Y->bool p:Y->Y f g.
  p permutes B ==>
  f IN functions A B ==>
  g IN functions A B ==>
  (\a. if a IN A then p (f a) else ARB) =
  (\a. if a IN A then p (g a) else ARB) ==>
  f = g
`,
  rw[in_functions;elim_image_subset_u] THEN
  rw[fun_eq_thm_e] THEN
  qed[permutes]
);;
```
### Informal statement
For any sets `A` and `B` represented by predicates `X : T -> bool` and `Y : T -> bool` respectively, any permutation `p` of `B`, and any functions `f` and `g` from `A` to `B`, if `p` permutes `B`, `f` is a function from `A` to `B`, `g` is a function from `A` to `B`, and the function that maps any `a` to `p (f a)` if `a` is in `A` and to `ARB` otherwise, is equal to the function that maps any `a` to `p (g a)` if `a` is in `A` and to `ARB` otherwise, then `f` and `g` are equal.

### Informal sketch
The proof proceeds as follows:
- First, expand the definition of `IN functions A B` using `rw[in_functions;elim_image_subset_u]`. This likely rewrites the statement to explicitly state that `f` and `g` are functions from `A` to `B` by checking that the image of `f` and `g` when restricted to `A` is a subset of `B`.
- Then, apply `rw[fun_eq_thm_e]`. This expands functional equality to element-wise equality, turning function equality into an equality between function application on an arbitrary element.
- Finally, apply the theorem `permutes` to complete the proof. This likely applies the property that a permutation is injective, implying that if `p (f a) = p (g a)` then `f a = g a`, leading to `f = g`.

### Mathematical insight
This theorem states that if two functions from `A` to `B` are transformed by the same permutation on `B`, and the results are equal when extended outside of `A` with `ARB`, then the original functions must be equal. This relies on the injectivity of permutations. The `ARB` is used as default value when the function is applied to items that are not in the domain `A`.

### Dependencies
- `in_functions`
- `elim_image_subset_u`
- `fun_eq_thm_e`
- `permutes`

### Porting notes (optional)
The use of `ARB` can be tricky depending on the target proof assistant's handling of undefined values. Ensure such a value exists and that the logic regarding its occurrence within the domain `A` is correctly handled. In proof assistants without built-in permutation types, ensure a suitable definition of `permutes` is available (likely requiring proofs of surjectivity and injectivity).


---

## image_permutes_arbo_functions

### Name of formal statement
image_permutes_arbo_functions

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_permutes_arbo_functions = prove(`
  !A:X->bool B:Y->bool p:Y->Y.
  p permutes B ==>
  IMAGE (\ab a. if a IN A then p(ab a) else ARB)
    (functions A B)
  = functions A B
`,
  rw[EXTENSION;IN_IMAGE;in_functions;elim_image_subset_u] THEN
  rw[fun_eq_thm_e] THEN
  intro THEN
  have `inverse (p:Y->Y) permutes B` [PERMUTES_INVERSE] THEN
  splitiff THENL [
    intro THENL [
      simp[] THEN
      qed[PERMUTES_IN_IMAGE]
    ;
      qed[permutes]
    ]
  ;
    intro THEN
    witness `\a:X. if a IN A then (inverse p)(x a:Y) else ARB:Y` THEN
    rw[BETA_THM] THEN
    intro THENL [
      simp[] THEN
      qed[PERMUTES_INVERSES;permutes]
    ;
      qed[PERMUTES_IN_IMAGE]
    ;
      qed[]
    ]
  ]
);;
```

### Informal statement
For any types `X` and `Y`, and any predicates `A: X -> bool` and `B: Y -> bool`, and any function `p: Y -> Y`, if `p` permutes `B`, then the image of the set of functions from `A` to `B` under the mapping that sends a function `ab` to the function that maps `a` to `p(ab a)` if `a` is in `A`, and to `ARB` otherwise, is equal to the set of functions from `A` to `B`.

### Informal sketch
The proof establishes the equality of two sets via extensionality. It assumes `p` permutes `B`.

- First, it shows that the image is a subset of `functions A B`. This follows from the fact that `p` maps elements within `B` (the codomain constraint).
- Second, it shows that `functions A B` is a subset of the image. To do this, it exhibits a witness function `f` defined as `\a:X. if a IN A then (inverse p)(x a:Y) else ARB:Y` such that the image of `f` under the given mapping is equal to `x`, where `x` is an arbitrary element of `functions A B`.

The proof relies crucially on the properties of permutations, especially the existence of an inverse `inverse p` and the fact that `p (inverse p y) = y` for elements `y` in `B`. The tactic `PERMUTES_INVERSE` is used to introduce the fact that `inverse (p:Y->Y) permutes B`.
The tactic `PERMUTES_INVERSES` is used to establish that for any `y` such that `y IN B`, then `p (inverse p y) = y`.
The tactic `PERMUTES_IN_IMAGE` provides the equivalence that `y IN B ==> p y IN B`.

### Mathematical insight
This theorem states that permuting the codomain of functions from `A` to `B` and then pushing forward through a specific transformation doesn't change the set of functions. This is a property of permutations, where rearranging the elements within the codomain still results in a function that can map to any value within that original codomain.

### Dependencies
- `EXTENSION`
- `IN_IMAGE`
- `in_functions`
- `elim_image_subset_u`
- `fun_eq_thm_e`
- `PERMUTES_INVERSE`
- `BETA_THM`
- `PERMUTES_INVERSES`
- `permutes`
- `PERMUTES_IN_IMAGE`

### Porting notes (optional)
- Ensure that the target proof assistant has a well-defined concept of permutations and inverses.
- Pay close attention to the handling of the `ARB` term, which represents an arbitrary value of the appropriate type. The target proof assistant must either have a similar mechanism, or the proof must be adapted to work without it.
- The proof makes heavy use of rewriting and equational reasoning, which may require specific tactics or support in the target proof assistant.


---

## injective_permutes_arbo_functions_functions

### Name of formal statement
injective_permutes_arbo_functions_functions

### Type of the formal statement
theorem

### Formal Content
```ocaml
let injective_permutes_arbo_functions_functions = prove(`
  !A:X->bool B:Y->bool C:Z->bool p:Y->Y f g.
  p permutes B ==>
  f IN functions (functions A B) C ==>
  g IN functions (functions A B) C ==>
  (\ab. if ab IN functions A B
        then f (\a. if a IN A then p (ab a) else ARB)
        else ARB) =
  (\ab. if ab IN functions A B
        then g (\a. if a IN A then p (ab a) else ARB)
        else ARB) ==>
  f = g
`,
  rw[fun_eq_thm_e] THEN
  intro THEN
  case `e:X->Y IN functions A B` THENL [
    have `inverse (p:Y->Y) permutes B` [PERMUTES_INVERSE] THEN
    subgoal `(\a:X. if a IN A then (inverse p)(e a:Y):Y else ARB) IN functions A B` THENL [
      rw[functions;IN_ELIM_THM;SUBSET;in_image_vw] THEN
      qed[functions_to;PERMUTES_IN_IMAGE]
    ; pass
    ] THEN
    subgoal `(\a:X. if a IN A then p(if a IN A then (inverse p)(e a:Y):Y else ARB) else ARB) = e` THENL [
      rw[FUN_EQ_THM] THEN
      qed[in_functions;PERMUTES_INVERSES]
    ; pass
    ] THEN
    specialize[
      `\a:X. if a IN A then (inverse p)(e a:Y):Y else ARB`
    ](know `!e:X->Y. (if e IN functions A B then f (\a. if a IN A then p (e a) else ARB:Y) else ARB) = (if e IN functions A B then g (\a. if a IN A then p (e a:Y) else ARB) else ARB):Z`) THEN
    qed[]
  ; pass
  ] THEN
  qed[in_functions]
);;
```
### Informal statement
For all sets A of type X->bool, B of type Y->bool, and C of type Z->bool, for all permutations p of type Y->Y that permutes B, for all functions f and g of type (X->Y)->Z, if f and g are in the set of functions from (functions A B) to C, and if the function that maps `ab` to `if ab IN functions A B then f (\a. if a IN A then p (ab a) else ARB) else ARB` is equal to the function that maps `ab` to `if ab IN functions A B then g (\a. if a IN A then p (ab a) else ARB) else ARB`, then f is equal to g.

### Informal sketch
The proof proceeds as follows:
- Assume `p` permutes `B`, `f` and `g` are functions from `functions A B` to `C`, and the two given functions are equal.
- We aim to show `f = g` using extensionality (proved with `fun_eq_thm_e`), that is, `!f g. (f = g) <=> (!x. f x = g x)`.
- Introduce an arbitrary `e : X -> Y` assumed to be in `functions A B`.
- We want to show that `f e = g e` under the given assumptions.
- Given `p permutes B`, we infer that the inverse of `p` also permutes `B`. This is stated using `PERMUTES_INVERSE`.
- First, prove that `(\a:X. if a IN A then (inverse p)(e a:Y):Y else ARB)` is in `functions A B`. This step involves rewriting with definitions like `functions` and using `PERMUTES_IN_IMAGE`.
- Second, prove that `(\a:X. if a IN A then p(if a IN A then (inverse p)(e a:Y):Y else ARB) else ARB) = e`. This utilizes `PERMUTES_INVERSES`.
- Specialize the assumption `!e:X->Y. (if e IN functions A B then f (\a. if a IN A then p (e a) else ARB:Y) else ARB) = (if e IN functions A B then g (\a. if a IN A then p (e a:Y) else ARB) else ARB):Z` with the expression `\a:X. if a IN A then (inverse p)(e a:Y):Y else ARB`.

### Mathematical insight
The theorem essentially states that if a permutation `p` is applied to the output of functions in `functions A B` before being fed into `f` and `g`, then the equality of `f` and `g` can be inferred from the equality of the composed functions. This relies on the fact that `p` is a permutation, ensuring that we can "undo" the permutation to recover the original input to `f` and `g`. The `ARB` terms ensures that this works for all values, including outside the functions sets.

### Dependencies
- Theorems: `fun_eq_thm_e`, `PERMUTES_INVERSES`, `PERMUTES_INVERSE`
- Definitions: `functions`, `SUBSET`, `IN_ELIM_THM`, `functions_to`, `PERMUTES_IN_IMAGE`, `FUN_EQ_THM`


---

## image_permutes_arbo_functions_functions

### Name of formal statement
image_permutes_arbo_functions_functions

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_permutes_arbo_functions_functions = prove(`
  !A:X->bool B:Y->bool C:Z->bool p:Y->Y.
  p permutes B ==>
  IMAGE
    (\bc ab. if ab IN functions A B
             then bc(\a. if a IN A
                         then p(ab(a))
                         else ARB)
             else ARB)
    (functions (functions A B) C)
  = functions (functions A B) C
`,
  rw[EXTENSION;functions;in_image_vw;IN_ELIM_THM] THEN
  once_rw[elim_image_subset_u] THEN
  once_rw[elim_image_subset_v] THEN
  rw[IN_ELIM_THM] THEN
  intro THEN
  splitiff THENL [
    intro THENL [
      simp[] THEN
      sufficesby(know `!u. (!v:X. v IN A ==> u v:Y IN B) /\ (!z. ~(z IN A) ==> u z = ARB) ==> v u:Z IN C`) THEN
      simp[BETA_THM;o_DEF] THEN
      qed[PERMUTES_IN_IMAGE]
    ;
      simp[]
    ]
  ;
    intro THENL [
      witness `\ab:X->Y. if ab IN functions A B then x(\a. if a IN A then (inverse p:Y->Y)(ab(a)) else ARB) else ARB:Z` THEN
      rw[functions;elim_image_subset_v;IN_ELIM_THM] THEN
      intro THENL [
        rw[fun_eq_thm_e] THEN
        intro THEN
        case `(!u:X. u IN A ==> e u:Y IN B) /\ (!z. ~(z IN A) ==> e z = ARB)` THENL [
          case `!v:X. v IN A ==> p (e v:Y):Y IN B` THENL [
            subgoal `e:X->Y = (\a. if a IN A then inverse p ((p:Y->Y) (e a)) else ARB)` THENL [
              rw[FUN_EQ_THM] THEN
              qed[PERMUTES_INVERSES]
            ; pass
            ] THEN
            simp[] THEN
            qed[]
          ; pass
          ] THEN
          simp[] THEN
          sufficesby(know `!z. ~((!u:X. u IN A ==> z u:Y IN B) /\ (!a. ~(a IN A) ==> z a = ARB)) ==> x z = ARB:Z`) THEN
          qed[permutes]
        ; pass
        ] THEN
        simp[]
      ;
        simp[] THEN
        sufficesby(know `!u. (!v:X. v IN A ==> u v:Y IN B) /\ (!z. ~(z IN A) ==> u z = ARB) ==> x u:Z IN C`) THEN
        rw[BETA_THM] THEN
        simp[] THEN
        qed[PERMUTES_INVERSE;PERMUTES_IN_IMAGE]
      ;
        qed[]
      ]
    ]
  ]
);;
```
### Informal statement
For all sets `A` of type `X -> bool`, `B` of type `Y -> bool`, and `C` of type `Z -> bool`, and for all permutations `p` of type `Y -> Y` over `B`, the image of the function space `functions (functions A B) C` under the mapping that sends each function `ab` in `functions A B` to the function that maps `a` in `A` to `p(ab(a))` and any `a` not in `A` to `ARB`, is equal to the function space `functions (functions A B) C`.

### Informal sketch
The proof shows that if `p` is a permutation on the set `B`, then the image of functions from `X` to `Y` (restricted by `A` and `B`) to functions from `Z` under the specified mapping is equal to the function space `functions(functions A B) C`.
- The proof proceeds by showing set equality via mutual inclusion.
- First, it shows the inclusion `IMAGE (\bc ab. ...) (functions (functions A B) C) SUBSET functions (functions A B) C`.
  - It uses extensionality and simplifies using the definition of `functions` membership of the image.
  - It needs to show that if `u` is function from `X` to `Y` such that, for every `v` in `A`, `u v` is in `B` and for every `z` not in `A`, `u z` is `ARB`, then `v u` is a function from `Z` to `C`.
  - It uses `PERMUTES_IN_IMAGE`.
- Second, it shows that `functions (functions A B) C SUBSET IMAGE (\bc ab. ...) (functions (functions A B) C)`.
  - It witnesses a function `ab` from `X` to `Y` such that if `ab` is in `functions AB`, then it is `x` applied to an inverse permutation.
  - It considers the case when `(!u:X. u IN A ==> e u:Y IN B) /\ (!z. ~(z IN A) ==> e z = ARB)` is true.
    - The inner case statement needs to show that if `v` in `A`, then `p (e v)` in `B`.
    - It introduces the subgoal `e:X->Y = (\a. if a IN A then inverse p ((p:Y->Y) (e a)) else ARB)` and discharges by `PERMUTES_INVERSES`
    - `PERMUTES_INVERSES` expands to show that `inverse p` and `p` are inverses.
    - It simplifies, discharging this inner case.
    - The condition `~((!u:X. u IN A ==> z u:Y IN B) /\ (!a. ~(a IN A) ==> z a = ARB)) ==> x z = ARB:Z` is discharged by `permutes` which ultimately needs to show that if there exists `u` in `A` such that `z u` is not in `B` then `x z = ARB`.
  - It then considers the cases when '(!u:X. u IN A ==> e u:Y IN B) /\ (!z. ~(z IN A) ==> e z = ARB)` is false.
    - It needs to show `!u. (!v:X. v IN A ==> u v:Y IN B) /\ (!z. ~(z IN A) ==> u z = ARB) ==> x u:Z IN C`.
    - This uses `PERMUTES_INVERSE;PERMUTES_IN_IMAGE`.

### Mathematical insight
This theorem is a statement about the behavior of function spaces under permutations. More specifically, it shows that if you permute the range of functions within a function space, the resulting set of functions is equivalent to the original space when the permutation operates on the correctly restricted domain. This is important for reasoning about the structure of functions and how they behave under transformations.

### Dependencies
- Theorems:
  - `EXTENSION`
  - `IN_ELIM_THM`
  - `FUN_EQ_THM`
  - `FUN_EQ_THM_E`
  - `PERMUTES_INVERSES`
  - `PERMUTES_INVERSE`
  - `PERMUTES_IN_IMAGE`
- Definitions:
  - `functions`
  - `in_image_vw`
  - `elim_image_subset_u`
  - `elim_image_subset_v`
  - `o_DEF`
  - `permutes`
  - `BETA_THM`

### Porting notes (optional)
- The `IMAGE` operator and set comprehension may have slightly different syntax or semantics in other provers. Care should be taken to ensure the correct meaning is captured.
- The treatment of `ARB` (arbitrary value) may need special attention as it affects the function space semantics.
- The rewriting strategy in HOL Light is very sensitive to the order of rewrites. Pay special attention to rewrite/simplification ordering when porting.


---

## min_le

### Name of formal statement
`min_le`

### Type of the formal statement
theorem

### Formal Content
```ocaml
let min_le = prove(`
  !a b.
  MIN a b <= a
  /\ MIN a b <= b
`,
  rw[MIN] THEN
  ARITH_TAC
);;
```
### Informal statement
For all `a` and `b`, `MIN a b` is less than or equal to `a`, and `MIN a b` is less than or equal to `b`.

### Informal sketch
- Expand the definition of `MIN a b` using the `MIN` rewrite rule, which states that `MIN a b = if a <= b then a else b`.
- The goal becomes `(if a <= b then a else b) <= a /\ (if a <= b then a else b) <= b`.
- The result follows directly from arithmetic reasoning (`ARITH_TAC`) after the `if` expression is expanded into two cases:
    - Case 1: `a <= b`. Then the goal is `a <= a /\ a <= b`, which holds trivially.
    - Case 2: `~(a <= b)`. Then the goal is `b <= a /\ b <= b`, which also holds trivially

### Mathematical insight
This theorem states that the minimum of two values is less than or equal to each of the values. This is a fundamental property of the minimum function and is essential for reasoning about inequalities involving minima.

### Dependencies
- Definition: `MIN`


---

## le_min

### Name of formal statement
le_min

### Type of the formal statement
theorem

### Formal Content
```ocaml
let le_min = prove(`
  !a b c.
  a <= MIN b c <=>
  a <= b /\ a <= c
`,
  rw[MIN] THEN
  ARITH_TAC
);;
```
### Informal statement
For all `a`, `b`, and `c`, `a` is less than or equal to the minimum of `b` and `c` if and only if `a` is less than or equal to `b` and `a` is less than or equal to `c`.

### Informal sketch
The proof proceeds as follows:
- First, expand the definition of `MIN`.
- Then, apply arithmetic tactics (`ARITH_TAC`) to complete the proof.

### Mathematical insight
This theorem states a fundamental property of the minimum function and its relationship to the less than or equal to relation. It is a natural and expected property, stating that a number is less than or equal to the minimum of two other numbers if and only if it is less than or equal to both of those numbers individually. It's useful for reasoning about inequalities involving minimum values.

### Dependencies
- Definitions: `MIN`


---

## max_le

### Name of formal statement
max_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let max_le = prove(`
  !a b c.
  MAX a b <= c <=>
  a <= c /\ b <= c
`,
  rw[MAX] THEN
  ARITH_TAC
);;
```
### Informal statement
For all real numbers `a`, `b`, and `c`, the maximum of `a` and `b` is less than or equal to `c` if and only if `a` is less than or equal to `c` and `b` is less than or equal to `c`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `MAX`.
- Then, apply an arithmetic tactic (`ARITH_TAC`) to complete the proof. This tactic uses linear arithmetic decision procedures to automatically handle inequalities involving real numbers.

### Mathematical insight
This theorem establishes a fundamental property of the maximum function with respect to inequalities. It states that the maximum of two numbers is less than or equal to a third number if and only if both of the first two numbers are individually less than or equal to the third. This is a canonical property used when reasoning about maxima and inequalities.

### Dependencies
- Definitions: `MAX`


---

## fact_1

### Name of formal statement
fact_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let fact_1 = prove(`
  FACT 1 = 1
`,
  rw[ARITH_RULE `1 = SUC 0`;FACT] THEN
  ARITH_TAC
);;
```

### Informal statement
Prove that the statement `FACT 1 = 1` is true.

### Informal sketch
The proof proceeds by rewriting `1` as `SUC 0` using `ARITH_RULE 1 = SUC 0` and then exploiting the definition `FACT` (presumably factorial here), and automatically discharging the remaining goal using `ARITH_TAC`.

### Mathematical insight
This theorem establishes the base case for the factorial function; namely that `FACT 1 = 1`.

### Dependencies
- Theorems & Definitions: `ARITH_RULE 1 = SUC 0`, `FACT`
- Tactics: `ARITH_TAC`


---

## binom_stair_sum

### Name of formal statement
binom_stair_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let binom_stair_sum = prove(`
  !e n.
  binom(n+e,e)
  = if e = 0 then 1 else nsum (0..n) (\a. binom(a+e-1,e-1))
`,
  GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[ARITH_RULE `0+e=e`;BINOM_REFL] THEN
    rw[NSUM_SING_NUMSEG] THEN
    rw[ARITH_RULE `0+e-1 = e-1`;BINOM_REFL] THEN
    rw[COND_ID]
  ; pass
  ] THEN
  intro THEN
  rw[NSUM_CLAUSES_NUMSEG;ARITH_RULE `0 <= SUC n`] THEN
  proven_if `e = 0` [binom] THEN
  num_linear_fact `~(e = 0) ==> e = SUC(e-1)` THEN
  have `binom(SUC(n + e),SUC(e-1)) = binom(n+e,e) + binom(n+e,e-1)` [binom] THEN
  have `binom(SUC(n + e),e) = binom(n+e,e) + binom(n+e,e-1)` [] THEN
  have `binom(SUC n + e,e) = binom(n+e,e) + binom(n+e,e-1)` [ARITH_RULE `SUC n+e = SUC(n+e)`] THEN
  num_linear_fact `~(e = 0) ==> SUC n + e - 1 = n+e` THEN
  qed[]
);;
```

### Informal statement
For all natural numbers `e` and `n`, `binom(n+e,e)` is equal to 1 if `e` is equal to 0, and is equal to the sum from `a = 0` to `n` of `binom(a+e-1,e-1)` otherwise.

### Informal sketch
The theorem is proved by induction on `e`.

- Base case: `e = 0`.  We need to prove `binom(n+0,0) = 1`. The theorem reduces to proving `binom(n,0) = 1`, which is true by the definition of `binom`. Then the right-hand side is simplified. It is shown that the sum from 0 to n is also equal to 1, specifically showing the sum is `binom(a + e - 1, e - 1)` with `e=0`, simplifies to `binom(a-1, -1)`, which the system understands that if `e=0` then the right hand side sum equals to 1 using `NSUM_SING_NUMSEG` and `rw[COND_ID]`.
- Inductive step: Assume the theorem holds for `e`. We want to show that it holds for `SUC e`.
  - Rewrite the sum using `NSUM_CLAUSES_NUMSEG`.
  - Apply the binomial identity relating `binom(SUC(n + e), SUC(e-1))` to `binom(n+e,e)` and `binom(n+e,e-1)`.
  - Assume that `e` is not equal to 0. Rewrite `binom(SUC n + e,e)` as `binom(n+e,e) + binom(n+e,e-1)` using the binomial identity `binom(SUC(n + e),e) = binom(n+e,e) + binom(n+e,e-1)`.
  - Rewrite `SUC n + e - 1` as `n + e`.
  - Conclude the inductive step.

### Mathematical insight
The theorem expresses `binom(n+e, e)` as a sum involving `binom(a+e-1,e-1)` for `0 <= a <= n`. The theorem states that `binom(n+e, e)` can be represented as the sum of `binom(a+e-1,e-1)` where `a` ranges from 0 to `n`. This identity provides a way to compute binomial coefficients iteratively.

### Dependencies
- `binom`
- `NSUM_SING_NUMSEG`
- `NSUM_CLAUSES_NUMSEG`


---

## nsum_reflect_0

### Name of formal statement
nsum_reflect_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nsum_reflect_0 = prove(`
  !f n.
  nsum(0..n) f = nsum(0..n) (\i. f(n-i))
`,
  intro THEN
  num_linear_fact `~(n < 0)` THEN
  specialize[`f:num->num`;`0`;`n:num`]NSUM_REFLECT THEN
  qed[ARITH_RULE `n-0 = n`]
);;
```

### Informal statement
For any function `f` from numbers to numbers, and for any natural number `n`, the sum of `f(i)` from `i = 0` to `n` is equal to the sum of `f(n - i)` from `i = 0` to `n`.

### Informal sketch
The proof proceeds by:
- Introduction of the universally quantified variables `f` and `n`.
- Showing the fact that `~(n < 0)` by linear arithmetic reasoning (i.e., `0 <= n`).
- Specializing the more general theorem `NSUM_REFLECT` to the specific function `f`, the number `0`, and the number `n`. This substitution yields the desired result after simplification.
- Applying `ARITH_RULE` to reduce `n-0 = n`.

### Mathematical insight
This theorem is a special case of `NSUM_REFLECT` where the lower bound of the summation is `0`. It states that the sum of a function `f` over the range `0` to `n` is equal to the sum of the function `f` reflected about the midpoint of the range. This is a useful identity for simplifying summations.

### Dependencies
- Theorems: `NSUM_REFLECT`
- Tactics: `intro`, `num_linear_fact`, `specialize`, `qed`, `ARITH_RULE`


---

## nsum_delta

### Name of formal statement
nsum_delta

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nsum_delta = prove(`
  !s a:X b.
  nsum s (\x. if x = a then b else 0)
  = (if a IN s then b else 0)
`,
  qed[NSUM_DELTA]
);;
```
### Informal statement
For any set `s` of type `X` and any elements `a` of type `X` and `b` of the same type as the codomain of the summation, the sum of the function that maps `x` to `b` if `x` equals `a` and to 0 otherwise, over the set `s`, is equal to `b` if `a` is in `s`, and 0 otherwise.

### Informal sketch
The proof relies on the definition of `nsum`. The sum is computed using an inductive argument over finite sets. The base case when `s` is the empty set is trivial. The inductive step involves considering a set `s` along with a new element `x`. If `x = a`, adding `b` to the sum (if `a IN s` then `b` else `0`). If `x != a` adding `0` to the sum (if `a IN s` then `b` else `0`). The proof proceeds by considering the cases when `a` is in `s` or not.

### Mathematical insight
This theorem expresses the fact that summing a function which is zero everywhere except at one point where it takes the value `b` results in `b` only if the point is within the summation set, otherwise it gives 0. This is a basic property of summation and indicator functions.

### Dependencies
- Theorems:
  - `NSUM_DELTA`


---

## term_le_nsum

### Name of formal statement
term_le_nsum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let term_le_nsum = prove(`
  !f S t:X.
  FINITE S ==>
  t IN S ==>
  f t <= nsum S f
`,
  qed[NSUM_DELETE;ARITH_RULE `a <= a + b:num`]
);;
```
### Informal statement
For any function `f` from type `X` to the natural numbers, any finite set `S` of type `X`, and any element `t` of type `X`, if `S` is finite and `t` is an element of `S`, then `f t` is less than or equal to the sum of `f x` for all `x` in `S`.

### Informal sketch
The proof proceeds as follows:
- First, the theorem `NSUM_DELETE` is applied. This theorem states that if `t IN S` and `f` is a function from `X` to the natural numbers, then `nsum S f = f t + nsum (delete t S) f`. Here, the precondition `FINITE S` and `t IN S` are already established.
- Then, `ARITH_RULE` is used, which proves `a <= a + b` given that `a` and `b` are natural numbers. In this case `a` is `f t` and `b` is `nsum (delete t S) f`. Since the result of `nsum` over natural numbers is always a natural number (due to the definition of `nsum`), `nsum (delete t S) f` is a natural number and therefore the inequality holds. Combining this with `nsum S f = f t + nsum (delete t S) f`, the final result `f t <= nsum S f` follows.

### Mathematical insight
The theorem states a fundamental property of the sum over a finite set of natural numbers. It asserts that the value of the function at any member of the set is less than or equal to the total sum of the function over the set. This result is important because it highlights the bound imposed by the total sum on any single element's contribution.

### Dependencies
- `NSUM_DELETE`
- `ARITH_RULE`


---

## binom_reverse_stair_sum

### Name of formal statement
binom_reverse_stair_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let binom_reverse_stair_sum = prove(`
  !e n.
  binom(n+e,e)
  = if e = 0 then 1 else
    nsum (0..n) (\a. binom(n-a+e-1,e-1))
`,
  intro THEN
  specialize[`e:num`;`n:num`]binom_stair_sum THEN
  specialize[`\a. binom(a+e-1,e-1)`;`n:num`]nsum_reflect_0 THEN
  qed[]
);;
```
### Informal statement
For all natural numbers `e` and `n`, the binomial coefficient of `n+e` choose `e` is equal to: if `e` is 0 then 1, otherwise the sum from `a = 0` to `n` of the binomial coefficient of `n-a+e-1` chose `e-1`.

### Informal sketch
The theorem is proven by:
- Introducing the universally quantified variables `e` and `n`.
- Applying the theorem `binom_stair_sum` specialized to `e` and `n`. This will require that sum of `binom(a, k)` for `a` from `0` to `n` is `binom(n+k+1, k+1)`.
- Applying the theorem `nsum_reflect_0` specialized to `\a. binom(a+e-1,e-1)` and `n`. The theorem `nsum_reflect_0` is probably of the form `nsum (0..n) f = nsum (0..n) (\a. f(n-a))`

### Mathematical insight
This theorem provides a recursive way to compute binomial coefficients. It expresses `binom(n+e, e)` as a sum involving `binom(n-a+e-1, e-1)`, effectively reducing the second argument of the binomial coefficient, which drives toward the base case `e = 0`. This identity likely arises from combinatorial reasoning about counting selections.

### Dependencies
- `binom_stair_sum`
- `nsum_reflect_0`


---

## fact_binom_lemma_37

### Name of formal statement
fact_binom_lemma_37

### Type of the formal statement
theorem

### Formal Content
```ocaml
let fact_binom_lemma_37 = prove(`
  !n i.
  i < n ==>
  FACT(n-i) * binom(n,i) =
  (FACT(n-1-i) * binom(n-1,i)) +
  ((n-1) * FACT(n-1-i) * binom(n-1,i))
`,
  intro THEN
  subgoal `FACT(n-i) = (n-i)*FACT(n-1-i)` THENL [
    num_linear_fact `i < n ==> n-i = SUC(n-1-i)` THEN
    qed[FACT]
  ; pass
  ] THEN
  simp[] THEN
  subgoal `(n - i) * binom (n,i) = binom (n - 1,i) + (n - 1) * binom (n - 1,i)` THENL [
    case `i = 0` THENL [
      simp[binom] THEN
      ASM_ARITH_TAC
    ; pass
    ] THEN
    specialize[`n-1`;`i:num`]BINOM_TOP_STEP THEN
    num_linear_fact `i < n ==> n-1+1 = n` THEN
    have `(n-i)*binom(n,i) = n*binom(n-1,i)` [] THEN
    num_linear_fact `i < n ==> n = 1 + (n-1)` THEN
    have `1 * binom(n-1,i) + (n-1) * binom(n-1,i) = n * binom(n-1,i)` [RIGHT_ADD_DISTRIB] THEN
    have `binom(n-1,i) + (n-1) * binom(n-1,i) = n * binom(n-1,i)` [MULT_CLAUSES] THEN
    qed[]
  ; pass
  ] THEN
  have `((n - i) * binom (n,i)) * FACT(n-1-i) = (binom (n - 1,i)) * FACT(n-1-i) + ((n - 1) * binom (n - 1,i)) * FACT(n-1-i)` [RIGHT_ADD_DISTRIB] THEN
  ASM_ARITH_TAC
);;
```
### Informal statement
For all natural numbers `n` and `i`, if `i` is less than `n`, then `FACT(n-i) * binom(n,i)` is equal to `(FACT(n-1-i) * binom(n-1,i)) + ((n-1) * FACT(n-1-i) * binom(n-1,i))`.

### Informal sketch
The proof proceeds as follows:
- First, prove that `FACT(n-i) = (n-i)*FACT(n-1-i)` under the assumption that `i < n`.
  - This is proved by showing that `n-i = SUC(n-1-i)` where `SUC(x)` means `x+1`
  - Using the definition of `FACT`, the proof is complete.
- Simplify the main goal using the above result.
- Next, prove that `(n - i) * binom (n,i) = binom (n - 1,i) + (n - 1) * binom (n - 1,i)`.
  - Case split on whether `i = 0`.
    - If `i = 0`, simplify using the definition of `binom` and arithmetic.
    - Otherwise, use the theorem `BINOM_TOP_STEP` which states that `(n:num)*binom(n-1,i) = i*binom(n-1,i-1) + (n-i)*binom(n-1,i)`. Specialise `BINOM_TOP_STEP` appropriately.
    - Show that `n-1+1 = n`.
    - Show that `(n-i)*binom(n,i) = n*binom(n-1,i)`.
    - Show that `n = 1 + (n-1)`.
    - Show that `1 * binom(n-1,i) + (n-1) * binom(n-1,i) = n * binom(n-1,i)` using the right distributivity of addition.
    - Show that `binom(n-1,i) + (n-1) * binom(n-1,i) = n * binom(n-1,i)`.
- Finally show `((n - i) * binom (n,i)) * FACT(n-1-i) = (binom (n - 1,i)) * FACT(n-1-i) + ((n - 1) * binom (n - 1,i)) * FACT(n-1-i)` using the right distributivity of addition.
- The goal is proved by arithmetic simplification.

### Mathematical insight
This theorem relates the binomial coefficient and the factorial function. It essentially rewrites `FACT(n-i) * binom(n,i)` in terms of binomial coefficients and factorials with a smaller n (n-1). This is likely to be used in inductive proofs involving binomial coefficients and factorials.

### Dependencies
- Theorems:
    - `BINOM_TOP_STEP`
- Definitions:
    - `FACT`
    - `binom`
    - `SUC`
    - `RIGHT_ADD_DISTRIB`
    - `MULT_CLAUSES`


---

## properly_le

### Name of formal statement
properly_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let properly_le = prove(`
  properly (<=) = (<):num->num->bool
`,
  rw[properly;FUN_EQ_THM] THEN
  ARITH_TAC
);;
```

### Informal statement
The predicate `properly` applied to the less-than-or-equal-to relation `<=` is equal to the less-than relation `<` over natural numbers. That is, for any two natural numbers `x` and `y`, `properly (<=) x y` if and only if `x < y`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `properly`. The definition of `properly` states that `properly r x y` is defined as `r x y /\ ~ r y x`.
- Next, rewrite using the theorem `FUN_EQ_THM` which states that two functions are equal if they are equal at all arguments. Hence we need to show that `(<=) x y /\ ~ (<=) y x = (<) x y`.
- Then, apply `ARITH_TAC`. This tactic uses arithmetic decision procedures that check if a goal is true based on arithmetic rules. Specifically, it uses the fact that `x <= y /\ ~ (y <= x)` is equivalent to `x < y` for natural numbers `x` and `y`.

### Mathematical insight
The theorem states a fundamental relationship between non-strict inequality (`<=`) and strict inequality (`<`) on natural numbers. Essentially it says that `x <= y` and not `y <= x` is the same as `x < y`. The `properly` predicate filters the actual elements from the input relations.

### Dependencies
- `properly`
- `FUN_EQ_THM`


---

## o_permutes_subset

### Name of formal statement
o_permutes_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let o_permutes_subset = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  A o f SUBSET S
`,
  rw[SUBSET;IN;o_THM;permutes] THEN
  qed[]
);;
```
### Informal statement
For any type `X`, for any set `S` of elements of `X`, and for any function `f` from `X` to `X`, if `f` permutes `S` and `A` is a subset of `S`, then the image of `A` under `f` is a subset of `S`.

### Informal sketch
*   The proof starts by rewriting the statement using the definitions of `SUBSET`, `IN` (set membership), `o_THM` (function composition), and `permutes`.
*   The definition of `permutes` involves two conditions: first, that the image of the set `S` under the function `f` is a subset of `S`, and second, that the function `f` is injective when restricted to `S`.
*   The rewrite unfolds the condition `A o f SUBSET S` to `!x. IN x (A o f) ==> IN x S`. Then, replacing `(A o f)` by `IMAGE f A` and using the definition of `permutes` and the fact that `A SUBSET S` we can deduce that `A o f SUBSET S` holds.

### Mathematical insight
This theorem states a fundamental property of permutations: if a function `f` permutes a set `S`, it maps any subset `A` of `S` into `S`. This is a key property when reasoning about permutations and their actions on sets and subsets. It highlights the fact that a permutation, by definition, preserves the elements within the permuted set.

### Dependencies
*   Theorems/Definitions: `SUBSET`, `IN`, `o_THM`, `permutes`


---

## image_permutes_subset

### Name of formal statement
image_permutes_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_permutes_subset = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  IMAGE f A SUBSET S
`,
  rw[SUBSET;IN_IMAGE;permutes] THEN
  qed[]
);;
```
### Informal statement
For all sets `A` and `S`, and for all functions `f` from `X` to `X`, if `f` permutes `S` and `A` is a subset of `S`, then the image of `A` under `f` is a subset of `S`.

### Informal sketch
The proof proceeds by rewriting the definitions of `SUBSET`, `IN_IMAGE`, and `permutes`. The definition of `permutes` reveals that `f` maps elements of `S` to `S`.
- The goal is `IMAGE f A SUBSET S`, which unfolds to `!y. IN y (IMAGE f A) ==> IN y S`.
- Assume `IN y (IMAGE f A)`, so there exists `x` in `A` such that `f x = y`.
- Since `A SUBSET S` we have that `x` is in `S`.
- Because `f permutes S`, `f` maps `S` to `S` injectively and surjectively, and since `x` is in `S`, `f x` is in `S`, thus `y` is in `S`.

### Mathematical insight
This theorem states that if a function permutes a set `S`, then the image of any subset `A` of `S` under `f` is also a subset of `S`. This is a standard result when working with permutations and their effect on subsets. The permutation `f` maps elements within `S` and does not map elements outside of `S` into `S`.

### Dependencies
- Definitions: `SUBSET`, `IN_IMAGE`, `permutes`


---

## image_inverse_permutes

### Name of formal statement
image_inverse_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_inverse_permutes = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  IMAGE (inverse f) A = A o f
`,
  rw[EXTENSION;IN_IMAGE;SUBSET;IN;o_THM] THEN
  rw[permutes;inverse] THEN
  qed[]
);;
```
### Informal statement
For all sets `A` and `S`, and for all functions `f` from `X` to `X`, if `f` permutes `S` and `A` is a subset of `S`, then the image of `A` under the inverse of `f` is equal to the composition of `A` and `f`.

### Informal sketch
The proof proceeds as follows:
- Start with the definitions of `IMAGE` (image of a set), `SUBSET`, `IN` (set membership), and `o_THM` (function composition). Apply rewrite rules based on these definitions to expand the goal.
- Expand the definition of `permutes` and `inverse` using their respective definitions.
- The goal can be proven after these expansions.

### Mathematical insight
This theorem relates the image of a set under the inverse of a permutation to the composition of the set with the permutation. It demonstrates how the inverse function acts on subsets within the set being permuted, linking it to the direct action of the function through composition. This result is useful when reasoning about the behavior of permutations on sets and their elements.

### Dependencies
- Definitions: `EXTENSION`, `IN_IMAGE`, `SUBSET`, `IN`, `o_THM`, `permutes`,`inverse`


---

## image_o_permutes

### Name of formal statement
image_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_o_permutes = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  IMAGE f (A o f) = A
`,
  rw[EXTENSION;SUBSET;IN_ELIM_THM;IN;IMAGE;o_THM;permutes] THEN
  qed[]
);;
```
### Informal statement
For any set `S`, any function `f` from `X` to `X`, and set `A`, if `f` permutes `S` and `A` is a subset of `S`, then the image of `A o f` under `f` is equal to `A`.

### Informal sketch
The proof proceeds by rewriting using definitions and existing theorems.
- First, the theorem is rewritten using the definitions of `EXTENSION`, `SUBSET`, `IN_ELIM_THM`, `IN`, `IMAGE`, `o_THM`, and `permutes`.
- The rewritten goal is then discharged, completing the proof.

### Mathematical insight
This theorem states that if a function `f` permutes a set `S`, then applying `f` to the composition of `A` with `f`, where `A` is a subset of `S`, results in the original set `A`. The composition `A o f` restricts `f` to `A`. Taking the image of `A o f` under `f` effectively applies `f` twice to elements originally in `A`, but since `f` permutes `S` containing `A`, the result remains in `A`, recovering the original set.

### Dependencies
- Definitions: `EXTENSION`, `SUBSET`, `IN`, `IMAGE`, `o_THM`, `permutes`.
- Theorems: `IN_ELIM_THM`.


---

## o_image_permutes

### Name of formal statement
o_image_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let o_image_permutes = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  (IMAGE f A) o f = A
`,
  rw[EXTENSION;SUBSET;IMAGE;IN;IN_ELIM_THM;o_THM;permutes] THEN
  qed[]
);;
```
### Informal statement
For all sets `A` and `S`, and for all functions `f` from `X` to `X`, if `f` permutes `S` and `A` is a subset of `S`, then the composition of the image of `A` under `f` with `f` itself equals `A`. More formally, if `f` is a permutation of `S` and `A` is a subset of `S`, then `IMAGE f A o f = A`.

### Informal sketch
We want to prove that if `f` permutes `S` and `A` is a subset of `S`, then `IMAGE f A o f = A`.

- The proof proceeds by rewriting using the definitions of `EXTENSION`, `SUBSET`, `IMAGE`, `IN`, `IN_ELIM_THM`, `o_THM`, and `permutes`.
- After rewriting, the proof is completed via standard equational reasoning (`qed[]`).

### Mathematical insight
This theorem relates permutations to the image of sets under functions. Given a set `S` and a permutation `f` of `S`, if we take a subset `A` of `S`, apply `f` to get its image `IMAGE f A`, and then effectively "undo" the `IMAGE` operation within the context of the permuation `f`, we recover the original set `A`.

### Dependencies
- Definitions: `EXTENSION`, `SUBSET`, `IMAGE`, `IN`, `o_THM`, `permutes`
- Theorems: `IN_ELIM_THM`

### Porting notes (optional)
- The order of evaluation for `IMAGE f A o f ` may require adjustments depending on the target system's evaluation strategy.
- The tactics `rw` and `qed` may have direct analogs or require custom implementations depending on the target proof assistant.


---

## card_image_permutes

### Name of formal statement
card_image_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_image_permutes = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  FINITE A ==>
  CARD(IMAGE f A) = CARD A
`,
  intro THEN
  sufficesby CARD_IMAGE_INJ THEN
  qed[permutes]
);;
```
### Informal statement
For all sets `A`, `S`, and functions `f` from `X` to `X`, if `f` permutes `S` and `A` is a subset of `S` and `A` is finite, then the cardinality of the image of `A` under `f` is equal to the cardinality of `A`.

### Informal sketch
The proof proceeds as follows:
- Introduce the quantified variables `A`, `S`, and `f`.
- Suffices to show that the function `f` restricted to `A` is injective, given that `f` permutes `S` and `A` is a subset of `S`.
- The proof concludes by appealing to the theorem `CARD_IMAGE_INJ` which states that if a function is injective then the cardinality of the image of a set is equal to the cardinality of the set. The injectivity is guaranteed by the assumption that `f` permutes `S` and `A` is assumed to be a subset of `S`.

### Mathematical insight
This theorem states that if a function `f` permutes a set `S`, then the cardinality of any finite subset `A` of `S` is preserved under the image of `f`. This is a fundamental property when dealing with permutations and finite sets. It is used, for example, when one needs to prove facts about combinatorial objects invariant under some permutation group.

### Dependencies
- Theorem: `CARD_IMAGE_INJ`
- Definition: `permutes`


---

## card_o_permutes

### Name of formal statement
card_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_o_permutes = prove(`
  !A S f:X->X.
  f permutes S ==>
  A SUBSET S ==>
  FINITE A ==>
  CARD(A o f) = CARD A
`,
  intro THEN
  have `A o (f:X->X) = IMAGE (inverse f) A` [image_inverse_permutes] THEN
  simp[] THEN
  sufficesby CARD_IMAGE_INJ THEN
  have `inverse (f:X->X) permutes S` [PERMUTES_INVERSE] THEN
  qed[permutes]
);;
```
### Informal statement
For all sets `A`, `S`, and functions `f` from `X` to `X`, if `f` permutes `S` and `A` is a subset of `S` and `A` is finite, then the cardinality of the image of `A` under `f` is equal to the cardinality of `A`.

### Informal sketch
The proof proceeds as follows:
- Assume `f` permutes `S`, `A` is a subset of `S`, and `A` is finite.
- Prove that `A o f = IMAGE (inverse f) A` using the theorem `image_inverse_permutes`.
- Simplify using basic simplification rules.
- Reduce the goal to proving that the cardinality of `IMAGE (inverse f) A` is equal to the cardinality of `A` by `CARD_IMAGE_INJ`.
- Establish that `inverse f` permutes `S` from the assumption that `f` permutes `S` using the theorem `PERMUTES_INVERSE`.
- Conclude the proof because the inverse of a permutation is itself a permutation and thus injective on S, hence the cardinality of the image of A under the inverse is the same as the cardinality of A when A is a subset of S.

### Mathematical insight
This theorem states that permutations preserve the cardinality of subsets within the set they permute. This is a fundamental property used when reasoning about counting and combinatorics within a finite set. The key idea is that a permutation establishes a bijection between a set and itself, and thus any subset will have the same number of elements as its image under the permutation.

### Dependencies
- Theorems:
  - `image_inverse_permutes`
  - `PERMUTES_INVERSE`
  - `CARD_IMAGE_INJ`
  - `permutes`


---

## o_permutes_cancel

### Name of formal statement
o_permutes_cancel

### Type of the formal statement
theorem

### Formal Content
```ocaml
let o_permutes_cancel = prove(`
  !S f:X->X g h:X->Y.
  f permutes S ==>
  g o f = h o f ==>
  g = h
`,
  intro THEN
  subgoal `g:X->Y = (g o (f:X->X)) o inverse f` THENL [
    rw[GSYM o_ASSOC] THEN
    qed[PERMUTES_INVERSES_o;I_O_ID]
  ; pass
  ] THEN
  subgoal `h:X->Y = (h o (f:X->X)) o inverse f` THENL [
    rw[GSYM o_ASSOC] THEN
    qed[PERMUTES_INVERSES_o;I_O_ID]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For all sets `S` and functions `f: X -> X`, `g: X -> Y`, and `h: X -> Y`, if `f` permutes `S` and `g o f = h o f`, then `g = h`.

### Informal sketch
The proof proceeds by showing both `g` and `h` are equal to `(g o f) o inverse f` and `(h o f) o inverse f` respectively.
- First, it's shown that `g = (g o f) o inverse f`
  - The equation `(g o f) o inverse f` is rewritten using the associativity of function composition, `o_ASSOC`.
  - Then `PERMUTES_INVERSES_o` asserts that `f o inverse f` and `inverse f o f` are equal to the identity function `I`. Then `I_O_ID` shows that applying the identity function `I` to a function `g` yields `g`
 - Secondly, it's shown that `h = (h o f) o inverse f` which follows by the same symmetric argument as the first.
 - Finally, since it is given that `g o f = h o f`, it follows that `g = h`.

### Mathematical insight
This theorem states that if two functions `g` and `h` when composed with a permutation `f` on the right are equal, then `g` and `h` must be equal. In other words, right composition with a permutation is injective. The key idea is to use the inverse of the permutation to "cancel out" the `f` by composing with `inverse f`.

### Dependencies
- `PERMUTES_INVERSES_o`
- `I_O_ID`
- `o_ASSOC`


---

## range

### Name of formal statement
range

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let range = new_definition `
  range = (>):num->num->bool
`;;
```
### Informal statement
The `range` relation, taking two natural numbers `m` and `n` as input, is defined to be equivalent to the greater-than relation `>` between `m` and `n`. Thus, `range m n` is true if and only if `m > n`.

### Informal sketch
- The definition introduces the `range` relation as a synonym for the `>` relation on natural numbers.
- This is a direct definition so there is no proof to sketch.

### Mathematical insight
- The definition provides an alternative name `range` for the `>` relation on natural numbers. While `>` is commonly used, `range` might be preferred in contexts involving intervals or sequences.

### Dependencies
- Definition: `>` (greater-than relation on natural numbers)


---

## range_lt

### Name of formal statement
range_lt

### Type of the formal statement
theorem

### Formal Content
```ocaml
let range_lt = prove(`
  !n i.
  i IN range n <=> i < n
`,
  rw[range;IN;GT]
);;
```
### Informal statement
For all natural numbers `n` and `i`, `i` is in the range of `n` if and only if `i` is less than `n`.

### Informal sketch
The proof uses rewriting with the definitions of `range`, `IN` (set membership), and `GT` (greater than).
- Expand the definition of `range n` as a set, i.e., `{0, ..., n-1}`.
- Expand the definition of `IN` to rewrite `i IN {0, ..., n-1}` as `i mem {0, ..., n-1}`.
- Reduce the goal `i mem {0, ..., n-1}` to the equivalent `i < n` by definition of membership in the set `{0, ..., n-1}` by mathematical definition of `GT`

### Mathematical insight
This theorem establishes the fundamental relationship between the range of a natural number `n` and the less-than relation. It formalizes the intuitive notion that the range `range n` contains exactly the natural numbers strictly less than `n`. This connection is essential for reasoning about finite sets and for relating set-theoretic concepts to arithmetic.

### Dependencies
- Definitions: `range`, `IN`, `GT`


---

## range_set_lt

### Name of formal statement
range_set_lt

### Type of the formal statement
theorem

### Formal Content
```ocaml
let range_set_lt = prove(`
  !n.
  range n = {i | i < n}
`,
  rw[EXTENSION;range_lt;IN_ELIM_THM]
);;
```
### Informal statement
For all natural numbers `n`, the range of `n` (denoted `range n`) is equal to the set of all `i` such that `i` is less than `n` (denoted `{i | i < n}`).

### Informal sketch
The proof proceeds by rewriting the definition of `range n`.

- First, the `EXTENSION` tactic is used, which says that to prove two sets are equal, it suffices to prove that they have the same elements.
- Next, the definition of `range_lt` (presumably `range n = {i | i < n}`) is used to rewrite the left-hand side of the equality.
- Finally, `IN_ELIM_THM`, which states that `x IN {y | P y} <=> P x`, is used to remove the set membership condition, resulting in a trivial equality.

### Mathematical insight
This theorem explicitly defines the range of a natural number `n` as the set of all natural numbers strictly less than `n`. This is a standard definition used to represent initial segments of the natural numbers. It's crucial for many inductive arguments and constructions.

### Dependencies
- Definitions: `range`
- Theorems: `EXTENSION`, `range_lt`, `IN_ELIM_THM`


---

## range_0

### Name of formal statement
range_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let range_0 = prove(`
  range 0 = {}
`,
  rw[EXTENSION;range_lt;EMPTY;IN_ELIM_THM] THEN
  ARITH_TAC
);;
```

### Informal statement
The range of the function `range` applied to the natural number 0 is the empty set. In other words, `{n | n < 0}` is empty, where `n` ranges over natural numbers.

### Informal sketch
The proof proceeds by showing that for any set, if it has the same elements as the `range 0` it should the same as the empty set({}). This is done by rewriting the goal using the extensionality axiom (`EXTENSION`).
- The definition of `range_lt` is used to rewrite `n IN range 0` to `n < 0`.
- The definition of the empty set `EMPTY` is used, and `IN_ELIM_THM` to rewrite `x IN {}` to `F`.
- Finally, `ARITH_TAC` simplifies `n < 0` to `F`, which completes the proof.

### Mathematical insight
The theorem `range_0` establishes a fundamental property of the range function, specifically when applied to 0. It confirms that there are no natural numbers less than 0, hence the resulting set is empty. It's a basic result used in set theory and number theory within HOL Light.

### Dependencies
- Theorems/Definitions: `EXTENSION`, `range_lt`, `EMPTY`, `IN_ELIM_THM`


---

## range_add_1_delete_refl

### Name of formal statement
range_add_1_delete_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let range_add_1_delete_refl = prove(`
  !n.
  range(n+1) DELETE n = range n
`,
  rw[DELETE;range_lt;EXTENSION;IN_ELIM_THM] THEN
  ARITH_TAC
);;
```
### Informal statement
For all natural numbers *n*, removing *n* from the range from 0 to *n* (exclusive) yields the range from 0 to *n* (exclusive).

### Informal sketch
*   Start with the goal: `!n. range(n+1) DELETE n = range n`.
*   Rewrite using the definition of `DELETE`, which states `x DELETE y = λz. z ∈ x ∧ ¬(z = y)`.
*   Rewrite using the definition of `range_lt`, which gives the definition of `range`. `range n = {0, ..., n-1}`.
*   Rewrite using the definition of `EXTENSION`, which states that two sets are equal if they have the same elements: `(!x. (x IN s <=> x IN t)) <=> s = t`.
*   Rewrite using `IN_ELIM_THM`, which elaborates `x IN {y | P y}` to `P x`.
*   Finally, simplify the resulting arithmetic expression using `ARITH_TAC`.

### Mathematical insight
This theorem expresses the fact that removing the upper bound from the set of natural numbers less than or equal to *n* does not change the set of elements less than *n*. This is because the upper bound *n* is not included in the set `range n`, i.e., the set `{0, 1, ..., n-1}`.

### Dependencies
- Definitions: `DELETE`, `range_lt`, `EXTENSION`, `IN_ELIM_THM`
- Theorems: None

### Porting notes (optional)
The main challenge in porting this theorem would involve ensuring that the target proof assistant has equivalent definitions for set difference (`DELETE`), range (`range`), set extensionality (`EXTENSION`), and membership (`IN_ELIM_THM`). The `ARITH_TAC` tactic relies on built-in arithmetic reasoning; ensure the target system can handle such reasoning automatically or provide the necessary rules.

---

## finite_range

### Name of formal statement
finite_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_range = prove(`
  !n.
  FINITE(range n)
`,
  rw[range_set_lt] THEN
  qed[FINITE_NUMSEG_LT]
);;
```
### Informal statement
For all natural numbers `n`, the set `range n` is finite.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the goal using `range_set_lt`, which expresses `range n` as the set of natural numbers less than `n`: `{m | m < n}`.
- Then, apply the theorem `FINITE_NUMSEG_LT`, which states that the set of natural numbers less than `n` is finite.

### Mathematical insight
This theorem establishes a fundamental connection between natural numbers and finite sets. Specifically, it shows that for any natural number `n`, the set of natural numbers less than `n` is always finite.
This result is important because it is used in defining and reasoning about finite sets in terms of natural numbers. It highlights how segments of natural numbers can serve as prototypes for finite sets.

### Dependencies
- Rewriting: `range_set_lt`
- Theorems: `FINITE_NUMSEG_LT`

### Porting notes (optional)
This theorem relies on the definitions/theorems `range_set_lt` and `FINITE_NUMSEG_LT`. Ensure that these are available or provable within the target proof assistant. Most proof assistants have similar theorems related to finiteness of initial segments of natural numbers, or a notion of `range`, though the names may differ. The proof is short, so it should be relatively easy to reproduce in another system, even if automation differs.


---

## card_range

### Name of formal statement
card_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let card_range = prove(`
  !n.
  CARD(range n) = n
`,
  rw[range_set_lt] THEN
  qed[CARD_NUMSEG_LT]
);;
```
### Informal statement
For all natural numbers `n`, the cardinality of the range from 0 up to (but not including) `n` is equal to `n`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `range_set_lt`, which rewrites `range n` to the set `{i | i < n}`.
- Then, apply the theorem `CARD_NUMSEG_LT`, which states that the cardinality of the set of natural numbers less than `n` is `n`.

### Mathematical insight
This theorem states a fundamental connection between the set of natural numbers less than `n` and the number `n` itself. It formalizes the intuitive notion that `n` represents the size of the set `{0, 1, ..., n-1}`.

### Dependencies

- Theorems:
  - `range_set_lt`
  - `CARD_NUMSEG_LT`


---

## swap_permutes_range

### Name of formal statement
swap_permutes_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let swap_permutes_range = prove(`
  !n i j.
  i < n ==>
  j < n ==>
  swap(i,j) permutes range n
`,
  rw[swap;permutes;range_lt] THEN
  qed[]
);;
```
### Informal statement
For all natural numbers `n`, `i`, and `j`, if `i` is less than `n` and `j` is less than `n`, then `swap(i, j)` permutes the set `range n`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definitions of `swap`, `permutes`, and `range_lt`.
- Applying the reflexivity tactic `qed[]` to complete the proof. The rewriting steps should reduce both sides of the `permutes` relationship to equivalent forms, ultimately proving it.

### Mathematical insight
The theorem states that swapping two elements within the range `0` to `n-1` results in a permutation of the original range. This is a fundamental property used when reasoning about the correctness of sorting algorithms and other operations on sequences. The definition of `swap` and `permutes` and the properties of `range` are essential for formalizing and proving this claim.

### Dependencies
- Definitions: `swap`, `permutes`, `range_lt`


---

## finite_ordering

### Name of formal statement
finite_ordering

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_ordering = prove(`
  !S:X->bool.
  FINITE S ==>
  ?f. IMAGE f (range(CARD S)) = S
`,
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[CARD_CLAUSES;range_0;IMAGE_CLAUSES]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    witness `\i:num. if i = CARD(S:X->bool) then x else f i:X` THEN
    simp[EXTENSION;in_image_vw;IN_INSERT;CARD_CLAUSES] THEN
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    intro THEN
    splitiff THENL [
      intro THEN
      have `v < 1+CARD(S:X->bool)` [range_lt] THEN
      proven_if `v = CARD(S:X->bool)` [] THEN
      num_linear_fact `v < 1+CARD(S:X->bool) ==> ~(v = CARD S) ==> v < CARD S` THEN
      have `v IN range(CARD(S:X->bool))` [range_lt] THEN
      qed[IN_IMAGE]
    ;
      intro THENL [
        witness `CARD(S:X->bool)` THEN
        rw[range_lt] THEN
        simp[ARITH_RULE `n < 1+n`]
      ;
        choose `v:num` `v IN range(CARD(S:X->bool)) /\ f v = x':X` [IN_IMAGE] THEN
        witness `v:num` THEN
        have `v < CARD(S:X->bool)` [range_lt] THEN
        num_linear_fact `v < CARD(S:X->bool) ==> ~(v = CARD S)` THEN
        num_linear_fact `v < CARD(S:X->bool) ==> v < 1 + CARD S` THEN
        qed[range_lt]
      ]
    ]
  ]
);;
```

### Informal statement
For any set `S` of type `X -> bool`, if `S` is finite, then there exists a function `f` such that the image of `f` over the range of `CARD S` (where `CARD S` is the cardinality of `S`) is equal to `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of sets.

- Base case: The empty set is finite, and we show that the image of a function over the empty range is the empty set.
- Inductive step: Assume the theorem holds for all sets `S` where `x INSERT S` is finite. We attempt to prove it true for `x INSERT S`.
  - We define a function `f` that maps `CARD S` to `x` and otherwise maps `i` to `f i`, where `f` is the function guaranteed by the inductive hypothesis for the set `S`.
  - We show that `IMAGE f (range (CARD (x INSERT S))) = x INSERT S`. This involves proving that every element in the range maps to some element in the image and conversely, if an element is in `x INSERT S`, then it is in the image of `f` over `range (CARD (x INSERT S))`.
  - The proof makes use of facts about `CARD`, `IMAGE`, `INSERT` and arithmetic reasoning. Specifically, linear arithmetic is used to manipulate inequalities involving cardinalities.

### Mathematical insight
This theorem establishes that a finite set of cardinality `n` (i.e., `CARD S = n`) can be put into a bijective (one-to-one and onto) correspondence with the natural numbers less than `n`. This is done here by constructing a function `f` that maps the range of `CARD S` (the set of natural numbers less than the cardinality of `S`) onto the set `S` itself. The `IMAGE f (range (CARD S))` represents the elements of `S` mapped to by the integers in the range of `CARD S`. Informally, we can enumerate the elements of a finite set. The theorem is related to the concept ITSET, an iterated set allowing to model finite collection of objects.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `CARD_CLAUSES`
- `range_0`
- `IMAGE_CLAUSES`
- `EXTENSION`
- `in_image_vw`
- `IN_INSERT`
- `ARITH_RULE`
- `IN_IMAGE`
- `range_lt`


---

## injective_finite_ordering

### Name of formal statement
injective_finite_ordering

### Type of the formal statement
theorem

### Formal Content
```ocaml
let injective_finite_ordering = prove(`
  !S:X->bool f.
  IMAGE f (range(CARD S)) = S ==>
  (!x y. x < CARD S ==> y < CARD S ==> f x = f y ==> x = y)
`,
  rw[GSYM range_lt] THEN
  intro THEN
  have `FINITE(range(CARD(S:X->bool)))` [finite_range] THEN
  have `CARD(range(CARD(S:X->bool))) = CARD S` [card_range] THEN
  qed[CARD_IMAGE_EQ_INJ]
);;
```
### Informal statement
For any set `S` of type `X->bool` and any function `f` from natural numbers to `X`, if the image of `f` restricted to the range of the cardinality of `S` is equal to `S`, then `f` is injective when restricted to arguments less than the cardinality of `S`. In other words: for all `x` and `y`, if `x` is less than the cardinality of `S`, and `y` is less than the cardinality of `S`, and `f x = f y`, then `x = y`.

### Informal sketch
The proof proceeds as follows:
- Assume `IMAGE f (range(CARD S)) = S`.
- Introduce `x` and `y` and assume `x < CARD S`, `y < CARD S` and `f x = f y`.
- Show that `FINITE(range(CARD(S)))`. This fact follows as `S` is represented using a boolean predicate so `CARD S` is always finite (this depends on the side condition indicated in the comment).
- Show that `CARD(range(CARD(S))) = CARD S`.
- Then, using `CARD_IMAGE_EQ_INJ`, we can show `x = y`, concluding the proof.

### Mathematical insight
This theorem formalizes the idea that if a function maps an initial segment of the natural numbers onto a set with cardinality `n`, then the function must be injective on that initial segment. This is because if any two elements in the initial segment mapped to the same element in the set, the cardinality of the image would be strictly less than `n`. This result is directly using the cardinality theorem `CARD_IMAGE_EQ_INJ` that relates the cardinality of the image of a function to the cardinality of its domain, provided the function is injective.

### Dependencies
- `GSYM`
- `range_lt`
- `CARD_IMAGE_EQ_INJ`

### Porting notes (optional)
- The comment "XXX: relies on CARD S always being finite" is crucial. Systems like Coq or Lean might require explicit finiteness assumptions for `S` or `CARD S` in the hypothesis if `S` is a general set.
- The HOL Light library `arith` needs to be loaded for the definition of `CARD` and related finiteness results. The porter needs to ensure corresponding finiteness properties are available in the target system.


---

## bij_finite_ordering

### Name of formal statement
bij_finite_ordering

### Type of the formal statement
theorem

### Formal Content
```ocaml
let bij_finite_ordering = prove(`
  !S:X->bool f.
  IMAGE f (range(CARD S)) = S ==>
  BIJ f (range(CARD S)) S
`,
  rw[BIJ;INJ;SURJ] THEN
  REPEAT GEN_TAC THEN
  DISCH_TAC THEN
  have `!x y. x < CARD(S:X->bool) ==> y < CARD S ==> f x = f y:X ==> x = y` [injective_finite_ordering] THEN
  ASM SET_TAC[range_lt]
);;
```

### Informal statement
For any set `S` represented as a boolean function over a type `X` (i.e., `S: X -> bool`) and any function `f: num -> X`, if the image of `f` applied to the range of the cardinality of `S` is equal to `S`, then `f` is a bijection from the range of the cardinality of `S` to `S`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the definition of `BIJ` in terms of `INJ` and `SURJ`.
- Discharge the hypotheses of the goal with `REPEAT GEN_TAC` and `DISCH_TAC`.
- Prove that `f` is injective:
  - Assume `x < CARD S`, `y < CARD S`, and `f x = f y`.
  - Show that `x = y`.
  - This step relies on the theorem `injective_finite_ordering`.
- Apply the assumption `IMAGE f (range (CARD S)) = S` using `ASM SET_TAC[range_lt]`.

### Mathematical insight
This theorem establishes that if the image of a function `f` from an initial segment of the natural numbers (specifically, `range (CARD S)`) covers the set `S`, then `f` must be a bijection. The cardinality `CARD S` is used to index all the elements of `S` without replacement, which guarantees injectivity because the indexing is based on natural number order. Crucially, it relies on the fact that `CARD S` is finite.

### Dependencies
- Definitions: `BIJ`, `INJ`, `SURJ`
- Theorems: `injective_finite_ordering`, `range_lt`

### Porting notes (optional)
- The theorem relies heavily on the finiteness of `CARD S`. Be sure to check how cardinality is defined and handled in the target proof assistant.
- The tactic `ASM SET_TAC` is specific to HOL Light. In other proof assistants, the discharge of the hypothesis `IMAGE f (range (CARD S)) = S` and the use of `range_lt` may need to be done via explicit rewriting or application of the assumption.


---

## image_numseg_antidiagonal

### Name of formal statement
image_numseg_antidiagonal

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_numseg_antidiagonal = prove(`
  !d:num.
  IMAGE (\a:num. a,d-a) (0..d)
  = {a,b | a + b = d}
`,
  rw[GSYM NUMSEG_LE;IMAGE;EXTENSION;IN_ELIM_THM] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    witness `x':num` THEN
    witness `d - x':num` THEN
    qed[SUB_ADD;ADD_SYM]
  ;
    intro THEN
    witness `a:num` THEN
    qed[LE_EXISTS;ADD_SUB2]
  ]
);;
```
### Informal statement
For any natural number `d`, the image of the function that maps `a` to the pair `(a, d - a)` applied to the set of natural numbers from `0` up to `d` (inclusive) is equal to the set of pairs `(a, b)` such that `a + b = d`.

### Informal sketch
The proof proceeds by showing that the two sets are equal by demonstrating inclusion in both directions.

- First direction: Given an element in the image, `(a, d - a)` for some `a` in `{0, ..., d}`, show that it is in the set `{(a, b) | a + b = d}`.  This involves choosing `x'` as `a` and `d - x'` as `d - a`, then substituting to show `a + (d - a) = d`. The terms `SUB_ADD` and `ADD_SYM` likely handle the algebraic simplification.
- Second direction: Given a pair `(a, b)` such that `a + b = d`, show that this pair is in the image. This involves proving that there exists an `a` such that `a` is in `{0, ..., d}` and `b = d - a`. We choose `a` as `a`, and verify `a <= d` and `d = a + b` implies `b = d - a`, using `LE_EXISTS` and `ADD_SUB2`.

### Mathematical insight
The theorem characterizes the set of pairs of natural numbers that sum to a given natural number `d`. It shows that these pairs are precisely those that can be generated by taking `a` from `0` to `d` and mapping it to `(a, d - a)`. This is a basic but important result for reasoning about number theory and combinatorial arguments.

### Dependencies
- `GSYM`
- `NUMSEG_LE`
- `IMAGE`
- `EXTENSION`
- `IN_ELIM_THM`
- `SUB_ADD`
- `ADD_SYM`
- `LE_EXISTS`
- `ADD_SUB2`


---

## numseg_le_lt_reflect

### Name of formal statement
numseg_le_lt_reflect

### Type of the formal statement
theorem

### Formal Content
```ocaml
let numseg_le_lt_reflect = prove(`
  !m n:num.
  m <= n ==>
  IMAGE (\a. n - a) {i | i < n - m} = {i | m < i /\ i <= n}
`,
  rw[IMAGE;EXTENSION;IN_ELIM_THM] THEN
  intro THEN
  splitiff THENL [
    ASM_ARITH_TAC
  ;
    intro THEN
    witness `n - x:num` THEN
    ASM_ARITH_TAC
  ]
);;
```
### Informal statement
For all natural numbers `m` and `n`, if `m` is less than or equal to `n`, then the image of the set of all `i` such that `i` is less than `n - m` under the function that maps `a` to `n - a`, is equal to the set of all `i` such that `m` is less than `i` and `i` is less than or equal to `n`.

### Informal sketch
The proof proceeds as follows:
- Introduce the quantifiers.
- Split the set equality goal into two implications using the definitions of `IMAGE`, `EXTENSION` and `IN_ELIM_THM`.
- The first implication corresponds to showing that if `x` is in `IMAGE (\a. n - a) {i | i < n - m}` then `x` is in `{i | m < i /\ i <= n}`. This is handled by arithmetic simplification (`ASM_ARITH_TAC`).
- The second implication starts by introducing `x` satisfying `m < x /\ x <= n` and constructs a witness `n - x` to show that there exists `a` such that `x = n - a` and `a < n - m`. Again, this is handled by arithmetic simplification (`ASM_ARITH_TAC`).

### Mathematical insight
This theorem relates the elements in a numerical segment after applying a reflection around the average of the bounds of the segment.  It demonstrates a symmetry property in the natural numbers and is useful for reasoning about numerical ranges and their transformations.

### Dependencies
- `IMAGE`
- `EXTENSION`
- `IN_ELIM_THM`


---

## numseg_le_reflect_0

### Name of formal statement
numseg_le_reflect_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let numseg_le_reflect_0 = prove(`
  !n:num.
  IMAGE (\a. n - a) (0..n) = (0..n)
`,
  rw[GSYM NUMSEG_LE;IMAGE;EXTENSION;IN_ELIM_THM] THEN
  intro THEN
  splitiff THENL [
    qed[ARITH_RULE `n - a <= n:num`]
  ;
    intro THEN
    witness `n - x:num` THEN
    qed[ARITH_RULE `n - a <= n:num`;ARITH_RULE `x <= n ==> x = n - (n - x):num`]
  ]
);;
```
### Informal statement
For all natural numbers `n`, the image of the set `{a | 0 <= a <= n}` under the function that maps `a` to `n - a` is equal to the set `{a | 0 <= a <= n}`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the goal using the definition of `NUMSEG_LE` (which likely defines `0..n` as `{a | 0 <= a <= n}`), `IMAGE` (definition of image of a set under a function), `EXTENSION` (extensional equality of sets), and `IN_ELIM_THM` (likely a theorem for eliminating set membership).
- Introduce the universal quantifier `n`.
- Split the set equality into two inclusions.
  - The first inclusion, `IMAGE (\a. n - a) (0..n) SUBSET (0..n)`, is proved directly by using arithmetic reasoning (`ARITH_RULE`) to show that if `a` is in `0..n`, then `n - a <= n`.
  - For the second inclusion, i.e. `(0..n) SUBSET IMAGE (\a. n - a) (0..n)`, we introduce an element `x` in `0..n` and witness that `n - x` is an element in the set `0..n` that gets mapped to `x` by the given function. This is achieved by using arithmetic reasoning (`ARITH_RULE`) to show that if `x <= n`, then `n - (n - x) = x` and `n - x <= n`.

### Mathematical insight
The theorem states that subtracting each element of the set `{0, 1, ..., n}` from `n` results in the same set `{0, 1, ..., n}`. This is because the transformation `n - a` simply reverses the order of the elements within the set. This is a basic property used when dealing with finite sequences of numbers.

### Dependencies
- `NUMSEG_LE`
- `IMAGE`
- `EXTENSION`
- `IN_ELIM_THM`
- `ARITH_RULE`

### Porting notes (optional)
The main challenge in porting this theorem is handling the arithmetic reasoning (`ARITH_RULE`). Other proof assistants might require more explicit steps to prove the inequalities involved.
Also, the definitions of set operations/constructions (`IMAGE`, `EXTENSION`, `IN_ELIM_THM`) need to be verified, as their HOL Light definitions are not provided.


---

## real_of_num_plus_minus_minus

### Name of formal statement
real_of_num_plus_minus_minus

### Type of the formal statement
theorem

### Formal Content
```ocaml
let real_of_num_plus_minus_minus = prove(`
  !a b.
  &(a+b) - &a - &b = &0:real
`,
  intro THEN
  num_linear_fact `a <= (a+b):num` THEN
  num_linear_fact `b <= (a+b)-a:num` THEN
  num_linear_fact `(a+b)-a-b = 0` THEN
  simp[REAL_OF_NUM_SUB]
);;
```
### Informal statement
For all natural numbers `a` and `b`, the real number representation of `(a+b)` minus the real number representation of `a` minus the real number representation of `b` is equal to the real number representation of `0`.

### Informal sketch
The proof proceeds by:
- Introduction of the variables `a` and `b`.
- Applying the theorem `num_linear_fact` to prove `a <= (a+b)` for natural numbers.
- Applying the theorem `num_linear_fact` to prove `b <= (a+b)-a` for natural numbers.
- Applying the theorem `num_linear_fact` to prove `(a+b)-a-b = 0` for natural numbers.
- Using simplification based on the theorem `REAL_OF_NUM_SUB` relating the real representation of subtraction on natural numbers to real subtraction on their real representations.

### Mathematical insight
This theorem demonstrates the compatibility between natural number arithmetic and real number arithmetic, specifically regarding addition and subtraction. It confirms that the real number representation of the sum of two natural numbers, minus the real number representations of each individual number, results in the real number representation of zero. This is a fundamental property verifying that the embedding of natural numbers into real numbers preserves the arithmetic operations.

### Dependencies
- Theorems: `num_linear_fact`, `REAL_OF_NUM_SUB`


---

## fact_binom_lemma_37_real

### Name of formal statement
fact_binom_lemma_37_real

### Type of the formal statement
theorem

### Formal Content
```ocaml
let fact_binom_lemma_37_real = prove(`
  !n i.
  i < n ==>
  &(FACT(n-i) * binom(n,i))
  -
  &(FACT(n-1-i) * binom(n-1,i))
  -
  &((n-1) * FACT(n-1-i) * binom(n-1,i))
  = &0:real
`,
  qed[real_of_num_plus_minus_minus;fact_binom_lemma_37]
);;
```
### Informal statement
For all natural numbers `n` and `i`, if `i` is less than `n`, then the real number representation of `FACT(n-i) * binom(n,i)` minus the real number representation of `FACT(n-1-i) * binom(n-1,i)` minus the real number representation of `(n-1) * FACT(n-1-i) * binom(n-1,i)` equals the real number representation of 0.

### Informal sketch
The proof relies on several previous results:
- First, the goal is expressed in terms of real numbers using `real_of_num`. Then, use prior established algebraic relations.
- Utilized the previously proven lemma `fact_binom_lemma_37` which deals with a similar expression but without the real number conversion.

### Mathematical insight
This lemma establishes a relationship between factorials and binomial coefficients, specifically providing a formula that simplifies to zero under certain conditions. This kind of result is useful in combinatorial arguments and in simplifying expressions in analysis.

### Dependencies
- Theorems:
  - `real_of_num_plus_minus_minus`
  - `fact_binom_lemma_37`


---

## isum_integer_sum

### Name of formal statement
isum_integer_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let isum_integer_sum = prove(`
  !(f:X->int) S.
  FINITE S ==>
  isum S f =
  ring_sum integer_ring S f
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[ISUM_CLAUSES;RING_SUM_CLAUSES] THEN
    rw[INTEGER_RING]
  ;
    simp[ISUM_CLAUSES;RING_SUM_CLAUSES] THEN
    rw[INTEGER_RING;IN_UNIV]
  ]
);;
```
### Informal statement
For all functions `f` from `X` to the integers, and for all sets `S`, if `S` is finite, then `isum S f` (the sum of `f(x)` over all `x` in `S`) is equal to `ring_sum integer_ring S f` (the sum of `f(x)` over all `x` in `S` using the `integer_ring` structure).

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then both `isum S f` and `ring_sum integer_ring S f` reduce to 0 (the additive identity of the integers). This follows from the definitions `ISUM_CLAUSES` and `RING_SUM_CLAUSES`, along with the definition of `INTEGER_RING`.

- Inductive step: Assume that for all subsets `T` of `S`, if `T` is finite and `T` is a proper subset of `S`, then `isum T f = ring_sum integer_ring T f`.  We need to show that `isum S f = ring_sum integer_ring S f`. Since `S` is finite and non-empty, we can pick an element `x` from `S` and consider `S'` defined as `S \ {x}`. By the inductive hypothesis, `isum S' f = ring_sum integer_ring S' f`. By definition, `isum S f = isum S' f + f(x)` and `ring_sum integer_ring S f = ring_sum integer_ring S' f + f(x)`. Applying the inductive hypothesis gives the desired result. The membership condition `IN_UNIV` is used to ensure that the chosen element belongs to the intended set during manipulations of the sum.

### Mathematical insight
This theorem establishes the equivalence between the generic summation function `isum` and the ring summation function `ring_sum` when applied to integers over a finite set. It confirms that the standard way of summing integers is consistent with the more general notion of summation within a ring structure, specifically `integer_ring`.

### Dependencies
- `ISUM_CLAUSES`
- `RING_SUM_CLAUSES`
- `INTEGER_RING`
- `FINITE_INDUCT_STRONG`
- `IN_UNIV`


---

## sum_real_of_int

### Name of formal statement
sum_real_of_int

### Type of the formal statement
theorem

### Formal Content
```ocaml
let sum_real_of_int = prove(`
  !(f:X->int) S.
  FINITE S ==>
  sum S (\s. real_of_int (f s))
  = real_of_int (isum S f)
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[SUM_CLAUSES;ISUM_CLAUSES;REAL_OF_INT_CLAUSES]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    simp[SUM_CLAUSES;ISUM_CLAUSES;REAL_OF_INT_CLAUSES]
  ]
);;
```
### Informal statement
For any function `f` from a type `X` to the integers, and for any finite set `S` of elements of type `X`, the sum of `real_of_int (f s)` over all `s` in `S` is equal to `real_of_int` applied to the integer sum of `f s` over all `s` in `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty. The sums on both sides are zero, and `real_of_int 0 = 0`.
- Inductive step: Assume the result holds for all subsets of `S`. Remove an element `x` from `S`. Then `S` is `x INSERT S'`, where `S'` is a subset of `S`. We then simplify both sides using the clauses for `SUM`, `ISUM`, and `REAL_OF_INT`, using the inductive hypothesis on `S'`. Finally, we prove the result holds for `S`.

### Mathematical insight
This theorem relates the summation of a function (mapping to integers) over a finite set to the real number representation of the integer sum of that function. This emphasizes how the real number coercion interacts with summation. It's important for reasoning about numerical computations and approximations involving integers and reals.

### Dependencies
- Definitions: `FINITE`, `sum`, `isum`, `real_of_int`
- Theorems: `SUM_CLAUSES`, `ISUM_CLAUSES`, `REAL_OF_INT_CLAUSES`


---

## int_of_num_sum

### Name of formal statement
int_of_num_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let int_of_num_sum = prove(`
  !(f:X->num) S.
  FINITE S ==>
  &(nsum S f):int = isum S (\x. &(f x))
`,
  intro THEN
  rw[int_eq] THEN
  simp[INT_OF_REAL_THM REAL_OF_NUM_SUM;sum_real_of_int]
);;
```
### Informal statement
For any function `f` from a type `X` to the type of natural numbers `num`, and for any finite set `S` of type `X`, the integer representation of the numeral sum of `f` over `S` is equal to the integer sum of the real representation of `f` over `S`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions that `f` is a function from `X` to `num` and `S` is a finite set.
- Rewrite the goal using `int_eq`, which likely expresses the equality between integers and real numbers.
- Simplify the goal using the theorems `INT_OF_REAL_THM` (likely converts a real number to an integer), `REAL_OF_NUM_SUM` (likely relates the real representation of a numeral sum to the real representation of the summands), and `sum_real_of_int` (likely converts a sum of integers to a sum of reals).

### Mathematical insight
This theorem relates the numeral sum of a function over a finite set to the integer sum of the real representations of the function's values over the same set. It bridges the gap between the numeral and integer representations of sums, allowing reasoning about sums of natural numbers within the integer domain. `nsum` likely calculates a sum using natural number arithmetic while `isum` likely calculates a sum using integer arithmetic. The theorem states that converting each addend from `num` to `real` and then summing as reals gives the same result (when converted to an integer) as summing the `num` values and then converting to an integer. The finiteness condition on the set `S` is necessary for the sums to be well-defined.

### Dependencies
- `int_eq`
- `INT_OF_REAL_THM`
- `REAL_OF_NUM_SUM`
- `sum_real_of_int`


---

## ring_div_refl

### Name of formal statement
ring_div_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_div_refl = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ring_div r c c =
  if ring_unit r c then ring_1 r else ring_0 r
`,
  rw[ring_div;ring_inv] THEN
  intro THEN
  case `ring_unit(r:R ring) c` THENL [
    choose `d:R` `d IN ring_carrier(r:R ring) /\ ring_mul r c d = ring_1 r` [ring_unit] THEN
    qed[]
  ;
    qed[RING_MUL_RZERO]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any element `c`, if `c` is in the carrier of the ring `r`, then `ring_div r c c` is equal to `ring_1 r` if `c` is a unit in `r`, and `ring_0 r` otherwise.

### Informal sketch
- The proof starts by rewriting `ring_div` using its definition in terms of `ring_inv`.
- Then, it introduces the assumption that `c` is in the ring carrier.
- Next, it performs a case split based on whether `c` is a unit in `r`.
  - **Case 1:** If `c` is a unit in `r`, then we choose an element `d` which is in the carrier of the ring `r` and satisfies `ring_mul r c d = ring_1 r`. Then, using this `d` we have `ring_div r c c = ring_mul r c (ring_inv r c) = ring_mul r c d = ring_1 r`.
  - **Case 2:** If `c` is not a unit in `r`, then `ring_inv r c = ring_0 r`, and hence `ring_div r c c = ring_mul r c (ring_inv r c) = ring_mul r c (ring_0 r) = ring_0 r` by `RING_MUL_RZERO`.

### Mathematical insight
This theorem states that dividing an element by itself in a ring yields the multiplicative identity (one) if the element is a unit (invertible), and zero otherwise. This is a natural extension of the usual arithmetic where division by zero is undefined, but in a ring structure, a non-invertible element effectively behaves like zero when it appears as the denominator.

### Dependencies
- `ring_div`
- `ring_inv`
- `ring_unit`
- `RING_MUL_RZERO`


---

## ring_add_sub_cancel

### Name of formal statement
ring_add_sub_cancel

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_add_sub_cancel = prove(`
  !(r:R ring) a b.
  a IN ring_carrier r ==>
  b IN ring_carrier r ==>
  ring_add r a (ring_sub r b a) = b
`,
  RING_TAC
);;
```

### Informal statement
For any ring `r` and any elements `a` and `b`, if `a` belongs to the carrier of the ring `r` and `b` belongs to the carrier of the ring `r`, then `ring_add r a (ring_sub r b a) = b`.

### Informal sketch
The proof uses `RING_TAC`, which automatically proves ring identities. Specifically, the statement expresses an additive cancellation law (with a subtraction) in a general ring structure. The tactic handles rewriting `ring_sub r b a` as `ring_add r b (ring_neg r a)` and then applies the ring axioms to simplify the expression `ring_add r a (ring_add r b (ring_neg r a))` to `b`.

### Mathematical insight
The theorem `ring_add_sub_cancel` is a basic cancellation law in ring theory, showing that adding `a` and then subtracting `a` from `b` results in `b`. This demonstrates the inverse relationship between addition and subtraction in a रिंग. It is a fundamental property expected in rings and is essential for algebraic manipulations.

### Dependencies
- Tactics: `RING_TAC`


---

## ring_sum_image_injective

### Name of formal statement
ring_sum_image_injective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_image_injective = prove(`
  !r (f:K->L) (g:L->A) s.
  (!x y. f x = f y ==> x = y)
  ==> ring_sum r (IMAGE f s) g = ring_sum r s (g o f)
`,
  qed[RING_SUM_IMAGE]
);;
```
### Informal statement
For all rings `r`, functions `f` from `K` to `L`, and `g` from `L` to `A`, and sets `s`, if `f` is injective (i.e., for all `x` and `y`, `f x = f y` implies `x = y`), then the ring sum of `g` over the image of `s` under `f` is equal to the ring sum of `g o f` over `s`.

### Informal sketch
The proof proceeds by induction on the set `s` using the theorem `RING_SUM_IMAGE`.

*   The goal is to show that `ring_sum r (IMAGE f s) g = ring_sum r s (g o f)` given that `f` is injective.
*   The proof uses the theorem `RING_SUM_IMAGE``, which states that `ring_sum r (IMAGE f s) g = ring_sum r s (g o f)` without the injectivity assumption on `f`.
*   Since the statement of `RING_SUM_IMAGE` is already identical to the goal, no additional proof steps are needed besides applying the named theorem.

### Mathematical insight
This theorem states that if we have an injective function `f`, the ring sum over the image of a set `s` under `f` is equal to the ring sum over the original set `s` using the composition of the function `g` and `f`. This is significant because injective functions preserve the structure needed for the ring sum when mapping sets, so the result of the summation is unchanged whether working with the original set or its image under the injective function.

### Dependencies
- Theorems: `RING_SUM_IMAGE`


---

## ring_sum_image_injective_pair

### Name of formal statement
ring_sum_image_injective_pair

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_image_injective_pair = prove(`
  !r (f:A#B->L) (g:L->X) s.
  (!(a,b) (c,d). f (a,b) = f (c,d) ==> (a,b) = (c,d))
  ==> ring_sum r (IMAGE f s) g = ring_sum r s (g o f)
`,
  intro THEN
  have `!x y. (f:A#B->L) x = f y ==> x = y` [injective_pair_rewrite] THEN
  qed[ring_sum_image_injective]
);;
```
### Informal statement
For any ring structure `r`, any functions `f:A#B->L` and `g:L->X`, and any set `s` of pairs in `A#B`, if `f` is injective when applied to pairs (that is, for all pairs `(a,b)` and `(c,d)`, if `f (a,b) = f (c,d)` then `(a,b) = (c,d)`), then the `ring_sum` of the image of `s` under `f` with respect to `g` (i.e., `ring_sum r (IMAGE f s) g`) is equal to the `ring_sum` of `s` with respect to the composition of `g` and `f` (i.e., `ring_sum r s (g o f)`).

### Informal sketch
The proof proceeds by:
- Introducing the assumptions.
- Applying the theorem `ring_sum_image_injective` which rewrites `ring_sum r (IMAGE f s) g` to `ring_sum r s (g o f)` under the assumption `!x y. f x = f y ==> x = y` (injectivity of f).
- Discharging the goal.

### Mathematical insight
This theorem relates the ring sum of a set's image under an injective function to the ring sum of the original set, composed with the imaging function. This is useful for transferring ring sums through injective mappings and simplifying calculations. Ring sums are generalizations of sums, so this in particular says that if `f` is injective then summation over the image of `f` is the same as summation on the pre-image.

### Dependencies
- `ring_sum_image_injective`
- `injective_pair_rewrite` (used syntactically in the proof)


---

## ring_sum_delete2

### Name of formal statement
ring_sum_delete2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_delete2 = prove(`
  !(r:R ring) S (f:X->R) s.
  FINITE S ==>
  s IN S ==>
  f s IN ring_carrier r ==>
  ring_sum r S f
  = ring_add r (f s) (ring_sum r (S DELETE s) f)
`,
  intro THEN
  simp[RING_SUM_DELETE] THEN
  have `ring_sum (r:R ring) S (f:X->R) IN ring_carrier r` [RING_SUM] THEN
  qed[ring_add_sub_cancel]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any finite set `S` of type `X`, any function `f` from `X` to `R`, and any element `s` in `S` such that `f s` is in the carrier of the ring `r`, the ring sum of `f` over `S` with respect to ring `r` is equal to the ring addition of `f s` with the ring sum over `S` with `s` deleted with respect to the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Start by introducing the assumptions `r:R ring`, `S`, `f:X->R`, `s`, `FINITE S`, `s IN S` and `f s IN ring_carrier r`.
- Simplify using the theorem `RING_SUM_DELETE`.
- Use the theorem `ring_sum (r:R ring) S (f:X->R) IN ring_carrier r` which is named `RING_SUM`.
- Apply `ring_add_sub_cancel`.

### Mathematical insight
This theorem decomposes a ring sum over a finite set `S` into the ring addition of a specific element's image under `f` (namely `f s`) and the ring sum over the remaining elements in `S`. It hinges on the assumption that `s` is in `S` and that `f s` is an element of the ring's carrier. This is a useful lemma for inductive proofs or recursive computations involving ring sums.

### Dependencies
- `RING_SUM_DELETE`
- `RING_SUM`
- `ring_add_sub_cancel`


---

## ring_sum_shift1

### Name of formal statement
ring_sum_shift1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_shift1 = prove(`
  !(r:R ring) f n.
  f 0 = ring_0 r ==>
  ring_sum r (0..n+1) f
  = ring_sum r (0..n) (\a. f (a+1))
`,
  rw[GSYM NUMSEG_LE] THEN
  intro THEN
  set_fact_using `0 IN {a | a <= n+1}` [ARITH_RULE `0 <= n+1`] THEN
  have `f 0 IN ring_carrier(r:R ring)` [RING_0] THEN
  specialize[`n+1`]FINITE_NUMSEG_LE THEN
  specialize[`r:R ring`;`{a | a <= n+1}`;`f:num->R`;`0`]ring_sum_delete2 THEN
  simp[RING_ADD_LZERO;RING_SUM] THEN
  rw[NUMSEG_LE] THEN
  rw[GSYM RING_SUM_OFFSET] THEN
  have `0 INSERT ((0+1)..(n+1)) = 0..(n+1)` [NUMSEG_LREC;ARITH_RULE `0 <= n+1`] THEN
  have `~(0 IN ((0+1)..(n+1)))` [IN_NUMSEG;ARITH_RULE `~(0+1 <= 0)`] THEN
  have `(0..(n+1)) DELETE 0 = ((0+1)..(n+1))` [insert_delete_nonmember] THEN
  simp[]
);;
```
### Informal statement
For any ring `r` over type `R`, and any function `f` from natural numbers to `R`, and any natural number `n`, if `f(0)` is the ring zero element in `r`, then the ring sum of `f(a)` from `a = 0` to `n+1` is equal to the ring sum of `f(a+1)` from `a = 0` to `n`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the right-hand side using `NUMSEG_LE` (which states that `m <= n <==> m IN (0..n)`) to convert the condition into set membership.
- Introduce the assumptions: `ring r`, `f`, and `n`; also use `ARITH_RULE` to establish that `0` is in the set `{a | a <= n+1}`.
- Use the fact that `f 0` is an element of the `ring_carrier` (using `RING_0`, which states that `ring_0 r IN ring_carrier r`).
- Specialize theorem `ring_sum_delete2` (which removes an element from a sum) with `n+1` using `FINITE_NUMSEG_LE`.
- Simplify using theorems `RING_ADD_LZERO` (addition with zero leaves the term unchanged) and `RING_SUM` (definition of ring sum).
- Rewrite again using `NUMSEG_LE`.
- Rewrite using `RING_SUM_OFFSET` (which relates sums over shifted ranges with sums over the original range). This step is reversed so `GSYM RING_SUM_OFFSET`.
- Show that `0 INSERT ((0+1)..(n+1)) = 0..(n+1)` using `NUMSEG_LREC` and `ARITH_RULE`.
- Show that `~(0 IN ((0+1)..(n+1)))` using `IN_NUMSEG` and `ARITH_RULE`.
- Show that `(0..(n+1)) DELETE 0 = ((0+1)..(n+1))` using `insert_delete_nonmember` (inserting and immediately deleting an element not in a set returns the original set).
- Simplify to conclude the proof.

### Mathematical insight
This theorem states that if the initial value `f(0)` of a function is the zero element of a ring, then summing the function `f(a)` from `0` to `n+1` is equivalent to summing the shifted function `f(a+1)` from `0` to `n`. This essentially removes the `f(0)` element from the sum on the left side because it contributes zero. It's a useful identity for manipulating ring sums.

### Dependencies
- `NUMSEG_LE`
- `RING_0`
- `FINITE_NUMSEG_LE`
- `ring_sum_delete2`
- `RING_ADD_LZERO`
- `RING_SUM`
- `RING_SUM_OFFSET`
- `NUMSEG_LREC`
- `IN_NUMSEG`
- `insert_delete_nonmember`
- `ARITH_RULE`


---

## ring_sum_insert_top

### Name of formal statement
ring_sum_insert_top

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_insert_top = prove(`
  !(r:R ring) f n.
  f (n+1) = ring_0 r ==>
  ring_sum r (0..n+1) f
  = ring_sum r (0..n) f
`,
  rw[GSYM NUMSEG_LE] THEN
  intro THEN
  set_fact_using `n+1 IN {a | a <= n+1}` [ARITH_RULE `n+1 <= n+1`] THEN
  have `f (n+1) IN ring_carrier(r:R ring)` [RING_0] THEN
  specialize[`n+1`]FINITE_NUMSEG_LE THEN
  specialize[`r:R ring`;`{a | a <= n+1}`;`f:num->R`;`n+1`]ring_sum_delete2 THEN
  simp[RING_ADD_LZERO;RING_SUM] THEN
  have `(n+1) INSERT (0..((n+1)-1)) = 0..(n+1)` [NUMSEG_RREC;ARITH_RULE `0 <= n+1`] THEN
  have `(n+1)-1 = n` [ADD_SUB] THEN
  have `(n+1) INSERT (0..n) = 0..(n+1)` [NUMSEG_RREC;ARITH_RULE `0 <= n+1`] THEN
  have `~((n+1) IN (0..n))` [IN_NUMSEG;ARITH_RULE `~(n+1 <= n)`] THEN
  have `(0..(n+1)) DELETE (n+1) = 0..n` [insert_delete_nonmember] THEN
  rw[NUMSEG_LE] THEN
  simp[]
);;
```

### Informal statement
For any ring `r` with carrier `ring_carrier(r:R ring)`, and any function `f` from natural numbers to `ring_carrier(r:R ring)`, and any natural number `n`, if `f (n+1)` is equal to the ring zero `ring_0 r`, then the ring sum of `f` over the set of natural numbers from 0 to `n+1` is equal to the ring sum of `f` over the set of natural numbers from 0 to `n`.

### Informal sketch
The proof proceeds by rewriting and simplification using several key lemmas:

- First, rewrite `ring_sum r (0..n+1) f` using `ring_sum_delete2` to express the sum from 0 to `n+1` as the sum from 0 to `n` plus the term `f (n+1)`.  This step leverages the property that `n+1` is in the set `{a | a <= n+1}` and that `f (n+1)` is in `ring_carrier(r:R ring)`.
- Simplify the resulting expression using `RING_ADD_LZERO`, given that `f (n+1)` is equal to `ring_0 r`, effectively removing the added term.
- Use theorems relating to the set equality `(n+1) INSERT (0..((n+1)-1)) = 0..(n+1)` and `(0..(n+1)) DELETE (n+1) = 0..n` to manipulate the summation range.
- Finally, perform rewriting with `NUMSEG_LE` and simplification to complete the proof.

### Mathematical insight
This theorem states that if the last term added to a ring sum is zero, then removing that term will not change the value of the sum. This is a fundamental property used when manipulating sums, particularly in the context of rings.

### Dependencies
- `NUMSEG_LE`
- `RING_0`
- `ring_sum_delete2`
- `RING_ADD_LZERO`
- `NUMSEG_RREC`
- `ADD_SUB`
- `IN_NUMSEG`
- `insert_delete_nonmember`


---

## ring_mul_sum_mul_delete

### Name of formal statement
ring_mul_sum_mul_delete

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_mul_sum_mul_delete = prove(`
  !(r:R ring) S:X->bool f:X->R g:X->R x.
  ~(x IN S) ==>
  FINITE S ==>
  g x IN ring_carrier r ==>
  (!s. s IN S ==> g s IN ring_carrier r) ==>
  (!s. s IN S ==> f s IN ring_carrier r) ==>
  ring_mul r
    (g x)
    (ring_sum r S (\s. ring_mul r (f s) (ring_product r (S DELETE s) g)))
  =  ring_sum r S (\s. ring_mul r (f s) (ring_product r ((x INSERT S) DELETE s) g))
`,
  intro THEN
  have `!s:X. s IN S ==> ring_product r (S DELETE s) g IN ring_carrier(r:R ring)` [RING_PRODUCT] THEN
  have `!s:X. s IN S ==> ring_mul r (f s) (ring_product r (S DELETE s) g) IN ring_carrier(r:R ring)` [RING_MUL] THEN
  have `!s:X. s IN S ==> ring_product r ((x INSERT S) DELETE s) g IN ring_carrier(r:R ring)` [RING_PRODUCT] THEN
  specialize[`r:R ring`;`\s:X. ring_mul(r:R ring) (f s) (ring_product r (S DELETE s) g)`;`g(x:X):R`;`S:X->bool`](GSYM RING_SUM_LMUL) THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  intro THEN
  simp[] THEN
  set_fact `!s:X. s IN S ==> ~(x IN S) ==> (x INSERT S) DELETE s = x INSERT (S DELETE s)` THEN
  have `(x:X INSERT S) DELETE a = x INSERT (S DELETE a)` [] THEN
  have `FINITE(S DELETE a:X)` [FINITE_DELETE] THEN
  set_fact `!s:X. s IN S ==> ~(x IN S) ==> ~(x IN S DELETE s)` THEN
  have `~(x:X IN S DELETE a)` [] THEN
  simp[RING_PRODUCT_CLAUSES] THEN
  have `g(x:X) IN ring_carrier(r:R ring)` [] THEN
  have `f(a:X) IN ring_carrier(r:R ring)` [] THEN
  have `ring_product r (S DELETE a:X) g IN ring_carrier(r:R ring)` [RING_PRODUCT] THEN
  specialize[`r:R ring`;`f(a:X):R`;`g(x:X):R`;`ring_product(r:R ring) (S DELETE a:X) g`]RING_MUL_ASSOC THEN
  specialize[`r:R ring`;`g(x:X):R`;`f(a:X):R`;`ring_product(r:R ring) (S DELETE a:X) g`]RING_MUL_ASSOC THEN
  specialize[`r:R ring`;`f(a:X):R`;`g(x:X):R`]RING_MUL_SYM THEN
  qed[]
);;
```
### Informal statement
Let `r` be a ring, `S` be a set of type `X`, `f` and `g` be functions from `X` to `R`, and `x` be an element of type `X`. If `x` is not in `S`, `S` is finite, `g(x)` is in the carrier of the ring `r`, for all `s` in `S`, `g(s)` is in the carrier of the ring `r`, and for all `s` in `S`, `f(s)` is in the carrier of the ring `r`, then the ring multiplication of `g(x)` with the ring sum over `S` of the function mapping `s` to the ring multiplication of `f(s)` with the ring product over `S` with `s` deleted of `g` is equal to the ring sum over `S` of the function mapping `s` to the ring multiplication of `f(s)` with the ring product over `(x` inserted into `S)` with `s` deleted of `g`.

### Informal sketch
The proof establishes an equality involving ring multiplication, ring sum, and ring product within a ring `r`. It leverages the fact that `x` is not in `S` to simplify the expression.

- The proof starts by introducing assumptions and aiming to prove the equality.
- It uses `RING_SUM_LMUL` (ring sum left multiplication) and `RING_SUM_EQ` properties to transform the left-hand side into the right-hand side.
- Key steps involve simplifying using the fact that `x` is not in `S` and rewriting `(x INSERT S) DELETE s` as `x INSERT (S DELETE s)`.
- The proof relies on properties of `DELETE` and `INSERT` operations on sets, as well as the finiteness of `S`.
- Properties of the ring carrier and closure under ring multiplication and ring product are crucial.
- Finally, applications of the associativity and symmetry of `RING_MUL` complete the proof.

### Mathematical insight
This theorem relates the ring multiplication of a function value outside the set `S` with the ring sum calculated on `S`, involving another function and a ring product, to the ring sum calculated on `S`, involving the other function and the ring product after inserting the element into `S`. The underlying idea is to distribute the ring multiplication over the ring sum, taking into account the element `x` being outside `S`.

### Dependencies
- `RING_PRODUCT`
- `RING_MUL`
- `RING_SUM_LMUL`
- `RING_SUM_EQ`
- `FINITE_DELETE`
- `RING_PRODUCT_CLAUSES`
- `RING_MUL_ASSOC`
- `RING_MUL_SYM`


---

## ring_sum_numseg_le_reflect

### Name of formal statement
ring_sum_numseg_le_reflect

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_numseg_le_reflect = prove(`
  !(r:R ring) n f:num->R.
  ring_sum r (0..n) f
  = ring_sum r (0..n) (\b. f(n - b))
`,
  intro THEN
  subgoal `!x:num y:num. x IN (0..n) /\ y IN (0..n) /\ n-x = n-y ==> x = y` THENL [
    rw[IN_ELIM_THM;GSYM NUMSEG_LE] THEN
    qed[IN_ELIM_THM;ARITH_RULE `x <= n /\ y <= n /\ n-x = n-y ==> x = y:num`]
  ;
    pass
  ] THEN
  specialize_assuming[`r:R ring`;`\a:num. n - a`;`f:num->R`;`0..n`]RING_SUM_IMAGE THEN
  have `ring_sum (r:R ring) (IMAGE (\a:num. n - a) (0..n)) f = ring_sum r (0..n) (f o (\a. n - a))` [] THEN
  have `IMAGE (\a:num. n - a) (0..n) = (0..n)` [numseg_le_reflect_0] THEN
  have `ring_sum (r:R ring) (0..n) f = ring_sum r (0..n) (f o (\a. n - a))` [] THEN
  simp[o_THM] THEN
  sufficesby RING_SUM_EQ THEN
  qed[o_THM]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any natural number `n`, and any function `f` from natural numbers to `R`, the ring sum of `f` over the natural number segment from 0 to `n` is equal to the ring sum of the function that maps `b` to `f(n - b)` over the natural number segment from 0 to `n`.

### Informal sketch
The proof proceeds as follows:
- First, introduce the assumptions `r:R ring`, `n`, and `f:num->R`.
- Show that if `x` and `y` are elements of the natural number segment from 0 to `n`, and `n-x = n-y`, then `x = y`. This is proved by rewriting using `IN_ELIM_THM` and `NUMSEG_LE`, then using arithmetic reasoning.
- Apply the theorem `RING_SUM_IMAGE` by specializing it with `r:R ring`, `\a:num. n - a`, `f:num->R`, and `0..n`.
- Show that `IMAGE (\a:num. n - a) (0..n) = (0..n)` using the theorem `numseg_le_reflect_0`.
- Simplify using `o_THM` and then apply `RING_SUM_EQ` to finish the proof.

### Mathematical insight
This theorem states that the ring sum over an interval is invariant if the function being summed is reflected about the midpoint of the interval. This is a useful property when dealing with summations and can simplify calculations or proofs related to sums. Essentially, it highlights a symmetry property of summation over an interval.

### Dependencies
- `RING_SUM_IMAGE`
- `numseg_le_reflect_0`
- `RING_SUM_EQ`
- `IN_ELIM_THM`
- `NUMSEG_LE`
- `o_THM`


---

## ring_sum_numseg_le_offset

### Name of formal statement
ring_sum_numseg_le_offset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_numseg_le_offset = prove(`
  !(r:R ring) m n f:num->R.
  ring_sum r (0..m) f
  = ring_sum r (0..m+n) (\b. if n <= b then f(b - n) else ring_0 r)
`,
  intro THEN
  specialize[`n:num`;`r:R ring`;`\i:num. f(i - n):R`;`0:num`;`m:num`]RING_SUM_OFFSET THEN
  have `(0+n..m+n) SUBSET (0..m+n)` [SUBSET_NUMSEG;ARITH_RULE `0 <= 0+n`;ARITH_RULE `m+n <= m+n:num`] THEN
  subgoal `!x. x IN 0..m+n ==> ~(x IN 0+n..m+n) ==> (if n <= x then f(x-n) else ring_0(r:R ring)) = ring_0 r` THENL [
    rw[numseg;IN_ELIM_THM] THEN
    qed[ARITH_RULE `x:num <= m+n /\ ~(0+n <= x /\ x <= m+n) ==> ~(n <= x)`]
  ; pass
  ] THEN
  specialize[`r:R ring`;`\b:num. if n <= b then f(b-n) else ring_0(r:R ring)`;`0+n..m+n`;`0..m+n`]RING_SUM_SUPERSET THEN
  subgoal `!a. a IN 0+n..m+n ==> (if n <= a then f(a-n) else ring_0 r) = f(a-n):R` THENL [
    rw[numseg;IN_ELIM_THM] THEN
    qed[ARITH_RULE `0+n = n`]
  ; pass
  ] THEN
  specialize[`r:R ring`;`\i:num. if n <= i then f(i-n) else ring_0(r:R ring)`;`\i:num. f(i-n):R`;`0+n..m+n`]RING_SUM_EQ THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  qed[ARITH_RULE `(b+n)-n = b:num`]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), and for any natural numbers `m` and `n`, and for any function `f` from natural numbers to the ring `R`, the ring sum of `f` over the natural number segment from 0 to `m` is equal to the ring sum of a modified function over the natural number segment from 0 to `m+n`. The modified function maps `b` to `f(b-n)` if `n` is less than or equal to `b`, and to `ring_0 r` otherwise.

### Informal sketch
The proof proceeds as follows:
- Apply the `RING_SUM_OFFSET` theorem, instantiating it with `n`, the ring `r`, the function `\i:num. f(i - n):R`, 0, and `m`.
- Establish that `(0+n..m+n)` is a subset of `(0..m+n)`.
- Prove that for all `x` in `(0..m+n)`, if `x` is not in `(0+n..m+n)`, then `(if n <= x then f(x-n) else ring_0(r:R ring)) = ring_0 r`. This involves rewriting using `numseg` and `IN_ELIM_THM`, and then using arithmetic reasoning.
- Apply the `RING_SUM_SUPERSET` theorem, instantiating it with the ring `r`, the function `\b:num. if n <= b then f(b-n) else ring_0(r:R ring)`, the segment `0+n..m+n`, and the segment `0..m+n`.
- Prove that for all `a` in `(0+n..m+n)`, `(if n <= a then f(a-n) else ring_0 r) = f(a-n):R`. This involves rewriting using `numseg` and `IN_ELIM_THM`, and then arithmetic reasoning.
- Apply the `RING_SUM_EQ` theorem, instantiating it with the ring `r`, the function `\i:num. if n <= i then f(i-n) else ring_0(r:R ring)`, the function `\i:num. f(i-n):R`, and the segment `0+n..m+n`.
- Simplify.
- Establish the conclusion using `RING_SUM_EQ` along with the arithmetic rule `(b+n)-n = b:num`.

### Mathematical insight
This theorem provides a useful identity for manipulating ring sums over natural number segments. Specifically, it shows how one can shift the index of summation by introducing a zero term to compensate for the shift. This is particularly useful when dealing with sums that need to be aligned or combined.

### Dependencies
- `RING_SUM_OFFSET`
- `SUBSET_NUMSEG`
- `RING_SUM_SUPERSET`
- `RING_SUM_EQ`
- `numseg`
- `IN_ELIM_THM`
---

---

## ring_sum_numseg_le_expand

### Name of formal statement
ring_sum_numseg_le_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_numseg_le_expand = prove(`
  !(r:R ring) m n f:num->R.
  m <= n ==>
  ring_sum r (0..m) f
  = ring_sum r (0..n) (\a. if a <= m then f(a) else ring_0 r)
`,
  intro THEN
  subgoal `ring_sum(r:R ring) (0..m) f = ring_sum r (0..m) (\a. if a <= m then f(a) else ring_0 r)` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[GSYM NUMSEG_LE;IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby(GSYM RING_SUM_SUPERSET) THEN
  intro THENL [
    rw[SUBSET_NUMSEG] THEN
    qed[ARITH_RULE `0 <= 0`]
  ;
    have `~(x <= m:num)` [
      NUMSEG_LE;IN_ELIM_THM
    ] THEN
    simp[]
  ]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), and any natural numbers `m` and `n`, and any function `f` from natural numbers to the carrier of the ring `R`, if `m` is less than or equal to `n`, then the ring sum of `f` over the natural number segment from 0 to `m` is equal to the ring sum of a modified function over the natural number segment from 0 to `n`. The modified function maps `a` to `f(a)` if `a` is less than or equal to `m`, and to the ring zero element of `r` otherwise.

### Informal sketch
The proof proceeds by induction and case splitting:

- First, the goal is to prove that `ring_sum r (0..m) f = ring_sum r (0..m) (\a. if a <= m then f(a) else ring_0 r)`.
  - This follows directly from `RING_SUM_EQ` after rewriting with `GSYM NUMSEG_LE` and `IN_ELIM_THM`.
- Second, we simplify the induction step using `simp[]`.
- Now, we prove the main goal using `GSYM RING_SUM_SUPERSET`.
  - To use `RING_SUM_SUPERSET`, we must show `0..m` is a subset of `0..n`.
    - This is proved by rewriting with `SUBSET_NUMSEG` and checking `0 <= 0` which results in `true`.
  - We must also show that if `x` is not less than or equal to `m`, then the modified `f` equals zero.
    - Given `~(x <= m:num)` apply `NUMSEG_LE` and `IN_ELIM_THM` to derive the modified `f` equals zero.

### Mathematical insight
This theorem expresses a way to expand the range of a ring sum. If we have a sum over `0..m` and we want to express it as a sum over a larger range `0..n`, we can do so by extending the function being summed such that it returns zero outside the original range. This is a useful technique for manipulating sums and comparing sums over different ranges.

### Dependencies
- `RING_SUM_EQ`
- `GSYM`
- `NUMSEG_LE`
- `IN_ELIM_THM`
- `RING_SUM_SUPERSET`
- `SUBSET_NUMSEG`
- `ARITH_RULE`

### Porting notes (optional)
The theorem relies on rewriting with conditions about numerical segments and set membership using `NUMSEG_LE` and `IN_ELIM_THM`. Ensure that similar theorems are available, or that the subset relationship can be derived. The most involved part is likely the availability of `RING_SUM_SUPERSET`, which asserts equality of sums when the function summed outside the original set is zero. The tactic `ARITH_RULE` is a generic tactic for proving basic arithmetic facts, and should be replaceable in any system with a similar tactic or decision procedure for linear arithmetic over the naturals.


---

## num_in_subring

### Name of formal statement
num_in_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let num_in_subring = prove(`
  !(r:R ring) s.
  s subring_of r ==>
  !n. ring_of_num r n IN s
`,
  rw[subring_of] THEN
  GEN_TAC THEN GEN_TAC THEN DISCH_TAC THEN
  INDUCT_TAC THEN
  qed[ring_of_num]
);;
```
### Informal statement
For any ring `r` and any `s` that is a subring of `r`, for all natural numbers `n`, the element `ring_of_num r n` is in `s`.

### Informal sketch
The proof proceeds by induction on `n`.

- The base case is handled by `ring_of_num`, which maps 0 to the zero element of ring `r`, and since `s` is a subring, it must contain the zero element of `r`.
- The inductive step shows that if `ring_of_num r n` is in `s`, then `ring_of_num r (SUC n)` is also in `s`. This follows because `ring_of_num r (SUC n)` is `ring_add r (ring_of_num r n) (ring_one r)`, and `s` is closed under addition and contains the ring's one.

The tactics used are `rw[subring_of]`, `GEN_TAC`, `DISCH_TAC`, `INDUCT_TAC`, and `qed[ring_of_num]`. Rewriting with `subring_of` unfolds the definition of a subring. Repeated application of `GEN_TAC` universally quantifies over the variables. `DISCH_TAC` discharges assumptions. `INDUCT_TAC` performs induction on the natural number `n`. Finally, `qed[ring_of_num]` uses the definition of `ring_of_num` to finish the proof.

### Mathematical insight
This theorem establishes that any subring of a ring contains all elements constructed by repeatedly adding the ring's multiplicative identity, starting from the ring's zero element. This reflects the idea that subrings are closed under the operations inherited from the parent ring and must, therefore, contain at least the elements one would obtain by iteratively adding the one.

### Dependencies
- `subring_of`
- `ring_of_num`


---

## int_in_subring

### Name of formal statement
int_in_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let int_in_subring = prove(`
  !(r:R ring) s.
  s subring_of r ==>
  !i. ring_of_int r i IN s
`,
  rw[FORALL_INT_CASES] THEN
  rw[RING_OF_INT_NEG;RING_OF_INT_OF_NUM] THEN
  qed[num_in_subring;subring_of]
);;
```
### Informal statement
For any ring `r` and any subset `s`, if `s` is a subring of `r`, then for any integer `i`, the ring representation of `i` in `r` (denoted `ring_of_int r i`) is an element of `s`.

### Informal sketch
The proof proceeds as follows:
- The theorem is proved by splitting the universal quantification over integers `i` into the cases where `i` is a natural number or a negative integer using `FORALL_INT_CASES`.
- Rewrite using `RING_OF_INT_NEG` which defines the ring of integer representation of negative numbers and `RING_OF_INT_OF_NUM` which defines the ring representation of numerals (natural numbers), turning `ring_of_int r i` into either `ring_of_num r i` or `- ring_of_num r i`
- The resulting goals are discharged automatically by appealing to `num_in_subring` which states that numerals are within a subring, and the subring property `subring_of`, which states closure under ring operations. The negative elements are inside subring because subrings are closed under negation.

### Mathematical insight
The theorem essentially states that if you have a subring `s` of a ring `r`, then the image of any integer under the canonical ring homomorphism from the integers into `r` is contained in `s`. This is a fundamental property of subrings and is crucial for reasoning about algebraic structures within rings. Since subrings contain the ring's zero `0` and unit `1` and are closed under addition, they inherently contain the image of the integers.

### Dependencies
- Theorems: `FORALL_INT_CASES`, `RING_OF_INT_NEG`, `RING_OF_INT_OF_NUM`, `num_in_subring`, `subring_of`

### Porting notes (optional)
- The tactic `FORALL_INT_CASES` splits an integer quantification into natural number and negative integer cases. Ensure that the target system has appropriate infrastructure for handling integer case splitting.
- The proof relies on rewriting with standard definitions and properties of subrings. Ensure that the corresponding properties are available in the target system.


---

## ring_sum_subring_generated

### Name of formal statement
ring_sum_subring_generated

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_subring_generated = prove(`
  !(r:R ring) S A (f:X->R).
  S subring_of r /\
  (!x. x IN A ==> f x IN S) ==>
  ring_sum (subring_generated r S) A f
  = ring_sum r A f
`,
  simp[] THEN
  intro THEN
  set_fact `(!x:X. x IN A ==> (f x):R IN S) ==> {x | x IN A /\ f x IN S} = A` THEN
  simp[RING_SUM_SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` of type `R`, any subring `S` of `r`, any set `A` of type `X`, and any function `f` from `X` to `R`, if `S` is a subring of `r` and for all `x` in `A`, `f x` is in `S`, then the ring sum over the subring generated by `S` associated with `A` and `f` is equal to the ring sum over `r` associated with `A` and `f`.

### Informal sketch
The proof proceeds by:
- Starting with the assumption that `S` is a subring of `r` and that for any `x` in `A`, `f x` is in `S`.
- Making use of the theorem `RING_SUM_SUBRING_GENERATED` which states that if `S` is a subring and the image of `f` over `A` is included in `S`, then the `ring_sum` over the subring generated by `S` is equal to the `ring_sum` over the original ring.
- Thus the goal follows by simplification.
- The tactic `set_fact \`(!x:X. x IN A ==> (f x):R IN S) ==> {x | x IN A /\ f x IN S} = A\`` is used. The statement `(!x:X. x IN A ==> (f x):R IN S) ==> {x | x IN A /\ f x IN S} = A` is not obviously relevant to the theorem being proved. Setting this fact might be a way to massage the assumptions so that they apply to the `RING_SUM_SUBRING_GENERATED` theorem.

### Mathematical insight
The theorem essentially states that if the image of the function `f` is already contained within the subring `S`, then summing over the subring generated by `S` yields the same result as summing over the original ring `r`. This is because the subring generated by `S` is the smallest subring containing `S`, so if `f`'s image is already in `S`, then the generated subring doesn't add anything new to the summation.

### Dependencies
- Definition: `subring_of`
- Definition: `ring`
- Definition: `ring_sum`
- Definition: `subring_generated`
- Theorem: `RING_SUM_SUBRING_GENERATED`


---

## ring_sum_subring_generated_v2

### Name of formal statement
ring_sum_subring_generated_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_subring_generated_v2 = prove(`
  !(r:R ring) S A (f:X->R).
  (!x. x IN A ==> f x IN ring_carrier(subring_generated r S)) ==>
  ring_sum (subring_generated r S) A f
  = ring_sum r A f
`,
  intro THEN
  have `ring_carrier(subring_generated(r:R ring) S) subring_of r` [SUBRING_SUBRING_GENERATED] THEN
  have `subring_generated(r:R ring) (ring_carrier(subring_generated r S)) = subring_generated r S` [SUBRING_GENERATED_BY_SUBRING_GENERATED] THEN
  qed[ring_sum_subring_generated]
);;
```
### Informal statement
For any ring `r` of type `R ring`, set `S`, set `A`, and function `f` from a type `X` to `R`, if for all `x` in `A`, `f x` is in the carrier of the subring generated by `S` in `r`, then the ring sum over the subring generated by `S` in `r`, indexed by `A` and using `f`, is equal to the ring sum over the full ring `r`, indexed by `A` and using `f`.

### Informal sketch
*   We are given that for all `x` in `A` implies `f x` is in the carrier of the subring generated by `S` in `r`.
*   The goal is to prove that the ring sum of `f` over `A` with respect to the subring generated by `S` is equal to the ring sum of `f` over `A` with respect to the original ring `r`.
*   First, we establish that the carrier of the subring generated by `S` is a subring of `r`, using the theorem `SUBRING_SUBRING_GENERATED`.
*   Next, we show that the subring generated by the carrier of the subring generated by `S` is equal to the subring generated by `S`, using the theorem `SUBRING_GENERATED_BY_SUBRING_GENERATED`.
*   Finally, we apply `ring_sum_subring_generated`.

### Mathematical insight
The theorem essentially states that if the image of the function `f` is contained within the subring generated by `S`, then the ring sum computed within the subring generated by `S` is the same as the ring sum computed in the original ring. This is because the ring sum operation only involves elements generated by S, so restricting the computation to the subring generated by S does not change the result.

### Dependencies
- `SUBRING_SUBRING_GENERATED`
- `SUBRING_GENERATED_BY_SUBRING_GENERATED`
- `ring_sum_subring_generated`


---

## ring_sum_in_subring

### Name of formal statement
ring_sum_in_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_in_subring = prove(`
  !(r:R ring) G S (f:X->R).
  (!s. s IN S ==> f s IN ring_carrier(subring_generated r G)) ==>
  ring_sum r S f IN ring_carrier(subring_generated r G)
`,
  qed[ring_sum_subring_generated_v2;RING_SUM]
);;
```
### Informal statement
For any ring `r`, any set `G`, any set `S`, and any function `f` from `X` to the carrier of `r`, if for all `s` in `S`, `f s` is in the carrier of the subring generated by `G` in `r`, then the ring sum of `f` over `S` in `r` is also in the carrier of the subring generated by `G` in `r`.

### Informal sketch
The proof demonstrates that `ring_sum r S f` belongs to `ring_carrier(subring_generated r G)` under the assumption that for all `s` in `S`, `f s` belongs to `ring_carrier(subring_generated r G)`.

- The proof proceeds by induction on the set `S`.

- The base case, where `S` is empty, leverages the fact that `ring_sum r EMPTY f` is the ring zero `ring_zero r`, which is always in the carrier of any subring (including `subring_generated r G`).

- In the inductive step, a member `x` is removed from `S` to obtain `S'`. Then, it is shown that `ring_sum r S f` which equals `ring_sum r (INSERT x S') f`, which equals `ring_add r (f x) (ring_sum r S' f)` belongs to `ring_carrier(subring_generated r G)`.  This involves using the inductive hypothesis that `ring_sum r S' f` belongs to `ring_carrier(subring_generated r G)` and the assumption that `f x` belongs to `ring_carrier(subring_generated r G)`. Then, since `ring_carrier(subring_generated r G)` is closed under the ring addition of `r`, `ring_add r (f x) (ring_sum r S' f)` belongs to `ring_carrier(subring_generated r G)`.

### Mathematical insight
This theorem establishes that the ring sum of elements within a subring remains within that subring, demonstrating closure under summation. Since `subring_generated r G` will contain the ring_zero and be closed under ring_add, it is thus closed under `ring_sum`. This is fundamental for reasoning about structures generated from subsets within a ring.

### Dependencies
- Theorems:
  - `ring_sum_subring_generated_v2`
- Constants:
  - `RING_SUM`


---

## ring_product_subring_generated

### Name of formal statement
ring_product_subring_generated

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) S A (f:X->R).
  S subring_of r /\
  (!x. x IN A ==> f x IN S) ==>
  ring_product (subring_generated r S) A f
  = ring_product r A f
```

### Informal statement
For any ring `r` of type `R ring`, any subring `S` of `r`, any set `A` of type `X`, and any function `f` from `X` to `R`, if `S` is a subring of `r` and for all `x` in `A`, `f(x)` is in `S`, then the ring product of `f` over `A` within the subring generated by `S` with respect to `r` is equal to the ring product of `f` over `A` within the ring `r`.

### Informal sketch
The theorem states that if the image of a function `f` is contained in a subring `S` of a ring `r`, then the ring product of `f` over a set `A` computed within the subring generated by `S` with respect to `r` is the same as the ring product computed within the entire ring `r`.

- The proof starts by introducing the assumptions: `S` is a subring of `r` and for all `x` in `A`, `f(x)` is in `S`.
- An assumption `(!x:X. x IN A ==> (f x):R IN S) ==> {x | x IN A /\ f x IN S} = A` is set as a fact. This fact is used to simplify the expression within the ring product.
- The theorem's conclusion then follows directly by simplifying using the definition of `RING_PRODUCT_SUBRING_GENERATED`.

### Mathematical insight
This theorem essentially states that when computing the ring product of a function, if the image of that function lies within a subring, then restricting the computation to the subring doesn't change the result. This is because the ring product only involves elements arising from the image of `f`, and if `f` always maps to the subring `S`, then the subring generated by `S` which includes all possible combinations of elements from S using ring operations, will be the same as the result in `r`.

### Dependencies
- `RING_PRODUCT_SUBRING_GENERATED`


---

## ring_product_subring_generated_v2

### Name of formal statement
ring_product_subring_generated_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_subring_generated_v2 = prove(`
  !(r:R ring) S A (f:X->R).
  (!x. x IN A ==> f x IN ring_carrier(subring_generated r S)) ==>
  ring_product (subring_generated r S) A f
  = ring_product r A f
`,
  intro THEN
  have `ring_carrier(subring_generated(r:R ring) S) subring_of r` [SUBRING_SUBRING_GENERATED] THEN
  have `subring_generated(r:R ring) (ring_carrier(subring_generated r S)) = subring_generated r S` [SUBRING_GENERATED_BY_SUBRING_GENERATED] THEN
  qed[ring_product_subring_generated]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `S`, any set `A`, and any function `f` from `X` to `R`, if for all `x` in `A`, `f x` is in the carrier of the subring generated by `S` in `r`, then `ring_product` with respect to the subring generated by `S` in `r`, `A`, and `f` is equal to `ring_product` with respect to `r`, `A`, and `f`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Show that the carrier of the subring generated by `S` is a subring of `r` using `SUBRING_SUBRING_GENERATED`.
- Show that the subring generated by the carrier of the subring generated by `S` is equal to the subring generated by `S`, using `SUBRING_GENERATED_BY_SUBRING_GENERATED`. This uses the fact that taking the subring generated of a subring has no effect.
- Conclude by rewriting with `ring_product_subring_generated`.

### Mathematical insight
This theorem states that when computing the `ring_product` over a set `A` with a function `f` whose values are within the subring generated by `S`, we can restrict the ring to the subring generated by `S` without changing the result. This is important because it allows us to compute `ring_product` within a smaller ring, which can simplify calculations and proofs.

### Dependencies
- `SUBRING_SUBRING_GENERATED`
- `SUBRING_GENERATED_BY_SUBRING_GENERATED`
- `ring_product_subring_generated`


---

## ring_product_in_subring

### Name of formal statement
ring_product_in_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_in_subring = prove(`
  !(r:R ring) G S (f:X->R).
  (!s. s IN S ==> f s IN ring_carrier(subring_generated r G)) ==>
  ring_product r S f IN ring_carrier(subring_generated r G)
`,
  qed[ring_product_subring_generated_v2;RING_PRODUCT]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `G`, any set `S`, and any function `f` from `X` to `R`: if for all `s` in `S`, `f s` is in the carrier of the subring generated by `G` in `r`, then the ring product of `f` over `S` with respect to `r` is in the carrier of the subring generated by `G` in `r`.

### Informal sketch
The proof proceeds as follows:
- Hypothesis: Assume that for all `s` in `S`, `f s` is in the `ring_carrier` of the `subring_generated r G`.
- Goal: Show that `ring_product r S f` is in `ring_carrier(subring_generated r G)`.
- Apply the theorem `ring_product_subring_generated_v2`, which states that if `S` is finite and for all `s` in `S`, `f s` is in `ring_carrier(subring_generated r G)`, then the ring product of `f` over `S` with respect to `r` is in `ring_carrier(subring_generated r G)`.
- The proof uses `RING_PRODUCT` which is most likely the definition of ring product or a theorem that expands it.

### Mathematical insight
This theorem states that the ring product of elements within a subring remains within that subring, assuming the subring is generated in particular. This is a fundamental property demonstrating the closure of subrings under ring operations. This closure property is essential for reasoning about algebraic structures and is widely used in algebraic proofs.

### Dependencies
- Theorem: `ring_product_subring_generated_v2`
- Definition/Theorem: `RING_PRODUCT`


---

## ring_pow_in_subring

### Name of formal statement
ring_pow_in_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_in_subring = prove(`
  !(r:R ring) G f n.
  f IN ring_carrier(subring_generated r G) ==>
  ring_pow r f n IN ring_carrier(subring_generated r G)
`,
  qed[RING_POW_SUBRING_GENERATED;RING_POW]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `G`, any element `f`, and any natural number `n`, if `f` is an element of the carrier of the subring generated by `G` in `r`, then the `n`-th power of `f` in `r` is also an element of the carrier of the subring generated by `G` in `r`.

### Informal sketch
The proof demonstrates that if an element `f` belongs to the subring generated by a set `G` in a ring `r`, then any natural number power of `f` computed within the ring `r` also belongs to that subring.

- The main step is to leverage the theorem `RING_POW_SUBRING_GENERATED`, which states that natural number powers belong to subrings generated by sets containing the base element of the power.
- Additionally, the theorem `RING_POW` may contribute to connecting the definition of ring power within a general ring to the power operation within the specific subring.

### Mathematical insight
This theorem confirms a fundamental property of subrings, specifically that they are closed under the ring's power operation. This closure is crucial because it guarantees that algebraic manipulations, such as forming polynomials of elements within the subring, stay within the subring. In other words, any element algebraically generated from elements in the generating set `G` of the subring will remain in this subring when raised to any natural number power.

### Dependencies
- Theorems: `RING_POW_SUBRING_GENERATED`, `RING_POW`


---

## ring_sum_1

### Name of formal statement
ring_sum_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_1 = prove(`
  !(r:R ring) S.
  FINITE S ==>
  ring_sum r S (\s:X. ring_1 r)
  = ring_of_num r (CARD S)
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[card_empty;RING_SUM_CLAUSES;RING_OF_NUM_0]
  ;
    simp[card_insert;RING_SUM_CLAUSES;RING_1;ARITH_RULE `CARD S + 1 = SUC(CARD(S:X->bool))`;ring_of_num] THEN
    qed[RING_ADD_SYM;RING_1;RING_OF_NUM]
  ]
);;
```
### Informal statement
For any ring `r` and any finite set `S`, the ring sum of the elements in `S`, where each element is mapped to the ring identity `ring_1 r`, is equal to the ring of the numbers `r` applied to the cardinality of `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base Case: If `S` is empty, then the cardinality of `S` is 0, the ring sum over `S` is the additive identity `ring_0 r`, and the ring of numbers of 0 is also the additive identity `ring_0 r`. The proof tactics `card_empty`, `RING_SUM_CLAUSES`, and `RING_OF_NUM_0` are used here.
- Inductive Step: Assume the theorem holds for all subsets of size less than the size of `S`. Then, `S` can be written as `INSERT x S'`, where `x` is an element and `S'` is a set such that `FINITE S'`. By definition, the cardinality of insert `INSERT x S'` is `CARD S' + 1`. The `ring_sum` over `INSERT x S'` is the sum of `ring_1 r` and the `ring_sum` over `S'`. By the inductive hypothesis, the `ring_sum` over `S'` is equal to `ring_of_num r (CARD S')`. Therefore, we have `ring_1 r + ring_of_num r (CARD S') = ring_of_num r (CARD S' + 1)`, which is `ring_of_num r (CARD (INSERT x S'))`. The proof tactics `simp[card_insert;RING_SUM_CLAUSES;RING_1;ARITH_RULE;ring_of_num]`, `RING_ADD_SYM`, `RING_1`, and `RING_OF_NUM` are used in this case.

### Mathematical insight
This theorem relates the ring sum of a constant value (the multiplicative identity) over a finite set to the cardinality of the set embedded into the ring via `ring_of_num`. It highlights how the number of elements in a set can be represented within a ring structure. This is a basic but important result for relating set theory to algebraic structures.

### Dependencies
- `FINITE`
- `ring`
- `ring_sum`
- `ring_1`
- `ring_of_num`
- `CARD`
- `card_empty`
- `card_insert`
- `RING_SUM_CLAUSES`
- `RING_OF_NUM_0`
- `RING_1`
- `RING_ADD_SYM`
- `RING_OF_NUM`


---

## ring_sum_num

### Name of formal statement
ring_sum_num

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_num = prove(`
  !(r:R ring) (f:X->num) S.
  FINITE S ==>
  ring_sum r S (\s. ring_of_num r (f s))
  = ring_of_num r (nsum S f)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;NSUM_CLAUSES;ring_of_num]
  ;
    simp[RING_SUM_CLAUSES;NSUM_CLAUSES] THEN
    rw[RING_OF_NUM;RING_OF_NUM_ADD]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any function `f` from a type `X` to the natural numbers `num`, and any set `S` of type `X`, if `S` is finite, then the ring sum over `S` of the values `ring_of_num r (f s)` for elements `s` in `S` is equal to `ring_of_num r` applied to the natural number sum of `f s` over `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, both `ring_sum r S (\s. ring_of_num r (f s))` and `nsum S f` are zero, and `ring_of_num r 0 = 0`.
- Inductive step: Assume that the theorem holds for all finite subsets of `S`. Pick an element `x` in `S`.
  Then `ring_sum r S (\s. ring_of_num r (f s))` can be written as `ring_sum r (S insert x) (\s. ring_of_num r (f s))`, which expands to `ring_of_num r (f x) + ring_sum r S (\s. ring_of_num r (f s))` using the `RING_SUM_CLAUSES`. By the induction hypothesis, `ring_sum r S (\s. ring_of_num r (f s)) = ring_of_num r (nsum S f)`.  Then using `RING_OF_NUM_ADD` and `NSUM_CLAUSES`, `nsum (S insert x) f = f x + nsum S f` and `ring_of_num r (f x) + ring_of_num r (nsum S f) = ring_of_num r (f x + nsum S f) = ring_of_num r (nsum (S insert x) f)`.

### Mathematical insight
This theorem connects the ring summation and numerical summation. It states that summing the ring embedding of the numerical values of `f` over a set `S` is equivalent to embedding the numerical summation of `f` over the same `S` into the ring. The theorem is important because it permits reasoning about numerical functions within a ring structure when the results of these functions are embedded into the ring being summed over.

### Dependencies
- Definitions: `ring_sum`, `ring_of_num`, `nsum`
- Theorems: `RING_SUM_CLAUSES`, `NSUM_CLAUSES`, `RING_OF_NUM_ADD`
- Tactics: `FINITE_INDUCT_STRONG`

### Porting notes (optional)
The proof relies on induction over finite sets. In systems that lack a direct notion of finiteness, it may be necessary to use an alternative characterization, for example, injectivity of a mapping into an initial segment of the natural numbers. The `FINITE_INDUCT_STRONG` tactic represents a relatively standard induction principle, so should be available in most proof assistants either directly or through a library.


---

## ring_pow_sub1

### Name of formal statement
ring_pow_sub1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_sub1 = prove(`
  !(r:R ring) c d.
  c IN ring_carrier r ==>
  ~(d = 0) ==>
  ring_mul r c (ring_pow r c (d-1)) = ring_pow r c d
`,
  intro THEN
  have `ring_pow(r:R ring) c (1 + (d-1)) = ring_mul r (ring_pow r c 1) (ring_pow r c (d-1))` [RING_POW_ADD] THEN
  have `ring_pow(r:R ring) c 1 = c` [RING_POW_1] THEN
  num_linear_fact `~(d = 0) ==> 1 + (d-1) = d:num` THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and elements `c` and `d`, if `c` is an element of the carrier of the ring `r`, and `d` is not equal to 0, then `c * (c ^ (d-1)) = c ^ d`, where `*` and `^` are the ring multiplication and exponentiation operations in `r`, respectively.

### Informal sketch
The proof proceeds by induction and rewriting.

- First, we introduce the assumptions. `ring_pow(r:R ring) c (1 + (d-1)) = ring_mul r (ring_pow r c 1) (ring_pow r c (d-1))` is obtained by rewriting `RING_POW_ADD`.
- The subterm `ring_pow r c 1` is rewritten to `c` using `RING_POW_1`.
- Simplify arithmetic `~(d = 0) ==> 1 + (d-1) = d`.
- Finally, the goal follows by simplification.

### Mathematical insight
This theorem states a fundamental algebraic property of ring exponentiation: `c` raised to the power of `d` is equal to `c` times `c` raised to the power of `d-1`, provided that `d` is not zero. This is a basic property used in many algebraic manipulations. This theorem helps to establish the properties of ring exponentiation, allowing for reasoning about polynomials.

### Dependencies
- Theorems:
  - `RING_POW_ADD`
  - `RING_POW_1`


---

## ring_pow_product

### Name of formal statement
ring_pow_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_product = prove(`
  !(r:R ring) (p:X->R) n S.
  FINITE S ==>
  (!s. s IN S ==> p s IN ring_carrier r) ==>
  ring_pow r (ring_product r S p) n
  = ring_product r S (\s:X. ring_pow r (p s) n)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES] THEN
    rw[RING_POW_ONE]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    simp[RING_PRODUCT_CLAUSES;RING_POW] THEN
    have `p(x:X) IN ring_carrier(r:R ring)` [] THEN
    simp[RING_MUL_POW;RING_PRODUCT]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, a function `p` from `X` to `R`, a natural number `n`, and a set `S` of type `X`, if `S` is finite and for all `s` in `S`, `p s` is in the carrier of `r`, then the `n`-th power in `r` of the product in `r` over `S` of `p` is equal to the product in `r` over `S` of the `n`-th power in `r` of `p s`.

### Informal sketch
The theorem is proved by strong induction on the finiteness of `S`.
- Base case: When `S` is empty, the product over `S` is `ring_one r`, and `ring_pow r (ring_one r) n = ring_one r`. The product over the empty set of ring powers is also `ring_one r`.
- Inductive step: Assume the theorem holds for all subsets of `x INSERT S`. We want to show that it holds for `x INSERT S`.
We know that `ring_product r (x INSERT S) p = ring_mul r (p x) (ring_product r S p)`.
We then consider `ring_pow r (ring_product r (x INSERT S) p) n = ring_pow r (ring_mul r (p x) (ring_product r S p)) n`.

Using the inductive hypothesis, `ring_pow r (ring_product r S p) n = ring_product r S (\s. ring_pow r (p s) n)`. Therefore, `ring_pow r (ring_mul r (p x) (ring_product r S p)) n` becomes `ring_mul r (ring_pow r (p x) n) (ring_product r S (\s. ring_pow r (p s) n))`, which is exactly `ring_product r (x INSERT S) (\s. ring_pow r (p s) n)`.

### Mathematical insight
This theorem states that exponentiation distributes over products in rings, provided that the set over which the product is taken is finite. This is a fundamental property used extensively when working with powers of products within ring structures.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `RING_POW_ONE`
- `RING_MUL_POW`
- `RING_PRODUCT`
- `RING_POW`

### Porting notes (optional)
This theorem relies on a correct definition of `ring_pow` and `ring_product`. One must ensure that `ring_product` handles the empty set case correctly, typically by defining the product over the empty set as the ring's multiplicative identity `ring_one`. The main difficulty in porting this theorem might arise from differences in how finiteness is handled or required in different proof assistants. In systems with dependent types, it might be necessary to explicitly pass a proof of `FINITE S` to the product function.


---

## ring_sum_numseg_0_diff

### Name of formal statement
ring_sum_numseg_0_diff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_numseg_0_diff = prove(`
  !(r:R ring) m n f.
  m <= n ==>
  ring_sum r {i | m < i /\ i <= n} f
  = ring_sub r
      (ring_sum r (0..n) f)
      (ring_sum r (0..m) f)
`,
  intro THEN
  subgoal `{i | m < i /\ i <= n} = (0..n) DIFF (0..m)` THENL [
    rw[EXTENSION;IN_DIFF;IN_ELIM_THM;IN_NUMSEG] THEN
    ARITH_TAC
  ; pass
  ] THEN
  have `FINITE (0..n)` [FINITE_NUMSEG] THEN
  have `(0..m) SUBSET (0..n)` [SUBSET_NUMSEG;ARITH_RULE `0 <= 0`] THEN
  qed[RING_SUM_DIFF]
);;
```
### Informal statement
For any ring `r`, and any integers `m` and `n`, and any function `f` from integers to the ring `r`, if `m` is less than or equal to `n`, then the ring sum over `r` of `f` for all `i` such that `m` is less than `i` and `i` is less than or equal to `n` is equal to the ring subtraction over `r` of the ring sum over `r` of `f` from `0` to `n` and the ring sum over `r` of `f` from `0` to `m`.

### Informal sketch
The proof proceeds by:
- First, by proving that `{i | m < i /\ i <= n}` is equal to `(0..n) DIFF (0..m)` using the definitions of `EXTENSION`, `IN_DIFF`, `IN_ELIM_THM`, and `IN_NUMSEG` and arithmetic reasoning.
- Then, show that `(0..n)` is finite using `FINITE_NUMSEG`.
- Next, show that `(0..m)` is a subset of `(0..n)` using `SUBSET_NUMSEG` and arithmetic reasoning.
- Finally, apply `RING_SUM_DIFF` to conclude the result.

### Mathematical insight
This theorem decomposes a sum over a numerical segment into the difference of two sums from zero, which might be helpful for deriving recursive formulas or simplifying expressions involving summations.

### Dependencies
- Theorems:
  - `EXTENSION`
  - `IN_DIFF`
  - `IN_ELIM_THM`
  - `IN_NUMSEG`
  - `FINITE_NUMSEG`
  - `SUBSET_NUMSEG`
  - `RING_SUM_DIFF`

### Porting notes (optional)
The main challenge might be related to automation; a similar effect of the tactic `ARITH_TAC` must be achieved. Also, make sure that `RING_SUM_DIFF` and auxilliary theorems have been already ported since it is a dependency.


---

## ring_sum_numseg_0_diff_reflect

### Name of formal statement
ring_sum_numseg_0_diff_reflect

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_numseg_0_diff_reflect = prove(`
  !(r:R ring) m n f.
  m <= n ==>
  ring_sum r {i | i < n-m} (\i. f(n-i))
  = ring_sub r
      (ring_sum r (0..n) f)
      (ring_sum r (0..m) f)
`,
  simp[GSYM ring_sum_numseg_0_diff] THEN
  intro THEN
  subgoal `!x y. x IN {i:num | i < n - m} ==> y IN {i | i < n - m} ==> n - x = n - y ==> x = y` THENL [
    rw[IN_ELIM_THM] THEN
    ARITH_TAC
  ; pass
  ] THEN
  specialize[`r:R ring`;`\i:num. n-i`;`f:num->R`;`{i | i < n - m:num}`]RING_SUM_IMAGE THEN
  have `IMAGE (\i:num. n - i) {i | i < n - m} = {i | m < i /\ i <= n}` [numseg_le_lt_reflect] THEN
  have `ring_sum(r:R ring) {i:num | m < i /\ i <= n} f = ring_sum r {i | i < n - m} (f o (\i. n - i))` [] THEN
  have `ring_sum(r:R ring) {i:num | i < n - m} (f o (\i. n - i)) = ring_sum r {i | i < n - m} (\i. f (n - i))` [RING_SUM_EQ;o_THM] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and any natural numbers `m` and `n`, and any function `f` from natural numbers to the ring `r`, if `m` is less than or equal to `n`, then the ring sum over `r` of `f(n-i)` where `i` ranges over the set of natural numbers less than `n-m` is equal to the ring subtraction over `r` of the ring sum over `r` of `f(i)` where `i` ranges from 0 to `n` from the ring sum over `r` of `f(i)` where `i` ranges from 0 to `m`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `ring_sum_numseg_0_diff`, but with arguments flipped using `GSYM`.
- Introduce the variables `r`, `m`, `n`, and `f`.
- Show that the function `\i. n - i` is injective within the set `{i | i < n - m}` which is required by `RING_SUM_IMAGE`. Arithmetics and set reasoning are automated by `ARITH_TAC`.
- Apply `RING_SUM_IMAGE`: specialize it with `r`, `\i. n-i`, `f`, and `{i | i < n - m}`.
- Prove that the image of `{i | i < n - m}` under the function `\i. n - i` is `{i | m < i /\ i <= n}` using theorem `numseg_le_lt_reflect`.
- Then show that `ring_sum(r:R ring) {i:num | m < i /\ i <= n} f = ring_sum r {i | i < n - m} (f o (\i. n - i))`.
- Rewrite using `RING_SUM_EQ` and `o_THM` to convert `ring_sum r {i | i < n - m} (f o (\i. n - i))` into `ring_sum r {i | i < n - m} (\i. f (n - i))`.
- Conclude the proof.

### Mathematical insight
The theorem expresses a relationship between a sum over a segment of the form `{i | i < n - m}` with a reversed index `f(n-i)` and the difference between two sums over segments from 0 to `n` and 0 to `m` respectively. Intuitively, it separates the initial segment of length `m+1` from the range `0..n` and reflects the upper portion `{m+1, m+2, ..., n}` of the range around `n`.

### Dependencies
- `ring_sum_numseg_0_diff`
- `RING_SUM_IMAGE`
- `RING_SUM_EQ`
- `numseg_le_lt_reflect`
- `o_THM`
- `GSYM`
- `IN_ELIM_THM`


---

## ring_pow_is_product

### Name of formal statement
ring_pow_is_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_is_product = prove(`
  !(r:R ring) a n.
  a IN ring_carrier r ==>
  ring_pow r a n
  = ring_product r (1..n) (\i. a)
`,
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[NUMSEG_CLAUSES;ARITH_RULE `~(1 = 0)`] THEN
    rw[ring_pow;RING_PRODUCT_CLAUSES]
  ;
    rw[NUMSEG_CLAUSES;ARITH_RULE `1 <= SUC n`] THEN
    have `FINITE (1..n)` [FINITE_NUMSEG] THEN
    have `~(SUC n IN 1..n)` [IN_NUMSEG;ARITH_RULE `~(SUC n <= n)`] THEN
    simp[ring_pow;RING_PRODUCT_CLAUSES]
  ]
);;
```
### Informal statement
For any ring `r` and any element `a` in the carrier of the ring `r`, and any natural number `n`, the ring power `a` to the `n` in `r` is equal to the ring product from 1 to `n` of the function that always returns `a`.

### Informal sketch
The proof is by induction on `n`.
- Base case: when `n = 0`, show that both sides are equal (to the ring identity) using the definitions of `ring_pow` and `ring_product`.
- Inductive step: assume the statement holds for `n`, and prove it for `SUC n`.
  - The inductive step rewrites `ring_pow r a (SUC n)` as `ring_mult r a (ring_pow r a n)`.
  - It also rewrites `ring_product r (1..SUC n) (\i. a)` as `ring_mult r a (ring_product r (1..n) (\i. a))`, because the set `1..SUC n` can be decomposed into `(1..n) UNION {SUC n}` and the function `(\i. a)` evaluated at `SUC n` is `a`.
  - By the inductive hypothesis, `ring_pow r a n = ring_product r (1..n) (\i. a)`. Substitute this equivalence into the expression to conclude the proof.

### Mathematical insight
This theorem establishes the fundamental connection between exponentiation (repeated multiplication) and the product notation in the context of rings. It expresses the idea that raising an element to a power `n` is equivalent to multiplying that element by itself `n` times.

### Dependencies
- `ring_pow`
- `ring_product`
- `NUMSEG_CLAUSES`
- `ARITH_RULE`
- `IN_NUMSEG`
- `FINITE_NUMSEG`
- `RING_PRODUCT_CLAUSES`


---

## ring_sum_sub

### Name of formal statement
ring_sum_sub

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_sub = prove(`
  !(r:R ring) f g S.
  FINITE S ==>
  (!s:X. s IN S ==> f s IN ring_carrier r) ==>
  (!s:X. s IN S ==> g s IN ring_carrier r) ==>
  ring_sum r S (\s. ring_sub r (f s) (g s))
  = ring_sub r (ring_sum r S f) (ring_sum r S g)
`,
  intro THEN
  rw[ring_sub] THEN
  specialize_assuming[`r:R ring`;`f:X->R`;`(\s:X. ring_neg(r:R ring) (g s))`;`S:X->bool`]RING_SUM_ADD THEN
  have `ring_sum(r:R ring) S (\s:X. ring_add r (f s) (ring_neg r (g s))) = ring_add r (ring_sum r S f) (ring_sum r S (\s. ring_neg r (g s)))` [RING_NEG] THEN
  simp[] THEN
  qed[RING_SUM_NEG]
);;
```
### Informal statement
Given a ring `r` and functions `f` and `g` from a type `X` to the carrier of `r`, and a finite set `S` of type `X`, if for all `s` in `S`, `f s` is in the ring carrier of `r`, and for all `s` in `S`, `g s` is in the ring carrier of `r`, then the ring sum over `S` of `ring_sub r (f s) (g s)` is equal to `ring_sub r (ring_sum r S f) (ring_sum r S g)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Rewrite `ring_sub` using its definition. The definition of `ring_sub r a b` is `ring_add r a (ring_neg r b)`.
- Specialize the theorem `RING_SUM_ADD` to the ring `r`, the functions `f` and `\s. ring_neg r (g s)`, and the set `S`.
- Apply `RING_NEG` to rewrite `ring_sum r S (\s. ring_neg r (g s))` into `ring_neg r (ring_sum r S g)`.
- Simplify the result.

### Mathematical insight
This theorem states that the ring sum of `f(s) - g(s)` over a finite set `S` is equal to the difference of the ring sums of `f(s)` and `g(s)` over `S`, where the subtraction is defined within the ring `r`. This is a distributive property of ring sums with respect to subtraction.

### Dependencies
- `ring_sub`
- `RING_SUM_ADD`
- `RING_NEG`


---

## unique_prime_valuation_lemma

### Name of formal statement
unique_prime_valuation_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let unique_prime_valuation_lemma = prove(`
  !(r:R ring) p d e f g.
  integral_domain r ==>
  ring_prime r p ==>
  f IN ring_carrier r ==>
  g IN ring_carrier r ==>
  ~(ring_divides r p g) ==>
  ring_mul r (ring_pow r p d) f
  = ring_mul r (ring_pow r p e) g ==>
  d <= e
`,
  intro THEN
  have `p IN ring_carrier(r:R ring)` [ring_prime] THEN
  have `~(p = ring_0(r:R ring))` [ring_prime] THEN
  have `~(ring_pow r p e = ring_0(r:R ring))` [INTEGRAL_DOMAIN_POW_EQ_0] THEN
  case `~(d <= e:num)` THENL [
    num_linear_fact `~(d <= e) ==> e < d:num` THEN
    num_linear_fact `e < d:num ==> d = e + (d-e)` THEN
    have `ring_pow(r:R ring) p d = ring_mul r (ring_pow r p e) (ring_pow r p (d-e))` [RING_POW_ADD] THEN
    have `ring_mul(r:R ring) (ring_mul r (ring_pow r p e) (ring_pow r p (d-e))) f = ring_mul r (ring_pow r p e) g` [] THEN
    have `ring_mul(r:R ring) (ring_pow r p e) (ring_mul r (ring_pow r p (d-e)) f) = ring_mul r (ring_pow r p e) g` [RING_MUL_ASSOC;RING_POW] THEN
    have `(ring_mul(r:R ring) (ring_pow r p (d-e)) f) = g` [INTEGRAL_DOMAIN_MUL_LCANCEL;RING_POW;RING_MUL] THEN
    num_linear_fact `e < d:num ==> d-e = 1 + (d-e-1)` THEN
    have `ring_pow(r:R ring) p (d-e) = ring_mul r (ring_pow r p 1) (ring_pow r p (d-e-1))` [RING_POW_ADD] THEN
    have `ring_pow(r:R ring) p (d-e) = ring_mul r p (ring_pow r p (d-e-1))` [RING_POW_1] THEN
    have `(ring_mul(r:R ring) (ring_mul r p (ring_pow r p (d-e-1))) f) = g` [] THEN
    have `ring_mul(r:R ring) p (ring_mul r (ring_pow r p (d-e-1)) f) = g` [RING_MUL_ASSOC;RING_POW] THEN
    qed[ring_divides;RING_POW;RING_MUL]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
Let `r` be a ring. Let `p`, `d`, `e`, `f`, and `g` be variables. Suppose that `r` is an integral domain and that `p` is a prime element in `r`. Suppose that `f` is an element of the carrier of `r` and `g` is an element of the carrier of `r`. Suppose that `p` does not divide `g` in `r`. Suppose that `p^d * f = p^e * g` in `r`. Then `d <= e`.

### Informal sketch
The proof proceeds by contradiction.
- Assume that `d > e`, i.e., `~(d <= e)`.
- Then `d = e + (d - e)`. Thus `p^d = p^(e + (d - e)) = p^e * p^(d - e)`.
- Substituting, we get `(p^e * p^(d - e)) * f = p^e * g`, which implies `p^e * (p^(d - e) * f) = p^e * g`.
- Since `r` is an integral domain and `p^e` is not zero, we can cancel `p^e` from both sides, resulting in `p^(d - e) * f = g`.
- Since `d > e`, `d - e >= 1`, we have `d - e = 1 + (d - e - 1)`. Thus `p^(d - e) = p^(1 + (d - e - 1)) = p * p^(d - e - 1)`.
- Substituting, we get `(p * p^(d - e - 1)) * f = p * (p^(d - e - 1) * f) = g`.
- Hence, `p` divides `g` in `r`, which contradicts the initial assumption that `p` does not divide `g`.
- Therefore, the initial assumption `d > e` must be false, so `d <= e`.

### Mathematical insight
This theorem states that given an integral domain `r` and a prime element `p` in `r`, if `p^d * f = p^e * g` and `p` does not divide `g`, then `d` must be less than or equal to `e`. This uniqueness property is fundamental in understanding divisibility in integral domains and is closely related to the concept of prime factorization.

### Dependencies
- `integral_domain`
- `ring_prime`
- `ring_divides`
- `ring_carrier`
- `ring_mul`
- `ring_pow`
- `RING_POW_ADD`
- `INTEGRAL_DOMAIN_MUL_LCANCEL`
- `RING_POW_1`
- `INTEGRAL_DOMAIN_POW_EQ_0`

### Porting notes (optional)
- In proof assistants like Coq or Lean, the `ring` tactic or similar automation might simplify handling the ring axioms.
- The `num_linear_fact` tactic is specific to HOL Light. In other proof assistants, one would need to use appropriate tactics or libraries for reasoning about inequalities and arithmetic on natural numbers.
- The `have` tactic is mostly to introduce intermediate steps. These steps can be inlined in proof assistants that do not require this kind of explicit step management, or the assertions can be translated into `assert` statements or intermediate lemmas if the target formal system encourages that style.


---

## unique_prime_valuation

### Name of formal statement
unique_prime_valuation

### Type of the formal statement
theorem

### Formal Content
```ocaml
let unique_prime_valuation = prove(`
  !(r:R ring) p d e f g.
  integral_domain r ==>
  ring_prime r p ==>
  f IN ring_carrier r ==>
  g IN ring_carrier r ==>
  ~(ring_divides r p f) ==>
  ~(ring_divides r p g) ==>
  ring_mul r (ring_pow r p d) f
  = ring_mul r (ring_pow r p e) g ==>
  (d = e /\ f = g)
`,
  intro THEN
  have `d <= e:num` [unique_prime_valuation_lemma] THEN
  have `e <= d:num` [unique_prime_valuation_lemma] THEN
  num_linear_fact `d <= e:num ==> e <= d ==> d = e` THENL [
    qed[]
  ;
    have `p IN ring_carrier(r:R ring)` [ring_prime] THEN
    have `~(p = ring_0(r:R ring))` [ring_prime] THEN
    have `~(ring_pow r p e = ring_0(r:R ring))` [INTEGRAL_DOMAIN_POW_EQ_0] THEN
    qed[INTEGRAL_DOMAIN_MUL_LCANCEL;RING_POW]
  ]
);;
```
### Informal statement
For any ring `r` that is an integral domain, and any `p`, `d`, `e`, `f`, and `g` such that `p` is a prime element in `r`, `f` and `g` are elements of `r`, `p` does not divide `f` and `p` does not divide `g`. If `ring_mul r (ring_pow r p d) f = ring_mul r (ring_pow r p e) g`, then `d = e` and `f = g`.

### Informal sketch
*   The proof starts by introducing the assumptions of the theorem using `intro`.

*   It aims to show that `d <= e` and `e <= d`. This is achieved through the lemma `unique_prime_valuation_lemma`.

*   Applying linear arithmetic (`num_linear_fact`) to the results `d <= e` and `e <= d` allows us to conclude that `d = e`.

*   Furthermore, using the assumption that `p` is a prime element in the ring `r`, we deduce that `p` is not equal to the zero element (`ring_0(r:R ring)`).

*   Then, through `INTEGRAL_DOMAIN_POW_EQ_0`, the proof establishes that `ring_pow r p e` is not equal to the zero element of the ring.

*   Finally, based on `INTEGRAL_DOMAIN_MUL_LCANCEL` and `RING_POW`, it concludes that `f=g`.

### Mathematical insight
The theorem asserts that if we have an equation in an integral domain `r` where two elements `f` and `g` are multiplied by powers of a prime element `p`, then the powers must be equal and the original elements `f` and `g` must also be equal. This establishes a form of unique factorization related to prime elements in integral domains. The theorem is important because it formalizes the idea that prime factorization is, in a certain sense, unique.

### Dependencies
*   `integral_domain`
*   `ring_prime`
*   `ring_carrier`
*   `ring_divides`
*   `ring_pow`
*   `ring_mul`
*   `ring_0`
*   `INTEGRAL_DOMAIN_POW_EQ_0`
*   `INTEGRAL_DOMAIN_MUL_LCANCEL`
*   `RING_POW`
*   `unique_prime_valuation_lemma`

### Porting notes (optional)
The proof relies heavily on the properties of integral domains and prime elements within the ring structure. Ensure the target proof assistant has equivalent definitions and theorems related to rings, integral domains, prime elements, and divisibility. The tactic `num_linear_fact` relies on linear arithmetic over natural numbers; so, an equivalent tactic may be needed. Also, `unique_prime_valuation_lemma` is used without its explicit definition being shown, requiring us to find the lemma or re-prove it; this needs to be investigated while porting.


---

## ring_sum_const

### Name of formal statement
ring_sum_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_const = prove(`
  !(r:R ring) c S.
  FINITE S ==>
  c IN ring_carrier r ==>
  ring_sum r S (\s:X. c)
  = ring_mul r (ring_of_num r (CARD S)) c
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;CARD_CLAUSES;RING_OF_NUM_0] THEN
    qed[RING_MUL_LZERO]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    simp[RING_SUM_CLAUSES;CARD_CLAUSES;ring_of_num] THEN
    RING_TAC
  ]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), any element `c` that belongs to the carrier of the ring `r`, and any finite set `S`, the ring sum of the constant function that always returns `c` over the set `S` is equal to the ring multiplication of `c` by the ring representation of the cardinality of `S`.
Formally:
∀ `r:R ring`. ∀ `c`. ∀ `S`. (`FINITE S` ∧ `c IN ring_carrier r`) → `ring_sum r S (\s:X. c) = ring_mul r (ring_of_num r (CARD S)) c`

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then the ring sum is zero, and the cardinality of `S` is zero. Thus we want to prove `ring_sum r EMPTY (\s:X. c) = ring_mul r (ring_of_num r 0) c`. `ring_sum r EMPTY (\s:X. c)` reduces to `ring_zero r` and `ring_of_num r 0` reduces to `ring_zero r`, thus the right hand side becomes `ring_mul r (ring_zero r) c`, which reduces to `ring_zero r`. We conclude by `RING_MUL_LZERO`.
- Inductive step: Assume that the theorem holds for all sets `S'` such that `CARD S' < CARD S`. We take an element `x` from `S` such that `S` is `x INSERT S'`, where `S'` is the complement of `{x}` in `S`. Assuming that `S` is finite, `S'` is also finite. The cardinality of `S` is `CARD S' + 1`. The ring sum over `S` reduces to `ring_add r c (ring_sum r S' (\s.c))` which by the induction hypothesis is `ring_add r c (ring_mul r (ring_of_num r (CARD S')) c)`. The right hand side reduces to `ring_mul r (ring_of_num r (CARD S)) c`, thus `ring_mul r (ring_of_num r (CARD S' + 1)) c`, which reduces to `ring_mul r (ring_add r (ring_of_num r (CARD S')) (ring_of_num r 1)) c `. Now we need to show that `ring_add r c (ring_mul r (ring_of_num r (CARD S')) c)` is equal to `ring_mul r (ring_add r (ring_of_num r (CARD S')) (ring_of_num r 1)) c `. The proof succeeds by ring tactics.

### Mathematical insight
This theorem states that the sum of a constant value `c` over a finite set `S` within a ring `r` is equivalent to multiplying `c` by the cardinality of `S` represented in the ring. This is a generalization of the familiar arithmetic fact that repeated addition is equivalent to multiplication.

### Dependencies
- `RING_SUM_CLAUSES`
- `CARD_CLAUSES`
- `RING_OF_NUM_0`
- `RING_MUL_LZERO`
- `ring_sum`
- `ring_mul`
- `ring_of_num`
- `CARD`
- `FINITE`
- `INSERT`
- `ring_add`
- `ring_zero`
- `IN`
- `ring_carrier`


---

## ring_product_const

### Name of formal statement
ring_product_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) c S.
  FINITE S ==>
  c IN ring_carrier r ==>
  ring_product r S (\s:X. c) = ring_pow r c (CARD S)
```

### Informal statement
For any ring `r`, any set `S`, and any element `c`, if `S` is finite and `c` is an element of the carrier of the ring `r`, then the ring product with respect to `r` over `S` of the constant function that always returns `c` is equal to `c` raised to the power of the cardinality of `S` with respect to the ring `r`.

### Informal sketch
*   The proof proceeds by strong induction on the finiteness of `S`.
*   **Base Case:** The base case is when `S` is empty. In this case, the ring product over the empty set is the multiplicative identity (by definition of `RING_PRODUCT_CLAUSES`), the cardinality of the empty set is 0 (by definition of `CARD_CLAUSES`), and `c` raised to the power 0 is also the multiplicative identity (by definition of `RING_POW_0`).
*   **Inductive Step:** Assume that for any set `S`, if `S` is finite, then the theorem holds. Consider `x INSERT S`.  Assume `FINITE(x INSERT S)`. We aim to show that `ring_product r (x INSERT S) (\s. c) = ring_pow r c (CARD (x INSERT S))`.
    *   By the definitions of `RING_PRODUCT_CLAUSES` and `CARD_CLAUSES`, we have `ring_product r (x INSERT S) (\s. c) = ring_op r c (ring_product r S (\s. c))` and `CARD (x INSERT S) = SUC (CARD S)`.
    *   By the induction hypothesis, `ring_product r S (\s:X. c) = ring_pow r c (CARD S)`. Thus, the left-hand side becomes `ring_op r c (ring_pow r c (CARD S))`.
    *   By the definition of `ring_pow`, `ring_pow r c (SUC (CARD S)) = ring_op r (ring_pow r c (CARD S)) c`.
    *   Therefore, `ring_op r c (ring_pow r c (CARD S)) = ring_pow r c (SUC (CARD S))`.

### Mathematical insight
The theorem states that if we repeatedly apply the ring's multiplicative operation to a constant value `c` over a finite set `S`, it's equivalent to raising `c` to the power of the number of elements in `S` inside the ring. This is a fundamental property that connects repeated multiplication to exponentiation in the context of rings.

### Dependencies
*   `RING_PRODUCT_CLAUSES`
*   `CARD_CLAUSES`
*   `RING_POW_0`
*   `ring_pow`

### Porting notes (optional)
*   The most significant challenge in porting this theorem is handling the finiteness condition (`FINITE S`) and the associated induction. Different proof assistants have varying levels of automation for finiteness proofs.
*   Ensure the definition of `ring_product` aligns with the HOL Light definition (typically, use the multiplicative identity when the set is empty). The definition of `ring_pow` should similarly align (exponentiation by zero yields the multiplicative identity).


---

## ring_of_num_injective_lemma

### Name of formal statement
ring_of_num_injective_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_injective_lemma = prove(`
  !(r:R ring) m n.
  ring_char r = 0 ==>
  ring_of_num r m = ring_of_num r n ==>
  n <= m
`,
  intro THEN
  case `m < n:num` THENL [
    num_linear_fact `m < n:num ==> n = (n-m)+m` THEN
    have `ring_of_num(r:R ring) n = ring_add r (ring_of_num r (n-m)) (ring_of_num r m)` [RING_OF_NUM_ADD] THEN
    have `ring_of_num(r:R ring) m = ring_add r (ring_of_num r (n-m)) (ring_of_num r m)` [] THEN
    have `ring_of_num r (n-m) = ring_0(r:R ring)` [RING_ADD_EQ_RIGHT;RING_OF_NUM] THEN
    have `n-m = 0` [RING_CHAR_EQ_0] THEN
    qed[ARITH_RULE `m < n ==> ~(n-m = 0)`]
  ;
    ASM_ARITH_TAC
  ]
);;
```
### Informal statement
For any ring `r` with characteristic 0, and any natural numbers `m` and `n`, if `ring_of_num r m` is equal to `ring_of_num r n`, then `n` is less than or equal to `m`.

### Informal sketch
The proof proceeds by contradiction. 
- Assume `m < n`.
- Write `n` as `(n-m) + m`.
- Then `ring_of_num r n` equals `ring_add r (ring_of_num r (n-m)) (ring_of_num r m)` by `RING_OF_NUM_ADD`.
- Since `ring_of_num r m = ring_of_num r n` it follows that `ring_of_num r (n-m) = ring_0 r`.
- Since the ring characteristic is 0 we can derive that `n-m = 0` using `RING_CHAR_EQ_0`.
- This gives a contradiction because `m < n` implies `~(n-m = 0)`.
- The case when `m < n` is false.
- Therefore `n <= m` by arithmetic.

### Mathematical insight
This theorem states that if a ring has characteristic zero, then the mapping from natural numbers into the ring (via `ring_of_num`) is injective when restricted to the direction where the second argument is smaller than the first. This is a fundamental property that links the natural numbers and their representation in rings of characteristic zero.

### Dependencies
- Theorems: `RING_OF_NUM_ADD`, `RING_ADD_EQ_RIGHT`, `RING_OF_NUM`, `RING_CHAR_EQ_0`
- Rules: `ARITH_RULE`


---

## ring_of_num_injective

### Name of formal statement
ring_of_num_injective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_injective = prove(`
  !(r:R ring) m n.
  ring_char r = 0 ==>
  ring_of_num r m = ring_of_num r n ==>
  m = n
`,
  intro THEN
  have `n <= m:num` [ring_of_num_injective_lemma] THEN
  have `m <= n:num` [ring_of_num_injective_lemma] THEN
  ASM_ARITH_TAC
);;
```
### Informal statement
For any ring `r` with characteristic 0, and any natural numbers `m` and `n`, if `ring_of_num r m` equals `ring_of_num r n`, then `m` equals `n`.

### Informal sketch
The proof proceeds as follows:
- Assume `ring_char r = 0` and `ring_of_num r m = ring_of_num r n`.
- Show that `n <= m` using the lemma `ring_of_num_injective_lemma`.
- Show that `m <= n` using the lemma `ring_of_num_injective_lemma`.
- Apply arithmetic tactics (`ASM_ARITH_TAC`) to conclude that `m = n`.

### Mathematical insight
This theorem states that in a ring with characteristic 0, the mapping from natural numbers to the ring via `ring_of_num` is injective. In other words, distinct natural numbers are mapped to distinct elements in the ring. This is important because it allows us to reason about natural numbers within the ring structure without losing information. This property fails in rings with non-zero characteristic, such as `Z_p` for a prime `p`.

### Dependencies
- Theorems: `ring_of_num_injective_lemma`


---

## ring_of_num_nonzero

### Name of formal statement
ring_of_num_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_nonzero = prove(`
  !(r:R ring) n.
  ring_char r = 0 ==>
  ring_of_num r n = ring_0 r ==>
  n = 0
`,
  qed[ring_of_num_injective;RING_OF_NUM_0]
);;
```
### Informal statement
For all ring `r` that satisfies the `R ring` predicate, and for all natural numbers `n`: if the characteristic of the ring `r` is 0, and if the ring element obtained by mapping `n` into the ring `r` (using `ring_of_num r n`) is equal to the zero element of the ring `r` (i.e., `ring_0 r`), then `n` must be equal to 0.

### Informal sketch
The proof proceeds as follows:
- Assume the characteristic of the ring `r` is 0, i.e., `ring_char r = 0`, and assume that `ring_of_num r n = ring_0 r`.
- Apply `ring_of_num_injective`, which states that `!r n m. ring_char r = 0 /\ ring_of_num r n = ring_of_num r m ==> n = m`.
- Specialize `ring_of_num_injective` to `n` and `0`: `ring_char r = 0 /\ ring_of_num r n = ring_of_num r 0 ==> n = 0`.
- Note that `ring_of_num r 0` is equal to `ring_0 r` according to `RING_OF_NUM_0` which says `!(r:R ring). ring_of_num r 0 = ring_0 r`.
- Since we assumed `ring_of_num r n = ring_0 r`, we can now rewrite`ring_of_num r n = ring_of_num r 0`.
- Then, using the assumptions `ring_char r = 0` , `ring_of_num r n = ring_0 r` and `RING_OF_NUM_0`, we can deduce `n = 0`.

### Mathematical insight
The theorem states that if a natural number `n` is mapped to the zero element of a ring with characteristic 0, then `n` must be 0. This is because in a ring of characteristic 0, the mapping from natural numbers into the ring is injective. This theorem is a crucial step in establishing the properties of rings with characteristic 0.

### Dependencies
- `ring_of_num_injective`
- `RING_OF_NUM_0`


---

## neg_ring_of_num_nonzero

### Name of formal statement
neg_ring_of_num_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let neg_ring_of_num_nonzero = prove(`
  !(r:R ring) n.
  ring_char r = 0 ==>
  ring_neg r (ring_of_num r n) = ring_0 r ==>
  n = 0
`,
  qed[ring_of_num_nonzero;RING_NEG_EQ_0;RING_OF_NUM]
);;
```
### Informal statement
For any ring `r` and any natural number `n`, if the characteristic of `r` is 0, and if the ring negation of the ring representation of `n` is equal to the ring zero, then `n` is equal to 0.

### Informal sketch
- The goal is to prove that if `-n = 0` in a ring `r` with characteristic 0, then `n` must be 0. That is, prove `!(r:R ring) n. ring_char r = 0 ==> ring_neg r (ring_of_num r n) = ring_0 r ==> n = 0`.
- The proof proceeds by applying the theorem `ring_of_num_nonzero`, followed by `RING_NEG_EQ_0`, and finally `RING_OF_NUM`.
- `ring_of_num_nonzero` likely asserts that if the ring-representation of `n` is not equal to zero in a ring of characteristic 0, then `n` is non-zero.
- `RING_NEG_EQ_0` probably states that `-x = 0` implies  `x = 0`, in a ring.
- `RING_OF_NUM` likely is used to reason about the ring representation of a natural number.

### Mathematical insight
This theorem establishes a basic property of rings with characteristic 0. It essentially states that in such rings, the ring representation of a natural number `n` has a non-trivial negation (i.e., not equal to zero) unless `n` is zero itself. This result is essential for many arguments involving number theory and ring theory. Knowing `ring_char r = 0` ensures we have enough "room" in the ring to distinguish different natural numbers and their negations.

### Dependencies
- `ring_of_num_nonzero`
- `RING_NEG_EQ_0`
- `RING_OF_NUM`


---

## ring_pow_neg_1_mul_refl

### Name of formal statement
ring_pow_neg_1_mul_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_neg_1_mul_refl = prove(`
  !(r:R ring) n.
  ring_mul r (
    ring_pow r (ring_neg r (ring_1 r)) n
  ) (
    ring_pow r (ring_neg r (ring_1 r)) n
  ) = ring_1 r
`,
  intro THEN
  havetac `ring_mul(r:R ring) (ring_neg r (ring_1 r)) (ring_neg r (ring_1 r)) = ring_1 r` RING_TAC THEN
  simp[GSYM RING_MUL_POW;RING_1;RING_NEG] THEN
  qed[RING_POW_ONE]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any natural number `n`, the ring multiplication of `ring_pow r (ring_neg r (ring_1 r)) n` by itself equals `ring_1 r`. In other words: `r^(-1)^n * r^(-1)^n = 1`.

### Informal sketch
The proof proceeds as follows:

- Introduce the ring `r` and the natural number `n`.
- Prove the base case that `ring_mul(r:R ring) (ring_neg r (ring_1 r)) (ring_neg r (ring_1 r)) = ring_1 r` using `RING_TAC`, relying on the properties of `RING_1` and `RING_NEG` to show that `(-1) * (-1) = 1`.
- Simplify the initial goal by rewriting using `RING_MUL_POW`, `RING_1`, and `RING_NEG`.
- Complete the proof using `RING_POW_ONE`, based on `(-1) * (-1) = 1`.

### Mathematical insight
This theorem demonstrates how repeated multiplication of the multiplicative inverse of the ring's identity (`-1`) relates to the ring's identity itself. It's particularly important when considering the properties of rings and their power operations.

### Dependencies
- Definition: `RING_MUL_POW`
- Definition: `RING_1`
- Definition: `RING_NEG`
- Theorem: `RING_POW_ONE`


---

## ring_pow_neg_1_plus1

### Name of formal statement
ring_pow_neg_1_plus1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_neg_1_plus1 = prove(`
  !(r:R ring) n.
  ring_pow r (ring_neg r (ring_1 r)) (n + 1)
  = ring_neg r (ring_pow r (ring_neg r (ring_1 r)) n)
`,
  intro THEN
  simp[RING_POW_ADD;RING_1;RING_NEG] THEN
  RING_TAC
);;
```
### Informal statement
For any ring `r` and any natural number `n`, `r` raised to the power of the ring negation of the ring unit of `r`, and then raised to the power of `n + 1`, is equal to the ring negation of `r` raised to the power of the ring negation of the ring unit of `r`, and then raised to the power of `n`.

### Informal sketch
The proof proceeds by:
- Introducing the universally quantified variables `r` and `n`.
- Applying simplification using the theorem `RING_POW_ADD` to rewrite `(ring_pow r (ring_neg r (ring_1 r)) (n + 1))` as `(ring_pow r (ring_neg r (ring_1 r)) n) * (ring_pow r (ring_neg r (ring_1 r)) 1)`. Simplification also uses the definitions of `RING_1` and `RING_NEG`.
- Applying `RING_TAC` to prove the resulting equation. This tactic likely uses ring axioms and simplification.

### Mathematical insight
The theorem expresses a relationship between exponentiation with negative one (`ring_neg r (ring_1 r)`) and addition in the exponent. It essentially states that raising to the `(n+1)`-th power of `(ring_neg r (ring_1 r))` is the same as raising to the `n`-th power and then negating the result. This reflects the fact that `(ring_neg r (ring_1 r))` behaves like `-1` in the exponent.

### Dependencies
- `RING_POW_ADD`
- `RING_1`
- `RING_NEG`
- `RING_TAC`


---

## ring_sum_cross_mul

### Name of formal statement
ring_sum_cross_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) P Q (f:X->R) (g:Y->R).
  FINITE P ==>
  FINITE Q ==>
  (!x:X. x IN P ==> f x IN ring_carrier r) ==>
  (!y:Y. y IN Q ==> g y IN ring_carrier r) ==>
  ring_sum r (P CROSS Q) (\(x,y). ring_mul r (f x) (g y))
  = ring_mul r (ring_sum r P f) (ring_sum r Q g)
```

### Informal statement
For any ring `r`, and any sets `P` and `Q`, and any functions `f` from `X` to `R` and `g` from `Y` to `R`, if `P` is finite, `Q` is finite, for every `x` in `P`, `f x` is in the carrier of `r`, and for every `y` in `Q`, `g y` is in the carrier of `r`, then the ring sum over the Cartesian product `P CROSS Q` of the function that maps `(x, y)` to the ring product of `f x` and `g y` is equal to the ring product of the ring sum over `P` of `f` and the ring sum over `Q` of `g`.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions of the theorem.
- Simplifying using the properties of `RING_SUM_RMUL` and `RING_SUM`
- Simplifying using the properties of `RING_SUM_LMUL` and `RING_SUM`
- Simplifying using `RING_SUM_SUM_PRODUCT`, `RING_SUM`, and `RING_MUL`
- Rewriting `CROSS` using its definition.

### Mathematical insight
This theorem states that the ring sum of pointwise products over a Cartesian product of index sets is equal to the product of the ring sums over each index set. This is a generalization of the distributive property of multiplication over addition, extended to finite sums within a ring structure. It is useful for manipulating sums over multiple indices or when dealing with product structures.

### Dependencies
- `RING_SUM_RMUL`
- `RING_SUM_LMUL`
- `RING_SUM_SUM_PRODUCT`
- `RING_SUM`
- `RING_MUL`
- `CROSS`
- `FINITE`
- `IN`
- `ring_carrier`


---

## ring_product_1_plus_expand

### Name of formal statement
ring_product_1_plus_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_1_plus_expand = prove(`
  !(r:R ring) c S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_product r S (\s:X. ring_add r (ring_1 r) (c s))
  = ring_sum r {A | A SUBSET S} (\A. ring_product r A c)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;POWERSET_CLAUSES;RING_SUM_SING;RING_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[RING_ADD_RDISTRIB;RING_SUM;RING_MUL_LID;RING_PRODUCT_CLAUSES;RING_ADD;RING_1;POWERSET_CLAUSES] THEN
    have `DISJOINT {A | A SUBSET S} (IMAGE (\A. (x:X) INSERT A) {A | A SUBSET S})` [powerset_insert_disjoint] THEN
    have `FINITE {A:X->bool | A SUBSET S}` [FINITE_POWERSET] THEN
    have `FINITE(IMAGE (\A. x INSERT A) {A:X->bool | A SUBSET S})` [FINITE_IMAGE] THEN
    specialize[
      `r:R ring`;
      `\A. ring_product r A (c:X->R)`;
      `{A:X->bool | A SUBSET S}`;
      `IMAGE (\A. x INSERT A) {A:X->bool | A SUBSET S}`
    ]RING_SUM_UNION THEN
    simp[] THEN
    subgoal `!a b. a IN {A | A SUBSET S} ==> b IN {A | A SUBSET S} ==> (x:X) INSERT a = x INSERT b ==> a = b` THENL [
      rw[IN_ELIM_THM;SUBSET;INSERT;EXTENSION] THEN
      intro THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `r:R ring`;
      `\A. (x:X) INSERT A`;
      `\A. ring_product r A (c:X->R)`;
      `{A:X->bool | A SUBSET S}`
    ]RING_SUM_IMAGE THEN
    subgoal `ring_sum r {A | A SUBSET S} ((\A. ring_product r A c) o (\A. x INSERT A)) = ring_sum r {A | A SUBSET S} (\A. ring_mul r (c(x:X):R) (ring_product r A c))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[IN_ELIM_THM;BETA_THM;o_THM] THEN
      intro THEN
      have `FINITE(a:X->bool)` [FINITE_SUBSET] THEN
      have `~((x:X) IN a)` [SUBSET] THEN
      simp[RING_PRODUCT_CLAUSES]
    ; pass
    ] THEN
    subgoal `ring_sum r {A | A SUBSET S} (\A. ring_mul r (c x) (ring_product r A (c:X->R))) = ring_mul r (c x) (ring_sum r {A | A SUBSET S} (\A. ring_product r A c))` THENL [
      specialize_assuming[
        `r:R ring`;
        `\A. ring_product r A (c:X->R)`;
        `(c:X->R) x`;
        `{A:X->bool | A SUBSET S}`
      ]RING_SUM_LMUL THEN
      qed[RING_PRODUCT]
    ; pass
    ] THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any function `c` of type `X -> R`, and any finite set `S` of type `X -> bool`, if for every `s` in `S`, `c s` is in the carrier of the ring `r`, then the ring product over `S` of the function mapping `s` to the ring sum of the ring one of `r` and `c s` is equal to the ring sum over the powerset of `S` of the function mapping `A` to the ring product over `A` of `c`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty. The goal reduces to showing that the ring product over the empty set of `ring_add r (ring_1 r) (c s)` equals the ring sum over the powerset of the empty set of `ring_product r A c`. The ring product over the empty set is `ring_1 r`, and the powerset of the empty set is the singleton set containing only the empty set, so the ring sum over the powerset is equal to the ring product over the empty set, which is `ring_1 r`.

- Inductive step: Assume the theorem holds for all subsets of `S`. Let `x` be an element of `S`. Rewrite `S` as `x INSERT S'`, where `S'` is `S` without `x`.
Then the left-hand side `ring_product r (x INSERT S') (\s. ring_add r (ring_1 r) (c s))` can be expanded using `RING_ADD_RDISTRIB` and properties of `RING_PRODUCT` to `ring_mul r (ring_add r (ring_1 r) (c x)) (ring_product r S' (\s. ring_add r (ring_1 r) (c s)))`.
By the inductive hypothesis, `ring_product r S' (\s. ring_add r (ring_1 r) (c s))` can be replaced with `ring_sum r {A | A SUBSET S'} (\A. ring_product r A c)`.
The right-hand side `ring_sum r {A | A SUBSET (x INSERT S') } (\A. ring_product r A c)` can be rewritten using the fact that `POWERSET (x INSERT S') = {A | A SUBSET S'} UNION IMAGE (\A. x INSERT A) {A | A SUBSET S'}`. It uses `RING_SUM_UNION` and a lemma showing that `IMAGE (\A. x INSERT A) {A | A SUBSET S'}` and `{A | A SUBSET S'}` are disjoint and finite. Then, `RING_SUM_IMAGE` rewrites `ring_sum r (IMAGE (\A. x INSERT A) {A | A SUBSET S'}) (\A. ring_product r A c)` to `ring_sum r {A | A SUBSET S'} (\A. ring_product r (x INSERT A) c)`. Further simplification using properties of `RING_PRODUCT` gives `ring_sum r {A | A SUBSET S'} (\A. ring_mul r (c x) (ring_product r A c))`. Using `RING_SUM_LMUL` lets us rewrite this as `ring_mul r (c x) (ring_sum r {A | A SUBSET S'} (\A. ring_product r A c))`.
Finally, using `RING_ADD_RDISTRIB` the term becomes `ring_mul r (ring_add r (ring_1 r) (c x)) (ring_sum r {A | A SUBSET S'} (\A. ring_product r A c))`.

### Mathematical insight
This theorem expresses the expansion of a product of sums in a ring. Specifically, it states that the product of `(1 + c(s))` over a finite set `S` (where `c` is a function mapping elements of `S` to the ring) is equal to the sum of all possible products of `c(s)` where `s` ranges over subsets of `S`. This is a generalization of the binomial theorem, where the set `S` represents the indices of the terms in the product.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POWERSET_CLAUSES`
- `RING_SUM_SING`
- `RING_1`
- `RING_ADD_RDISTRIB`
- `RING_SUM`
- `RING_MUL_LID`
- `RING_PRODUCT_CLAUSES`
- `RING_ADD`
- `RING_1`
- `POWERSET_CLAUSES`
- `DISJOINT`
- `IMAGE`
- `FINITE_POWERSET`
- `FINITE_IMAGE`
- `RING_SUM_UNION`
- `IN_ELIM_THM`
- `SUBSET`
- `INSERT`
- `EXTENSION`
- `RING_SUM_IMAGE`
- `BETA_THM`
- `o_THM`
- `FINITE_SUBSET`
- `RING_SUM_EQ`
- `RING_SUM_LMUL`
- `RING_PRODUCT`


---

## ring_product_sum_expand

### Name of formal statement
ring_product_sum_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_sum_expand = prove(`
  !(r:R ring) f Q P.
  FINITE P ==>
  FINITE Q ==>
  (!p q. p IN P ==> q IN Q ==> f p q IN ring_carrier r) ==>
  ring_product r P (\p:X. ring_sum r Q (\q:Y. f p q))
  = ring_sum r
      (functions P Q)
      (\g. ring_product r P (\p. f p (g p)))
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;functions_empty] THEN
    simp[RING_SUM_SING;RING_1]
  ;
    set_fact `(x:X) IN x INSERT P` THEN
    set_fact `!p:X. p IN P ==> p IN x INSERT P` THEN
    simp[functions_insert] THEN
    simp[RING_PRODUCT_CLAUSES;RING_SUM] THEN
    subgoal `ring_sum(r:R ring) (IMAGE (\(b,f) a:X. if a = x then b else f a:Y) (Q CROSS functions P Q)) (\a. if ~(f x (a x) IN ring_carrier r) then ring_product r P (\p. f p (a p)) else ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p)))) = ring_sum r (IMAGE (\(b,f) a. if a = x then b else f a) (Q CROSS functions P Q)) (\a.  ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p))))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM;in_image_vw;EXISTS_PAIR_THM;IN_CROSS;functions;IN_ELIM_THM;SUBSET] THEN
      intro THEN
      have `a(x:X):Y IN Q` [] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `ring_sum(r:R ring) (IMAGE (\(b,f) a:X. if a = x then b else f a:Y) (Q CROSS functions P Q)) (\a. ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p)))) = ring_sum r (Q CROSS functions P Q) ((\a. ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p)))) o (\(b,f) a. if a = x then b else f a))` THENL [
      specialize_assuming[
        `r:R ring`;
        `(\(b,f) a:X. if a = x then b else f a:Y)`;
        `\a:X->Y. ring_mul(r:R ring) (f x (a x)) (ring_product r P (\p. f p (a p)))`;
        `Q CROSS functions (P:X->bool) (Q:Y->bool)`
      ]RING_SUM_IMAGE THEN
      specialize[
        `P:X->bool`;
        `Q:Y->bool`;
        `x:X`
      ]functions_insert_injective THEN
      qed[]
    ; pass
    ] THEN
    simp[o_def_s;lambda_pair_ab] THEN
    simp[GSYM ring_sum_cross_mul;RING_PRODUCT;finite_functions] THEN
    sufficesby RING_SUM_EQ THEN
    rw[FORALL_PAIR_THM;IN_CROSS] THEN
    intro THEN
    subgoal `ring_product(r:R ring) P (\p:X. f p (p2 p:Y)) = ring_product r P (\p. f p (if p = x then p1 else p2 p))` THENL [
      sufficesby RING_PRODUCT_EQ THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and for any sets `P` and `Q`, and any function `f` such that if `p` is in `P` and `q` is in `Q`, then `f p q` is in the carrier of `r`, if `P` is finite and `Q` is finite, then the product of the sums `ring_product r P (\p. ring_sum r Q (\q. f p q))` is equal to the sum over the functions from `P` to `Q` of the products `ring_sum r (functions P Q) (\g. ring_product r P (\p. f p (g p)))`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `P`.

- Base case: `P` is empty. In this case, both sides of the equation reduce to the multiplicative identity of the ring `r`.

- Inductive step: Assume the theorem holds for all sets smaller than `INSERT x P`. We want to prove that the theorem holds for `INSERT x P`. 
  - Rewrite the left-hand side using `RING_PRODUCT_CLAUSES` and `RING_SUM`.
  - The goal is to show that `ring_sum(r:R ring) (IMAGE (\(b,f) a:X. if a = x then b else f a:Y) (Q CROSS functions P Q)) (\a. if ~(f x (a x) IN ring_carrier r) then ring_product r P (\p. f p (a p)) else ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p)))) = ring_sum r (IMAGE (\(b,f) a:X. if a = x then b else f a:Y) (Q CROSS functions P Q)) (\a.  ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p))))`.
    - This is shown by proving `RING_SUM_EQ`, using `in_image_vw;EXISTS_PAIR_THM;IN_CROSS;functions;IN_ELIM_THM;SUBSET`.
  - The next goal is `ring_sum(r:R ring) (IMAGE (\(b,f) a:X. if a = x then b else f a:Y) (Q CROSS functions P Q)) (\a. ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p)))) = ring_sum r (Q CROSS functions P Q) ((\a. ring_mul r (f x (a x)) (ring_product r P (\p. f p (a p)))) o (\(b,f) a. if a = x then b else f a))`.
    - This is shown by using `RING_SUM_IMAGE` and `functions_insert_injective`.
  - Apply simplifications, then prove the remaining goal using `RING_SUM_EQ`.

### Mathematical insight
This theorem describes how a product over a set `P` of sums over a set `Q` can be expanded into a sum over the set of functions from `P` to `Q` of products determined by these functions. This is an important result in ring theory, as it relates sums and products in a non-trivial way. It essentially distributes the product over the sum, leading to a sum over all possible "choices" (functions) of elements from the sets being summed over.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `functions_empty`
- `RING_SUM_SING`
- `RING_1`
- `functions_insert`
- `RING_PRODUCT_CLAUSES`
- `RING_SUM`
- `RING_SUM_EQ`
- `BETA_THM`
- `in_image_vw`
- `EXISTS_PAIR_THM`
- `IN_CROSS`
- `functions`
- `IN_ELIM_THM`
- `SUBSET`
- `RING_SUM_IMAGE`
- `functions_insert_injective`
- `o_def_s`
- `lambda_pair_ab`
- `GSYM ring_sum_cross_mul`
- `RING_PRODUCT`
- `finite_functions`
- `FORALL_PAIR_THM`
- `IN_CROSS`
- `RING_PRODUCT_EQ`

### Porting notes (optional)
- The theorem uses strong induction over finite sets, which may need to be expressed explicitly in other proof assistants.
- The `functions P Q` type might need to be implemented using dependent types or set theory depending on the system.
- Pay attention to how the rewriting rules for sums and products are applied, as the exact tactic names will differ in other provers.


---

## sub_in_subring

### Name of formal statement
sub_in_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let sub_in_subring = prove(`
  !(r:R ring) G a b.
  a IN ring_carrier r ==>
  b IN ring_carrier(subring_generated r G) ==>
  ( ring_sub r a b IN ring_carrier(subring_generated r G) <=>
    a IN ring_carrier(subring_generated r G)
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    have `b:R IN ring_carrier r` [RING_CARRIER_SUBRING_GENERATED_SUBSET;SUBSET] THEN
    specialize[](RING_RULE `a = ring_add(r:R ring) (ring_sub r a b) b`) THEN
    have `ring_add(subring_generated r G) (ring_sub r a b) b IN ring_carrier(subring_generated(r:R ring) G)` [RING_ADD] THEN
    qed[SUBRING_GENERATED]
  ;
    intro THEN
    qed[RING_SUB_SUBRING_GENERATED;RING_SUB]
  ]
);;
```
### Informal statement
For any ring `r` and subset `G` of the carrier of `r`, and for any elements `a` and `b`, if `a` is in the carrier of the ring `r` and `b` is in the carrier of the subring generated by `G` in `r`, then `ring_sub r a b` is in the carrier of the subring generated by `G` in `r` if and only if `a` is in the carrier of the subring generated by `G` in `r`.

### Informal sketch
The proof proceeds by showing both directions of the biconditional statement:

*   **Forward direction:** Assume `ring_sub r a b` is in `ring_carrier(subring_generated r G)`. Also, we know that `b` is in `ring_carrier(subring_generated r G)` by assumption. Using the property that `a = ring_add(r) (ring_sub r a b) b`. Then, we can conclude `a` is in `ring_carrier(subring_generated r G)` using the `RING_ADD` theorem and the fact that `subring_generated r G` is a subring, and therefore closed under ring addition.
*   **Backward direction:** Assume `a` is in `ring_carrier(subring_generated r G)`. We also know that `b` is in `ring_carrier(subring_generated r G)` by assumption. By `RING_SUB_SUBRING_GENERATED` and `RING_SUB`, `ring_sub r a b` is in `ring_carrier(subring_generated r G)`.

### Mathematical insight
This theorem shows that if we have two elements `a` and `b` of a ring `r`, where `b` is in a subring generated by a subset `G`, then `a` is in that subring if and only if `a - b` is in that subring. This highlights the closure of subrings under subtraction, conditional on `b` already belonging to the subring.

### Dependencies
*   `RING_CARRIER_SUBRING_GENERATED_SUBSET`
*   `SUBSET`
*   `RING_ADD`
*   `SUBRING_GENERATED`
*   `RING_SUB_SUBRING_GENERATED`
*   `RING_SUB`
*   `RING_RULE`

### Porting notes (optional)
The main challenge in porting this theorem lies in ensuring that the subring generated by a subset is correctly defined and that its carrier is properly handled. The dependencies listed are fundamental theorems about rings and subrings, which must be present in the target proof assistant. The proof strategy is relatively straightforward, relying on the closure properties of subrings under addition and subtraction.


---

## ring_sum_eq_name_d

### Name of formal statement
ring_sum_eq_name_d

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_eq_name_d = prove(`
  !(r:R ring) f g S:X->bool.
  (!d. d IN S ==> f d = g d) ==>
  ring_sum r S f = ring_sum r S g
`,
  qed[RING_SUM_EQ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any functions `f` and `g` from `X` to boolean values, and any set `S` of elements of type `X`, if for all `d`, `d` is in `S` implies `f d` equals `g d`, then the ring sum of `r` over `S` with function `f` equals the ring sum of `r` over `S` with function `g`.

### Informal sketch
The proof proceeds by showing that if two functions `f` and `g` agree on a set `S`, then their ring sums over `S` are equal.

- The antecedent `!d. d IN S ==> f d = g d` is assumed.
- The theorem `RING_SUM_EQ` is used which shows `ring_sum` is extensional with respect to the function it sums, hence `ring_sum r S f = ring_sum r S g`

### Mathematical insight
This theorem captures the extensionality property of the `ring_sum` with respect to the function being summed:  if we are summing over a set `S`, and two functions agree on `S`, then their sums are equal. This property simplifies reasoning about ring sums in cases where the functions only differ outside the relevant set `S`.

### Dependencies
- Theorems:
  - `RING_SUM_EQ`


---

## ring_product_delete

### Name of formal statement
ring_product_delete

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_delete = prove(`
  !(r:R ring) S t f:X->R.
  FINITE S ==>
  t IN S ==>
  f t IN ring_carrier r ==>
  ring_product r S f = ring_mul r (f t) (ring_product r (S DELETE t) f)
`,
  intro THEN
  set_fact `(t:X) IN S ==> t INSERT (S DELETE t) = S` THEN
  have `FINITE (S DELETE (t:X))` [FINITE_DELETE] THEN
  have `~(t IN (S DELETE (t:X)))` [IN_DELETE] THEN
  qed[RING_PRODUCT_CLAUSES]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `S` of type `X`, any element `t` of type `X`, and any function `f` from `X` to `R ring`, if `S` is finite and `t` is in `S` and `f t` is in the carrier of the ring `r`, then the ring product of `f` over `S` with respect to `r` is equal to the ring multiplication of `f t` with the ring product of `f` over `S` without `t` with respect to `r`.

### Informal sketch
The proof proceeds as follows:
- The theorem is introduced using `intro`.
- Then, the fact `(t:X) IN S ==> t INSERT (S DELETE t) = S` is set.
- The finiteness of `S DELETE (t:X)` is proven using `FINITE_DELETE`.
- It is proven that `~(t IN (S DELETE (t:X)))` using `IN_DELETE`.
- Finally, the proof is completed using `RING_PRODUCT_CLAUSES`. This likely uses the clauses that define the behavior of `ring_product` on finite sets, breaking down the product until the set becomes empty.

### Mathematical insight
This theorem provides a way to decompose the product of a function over a finite set in a ring. It essentially states that if we have a finite set `S` and we want to compute the product of `f(x)` for all `x` in `S`, then we can pick an arbitrary element `t` in `S`, compute `f(t)`, and multiply it by the product of `f(x)` for all `x` in `S` except `t`. This is a fundamental property of products over finite sets and is crucial for inductive proofs involving ring products.

### Dependencies
- `FINITE_DELETE`
- `IN_DELETE`
- `RING_PRODUCT_CLAUSES`


---

## ring_divides_pow_pow

### Name of formal statement
ring_divides_pow_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_divides_pow_pow = prove(`
  !(r:R ring) a e f.
  e <= f ==>
  a IN ring_carrier r ==>
  ring_divides r (ring_pow r a e) (ring_pow r a f)
`,
  intro THEN
  num_linear_fact `e <= f ==> f = e+(f-e):num` THEN
  have `ring_pow r a f:R = ring_mul r (ring_pow r a e) (ring_pow r a (f-e))` [RING_POW_ADD] THEN
  rw[ring_divides] THEN
  qed[RING_POW]
);;
```
### Informal statement
For any ring `r`, any element `a` in the carrier of `r`, and any natural numbers `e` and `f`, if `e` is less than or equal to `f`, then `ring_pow r a e` divides `ring_pow r a f` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Assume `e <= f`.
- Show that `f` can be written as `e + (f - e)`.
- Use the theorem `RING_POW_ADD` to rewrite `ring_pow r a f` as `ring_mul r (ring_pow r a e) (ring_pow r a (f-e))`.
- Use the definition of `ring_divides` to show that `ring_pow r a e` divides `ring_pow r a f` by showing that `ring_pow r a f` equals `ring_mul r (ring_pow r a e) w` where `w` is `ring_pow r a (f-e)`.
- Apply `RING_POW`.
### Mathematical insight
This theorem states a basic divisibility property of powers in rings. If one exponent is less than or equal to another, then the corresponding powers of an element are divisible within the ring. This theorem is useful in number theory and abstract algebra when reasoning about divisibility properties in rings.

### Dependencies
- Theorems: `RING_POW_ADD`
- Definitions: `ring_divides`
- Theories: `RING_POW`


---

## ring_product_collect

### Name of formal statement
ring_product_collect

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_collect = prove(`
  !(r:R ring) S f:X->R.
  FINITE S ==>
  (!s:X. s IN S ==> f s IN ring_carrier r) ==>
  ring_product r S f =
  ring_product r (IMAGE f S)
    (\y. ring_pow r y (CARD {s | s IN S /\ f s = y}))
`,
  intro THEN
  specialize[
    `r:R ring`;
    `f:X->R`;
    `f:X->R`;
    `S:X->bool`
  ]RING_PRODUCT_IMAGE_GEN THEN
  simp[] THEN
  sufficesby RING_PRODUCT_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  subgoal `ring_product r {x | x IN S /\ f x = a} f = ring_product r {x | x IN S /\ f x = a} (\x:X. a:R)` THENL [
    sufficesby RING_PRODUCT_EQ THEN
    rw[IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  have `a:R IN ring_carrier r` [IN_IMAGE] THEN
  set_fact `{x:X | x IN S /\ f x = a:R} SUBSET S` THEN
  have `FINITE {x:X | x IN S /\ f x = a:R}` [FINITE_SUBSET] THEN
  simp[ring_product_const]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any finite set `S` of type `X->bool`, and any function `f` from `X` to `R` such that for all `s` in `S`, `f s` is in the carrier of the ring `r`, the ring product of `f s` over `S` with respect to ring `r` is equal to the ring product over the image of `S` under `f` of `ring_pow r y (CARD {s | s IN S /\ f s = y})`.

### Informal sketch
The proof proceeds by induction on the finiteness of set `S` while handling the ring structure based on `r` and function `f`:

- Introduce assumptions about `r`, `S`, and `f`.
- Apply `RING_PRODUCT_IMAGE_GEN` to generalize to the ring product over the image of `S` under `f`.
- Simplify the expression using available simplifications.
- Reduce the theorem by showing equivalence according to `RING_PRODUCT_EQ`.
- Rewrite using `BETA_THM` in preparation for the core argument.
- Introduce another assumption and consider the case when the ring product of `f` over the set `{x | x IN S /\ f x = a}` (where `a` is an element of type `R`) is equivalent to the ring product of the constant function returning `a` over the same set; this is justified by `RING_PRODUCT_EQ` and the elimination of the `IN` relation `IN_ELIM_THM`.
- Pass the remaining subgoals.
- Show that `a` (of type `R`) being an element of the image of `f` is within the ring `carrier r`.
- Set the fact that `{x:X | x IN S /\ f x = a:R}` is a subset of `S`.
- Infer that `{x:X | x IN S /\ f x = a:R}` is finite because it is a subset of a finite set `S` using `FINITE_SUBSET`.
- Simplify using `ring_product_const`.

### Mathematical insight
The theorem provides a way to rewrite a product over a set `S` with a function `f` to an equivalent product over the image of `S` under `f`. The terms in this new product are powers of the image elements, where each element is raised to the power of the cardinality of its pre-image. This offers a useful tool for simplifying expressions involving ring products, especially when dealing with non-injective functions `f`.

### Dependencies
- Theorems: `RING_PRODUCT_IMAGE_GEN`, `RING_PRODUCT_EQ`, `BETA_THM`, `IN_ELIM_THM`, `FINITE_SUBSET`
- Definitions: `ring_product_const`


---

## ring_coprime_1

### Name of formal statement
ring_coprime_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_1 = prove(`
  !(r:R ring) a.
  a IN ring_carrier r ==>
  (ring_coprime r (ring_1 r,a)
   /\ ring_coprime r (a,ring_1 r)
  )
`,
  rw[ring_coprime] THEN
  qed[RING_1;RING_UNIT_DIVIDES]
);;
```
### Informal statement
For any ring `r` and any element `a` in the carrier of `r`, `a` is coprime to the ring unit `ring_1 r` and the ring unit `ring_1 r` is coprime to `a`.

### Informal sketch
- The proof starts by rewriting with the definition of `ring_coprime`.
- Then, it uses the theorems `RING_1` and `RING_UNIT_DIVIDES` to complete the proof. `RING_1` states that `ring_1 r` is an element of `ring_unit r`. `RING_UNIT_DIVIDES` states if `x` is a unit in `r` then `x` divides `y` for all `y` in the carrier of `r`. Since the ring unit divides `a` and `a` divides itself, the gcd of the two elements is the entire ring, so they are coprime.

### Mathematical insight
This theorem establishes a fundamental property of rings, namely that the ring unit is coprime with every element in the ring. This is important because it simplifies many arguments related to coprimality and divisibility in rings.

### Dependencies
- Definitions: `ring_coprime`
- Theorems: `RING_1`, `RING_UNIT_DIVIDES`


---

## ring_coprime_product_waterfall

### Name of formal statement
ring_coprime_product_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_product_waterfall = prove(`
  !(r:R ring) f:X->R a.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  a IN ring_carrier r ==>
  !S.
  FINITE S ==>
  (!s. s IN S ==> ring_coprime r (a,f s)) ==>
  ring_coprime r (a,ring_product r S f)
`,
  intro_gendisch THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    simp[RING_PRODUCT_CLAUSES] THEN
    qed[ring_coprime_1]
  ;
    have `x:X IN x INSERT S` [IN_INSERT] THEN
    have `f(x:X):R IN ring_carrier r` [SUBSET;ring_coprime] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `!s:X. s IN S ==> s IN x INSERT S` [IN_INSERT] THEN
    have `ring_coprime r (a,ring_product r S (f:X->R))` [] THEN
    qed[RING_COPRIME_RMUL;RING_PRODUCT;ring_coprime]
  ]
);;
```
### Informal statement
Let `r` be a ring, `f` a function from `X` to `R`, and `a` an element. If `r` is a unique factorization domain or `r` is an integral domain and a Bézout ring, and `a` is in the carrier of `r`, then for any finite set `S`, if `a` is coprime to `f s` for all `s` in `S`, then `a` is coprime to the ring product of `f` over `S` in `r`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: `S` is empty. Then `ring_product r S f` is 1, and `ring_coprime r (a, 1)` is true because `ring_coprime_1` is applicable.
- Inductive step: Assume the theorem holds for all subsets of `x INSERT S`.
  - Assume `x IN x INSERT S` and `f x IN ring_carrier r`.
  - Show that `ring_product r (x INSERT S) f = ring_product r (S INSERT x) f = ring_product r S f * f x`, where the equality is derived from `RING_PRODUCT_CLAUSES`.
  - Use the inductive hypothesis that `ring_coprime r (a, ring_product r S f)` holds.
  - Apply `RING_COPRIME_RMUL` and `ring_coprime` and `RING_PRODUCT`, to deduce `ring_coprime r (a, ring_product r (x INSERT S) f)`.

### Mathematical insight
This theorem shows that if an element `a` is coprime to each element in a finite set `S` under a ring `r`, then `a` is coprime to the product of all elements in `S`. This is a generalization of the property that if `a` is coprime to `b` and `a` is coprime to `c`, then `a` is coprime to `b * c` under certain conditions on the ring `r`.

### Dependencies
- `UFD`
- `integral_domain`
- `bezout_ring`
- `ring_carrier`
- `FINITE`
- `ring_coprime`
- `ring_product`
- `RING_PRODUCT_CLAUSES`
- `ring_coprime_1`
- `IN_INSERT`
- `SUBSET`
- `RING_COPRIME_RMUL`
- `RING_PRODUCT`


---

## ring_coprime_product

### Name of formal statement
ring_coprime_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_product = prove(`
  !(r:R ring) f:X->R a S.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  a IN ring_carrier r ==>
  FINITE S ==>
  (!s. s IN S ==> ring_coprime r (a,f s)) ==>
  ring_coprime r (a,ring_product r S f)
`,
  simp[ring_coprime_product_waterfall]
);;
```
### Informal statement
For any ring `r` that is either a unique factorization domain (UFD) or an integral domain and a Bezout ring, for any element `a` in the carrier of the ring `r`, for any finite set `S`, and for any function `f` from `S` to the carrier of `r`, if `a` is coprime to `f(s)` for every `s` in `S`, then `a` is coprime to the product of `f(s)` over all `s` in `S`.

### Informal sketch
The proof proceeds by induction on the size of the finite set `S`.
- Base case: If `S` is empty, the product of `f` over `S` is the ring's multiplicative identity, which is coprime to everything.
- Inductive step: Assume the theorem holds for a set `S`. Consider a larger set `S'` formed by adding an element `s'` to `S`. By the inductive hypothesis, `a` is coprime to the product of `f` over `S`. We are given that `a` is coprime to `f(s')`. We then need to show that `a` is coprime to the product of `f` over `S'`, which is the product of `f` over `S` multiplied by `f(s')`.
The proof uses the theorem `ring_coprime_product_waterfall`, and proof is performed by simplification.

### Mathematical insight
This theorem extends the notion of coprimality from pairs of elements to an element and a product of elements. It is a generalization of the property that if an element is coprime to each element in a finite set, it is also coprime to their product. This is a crucial property in number theory and ring theory, especially when dealing with factorization and divisibility.

### Dependencies
- `ring_coprime`
- `ring_product`
- `UFD`
- `integral_domain`
- `bezout_ring`
- `ring_coprime_product_waterfall`


---

## ring_product_divides_if_coprime_waterfall

### Name of formal statement
ring_product_divides_if_coprime_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_divides_if_coprime_waterfall = prove(`
  !(r:R ring) f:X->R a.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  a IN ring_carrier r ==>
  !S.
  FINITE S ==>
  (!s t. s IN S ==> t IN S ==> ~(s = t) ==> ring_coprime r (f s,f t)) ==>
  (!s. s IN S ==> ring_divides r (f s) a) ==>
  ring_divides r (ring_product r S f) a
`,
  intro_gendisch THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    simp[RING_PRODUCT_CLAUSES] THEN
    qed[RING_DIVIDES_1]
  ;
    have `x:X IN x INSERT S` [IN_INSERT] THEN
    have `f(x:X):R IN ring_carrier r` [SUBSET;ring_divides] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `!s:X. s IN S ==> s IN x INSERT S` [IN_INSERT] THEN
    have `ring_divides r (ring_product r S (f:X->R)) a` [] THEN
    subgoal `ring_coprime r (f x,ring_product r S (f:X->R))` THENL [
      specialize_assuming[
        `r:R ring`;
        `f:X->R`;
        `f(x:X):R`;
        `S:X->bool`
      ]ring_coprime_product THEN
      qed[]
    ; pass
    ] THEN
    qed[RING_DIVIDES_MUL]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `f` from a type `X` to the carrier of `r`, and any element `a` in the carrier of `r`, if either `r` is a unique factorization domain or `r` is an integral domain and a Bezout ring, then for any finite set `S` of type `X`, if for all distinct `s` and `t` in `S`, `f(s)` and `f(t)` are coprime in `r`, and for all `s` in `S`, `f(s)` divides `a` in `r`, then the product of `f(s)` over `S` in `r` divides `a` in `r`.

### Informal sketch
The proof proceeds by strong induction on the size of the finite set `S`.

- Base case: If `S` is empty, then the ring product over `S` is 1, and 1 divides anything, so the theorem holds (using `RING_DIVIDES_1`).
- Inductive step: Assume the theorem holds for all sets smaller than `x INSERT S`.  Assume that `x` is in `x INSERT S`. We know that `f(x)` is in the ring carrier since `f(x)` divides `a`. We must show that `ring_product r (x INSERT S) f` divides `a`.  
  - We simplify `ring_product r (x INSERT S) f` to `ring_mul r (f x) (ring_product r S f)`.
  - We have that `ring_product r S f` divides `a` by the induction hypothesis.
  - To show that `ring_mul r (f x) (ring_product r S f)` divides `a`, we need to show that `f x` and `ring_product r S f` are coprime (using `RING_DIVIDES_MUL`).
  - We show that `f x` and the product over S are coprime using the assumption that any two distinct elements of `x INSERT S` are coprime (`ring_coprime_product`).
  - With this we conclude that indeed `ring_product r (x INSERT S) f` divides `a`.

### Mathematical insight
The theorem states that if a finite collection of pairwise coprime elements all divide a given element `a`, then their product also divides `a`.  The condition of the ring being either a UFD or an integral domain and Bezout ring is needed to guarantee that the concept of coprimality has the desired properties (specifically, that if `a` is coprime to both `b` and `c`, it is coprime to their product). The tactic `FINITE_INDUCT_STRONG` is used to perform strong induction on the size of the finite set `S`. It reflects a common inductive pattern in mathematics: break down a problem on a composite object (here, `x INSERT S`) into a base case and an inductive case using insertion or similar constructors to increase size/complexity.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `RING_DIVIDES_1`
- `RING_DIVIDES_MUL`
- `RING_COPRIME_PRODUCT`
- `UFD`
- `integral_domain`
- `bezout_ring`
- `ring_carrier`
- `FINITE`
- `ring_coprime`
- `ring_divides`
- `ring_product`

### Porting notes (optional)
- In proof assistants like Coq or Lean, the finiteness condition might be handled using different representations of finite sets (e.g., lists or finite sets with decidable equality). Moreover, tactics for rewriting using definitions and inductive hypotheses might require adjustments based on the specific automation available in each system. For instance, in Lean, the `simp` tactic is very powerful, but it might be beneficial to utilize `rw` with more explicit direction in some instances to match the rewrites used in HOL Light.


---

## ring_product_divides_if_coprime

### Name of formal statement
ring_product_divides_if_coprime

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_divides_if_coprime = prove(`
  !(r:R ring) f:X->R a S.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  a IN ring_carrier r ==>
  FINITE S ==>
  (!s. s IN S ==> ring_divides r (f s) a) ==>
  (!s t. s IN S ==> t IN S ==> ~(s = t) ==> ring_coprime r (f s,f t)) ==>
  ring_divides r (ring_product r S f) a
`,
  simp[ring_product_divides_if_coprime_waterfall]
);;
```
### Informal statement
For any ring `r` with carrier set `ring_carrier r`, any function `f` from a type `X` to `r`, and any element `a` in `ring_carrier r`, and any finite set `S` of type `X`, if `r` is a unique factorization domain or `r` is an integral domain and a Bezout ring, and if for all `s` in `S`, the element `f s` divides `a` in the ring `r`, and if for all distinct `s` and `t` in `S`, `f s` and `f t` are coprime in the ring `r`, then the product of `f s` for all `s` in `S` divides `a` in the ring `r`.

### Informal sketch
The proof proceeds by mathematical induction on the size of the finite set `S`.
- Base case: `S` is empty. The product over the empty set is the ring unit, which divides any element.
- Inductive step: Assume the theorem holds for a set `S`. We need to show that it holds for `S U {x}` where `x` is not in `S`.
  - By the inductive hypothesis, `ring_product r S f` divides `a`.
  - We also know that `f x` divides `a`, and that `ring_product r S f` and `f x` are coprime.
  - If two coprime elements divide a, then their product divides a (a known property in UFDs and Bezout domains). Therefore, `ring_product r (S U {x}) f` divides `a`.
The `simp[ring_product_divides_if_coprime_waterfall]` tactic likely unfolds definitions, applies the inductive hypothesis, and uses the stated property about coprime divisors.

### Mathematical insight
This theorem states that if a collection of pairwise coprime elements in a UFD or Bezout domain all divide a single element, then their product must also divide that element. This is a generalization of the familiar result for integers and is a fundamental property in the theory of unique factorization and divisibility. The condition that the ring is a UFD or a Bezout domain (or both) is necessary to ensure that coprime elements behave as expected with respect to divisibility.

### Dependencies
- `UFD`
- `integral_domain`
- `bezout_ring`
- `ring_carrier`
- `FINITE`
- `ring_divides`
- `ring_coprime`
- `ring_product`
- `ring_product_divides_if_coprime_waterfall` (likely a collection of simplification rules)


---

## ring_coprime_lpow

### Name of formal statement
ring_coprime_lpow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_lpow = prove(`
  !(r:R ring) a b n.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  ring_coprime r (a,b) ==>
  ring_coprime r ((ring_pow r a n),b)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    qed[RING_POW_0;ring_coprime_1;ring_coprime]
  ;
    rw[ARITH_RULE `SUC n = n+1`] THEN
    intro THEN
    have `a:R IN ring_carrier r` [ring_coprime] THEN
    simp[RING_POW_ADD;RING_POW_1] THEN
    have `b:R IN ring_carrier r` [ring_coprime] THEN
    qed[RING_COPRIME_LMUL;RING_POW]
  ]
);;
```
### Informal statement
For any ring `r` which is either a unique factorization domain or an integral domain and a Bezout ring, and for any elements `a` and `b` in the ring `r`, and for any natural number `n`, if `a` and `b` are coprime in `r`, then `a^n` and `b` are coprime in `r`. Here, `ring_coprime r (x, y)` means that `x` and `y` are coprime in the ring `r`, and `ring_pow r a n` means `a` to the power of `n` in ring `r`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. Then `a^0 = 1`, and `1` and `b` are coprime. This relies on `RING_POW_0`, `ring_coprime_1` and `ring_coprime`.
- Inductive step: Assume that `a^n` and `b` are coprime. We want to show that `a^(n+1)` and `b` are coprime. Note that `a^(n+1) = a^n * a`. Since `a^n` and `b` are coprime (by the inductive hypothesis) and `a` and `b` are coprime (by assumption), we can conclude that `a^(n+1)` and `b` are coprime by `RING_COPRIME_LMUL`.

### Mathematical insight
This theorem states that if two elements in a ring are coprime, then raising one of the elements to any power preserves the coprimality with the other element. This is a useful property in ring theory and number theory, especially when dealing with factorization and divisibility. It generalizes the familiar result from integers that coprime integers remain coprime upon exponentiation.

### Dependencies
- `UFD`
- `integral_domain`
- `bezout_ring`
- `ring_coprime`
- `ring_pow`
- `RING_POW_0`
- `ring_coprime_1`
- `RING_POW_ADD`
- `RING_POW_1`
- `RING_COPRIME_LMUL`
- `RING_POW`


---

## ring_coprime_rpow

### Name of formal statement
ring_coprime_rpow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_rpow = prove(`
  !(r:R ring) a b n.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  ring_coprime r (a,b) ==>
  ring_coprime r (a,(ring_pow r b n))
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    qed[RING_POW_0;ring_coprime_1;ring_coprime]
  ;
    rw[ARITH_RULE `SUC n = n+1`] THEN
    intro THEN
    have `b:R IN ring_carrier r` [ring_coprime] THEN
    simp[RING_POW_ADD;RING_POW_1] THEN
    have `a:R IN ring_carrier r` [ring_coprime] THEN
    qed[RING_COPRIME_RMUL;RING_POW]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any elements `a` and `b` in `r`, and any natural number `n`, if either `r` is a UFD, or `r` is an integral domain and a Bezout ring, then if `a` and `b` are ring coprime in `r`, then `a` and `b^n` are ring coprime in `r`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. Then `b^0 = 1`. Since `a` and `1` are coprime for any `a`, the base case holds. This uses `RING_POW_0`, `ring_coprime_1`, and `ring_coprime`.
- Inductive step: Assume `ring_coprime r (a, ring_pow r b n)`. We need to show `ring_coprime r (a, ring_pow r b (n+1))`.
    - The inductive step uses the relationship `n+1 = SUC n`, rewriting with the arithmetic rule `ARITH_RULE SUCN = n+1`.
    - Introduce the assumption that `b` is in the carrier of the ring `r`, which is justified by `ring_coprime`.
    - Rewrite `ring_pow r b (n+1)` as `ring_mul r (ring_pow r b n) b` using `RING_POW_ADD` and `RING_POW_1`.
    - Introduce the assumption that `a` is in the carrier of the ring `r`, which is justified by `ring_coprime`.
    - The theorem `RING_COPRIME_RMUL` states that if `a` and `b` are coprime and `a` and `c` are coprime, then `a` and `b*c` are coprime. Since we have assumed that `a` and `ring_pow r b n` are coprime, and  `a` and `b` are coprime, we can conclude that `a` and `(ring_pow r b n) * b` are coprime. This uses `RING_COPRIME_RMUL` and `RING_POW`.

### Mathematical insight
The statement formalizes the intuitive idea that if two elements are coprime, then one element is also coprime with any power of the other element. The condition about `r` being a UFD or an integral domain and a Bezout ring is necessary to ensure that the notion of coprimality is well-behaved in `r`.

### Dependencies
- `RING_POW_0`
- `ring_coprime_1`
- `ring_coprime`
- `ARITH_RULE`
- `RING_POW_ADD`
- `RING_POW_1`
- `RING_COPRIME_RMUL`
- `RING_POW`


---

## ring_coprime_lrpow

### Name of formal statement
ring_coprime_lrpow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_lrpow = prove(`
  !(r:R ring) a b m n.
  (UFD r \/ integral_domain r /\ bezout_ring r) ==>
  ring_coprime r (a,b) ==>
  ring_coprime r ((ring_pow r a m),(ring_pow r b n))
`,
  qed[ring_coprime_lpow;ring_coprime_rpow]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and for all elements `a` and `b` in `r`, and for all natural numbers `m` and `n`, if either `r` is a unique factorization domain (UFD) or `r` is an integral domain and a Bezout ring, and if `a` and `b` are ring coprime with respect to `r`, then `a` to the power of `m` and `b` to the power of `n` are ring coprime with respect to `r`.

### Informal sketch
The proof proceeds by referencing two existing theorems that handle the cases for powers of `a` and `b` individually. Specifically:
- `ring_coprime_lpow`: If `a` and `b` are coprime, then `a^m` and `b` are coprime.
- `ring_coprime_rpow`: If `a` and `b` are coprime, then `a` and `b^n` are coprime.
By applying these theorems sequentially, starting with `ring_coprime_lpow` to establish that `a^m` and `b` are ring coprime, and then using `ring_coprime_rpow` to show that `a^m` and `b^n` are ring coprime, we arrive at the desired conclusion.

### Mathematical insight
This theorem extends the notion of coprimality to powers of ring elements. It leverages the properties of unique factorization domains and Bezout rings. The condition `UFD r \/ integral_domain r /\ bezout_ring r` provides sufficient conditions for the coprimality to extend to powers. In a UFD, elements have unique prime factorizations, and in a Bezout ring, the greatest common divisor of two elements can be expressed as a linear combination of the elements. Coprimality is a fundamental concept in ring theory, and this theorem provides a useful tool for reasoning about coprimality in more complex settings.

### Dependencies
- `ring_coprime_lpow`
- `ring_coprime_rpow`


---

## ring_coprime_associates_prime

### Name of formal statement
ring_coprime_associates_prime

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_associates_prime = prove(`
  !(r:R ring) p q.
  integral_domain r ==>
  ring_prime r p ==>
  ring_prime r q ==>
  (
    ring_coprime r (p,q)
    <=> ~ring_associates r p q
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    have `ring_associates r p (p:R)` [RING_ASSOCIATES_REFL;ring_prime] THEN
    have `ring_coprime r (p,p:R)` [RING_ASSOCIATES_COPRIME] THEN
    have `ring_unit r (p:R)` [RING_COPRIME_REFL] THEN
    qed[ring_prime]
  ;
    intro THEN
    proven_if `ring_coprime r (p,q:R)` [] THEN
    have `q:R IN ring_carrier r` [ring_prime] THEN
    have `ring_divides r (p:R) q` [INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME] THEN
    have `p:R IN ring_carrier r` [ring_prime] THEN
    have `ring_divides r (q:R) p` [INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME;RING_COPRIME_SYM] THEN
    qed[ring_associates]
  ]
);;
```
### Informal statement
Given an integral domain `r` and elements `p` and `q`, if `p` and `q` are prime elements in the ring `r`, then `p` and `q` are coprime if and only if `p` and `q` are not associates.

### Informal sketch
The proof proceeds by showing the equivalence through two implications:

*   **"=>"**: Assuming `ring_coprime r (p, q)`, we aim to prove `~ring_associates r p q`.
    *   Assume `ring_coprime r (p, q)`.
    *   Using `ring_prime r q` and `INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME`, derive that either `ring_divides r p q` or `ring_coprime r p q`.
    *   If `ring_divides r p q`, then since `ring_prime r p` we can use `INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME` to obtain `ring_divides r q p`. Together with `ring_divides r p q` this implies `ring_associates r p q`. So we need to show that `ring_associates r p q` is not the case.
    *   From `ring_coprime r (p, q)` and `RING_COPRIME_SYM` we obtain `ring_coprime r (q, p)`.

*   **"<="**: Assuming `~ring_associates r p q`, we aim to prove `ring_coprime r (p, q)`.
    *   Assume `~ring_associates r p q`.
    *   Since `ring_associates r p p` by `RING_ASSOCIATES_REFL` we have `ring_associates r p (p:R)`. Combined with `ring_associates r p q` gives us `p` and `q` are distinct, which is equivalent to the statement that `ring_coprime r (p, p:R)` implying `RING_UNIT r (p:R)` by `RING_COPRIME_REFL`. Using `ring_prime r p`, derive a contradiction.

### Mathematical insight
This theorem establishes a fundamental relationship between coprimality and being associates for prime elements within an integral domain. It shows that two prime elements are coprime if and only if they are not associates of each other. This clarifies the notion of "distinctness" for prime elements in rings, where "distinct" is captured by not being associates, aligning with the idea of coprimality.

### Dependencies
- `integral_domain`
- `ring_prime`
- `ring_coprime`
- `ring_associates`
- `RING_ASSOCIATES_REFL`
- `RING_ASSOCIATES_COPRIME`
- `RING_COPRIME_REFL`
- `INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME`
- `RING_COPRIME_SYM`

### Porting notes (optional)
When porting to other proof assistants, ensure that the definitions of `ring_coprime`, `ring_prime`, `ring_divides`, and `ring_associates` align with the HOL Light definitions. The handling of integral domains might also differ slightly between systems, so careful attention should be paid to the axioms and properties associated with integral domains. The proof uses a standard splitting of an iff statement into two implications; most proof assistants have tactics or methods to automate this process.


---

## ring_divides_associates_prime

### Name of formal statement
ring_divides_associates_prime

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_divides_associates_prime = prove(`
  !(r:R ring) p q.
  integral_domain r ==>
  ring_prime r p ==>
  ring_prime r q ==>
  (
    ring_divides r p q
    <=> ring_associates r p q
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    have `~ring_unit r (p:R)` [ring_prime] THEN
    have `ring_irreducible r (q:R)` [INTEGRAL_DOMAIN_PRIME_IMP_IRREDUCIBLE] THEN
    qed[RING_NONUNIT_DIVIDES_IRREDUCIBLE]
  ;
    qed[ring_associates]
  ]
);;
```
### Informal statement
For any ring `r` that is an integral domain, and for any `p` and `q` that are prime elements in the ring `r`, `p` divides `q` if and only if `p` and `q` are associates.

### Informal sketch
The proof proceeds by mutual implication of `ring_divides r p q` and `ring_associates r p q`, given that `r` is an integral domain and `p` and `q` are prime.
- First, assume `ring_divides r p q`. Since `p` is prime and thus not a unit, and `q` is irreducible because it is prime in the integral domain, then `p` and `q` are associates according to the theorem `RING_NONUNIT_DIVIDES_IRREDUCIBLE`.
- Then, suppose `p` and `q` are associates; it follows directly from theorem `ring_associates` that `ring_divides r p q` holds.

### Mathematical insight
In an integral domain, two prime elements are associates if and only if one divides the other. This theorem links the divisibility and associate relationship between prime elements in the context of integral domains.

### Dependencies
- Definitions: `ring_divides`, `ring_associates`, `ring_prime`, `ring_unit`, `ring_irreducible`, `integral_domain`
- Theorems: `INTEGRAL_DOMAIN_PRIME_IMP_IRREDUCIBLE`, `RING_NONUNIT_DIVIDES_IRREDUCIBLE`, `ring_associates`


---

## ring_divides_product

### Name of formal statement
ring_divides_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_divides_product = prove(`
  !(r:R ring) S t:X f.
  FINITE S ==>
  t IN S ==>
  f t IN ring_carrier r ==>
  ring_divides r (f t) (ring_product r S f)
`,
  simp[ring_product_delete] THEN
  rw[ring_divides] THEN
  qed[RING_PRODUCT;RING_MUL]
);;
```
### Informal statement
For any ring `r` with carrier type `X`, for any finite set `S` of type `X`, for any element `t` in `S`, and for any function `f` from `X` to the carrier of ring `r`, if `f t` is an element of the carrier of `r`, then `f t` divides the ring product of `f` over `S` in the ring `r`.

### Informal sketch
The proof demonstrates that if `t` is an element of the finite set `S`, and `f t` belongs to the ring carrier, then `f t` divides the ring product of `f` over `S` in the ring `r`.
- The proof starts by simplifying using `ring_product_delete`, which simplifies the ring product of `f` over `S` into `ring_mul r (f t) (ring_product r (set_delete t S) f)`.
- Next, the definition of `ring_divides` is rewritten, replacing the divides relation with an existential quantifier, resulting in the goal to prove the existence of an element `x` such that `ring_product r S f = ring_mul r (f t) x`.
- Finally, the proof concludes by using the theorems `RING_PRODUCT` and `RING_MUL`, implicitly proving that `ring_product r (set_delete t S) f` satisfies the existential, since `ring_product r S f = ring_mul r (f t) (ring_product r (set_delete t S) f)` as shown by `ring_product_delete` at the start.

### Mathematical insight
This theorem states a fundamental property of ring products: if you have a finite product of elements in a ring, then each element in the set used to generate the product divides the product itself. This is a generalization of the familiar property in integer arithmetic, where each factor of a product divides the product.

### Dependencies
- `ring_product_delete`
- `ring_divides`
- `RING_PRODUCT`
- `RING_MUL`


---

## ring_sum_restrict_subset

### Name of formal statement
ring_sum_restrict_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_restrict_subset = prove(`
  !(r:R ring) S:X->bool U p.
  S SUBSET U ==>
  ring_sum r U (\s. if s IN S then p s else ring_0 r)
  = ring_sum r S p
`,
  intro THEN
  specialize[
    `S:X->bool`;
    `r:R ring`;
    `U:X->bool`;
    `p:X->R`
  ]RING_SUM_RESTRICT_SET THEN
  set_fact `S SUBSET U:X->bool ==> {x | x IN U /\ S x} = S` THEN
  rw[IN] THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, sets `S` and `U` of type `X->bool`, and function `p` from `X` to the carrier of ring `r`, if `S` is a subset of `U`, then the ring sum over `U` of the function that maps `s` to `p s` if `s` is in `S` and to the ring zero of `r` otherwise is equal to the ring sum over `S` of `p`.

### Informal sketch
*   The proof starts by introducing assumptions and specializing the theorem `RING_SUM_RESTRICT_SET` with `S`, `r`, `U`, and `p`.
*   It then uses the fact that `S SUBSET U` implies `{x | x IN U /\ S x} = S`.
*   Finally, it rewrites the expression using the definition of `IN` to complete the proof.

### Mathematical insight
This theorem states that when computing a ring sum over a set `U`, where the terms are defined based on membership in a subset `S` of `U`, we can restrict the summation directly to the subset `S`. This is useful for simplifying expressions and reasoning about sums with conditional terms. The ring sum over `U` with terms being `p s` if `s` is in `S` and zero otherwise is exactly the same as the ring sum over `S` with terms `p s`.

### Dependencies
* Theorems: `RING_SUM_RESTRICT_SET`


---

## ring_sum_range_add_1

### Name of formal statement
ring_sum_range_add_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_range_add_1 = prove(`
  !(r:R ring) n c:num->R.
  c n IN ring_carrier r ==>
  ring_sum r (range(n+1)) c
  = ring_add r (c n) (ring_sum r (range n) c)
`,
  intro THEN
  have `FINITE(range(n+1))` [finite_range] THEN
  have `n IN range(n+1)` [range_lt;ARITH_RULE `n < n+1`] THEN
  specialize[
    `r:R ring`;
    `range(n+1)`;
    `c:num->R`;
    `n:num`
  ]ring_sum_delete2 THEN
  qed[range_add_1_delete_refl]
);;
```
### Informal statement
For any ring `r` with carrier set `ring_carrier r`, and any function `c` from natural numbers to the carrier set of `r` (i.e., `c n IN ring_carrier r` for all `n`), the ring sum of `c` over the range from `0` to `n` inclusive (i.e., `range(n+1)`) is equal to the ring addition of `c n` to the ring sum of `c` over the range from `0` to `n-1` inclusive (i.e., `range n`).

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions, including the ring `r`, the function `c`, and the condition that `c n` is in the carrier set of `r`.
- Show that `range(n+1)` is a finite set using `finite_range`.
- Prove that `n` is an element of `range(n+1)` using `range_lt` and `ARITH_RULE`.
- Apply the theorem `ring_sum_delete2` to the specific ring `r`, range `range(n+1)`, function `c`, and element `n`.  This theorem allows us to remove an element from the summation if it is in the finite set being summed over.
- The equality follows by applying `range_add_1_delete_refl`.

### Mathematical insight
This theorem provides a recursive way to compute the ring sum over a range of natural numbers. It decomposes the sum from 0 to `n` into the sum from 0 to `n-1` plus the `n`-th term. This is a standard technique for proving properties about sums by induction.

### Dependencies
- `ring_carrier`
- `ring_sum`
- `range`
- `ring_add`
- `finite_range`
- `range_lt`
- `ring_sum_delete2`
- `range_add_1_delete_refl`
- `ARITH_RULE`


---

## ring_sum_range_add_1_sub

### Name of formal statement
ring_sum_range_add_1_sub

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_range_add_1_sub = prove(`
  !(r:R ring) n c:num->R.
  c n IN ring_carrier r ==>
  ring_sum r (range n) c
  = ring_sub r (ring_sum r (range(n+1)) c) (c n)
`,
  intro THEN
  simp[ring_sum_range_add_1] THEN
  have `ring_sum r (range n) c:R IN ring_carrier r` [RING_SUM] THEN
  RING_TAC
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any function `c` from natural numbers to the carrier of `r` (i.e., `c n IN ring_carrier r` for all `n`), and any natural number `n`, the ring sum of `c i` for `i` in the range from `0` to `n-1` is equal to the result of subtracting `c n` from the ring sum of `c i` where `i` ranges from `0` to `n`.

### Informal sketch
The proof proceeds as follows:
- Start by introducing the variables `r`, `n`, and `c`.
- Simplify the statement using `ring_sum_range_add_1`. This will result in `ring_sum r (range n) c = ring_sum r (range(n+1)) c - c n`.
- Establish that `ring_sum r (range n) c` belongs to the carrier set of the ring `r`. This is proved using the theorem `RING_SUM`.
- Finally, apply `RING_TAC` to complete the proof. This tactic likely uses the ring axioms and the membership of `ring_sum r (range n) c` in `ring_carrier r` to discharge any remaining goals.

### Mathematical insight
This theorem decomposes the ring sum over a range `0` to `n` into the ring sum over the extended range `0` to `n+1`, with the subtraction of the last term `c n`. This identity is useful for inductive proofs and for manipulating ring sums.

### Dependencies
- Theorems: `ring_sum_range_add_1`, `RING_SUM`
- Tactics: `RING_TAC`


---

## ring_exp_sum

### Name of formal statement
ring_exp_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_exp_sum = prove(`
  !(a:A ring) (b:B ring) E:A->B f:X->A S:X->bool.
  FINITE S ==>
  (!x:A. x IN ring_carrier a ==>
         E x IN ring_carrier b) ==>
  E(ring_0 a) = ring_1 b ==>
  (!x y. E(ring_add a x y)
         = ring_mul b (E x) (E y)) ==>
  (!x. x IN S ==> f x IN ring_carrier a) ==>
  E(ring_sum a S f)
  = ring_product b S (E o f)
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;RING_PRODUCT_CLAUSES] THEN
    qed[]
  ;
    have `x:X IN x INSERT S` [IN_INSERT] THEN
    have `f(x:X):A IN ring_carrier a` [SUBSET;ring_divides] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    rw[o_THM] THEN
    simp[RING_SUM_CLAUSES] THEN
    ASM SET_TAC[RING_SUM]
  ]
);;
```

### Informal statement
For any rings `a` of type `A` and `b` of type `B`, any function `E` from `A` to `B`, any function `f` from `X` to `A`, and any set `S` of type `X`, if `S` is finite, and if `E` maps elements of the carrier of ring `a` to the carrier of ring `b`, and if `E` maps the zero element of ring `a` to the one element of ring `b`, and if `E` distributes ring addition in `a` to ring multiplication in `b` (i.e., `E(ring_add a x y) = ring_mul b (E x) (E y)`), and if `f` maps elements of `S` to the carrier of ring `a`, then `E` of the ring sum of `f` over `S` with respect to ring `a` equals the ring product of `E o f` over `S` with respect to ring `b`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: If `S` is empty, then we need to show that `E (ring_sum a EMPTY f) = ring_product b EMPTY (E o f)`. This follows directly from the definitions of `ring_sum` and `ring_product` for empty sets using `RING_SUM_CLAUSES` and `RING_PRODUCT_CLAUSES`.
- Inductive step: Assume that the theorem holds for all subsets of `S`. We need to show that it also holds for `S` itself.
  - Let `x` be an element of `S`. Rewrite `x IN x INSERT S` using `IN_INSERT`.
  - We know `f x IN ring_carrier a` from the assumption `SUBSET` combined with `ring_divides`.
  - Apply the definition of `ring_product b (INSERT x S) (E o f)` using `RING_PRODUCT_CLAUSES`, which expands to `ring_mul b (E o f) x (ring_product b S (E o f))`.
  - Rewrite `(E o f) x` to `E (f x)` using `o_THM`.
  - Apply the definition of `ring_sum` to `ring_sum a (INSERT x S) f` using `RING_SUM_CLAUSES`, expanding it to `ring_add a (f x) (ring_sum a S f)`.
  - Because `E` preserves the ring structure (i.e. `E(ring_add a x y) = ring_mul b (E x) (E y)`), we can rewrite `E (ring_add a (f x) (ring_sum a S f))` to `ring_mul b (E (f x)) (E (ring_sum a S f))`.
  - Apply the induction hypothesis `E(ring_sum a S f) = ring_product b S (E o f)`.
  - Finally, use the assumption `!x y. E(ring_add a x y) = ring_mul b (E x) (E y)` to complete the proof.

### Mathematical insight
This theorem states that a ring homomorphism sends a ring sum to a ring product. The condition `E(ring_0 a) = ring_1 b` and `(!x y. E(ring_add a x y) = ring_mul b (E x) (E y))` essentially describe that `E` maps the additive identity of ring `a` to the multiplicative identity of ring `b` and that `E` is a homomorphism from the additive group of ring `a` to the multiplicative group of ring `b`. This is a fundamental result in abstract algebra and ring theory, connecting the additive and multiplicative structures of rings through homomorphisms.

### Dependencies
- `RING_SUM_CLAUSES`
- `RING_PRODUCT_CLAUSES`
- `o_THM`
- `RING_SUM`

### Porting notes (optional)
- The proof uses `FINITE_INDUCT_STRONG`, which may need to be replaced with equivalent induction principles in other proof assistants.
- The handling of operators and carrier membership conditions is important to preserve.
- The rewriting of `E o f` and applications of `RING_SUM_CLAUSES` and `RING_PRODUCT_CLAUSES` are critical steps.


---

## ring_hasQ

### Name of formal statement
ring_hasQ

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let ring_hasQ = new_definition `
  ring_hasQ (r:R ring)
  <=> (
    ring_char r = 0 /\
    (!n. ~(n = 0) ==> ring_unit r (ring_of_num r n))
  )
`;;
```

### Informal statement
For a ring `r` of type `R ring`, `ring_hasQ r` is true if and only if the characteristic of `r` is 0 and for all natural numbers `n`, if `n` is not equal to 0, then `ring_of_num r n` is a unit in the ring `r`.

### Informal sketch
The definition `ring_hasQ r` checks if a ring `r` contains an isomorphic copy of the rational numbers `Q`.
- The characteristic of the ring must be zero. This is the condition `ring_char r = 0`.
- Every non-zero natural number `n` can be mapped to a unit in the ring. This is the condition `!n. ~(n = 0) ==> ring_unit r (ring_of_num r n)`.

### Mathematical insight
The definition `ring_hasQ` captures the conditions necessary for a ring `r` to contain a copy of the rational numbers. The ring must have characteristic zero so that the natural numbers can be embedded. Then every non-zero natural number must have a multiplicative inverse. This implies that we can embed the rationals `p/q` in `r` by mapping it to `ring_of_num r p * inverse (ring_of_num r q)`. Note that the inverse is guaranteed to exists since `ring_of_num r q` is a unit.

### Dependencies
- Definitions:
  - `ring_char`
  - `ring_unit`
  - `ring_of_num`


---

## ring_hasQ_neg

### Name of formal statement
ring_hasQ_neg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_hasQ_neg = prove(`
  !(r:R ring) n.
  ring_hasQ r ==>
  ~(n = 0) ==>
  ring_unit r (ring_neg r (ring_of_num r n))
`,
  qed[RING_UNIT_NEG;ring_hasQ]
);;
```
### Informal statement
For all rings `r` of type `R ring` and all natural numbers `n`, if `r` has characteristic zero (i.e., `ring_hasQ r`) and `n` is not equal to zero, then `ring_neg r (ring_of_num r n)` is a unit in the ring `r` (i.e., `ring_unit r (ring_neg r (ring_of_num r n))`).

### Informal sketch
- The theorem states that the negation of a nonzero natural number in a ring with characteristic zero is a unit.
- The proof uses `RING_UNIT_NEG` which states that if `x` is not a unit, then `-x` is a unit.
- The proof also uses `ring_hasQ` which characterizes rings with characteristic zero.
- The theorem is proved by showing that under the given conditions (ring has characteristic zero and `n` is not zero), the negation of `n` is a unit.

### Mathematical insight
This theorem highlights a connection between rings of characteristic zero and units. In a ring with characteristic zero, any non-zero natural number when negated results in a unit. This has important implications when trying to define division or inverses within the ring.

### Dependencies
- Theorems: `RING_UNIT_NEG`, `ring_hasQ`


---

## numpreimages

### Name of formal statement
numpreimages

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let numpreimages = new_definition `
  numpreimages (f:X->Y) (S:X->bool) y
  = CARD {x | x IN S /\ f x = y}
`;;
```
### Informal statement
The number of preimages of `y` under the function `f`, restricted to the set `S`, is defined as the cardinality of the set of elements `x` such that `x` is in `S` and `f(x) = y`.

### Informal sketch
The definition `numpreimages` introduces a function that counts the number of elements in a subset `S` of the domain of a function `f` that map to a specific value `y` in the codomain. The definition uses the `CARD` function to determine the cardinality of the set `{x | x IN S /\ f x = y}`.

### Mathematical insight
This definition provides a way to quantify the size of the preimage of a single element `y` under a function `f`, restricted to a specific subset `S` of the domain. It is a standard concept in set theory and analysis, useful for characterizing functions and sets. The cardinality function `CARD` potentially returns a non-standard value in the infinite case, which may need careful consideration.

### Dependencies
- **Definitions:**
  - `CARD` (cardinality)
  - `IN` (set membership)


---

## image_numpreimages

### Name of formal statement
image_numpreimages

### Type of the formal statement
theorem

### Formal Content
```ocaml
let image_numpreimages = prove(`
  !S:X->bool f:X->Y.
  FINITE S ==>
  IMAGE f S
  = {y | ~(numpreimages f S y = 0)}
`,
  rw[extension_z;in_image_vw;IN_ELIM_THM;numpreimages] THEN
  intro THEN
  specialize[`S:X->bool`;`\x:X. f x = z:Y`]FINITE_RESTRICT THEN
  simp[CARD_EQ_0] THEN
  rw[EXTENSION;EMPTY;IN_ELIM_THM] THEN
  qed[]
);;
```

### Informal statement
For any set `S` of type `X -> bool` and any function `f` of type `X -> Y`, if `S` is finite, then the image of `f` applied to `S` is equal to the set of all `y` such that the number of preimages of `y` in `S` under `f` is not equal to 0.

### Informal sketch
The proof proceeds as follows:
- The theorem expands definitions of `IMAGE`, the `in_image_vw` theorem, `IN_ELIM_THM`, and `numpreimages` using rewriting.
- An assumption is introduced.
- We specialize `FINITE_RESTRICT` to `S:X->bool` and the function `\x:X. f x = z:Y` to provide finiteness of the restriction of `S`
- We simplify the expression using `CARD_EQ_0`.
- We rewrite using `EXTENSION`, `EMPTY`, and `IN_ELIM_THM`.
- The proof is completed.

### Mathematical insight
The theorem `image_numpreimages` provides a characterization of the image of a set `S` under a function `f`. It states that an element `y` is in the image of `S` under `f` if and only if there exists at least one element `x` in `S` such that `f(x) = y`. The condition `numpreimages f S y = 0` checks for the existence of such an element by counting the number of preimages of `y` in `S` under `f`. If the number of preimages is non-zero, then at least one such `x` exists, and hence `y` belongs to `IMAGE f S`.

### Dependencies
- Definitions: `IMAGE`, `numpreimages`
- Theorems: `extension_z`, `in_image_vw`, `IN_ELIM_THM`, `FINITE_RESTRICT`, `CARD_EQ_0`, `EXTENSION`, `EMPTY`


---

## numpreimages_o_permutes

### Name of formal statement
numpreimages_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let numpreimages_o_permutes = prove(`
  !S:X->bool f:X->Y g:X->X.
  FINITE S ==>
  g permutes S ==>
  numpreimages (f o g) S = numpreimages f S
`,
  rw[numpreimages;o_THM;fun_eq_thm_v] THEN
  intro THEN
  have `!s t:X. s IN {x | x IN S /\ f (g x:X) = v:Y} ==> t IN {x | x IN S /\ f (g x) = v} ==> g s = g t:X ==> s = t` [PERMUTES_INJECTIVE] THEN
  specialize[
    `S:X->bool`;
    `\x:X. f (g x:X) = v:Y`
  ]FINITE_RESTRICT THEN
  specialize[
    `g:X->X`;
    `{x:X | x IN S /\ f (g x:X) = v:Y}`
  ]CARD_IMAGE_INJ THEN
  subgoal `IMAGE g {x:X | x IN S /\ f(g x:X) = v:Y} = {x | x IN S /\ f x = v}` THENL [
    rw[EXTENSION;in_image_vw;IN_ELIM_THM] THEN
    qed[permutes]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For any set `S` of type `X -> bool`, any functions `f` of type `X -> Y` and `g` of type `X -> X`, if `S` is finite and `g` permutes `S`, then the number of preimages of `f o g` restricted to `S` is equal to the number of preimages of `f` restricted to `S`.

### Informal sketch
The proof proceeds as follows:

- Rewrite using the definition of `numpreimages`, the theorem for function composition `o_THM`, and `fun_eq_thm_v` (likely a variant of functional extensionality).
- Introduce the assumptions.
- Prove that `g` is injective on the set `{x | x IN S /\ f (g x:X) = v:Y}` using the fact that `g` permutes `S` (implying injectivity). The hypothesis `g permutes S` enables this through `PERMUTES_INJECTIVE`.
- Specialize `FINITE_RESTRICT` (finiteness of subsets) with `S` and `\x:X. f (g x:X) = v:Y`.
- Specialize `CARD_IMAGE_INJ` (cardinality of image under injection) with `g` and `{x:X | x IN S /\ f (g x:X) = v:Y}`. This employs the injectivity derived earlier.
- Show that the image of `{x | x IN S /\ f(g x:X) = v:Y}` under `g` is equal to `{x | x IN S /\ f x = v}`.
  - This is done by rewriting using `EXTENSION` to compare set membership.
  - Then rewrite using `in_image_vw` which is likely related to the definition of set image.
  - Finally rewrite using `IN_ELIM_THM` to eliminate `IN`.
  - The theorem `permutes` is used in conjunction with the rw tactic to carry out the proof.
- Conclude the proof.

### Mathematical insight
This result shows that preimages, when cardinality is considered, are invariant under permutations. This is a useful property for manipulating sets and functions in combinatorial settings. The theorem is a "warmup" for a more general result `numpreimages_permutes_o_perm`. It's likely useful when dealing with situations where the order of elements within a finite set is irrelevant.

### Dependencies
- Definitions:
  - `numpreimages`
- Theorems:
  - `o_THM`
  - `fun_eq_thm_v`
  - `PERMUTES_INJECTIVE`
  - `FINITE_RESTRICT`
  - `CARD_IMAGE_INJ`
  - `EXTENSION`
  - `in_image_vw`
  - `IN_ELIM_THM`
  - `permutes`


---

## numpreimages_permutes_o_perm

### Name of formal statement
numpreimages_permutes_o_perm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let numpreimages_permutes_o_perm = prove(`
  !A:X->bool f:X->X g:(X->X)->Y.
  FINITE A ==>
  f permutes A ==>
  numpreimages (\i:X->X. g(f o i)) (perm A)
  = numpreimages g (perm A)
`,
  rw[numpreimages;o_THM;fun_eq_thm_v] THEN
  intro THEN
  have `FINITE(perm(A:X->bool))` [finite_perm] THEN
  subgoal `IMAGE (\i. f o i) {i:X->X | i IN perm A /\ g (f o i) = v:Y} = {i | i IN perm A /\ g i = v}` THENL [
    once_rw[in_image_vw] THEN
    rw[EXTENSION;IN_IMAGE;IN_ELIM_THM] THEN
    intro THEN
    splitiff THENL [
      intro THENL [
        qed[IN;perm;PERMUTES_COMPOSE]
      ;
        simp[]
      ]
    ;
      intro THEN
      witness `inverse f:X->X o x:X->X` THEN
      have `inverse f:X->X permutes A` [PERMUTES_INVERSE] THEN
      have `f o inverse f:X->X = I` [PERMUTES_INVERSES_o] THEN
      subgoal `x:X->X = (f:X->X) o inverse f o x` THENL [
        rw[o_ASSOC] THEN
        qed[I_O_ID]
      ; pass
      ] THEN
      qed[PERMUTES_COMPOSE;IN;perm]
    ]
  ; pass
  ] THEN
  subgoal `!x y:X->X. x IN {i | i IN perm A /\ g (f o i) = v:Y} ==> y IN {i | i IN perm A /\ g (f o i) = v} ==> f o x = (f:X->X) o y ==> x = y` THENL [
    rw[IN_ELIM_THM] THEN
    have `inverse f o f:X->X = I` [PERMUTES_INVERSES_o] THEN
    subgoal `!x:X->X. x = inverse f o (f:X->X) o x` THENL [
      rw[o_ASSOC] THEN
      qed[I_O_ID]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `perm(A:X->bool)`;
    `\i:X->X. g(f:X->X o i) = v:Y`
  ]FINITE_RESTRICT THEN
  specialize[
    `\i:X->X. f:X->X o i`;
    `{i | i IN perm A /\ g(f:X->X o i) = v:Y}`
  ]CARD_IMAGE_INJ THEN
  qed[]
);;
```
### Informal statement
Given a predicate `A` on a type `X`, a function `f` from `X` to `X`, and a function `g` from `(X -> X)` to `Y`, if `A` is finite and `f` permutes `A`, then the number of preimages of `perm A` under the function `\i. g(f o i)` is equal to the number of preimages of `perm A` under the function `g`.

### Informal sketch
The proof proceeds by rewriting the goal using `numpreimages`, `o_THM`, and `fun_eq_thm_v`.

- An introductory step simplifies the goal to showing the preimages of `g` and `g o f` are the same over a `perm A`.
- The finiteness of `perm A` is stated.
- The core subgoal equates the images of the sets based on compositions and uses of `perm A`. Two directions are proved: membership in one implies membership in the other. The second direction does this by exhibiting an inverse.
- The injectivity of the function mapping `i` to `f o i` when restricted to the appropriate set is shown by using the inverse `inverse f`.
- Finiteness of the restriction to `perm A` is shown.
- Cardinality of the image of the set `{i | i IN perm A /\ g(f:X->X o i) = v:Y}` under `\i:X->X. f:X->X o i` is calculated using `CARD_IMAGE_INJ`.

### Mathematical insight
This theorem states that preimages of `perm A` are invariant under permutation, under function composition.

### Dependencies
- `numpreimages`
- `o_THM`
- `fun_eq_thm_v`
- `finite_perm`
- `in_image_vw`
- `EXTENSION`
- `IN_IMAGE`
- `IN_ELIM_THM`
- `IN`
- `perm`
- `PERMUTES_COMPOSE`
- `PERMUTES_INVERSE`
- `PERMUTES_INVERSES_o`
- `o_ASSOC`
- `I_O_ID`
- `FINITE_RESTRICT`
- `CARD_IMAGE_INJ`


---

## ring_sum_fiber_o

### Name of formal statement
ring_sum_fiber_o

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_fiber_o = prove(`
  !(r:R ring) S:X->bool f:X->Y g:Y->R y.
  FINITE {x | x IN S /\ f x = y} ==>
  g y IN ring_carrier r ==>
  ring_sum r {x | x IN S /\ f x = y} (g o f)
  = ring_mul r (ring_of_num r (numpreimages f S y)) (g y)
`,
  intro THEN
  subgoal `ring_sum r {x:X | x IN S /\ f x = y:Y} (g o f) = ring_sum r {x | x IN S /\ f x = y} (\x. g y):R` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[o_THM;BETA_THM;IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  simp[ring_sum_const] THEN
  rw[numpreimages]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `S` of type `X->bool`, any functions `f` of type `X->Y` and `g` of type `Y->R`, and any `y` of type `Y`, if the set `{x | x IN S /\ f x = y}` is finite, and `g y` is in the carrier of the ring `r`, then the ring sum over `x` in `{x | x IN S /\ f x = y}` of `g o f` is equal to the ring multiplication of the ring of the number of preimages of `f` in `S` at `y`, and `g y`.

### Informal sketch
The proof proceeds by:
- First, showing that `ring_sum r {x:X | x IN S /\ f x = y:Y} (g o f)` is equal to `ring_sum r {x | x IN S /\ f x = y} (\x. g y):R`. This is done by rewriting `g o f` to `\x. g (f x)` and using `IN_ELIM_THM` to rewrite `f x = y` to `g y`. Then use `RING_SUM_EQ` to conclude.
- Second, simplifying the expression using `ring_sum_const` which states that the ring sum of a constant function over a finite set is the ring multiplication of the ring of the cardinality of the set by the constant value.
- Third, rewriting using the definition of `numpreimages`.

### Mathematical insight
The theorem `ring_sum_fiber_o` relates the sum of a function `g o f` over the fiber of `f` at `y` to the product of `g y` and the cardinality of the fiber. This is a useful identity for simplifying sums, and it clarifies how summing `g o f` within a selection `S` relates to summing `g` at a specific value in its domain.

### Dependencies
- `ring_sum`
- `ring_carrier`
- `ring_mul`
- `ring_of_num`
- `numpreimages`
- `o_THM`
- `BETA_THM`
- `IN_ELIM_THM`
- `RING_SUM_EQ`
- `ring_sum_const`


---

## ring_product_fiber_o

### Name of formal statement
ring_product_fiber_o

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_fiber_o = prove(`
  !(r:R ring) S:X->bool f:X->Y g:Y->R y.
  FINITE {x | x IN S /\ f x = y} ==>
  g y IN ring_carrier r ==>
  ring_product r {x | x IN S /\ f x = y} (g o f)
  = ring_pow r (g y) (numpreimages f S y)
`,
  intro THEN
  subgoal `ring_product r {x:X | x IN S /\ f x = y:Y} (g o f) = ring_product r {x | x IN S /\ f x = y} (\x. g y):R` THENL [
    sufficesby RING_PRODUCT_EQ THEN
    rw[o_THM;BETA_THM;IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  simp[ring_product_const] THEN
  rw[numpreimages]
);;
```
### Informal statement
For any ring `r`, any set `S` of type `X->bool`, any functions `f:X->Y` and `g:Y->R`, and any `y` of type `Y`, if the set `{x | x IN S /\ f x = y}` is finite, and `g y` is in the carrier of the ring `r`, then the product over the set `{x | x IN S /\ f x = y}` with respect to the ring `r` of the function `g o f` is equal to the ring power in `r` of `g y` to the power of the number of preimages under `f` in `S` that map to `y`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions.
- Show that `ring_product r {x:X | x IN S /\ f x = y:Y} (g o f)` is equal to `ring_product r {x | x IN S /\ f x = y} (\x. g y):R` by showing that the functions are equal using `RING_PRODUCT_EQ` and then rewriting using `o_THM`, `BETA_THM`, `IN_ELIM_THM`.
- Simplify using `ring_product_const`.
- Rewrite with `numpreimages`.

### Mathematical insight
This theorem relates the ring product of a composition of functions over a fiber to the power of the value of the outer function at that fiber, raised to the number of elements in the fiber. This is especially useful when dealing with sums or products indexed by the preimages of a function.

### Dependencies
- `ring_product`
- `ring_product_const`
- `ring_pow`
- `numpreimages`
- `o_THM` (composition)
- `BETA_THM` (beta reduction)
- `IN_ELIM_THM`

### Porting notes (optional)
- The theorem relies on `ring_product` and `numpreimages` which are likely to have analogs in other proof assistants.
- The tactic `RING_PRODUCT_EQ` is specific to HOL Light. It asserts the equality of ring products based on the equality of their arguments (functions). In other proof assistants, one may need to prove this equality explicitly using properties of abstract rings and product/sum operators.


---

## ring_sum_o

### Name of formal statement
ring_sum_o

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_o = prove(`
  !(r:R ring) S:X->bool f:X->Y g:Y->R.
  FINITE S ==>
  (!y. y IN IMAGE f S ==> g y IN ring_carrier r) ==>
  ring_sum r S (g o f)
  = ring_sum r
      (IMAGE f S)
      (\y. ring_mul r (ring_of_num r (numpreimages f S y)) (g y))
`,
  intro THEN
  specialize[
    `r:R ring`;
    `f:X->Y`;
    `g:Y->R o f:X->Y`;
    `S:X->bool`
  ]RING_SUM_IMAGE_GEN THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  specialize[`S:X->bool`;`\x:X. f x = a:Y`]FINITE_RESTRICT THEN
  qed[ring_sum_fiber_o]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), any set `S` (of type `X->bool`), any function `f` (of type `X->Y`), and any function `g` (of type `Y->R`), if `S` is finite and for all `y` in the image of `f` restricted to `S`, `g y` is in the carrier of the ring `r`, then the ring sum of `g o f` over `S` equals the ring sum over the image of `f` restricted to `S` of the map that sends `y` to the ring product of the ring of numbers of the number of preimages of `y` under `f` restricted to `S` and `g y`.

### Informal sketch
The proof proceeds as follows:
- Intro the assumptions.
- Specialize the theorem `RING_SUM_IMAGE_GEN` with the assumptions.
- Simplify using `simp[]`.
- Suffice by `RING_SUM_EQ`.
- Rewrite using `BETA_THM` to simplify.
- Intro another assumption.
- Specialize `FINITE_RESTRICT` with `S` and `\x:X. f x = a:Y`.
- Finish proof with `qed[ring_sum_fiber_o]`.

In essence, this theorem relates the sum over a set to the sum over the image of that set under a function. This boils down to counting the number of preimages and summing over the image, weighting each element of the image by the number of preimages. It uses `RING_SUM_IMAGE_GEN` to generalize the summation over a set to the summation over the image of the set under some function.

### Mathematical insight
This theorem provides a way to compute a sum over a set by instead summing over the image of that set under a function. The key idea is to account for the multiplicity of each element in the image by multiplying it by the number of preimages. This is a standard technique in combinatorics and analysis when dealing with sums and integrals. It is important when calculating quantities that are additive over a domain that can be mapped to another domain. The `ring_sum_fiber_o` tag suggests it relates to sums over fibers of the function `f`.

### Dependencies
- Definitions: `ring_carrier`, `ring_sum`, `ring_mul`, `ring_of_num`, `numpreimages`
- Theorems: `RING_SUM_IMAGE_GEN`, `RING_SUM_EQ`, `BETA_THM`, `FINITE_RESTRICT`

### Porting notes (optional)
- The `numpreimages` function might need a specific definition in other proof assistants, as it may not be a standard library function.
- The finiteness condition `FINITE S` is crucial; ensure that the target system has a corresponding notion of finiteness and can reason about it effectively.
- The functions `ring_of_num`, `ring_mul`, `ring_carrier` and `ring_sum` should be defined according to the structure of rings in the target theorem prover to be applicable.


---

## ring_sum_o_v2

### Name of formal statement
ring_sum_o_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_o_v2 = prove(`
  !(r:R ring) S:X->bool f:X->Y g:Y->R.
  FINITE S ==>
  (!y. y IN IMAGE f S ==> g y IN ring_carrier r) ==>
  ring_sum r S (g o f)
  = ring_sum r
      {y | ~(numpreimages f S y = 0)}
      (\y. ring_mul r (ring_of_num r (numpreimages f S y)) (g y))
`,
  simp[GSYM image_numpreimages] THEN
  simp[ring_sum_o]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `S` of type `X` to boolean, any function `f` of type `X` to `Y`, and any function `g` of type `Y` to `R`, if `S` is finite and for all `y`, if `y` is in the image of `f` on `S` then `g y` is in the carrier of the ring `r`, then the ring sum of `g o f` over `S` with respect to ring `r` is equal to the ring sum with respect to ring `r` over the set of all `y` such that the number of preimages of `y` in `S` under `f` is not zero, of the function that maps `y` to the ring product in `r` of the ring of numbers in `r` of (the number of preimages of `y` in `S` under `f`) and `g y`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the left-hand side using `GSYM image_numpreimages` to express the set `{y | numpreimages f S y != 0}` as the image of `f` on `S`.
- Apply the theorem `ring_sum_o`, which relates the ring sum over a composition of functions to a ring sum over the image with a weighted sum. This directly proves the desired equality.

### Mathematical insight
This theorem generalizes the previous `ring_sum_o` theorem. It expresses a ring sum over the composition of two functions `g` and `f` in terms of a ring sum over the image of `f`. The original sum is transformed into a weighted sum over the image, where the weights are given by the multiplicities (number of preimages) of each element in the image. The condition `numpreimages f S y = 0` ensures we correctly handle cases where elements in the image have zero preimages.

### Dependencies
- `GSYM`
- `image_numpreimages`
- `ring_sum_o`
- `ring_carrier`
- `FINITE`
- `IMAGE`
- `ring_mul`
- `ring_of_num`
- `numpreimages`


---

## ring_sum_o_v3

### Name of formal statement
ring_sum_o_v3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_o_v3 = prove(`
  !(r:R ring) S:X->bool f:X->Y U:Y->bool g:Y->R.
  FINITE S ==>
  (!y. y IN U ==> g y IN ring_carrier r) ==>
  IMAGE f S SUBSET U ==>
  ring_sum r S (g o f)
  = ring_sum r U
      (\y. ring_mul r (ring_of_num r (numpreimages f S y)) (g y))
`,
  intro THEN
  have `!y:Y. y IN IMAGE (f:X->Y) S ==> g y:R IN ring_carrier r` [SUBSET] THEN
  simp[ring_sum_o_v2] THEN
  intro THEN
  simp[GSYM image_numpreimages] THEN
  specialize[
    `r:R ring`;
    `IMAGE (f:X->Y) S`;
    `U:Y->bool`;
    `\y. ring_mul r (ring_of_num r (numpreimages (f:X->Y) S y)) (g y):R`
  ](GSYM ring_sum_restrict_subset) THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM;IN_ELIM_THM] THEN
  intro THEN
  case `numpreimages (f:X->Y) S a = 0` THENL [
    subgoal `~(a IN IMAGE (f:X->Y) S)` THENL [
      simp[image_numpreimages;IN_ELIM_THM]
    ; pass
    ] THEN
    simp[RING_OF_NUM_0;RING_MUL_LZERO]
  ; pass
  ] THEN
  subgoal `a IN IMAGE (f:X->Y) S` THENL [
    simp[image_numpreimages;IN_ELIM_THM]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any sets `S` of type `X->bool` and `U` of type `Y->bool`, any functions `f` of type `X->Y` and `g` of type `Y->R`, the following holds: If `S` is finite and for all `y`, if `y` is in `U`, then `g y` is in the carrier set of the ring `r`, and the image of `S` under `f` is a subset of `U`, then the ring sum over `S` of the composition `g o f` is equal to the ring sum over `U` of the function that maps `y` to the ring product of `ring_of_num r` applied to the number of preimages of `y` in `S` under `f`, and `g y`.

### Informal sketch
The theorem states a transformation of a ring sum over a set `S` to a ring sum over a set `U` where `U` contains the image of `S` under a function `f`. The general strategy involves relating the sums by considering preimages.
- Intro the assumptions.
- Use the subset assumption to show for all `y`, if `y` is in the image of `f` applied to `S`, then `g y` is in the ring carrier of `r`.
- Simplify using `ring_sum_o_v2`.
- Simplify using `GSYM image_numpreimages` to transform the expression.
- Specialize `ring_sum_restrict_subset` with appropriate parameters `r`, the image of `f` applied to `S`, `U`, and a function involving `ring_mul`, `ring_of_num`, `numpreimages`, and `g`.
- Simplify.
- Reduce the goal to proving an equality of summands using `RING_SUM_EQ`.
- Rewrite using `BETA_THM` and `IN_ELIM_THM`.
- Perform case analysis on `numpreimages (f:X->Y) S a = 0`.
  - If `numpreimages (f:X->Y) S a = 0`, show equivalently `~(a IN IMAGE (f:X->Y) S)`.
  - Simplify to prove the goal: `ring_mul r (ring_of_num r 0) (g a) = ring_mul r (ring_of_num r (numpreimages (f:X->Y) S a)) (g a)`. Reduce it using simplification rules for zero.
  - If instead, `a IN IMAGE (f:X->Y) S`, the goal follows from the definition of `numpreimages`.

### Mathematical insight
This theorem provides a way to rewrite a ring sum over a set `S` by transforming the summing function and changing the set over which the sum is taken. The transformation involves the number of preimages. The theorem is useful for relating sums over different domains when there is a function mapping one domain to another.

### Dependencies
- `ring_sum_o_v2`
- `image_numpreimages`
- `ring_sum_restrict_subset`
- `RING_SUM_EQ`
- `RING_OF_NUM_0`
- `RING_MUL_LZERO`
- `BETA_THM`
- `IN_ELIM_THM`
- `GSYM`
- `SUBSET`
### Porting notes (optional)
The theorem relies on the `numpreimages` function, which calculates the number of preimages of a given element under a function. If the target proof assistant does not have such a function, it will need to be defined first. The `ring_sum_restrict_subset` is called with a set given by `IMAGE (f:X->Y) S `. The `ring_sum_o_v2` rule involves a composition of function and requires a ring structure, so the equivalent concepts must be available in the target system.


---

## ring_product_o

### Name of formal statement
ring_product_o

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_o = prove(`
  !(r:R ring) S:X->bool f:X->Y g:Y->R.
  FINITE S ==>
  (!y. y IN IMAGE f S ==> g y IN ring_carrier r) ==>
  ring_product r S (g o f)
  = ring_product r
      (IMAGE f S)
      (\y. ring_pow r (g y) (numpreimages f S y))
`,
  intro THEN
  specialize[
    `r:R ring`;
    `f:X->Y`;
    `g:Y->R o f:X->Y`;
    `S:X->bool`
  ]RING_PRODUCT_IMAGE_GEN THEN
  simp[] THEN
  sufficesby RING_PRODUCT_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  specialize[`S:X->bool`;`\x:X. f x = a:Y`]FINITE_RESTRICT THEN
  qed[ring_product_fiber_o]
);;
```

### Informal statement
Given a ring `r` of type `R ring`, a set `S` of type `X->bool`, a function `f` of type `X->Y`, and a function `g` of type `Y->R`, if `S` is finite and for all `y`, if `y` is in the image of `f` restricted to `S`, then `g y` is in the carrier of the ring `r`, then the ring product over `S` of the function `g o f` (i.e., `g` composed with `f`) is equal to the ring product over the image of `f` restricted to `S` of the function that maps `y` to `ring_pow r (g y) (numpreimages f S y)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions and specialize the theorem `RING_PRODUCT_IMAGE_GEN`.
- Simplify the goal.
- Reduce the goal to showing `ring_product r S (g o f) = ring_product r (IMAGE f S) (\y. ring_pow r (g y) (numpreimages f S y))` by using `RING_PRODUCT_EQ`.
- Apply beta reduction.
- Introduce a variable.
- Specialize `FINITE_RESTRICT` to reach the conclusion by `ring_product_fiber_o`. The goal is equivalent to showing `ring_product r S (g o f) = ring_product r (IMAGE f S) (\y. ring_pow r (g y) (numpreimages f S y))`.

### Mathematical insight
This theorem provides a way to compute a ring product over a set `S` by instead computing a ring product over the image of `S` under a function `f`. The function being summed in the latter product involves the number of preimages of each element in the image of `f`. This is a useful result because it sometimes allows us to reduce the complexity of the set over which we are taking the product.

### Dependencies
- `R ring`
- `FINITE`
- `IMAGE`
- `ring_carrier`
- `ring_product`
- `ring_pow`
- `numpreimages`
- `RING_PRODUCT_IMAGE_GEN`
- `RING_PRODUCT_EQ`
- `BETA_THM`
- `FINITE_RESTRICT`
- `ring_product_fiber_o`


---

## ring_product_o_v2

### Name of formal statement
ring_product_o_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_o_v2 = prove(`
  !(r:R ring) S:X->bool f:X->Y g:Y->R.
  FINITE S ==>
  (!y. y IN IMAGE f S ==> g y IN ring_carrier r) ==>
  ring_product r S (g o f)
  = ring_product r
      {y | ~(numpreimages f S y = 0)}
      (\y. ring_pow r (g y) (numpreimages f S y))
`,
  simp[GSYM image_numpreimages] THEN
  simp[ring_product_o]
);;
```
### Informal statement
For any ring `r` (with carrier set implicitly defined), any set `S` of type `X->bool`, any function `f` from `X` to `Y`, and any function `g` from `Y` to `R`, if `S` is finite, and for every `y` such that `y` is in the image of `f` restricted to `S`, `g y` is in the carrier of the ring `r`, then the product in `r` of `g o f` over `S` is equal to the product in `r` of `ring_pow r (g y) (numpreimages f S y)` over the set of `y` such that the number of preimages of `y` in `S` under `f` is not zero.

### Informal sketch
The proof proceeds as follows:
- First, apply simplification using goal-directed symmetric rewriting (`GSYM`) on the lemma `image_numpreimages`.
- Then simplify using the theorem `ring_product_o`.

### Mathematical insight
This theorem provides an alternative way to compute the ring product of a function composed with another function over a set. It relates the ring product over the original set to a ring product over the image of that set under the first function. The value at each point in the image is raised to the power of the number of preimages of that point. This is useful when the image of the set is smaller than the original set, potentially simplifying the computation of the product.

### Dependencies
- `image_numpreimages`
- `ring_product_o`


---

## ring_squarefree

### Name of formal statement
ring_squarefree

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let ring_squarefree = new_definition `
  ring_squarefree(r:R ring) a
  <=>
  (!b. b IN ring_carrier r ==>
   ring_divides r a (ring_mul r b b) ==>
   ring_divides r a b
  )
`;;
```

### Informal statement
For a ring `r` and an element `a`, `a` is squarefree in `r` if and only if for all `b` in the carrier of `r`, if `b*b` divides `a` in `r`, then `b` divides `a` in `r`.

### Informal sketch
The definition introduces the concept of a squarefree element within a ring. The definition states that an element `a` is squarefree in ring `r` if whenever the square of an element `b` in the carrier of the ring divides `a`, then `b` itself divides `a`.

*   Start with the goal `ring_squarefree(r) a <=> (!b. b IN ring_carrier r ==> ring_divides r a (ring_mul r b b) ==> ring_divides r a b)`.
*   The definition introduces the term `ring_squarefree(r) a` as an abbreviation for the condition on the right-hand side.

### Mathematical insight
This definition formalizes the notion of a squarefree element in a ring. In integers, a number `n` is squarefree if it is not divisible by any perfect square other than 1. This definition generalizes this concept to arbitrary rings, using the ring's multiplication and divisibility relations. Squarefree elements are important in various areas of mathematics, including number theory and algebraic geometry, and are useful for proving uniqueness results.

### Dependencies
*   Definitions: `ring_carrier`, `ring_divides`, `ring_mul`

### Porting notes (optional)
*   The definition relies on having a defined ring structure with associated carrier, multiplication, and divisibility relations. The porter needs to ensure that these structures are properly defined in the target proof assistant before porting this definition.
*   The explicit quantification of the carrier and the use of `ring_divides` and `ring_mul` may need adjustments depending on how rings and their operations are represented in other proof assistants (e.g., type classes in Isabelle/HOL or Coq).


---

## not_squarefree_if_divisible_by_square

### Name of formal statement
not_squarefree_if_divisible_by_square

### Type of the formal statement
theorem

### Formal Content
```ocaml
let not_squarefree_if_divisible_by_square = prove(`
  !(r:R ring) a b.
  integral_domain r ==>
  ~(a = ring_0 r) ==>
  b IN ring_carrier r ==>
  ~(ring_unit r b) ==>
  ring_divides r (ring_mul r b b) a ==>
  ~(ring_squarefree r a)
`,
  intro THEN
  have `a IN ring_carrier(r:R ring)` [ring_divides] THEN
  have `b IN ring_carrier(r:R ring)` [ring_unit] THEN
  choose `q:R` `q IN ring_carrier(r:R ring) /\ a = ring_mul r (ring_mul r b b) q` [ring_divides] THEN
  have `q IN ring_carrier(r:R ring)` [] THEN
  have `a = ring_mul(r:R ring) (ring_mul r b b) q` [] THEN
  recall(RING_RULE `a = ring_mul(r:R ring) (ring_mul r b b) q ==> ring_mul r (ring_mul r b q) (ring_mul r b q) = ring_mul r a q`) THEN
  have `ring_divides(r:R ring) a (ring_mul r (ring_mul r b q) (ring_mul r b q))` [ring_divides;RING_MUL] THEN
  have `ring_divides(r:R ring) a (ring_mul r b q)` [ring_squarefree;RING_MUL] THEN
  choose `u:R` `u IN ring_carrier(r:R ring) /\ ring_mul r b q = ring_mul r a u` [ring_divides] THEN
  have `u IN ring_carrier(r:R ring)` [] THEN
  have `ring_mul(r:R ring) b q = ring_mul r a u` [] THEN
  recall(RING_RULE `a = ring_mul(r:R ring) (ring_mul r b b) q /\ ring_mul r b q = ring_mul r a u ==> ring_mul r a (ring_1 r) = ring_mul r a (ring_mul r b u)`) THEN
  have `ring_1(r:R ring) = ring_mul r b u` [INTEGRAL_DOMAIN_MUL_LCANCEL;RING_1;RING_MUL] THEN
  qed[ring_unit]
);;
```
### Informal statement
In a ring `r` that is an integral domain, if `a` and `b` are elements of the ring, `a` is not the zero element, `b` is not a unit, and `a` is divisible by the square of `b` (i.e., `b * b`), then `a` is not squarefree.

### Informal sketch
The proof proceeds as follows:
- Assume `r` is an integral domain, `a` is a non-zero element of `r`, `b` is an element of `r` that is not a unit, and `a` is divisible by `b * b`.
- From `ring_divides`, obtain an element `q` in `r` such that `a = (b * b) * q`.
- Assume, for the sake of contradiction, that `a` is squarefree. This means if `a` is divisible by any `x`, then `a` is not divisible by `x * x`.
- Since `a = (b * b) * q`, it follows that `a` is divisible by `b * q`.
- By the assumption that `a` is squarefree, and since `a` is divisible by `b*q`, we get that `a` cannot be divisible by `(b*q)*(b*q)`.
- But since `a = (b * b) * q`, then `a*q = (b*q)*(b*q)`, then `a` is divisible by `(b*q)`.
- The definition of squarefree gives `(b*q)` is not a divisor of `a` then `b` is a ring unit which leads to a contradiction to the assumptions since `b` is not a ring unit.
Therefore, `a` is not squarefree.

### Mathematical insight
This theorem states a sufficient condition for a ring element to not be squarefree. Namely, if an element `a` is divisible by the square of a non-unit element `b`, then `a` is not squarefree. This result is a fundamental property used in algebraic number theory for identifying non-squarefree elements in integral domains.

### Dependencies
- `integral_domain`
- `ring_0`
- `ring_carrier`
- `ring_unit`
- `ring_divides`
- `ring_mul`
- `ring_squarefree`
- `RING_RULE` : This is a meta-theorem for equational reasoning in rings
- `INTEGRAL_DOMAIN_MUL_LCANCEL`
- `RING_1`


---

## product_coprime_primes_divides_waterfall

### Name of formal statement
product_coprime_primes_divides_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_coprime_primes_divides_waterfall = prove(`
  !(r:R ring).
  !P.
  FINITE P ==>
  P SUBSET ring_carrier r ==>
  !b.
  b IN ring_carrier r ==>
  (!p. p IN P ==> ring_prime r p) ==>
  (!p q. p IN P ==> q IN P ==> ring_divides r p q ==> p = q) ==>
  (!p. p IN P ==> ring_divides r p b) ==>
  ring_divides r (ring_product r P I) b
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    simp[RING_PRODUCT_CLAUSES] THEN
    qed[RING_DIVIDES_1]
  ;
    have `(x:R) IN x INSERT P` [IN_INSERT] THEN
    have `(x:R) IN ring_carrier r` [SUBSET] THEN
    have `I (x:R) = x` [I_THM] THEN
    have `I (x:R) IN ring_carrier r` [] THEN
    have `ring_product(r:R ring) (x INSERT P) I = ring_mul r x (ring_product r P I)` [RING_PRODUCT_CLAUSES] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `ring_divides r (x:R) b` [] THEN
    choose `c:R` `c IN ring_carrier r /\ (b:R) = ring_mul r x c` [ring_divides] THEN
    subgoal `!q:R. q IN P ==> ring_divides r q c` THENL [
      intro THEN
      have `q:R IN x INSERT P` [IN_INSERT] THEN
      have `q:R IN ring_carrier r` [SUBSET] THEN
      have `ring_divides r (q:R) b` [] THEN
      have `ring_divides r (q:R) (ring_mul r x c)` [] THEN
      have `~(ring_divides r (q:R) x)` [] THEN
      qed[ring_prime]
    ; pass
    ] THEN
    have `!q:R. q IN P ==> ring_prime r q` [IN_INSERT] THEN
    have `!p q:R. p IN P ==> q IN P ==> ring_divides r p q ==> p = q` [IN_INSERT] THEN
    have `P SUBSET (P:R->bool)` [SUBSET_REFL] THEN
    have `P SUBSET ring_carrier(r:R ring)` [SUBSET_INSERT;SUBSET_TRANS] THEN
    have `c:R IN ring_carrier r` [] THEN
    specialize[`c:R`](UNDISCH(know `P SUBSET ring_carrier(r:R ring) ==> (!b. b IN ring_carrier r ==> (!p. p IN P ==> ring_prime r p) ==> (!p q. p IN P ==> q IN P ==> ring_divides r p q ==> p = q) ==> (!p. p IN P ==> ring_divides r p b) ==> ring_divides r (ring_product r P I) b)`)) THEN
    qed[RING_DIVIDES_REFL;RING_DIVIDES_MUL2]
  ]
);;
```
### Informal statement
For any ring `r`, given a finite set `P` which is a subset of the carrier of `r`, and given an element `b` in the carrier of `r`; if every element `p` of `P` is prime in the ring `r`, and if for every `p` and `q` in `P`, `p` divides `q` implies `p` equals `q`, and if every element `p` of `P` divides `b`; then the product of all elements in `P` (using the ring's multiplication and the identity element) divides `b`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `P`.

- **Base Case:** If `P` is empty, then the ring product of the empty set is the identity `I` of the ring `r`, and `I` divides everything (specifically, `b`).
- **Inductive Step:** Suppose `P` is a nonempty finite set. Then `P` can be written as `x INSERT P'`, where `x` is an element of `P` and `P'` is a subset of `P`.
    - We have `ring_product r (x INSERT P') I = ring_mul r x (ring_product r P' I)`.
    - Since `x` is in `P`, then `x` divides `b`. Therefore, we can express `b` as `ring_mul r x c` for some `c` in the ring carrier.
    - The goal is to show that `ring_product r (x INSERT P') I` divides `b`, that is, `ring_mul r x (ring_product r P' I)` divides `ring_mul r x c`. It remains to show that `ring_product r P' I` divides `c`.
    - We need to establish that any `q` in `P'` divides `c`.
    - We know `q` divides `b = ring_mul r x c`.
    - If `q` does not divide `x`, then, given that `q` is prime, `q` must divide `c`.
    - Since `q` is in `P'`, and therefore in `P`, we have `!p q. p IN P ==> q IN P ==> ring_divides r p q ==> p = q`.
    - By the induction hypothesis, `ring_product r P' I` divides `c`.
    - Thus, since `x` divides `b`, and `ring_product r P' I` divides `c`, then `ring_mul r x (ring_product r P' I)` divides `ring_mul r x c` which is `b`.

### Mathematical insight
This theorem states that if a number `b` is divisible by a set of coprime primes, then it is divisible by their product. This is a fundamental result in number theory that connects divisibility, primality, and products. The condition that the primes are coprime (`ring_divides r p q ==> p = q`) is crucial, as it prevents overcounting of prime factors.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `RING_DIVIDES_1`
- `IN_INSERT`
- `SUBSET`
- `I_THM`
- `RING_DIVIDES`
- `ring_prime`
- `SUBSET_REFL`
- `SUBSET_INSERT`
- `SUBSET_TRANS`
- `RING_DIVIDES_REFL`
- `RING_DIVIDES_MUL2`

### Porting notes (optional)
- The induction on finite sets may need special consideration in other proof assistants, depending on their support for set theory and finiteness.
- The definition of `ring_prime` and `ring_divides` needs to be available, along with the properties of rings and their carriers.


---

## product_coprime_primes_divides

### Name of formal statement
product_coprime_primes_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_coprime_primes_divides = prove(`
  !(r:R ring) P b.
  P SUBSET ring_carrier r ==>
  FINITE P ==>
  b IN ring_carrier r ==>
  (!p. p IN P ==> ring_prime r p) ==>
  (!p q. p IN P ==> q IN P ==> ring_divides r p q ==> p = q) ==>
  (!p. p IN P ==> ring_divides r p b) ==>
  ring_divides r (ring_product r P I) b
`,
  intro THEN
  ASSUME_TAC(ISPECL[`b:R`](UNDISCH_ALL(ISPECL[`r:R ring`;`P:R->bool`]product_coprime_primes_divides_waterfall))) THEN
  qed[]
);;
```
### Informal statement
For any ring `r` with carrier `ring_carrier r`, any set `P` which is a subset of `ring_carrier r`, and any element `b` in `ring_carrier r`, if `P` is finite, every element `p` in `P` is prime in the ring `r`, the only elements `p` and `q` in `P` such that `p` divides `q` in `r` are those where `p` equals `q`, and every element `p` in `P` divides `b` in `r`, then the product of all elements in `P` (with respect to the ring `r`) divides `b` in `r`. The product uses the identity `I` element of the ring as the initial value.

### Informal sketch
The proof proceeds by induction on the size of the finite set `P`.
- Base Case: If `P` is empty, then the product of the elements in `P` is the identity `I` of the ring `r`. Since every element in the empty set `P` divides `b`, and there are no elements in the empty set, trivially every such element divides `b`. So `I` must divide `b`.
- Inductive Step: Assume the theorem holds for sets of size `n`. Consider a set `P` of size `n+1`. Pick an arbitrary element `p` from `P`. Let `P'` = `P` \ {`p`}. By assumption, `P'` is finite and all its elements are prime. By assumption, any element `p` in `P` divides `b`. By assumption, no distinct elements `p, q` in `P` can divide each other. Furthermore, the product of elements in `P'` also divides `b`. The product of `P` can be expressed as `ring_product r P I = ring_mult r p (ring_product r P' I)`. Because `p` is coprime to the `ring_product r P' I` and `p` divides `b` and `ring_product r P' I` divides `b`, we have that `ring_product r P I` divides an appropriate multiple of `b`, from which it follows that it divides `b`.
The proof uses `ASSUME_TAC` with an assumption derived through repeated specialization of the thm `product_coprime_primes_divides_waterfall`.

### Mathematical insight
This theorem formalizes the idea that if a finite set of coprime primes each divides some element, then their product also divides that element. This is a fundamental principle in number theory and ring theory, often used in factorization arguments and modular arithmetic.

### Dependencies
- `ring_carrier`
- `ring_prime`
- `ring_divides`
- `FINITE`
- `ring_product`
- `product_coprime_primes_divides_waterfall`
- `ring_mult`
- `I`

### Porting notes (optional)
- The proof relies on properties of finite sets and divisibility in rings. Ensure that the target proof assistant has well-developed libraries for these concepts. The inductive strategy should be straightforward to implement in most proof assistants.
- The key is unpacking `product_coprime_primes_divides_waterfall` correctly via repeated specialization, it's what provides the inductive argument.


---

## ring_squarefree_if_product_coprime_primes

### Name of formal statement
ring_squarefree_if_product_coprime_primes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_if_product_coprime_primes = prove(`
  !(r:R ring) P.
  P SUBSET ring_carrier r ==>
  FINITE P ==>
  (!p. p IN P ==> ring_prime r p) ==>
  (!p q. p IN P ==> q IN P ==> ring_divides r p q ==> p = q) ==>
  ring_squarefree r (ring_product r P I)
`,
  rw[ring_squarefree] THEN
  intro THEN
  subgoal `!p:R. p IN P ==> ring_divides r p (ring_product r P I)` THENL [
    intro THEN
    have `(p:R) IN ring_carrier r` [SUBSET] THEN
    have `I (p:R) = p` [I_THM] THEN
    have `I (p:R) IN ring_carrier r` [] THEN
    have `ring_product(r:R ring) {p} I = p` [RING_PRODUCT_SING] THEN
    have `FINITE {p:R}` [FINITE_SING] THEN
    have `{p:R} SUBSET P` [SUBSET;IN_SING] THEN
    qed[RING_DIVIDES_PRODUCT_SUBSET]
  ; pass
  ] THEN
  have `!p:R. p IN P ==> ring_divides r p (ring_mul r b b)` [RING_DIVIDES_TRANS;RING_MUL] THEN
  have `!p:R. p IN P ==> ring_divides r p b` [ring_prime] THEN
  specialize[`r:R ring`;`P:R->bool`;`b:R`]product_coprime_primes_divides THEN
  qed[]
);;
```

### Informal statement
For any ring `r`, and any set `P` of elements of `r`'s carrier, if `P` is finite, all elements of `P` are prime in `r`, for any two elements `p` and `q` in `P`, if `p` divides `q` in `r`, then `p = q`, then the product of `P` with respect to the identity `I` is squarefree in `r`.

### Informal sketch
The proof proceeds as follows:
- Start by expanding the definition of `ring_squarefree`.
- Introduce assumptions.
- Prove that for every `p` in `P`, `p` divides the product of `P` with respect to `I`.
  - Take an element `p` in `P`.
  - Show that `p` belongs to `r`'s carrier.
  - Use `I_THM` to get `I(p) = p`.
  - Deduce that `I(p)` is in ring carrier `r`.
  - Observe that the product of the singleton set `{p}` with respect to `I` is `p` using `RING_PRODUCT_SING`.
  - Note that `{p}` is finite using `FINITE_SING`.
  - Note that `{p}` is a subset of `P` using `SUBSET; IN_SING`.
  - Use `RING_DIVIDES_PRODUCT_SUBSET` to conclude that `p` divides the product of `P` with respect to `I`.
- Prove that for all `p` in `P`, `p` divides `b*b` where `b` is `ring_product r P I` by transitivity using `RING_DIVIDES_TRANS` and `RING_MUL`. Where `RING_MUL` is essentially `b * b = ring_mul r b b`.
- Prove that for all `p` in `P`, `p` divides `b` using the `ring_prime` assumption.
- Specialize `product_coprime_primes_divides` with `r`, `P`, and `b`, and apply.
- Conclude the proof.

### Mathematical insight
This theorem states that the product of a finite set of distinct prime elements in a ring is squarefree. The condition `(!p q. p IN P ==> q IN P ==> ring_divides r p q ==> p = q)` ensures that the primes are distinct. This is a standard result in ring theory.

### Dependencies
- `ring_squarefree`
- `ring_prime`
- `ring_divides`
- `RING_DIVIDES_PRODUCT_SUBSET`
- `product_coprime_primes_divides`
- `I_THM`
- `RING_PRODUCT_SING`
- `FINITE_SING`
- `RING_DIVIDES_TRANS`
- `RING_MUL`

### Porting notes (optional)
The theorem relies on the definition of `ring_squarefree`, `ring_prime`, and `ring_divides` within the HOL Light ring theory. Ensure that these definitions are ported consistently to the target proof assistant. The tactic `specialize` might have a different syntax or equivalent in other systems. The `have` tactic will have to be carefully considered when translated to other provers as it is combining different rules, you will therefore need to identify the steps and apply these different tactics on their own to generate the proof.


---

## ring_squarefree_if_product_coprime_primes_indexed

### Name of formal statement
ring_squarefree_if_product_coprime_primes_indexed

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_if_product_coprime_primes_indexed = prove(`
  !(r:R ring) S (f:X->R).
  FINITE S ==>
  (!s:X. s IN S ==> f s IN ring_carrier r) ==>
  (!s:X. s IN S ==> ring_prime r (f s)) ==>
  (!s t. s IN S ==> t IN S ==> ring_divides r (f s) (f t) ==> s = t) ==>
  ring_squarefree r (ring_product r S f)
`,
  intro THEN
  def `P:R->bool` `IMAGE (f:X->R) S` THEN
  have `FINITE (P:R->bool)` [FINITE_IMAGE] THEN
  havetac `(P:R->bool) SUBSET ring_carrier r`
    (rw[SUBSET;EXTENSION] THEN qed[IN_IMAGE]) THEN
  havetac `!p:R. p IN P ==> ring_prime r p`
    (rw[SUBSET;EXTENSION] THEN qed[IN_IMAGE]) THEN
  havetac `!p q:R. p IN P ==> q IN P ==> ring_divides r p q ==> p = q`
    (rw[SUBSET;EXTENSION] THEN qed[IN_IMAGE]) THEN
  specialize[`r:R ring`;`P:R->bool`]ring_squarefree_if_product_coprime_primes THEN
  have `!s t:X. s IN S ==> t IN S ==> f s = f t:R ==> s = t` [RING_DIVIDES_REFL] THEN
  specialize[`r:R ring`;`f:X->R`;`I:R->R`;`S:X->bool`]RING_PRODUCT_IMAGE THEN
  qed[I_O_ID]
);;
```

### Informal statement
For any ring `r`, any set `S`, and any function `f` from `X` to `r`, if `S` is finite, if every element `s` in `S` maps to an element `f s` in the carrier of the ring `r`, if for every `s` in `S`, `f s` is a prime element in the ring `r`, and if for any `s` and `t` in `S`, if `f s` divides `f t` in the ring `r`, then `s` equals `t`, then the product of the elements `f s` for `s` in `S` is squarefree in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions and define a new set `P` as the image of `S` under the function `f`. `IMAGE (f:X->R) S`
- Show that the set `P` is finite using `FINITE_IMAGE`.
- Show that `P` is a subset of the carrier of the ring `r`. This uses the fact that `f s` is in the ring carrier for all `s` in `S`.
- Show that every element `p` in `P` is a prime element in the ring `r`. This uses the fact that `f s` is prime for all `s` in `S`.
- Show that if `p` and `q` are in `P` and `p` divides `q` in the ring `r`, then `p` equals `q`. This uses the fact that if `f s` divides `f t` then `s = t`, and `f` is injective.
- Specialize the theorem `ring_squarefree_if_product_coprime_primes` to the particular ring `r` and the set `P`.
- Show that if `f s = f t` for `s` and `t` in `S`, then `s = t`. This effectively shows that `f` is injective on `S` which is a consequence of `RING_DIVIDES_REFL`.
- Specialize `RING_PRODUCT_IMAGE` to `r`,`f`,`I` and `S`
- Conclude by applying the specialized `ring_squarefree_if_product_coprime_primes` and `RING_PRODUCT_IMAGE`. This allows us to prove `ring_squarefree r (ring_product r S f)` because the assumptions guarantee that we have a finite set of coprime primes whose product we want to show is squarefree.

### Mathematical insight
The theorem provides a condition under which a product of elements in a ring is squarefree. Specifically, if we have a finite set `S` and a function `f` that maps elements of `S` to prime elements in a ring `r` such that `f` is injective, then the product of the elements in the image of `S` under `f` is squarefree. This generalizes the idea that a product of distinct primes is squarefree to the setting of a general ring. The condition that `f` is injective guarantees that the prime elements we are multiplying are distinct.

### Dependencies
- Theorems:
    - `ring_squarefree_if_product_coprime_primes`
    - `RING_PRODUCT_IMAGE`
- Definitions:
    - `ring_carrier`
    - `ring_prime`
    - `ring_divides`
    - `ring_squarefree`
    - `ring_product`

### Porting notes (optional)
- Porting to other provers may require careful attention to the definition of `FINITE` sets and the corresponding finiteness theorems. Additionally, the injectivity requirement and its derivation from `RING_DIVIDES_REFL` should be recreated.


---

## ring_squarefree_if_unit

### Name of formal statement
ring_squarefree_if_unit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_if_unit = prove(`
  !(r:R ring) p.
  ring_unit r p ==> ring_squarefree r p
`,
  rw[ring_squarefree] THEN
  qed[RING_UNIT_DIVIDES_ANY]
);;
```
### Informal statement
For any ring `r` and any element `p` in the ring `r`, if `p` is a unit in the ring `r`, then `p` is squarefree in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- We start with the definition of `ring_squarefree`.
- The goal is to prove that if `p` is a unit in the ring `r`, then `p` is squarefree in `r`.
- Apply `RING_UNIT_DIVIDES_ANY` to establish that if `p` is a ring unit, `p` divides anything.

### Mathematical insight
The theorem states that any unit in a ring is squarefree. In other words, a unit cannot be divisible by the square of any non-unit element. This is because units have multiplicative inverses, so they can "cancel out" any square factor.

### Dependencies
- Definitions: `ring_squarefree`
- Theorems: `RING_UNIT_DIVIDES_ANY`


---

## ring_squarefree_if_prime

### Name of formal statement
ring_squarefree_if_prime

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_if_prime = prove(`
  !(r:R ring) p.
  ring_prime r p ==> ring_squarefree r p
`,
  intro THEN
  have `p:R IN ring_carrier r` [ring_prime] THEN
  have `{p:R} SUBSET ring_carrier r` [SUBSET;IN_SING] THEN
  have `FINITE {p:R}` [FINITE_SING] THEN
  have `!q:R. q IN {p} ==> ring_prime r q` [IN_SING] THEN
  have `!q x:R. q IN {p} ==> x IN {p} ==> ring_divides r q x ==> q = x` [IN_SING] THEN
  specialize[`r:R ring`;`{p:R}`]ring_squarefree_if_product_coprime_primes THEN
  qed[RING_PRODUCT_SING;I_THM]
);;
```
### Informal statement
For any ring `r` and element `p`, if `p` is a prime element in the ring `r`, then `p` is a squarefree element in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a prime element in the ring `r`.
- Deduce that `p` is an element in `ring_carrier r`.
- Construct the singleton set `{p:R}`, which is a subset of `ring_carrier r`.
- The singleton set `{p:R}` is finite.
- All elements `q` in `{p}` are prime elements in the ring `r`.
- For all elements `q` and `x` in `{p}`, if `q` divides `x` in the ring `r`, then `q = x`.
- Specialize the theorem `ring_squarefree_if_product_coprime_primes` with ring `r` and the singleton set `{p}`.
- Apply `RING_PRODUCT_SING` and `I_THM` to conclude that `p` is a squarefree element in the ring `r`.

### Mathematical insight
The theorem captures the basic intuition that a prime element cannot have any square factors other than 1 (or units), and thus it is squarefree. This is a fundamental property used in unique factorization domains.

### Dependencies
- Theorems:
  - `ring_squarefree_if_product_coprime_primes`

- Definitions:
  - `ring_prime`
  - `ring_squarefree`
  - `ring_carrier`
  - `ring_divides`

- Other:
  - `IN_SING`
  - `SUBSET`
  - `FINITE_SING`
  - `RING_PRODUCT_SING`
  - `I_THM`

### Porting notes (optional)
The most challenging part may be in finding existing theorems that capture the behaviour of `ring_squarefree_if_product_coprime_primes`. The handling of sets and finiteness may also differ among systems. Make sure to find analogs for `IN_SING`, `SUBSET`, `FINITE_SING` and `RING_PRODUCT_SING`.


---

## ring_coprime_if_unit

### Name of formal statement
ring_coprime_if_unit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_coprime_if_unit = prove(`
  !(r:R ring) a b.
  ring_unit r a ==>
  b IN ring_carrier r ==>
  (ring_coprime r (a,b) /\ ring_coprime r (b,a))
`,
  rw[ring_coprime] THEN
  qed[ring_unit;RING_UNIT_DIVISOR]
);;
```
### Informal statement
For any ring `r` and elements `a` and `b`, if `a` is a unit in the ring `r` and `b` is in the carrier of the ring `r`, then `a` and `b` are coprime, and `b` and `a` are coprime.

### Informal sketch
The proof proceeds as follows:
- The definition of `ring_coprime` is expanded using `rw[ring_coprime]`.
- The subsequent proof is handled automatically using `qed[ring_unit;RING_UNIT_DIVISOR]`. This relies on the fact that if `a` is a unit it has an inverse which can be used to show that the ideal generated by `a` and `b` is equivalent to the entire ring `r`.

### Mathematical insight
This theorem states a fundamental property of coprime elements in a ring. Specifically, if one of the elements is a unit, then it is coprime with every element in the ring.

### Dependencies
- Definitions: `ring_coprime`, `ring_unit`, `ring_carrier`
- Theorems: `RING_UNIT_DIVISOR`


---

## ring_product_divides_factor_by_factor

### Name of formal statement
ring_product_divides_factor_by_factor

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_divides_factor_by_factor = prove(`
  !(r:R ring) (f:X->R) (g:X->R) S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_divides r (f s) (g s)) ==>
  ring_divides r (ring_product r S f) (ring_product r S g)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  simp[RING_PRODUCT_CLAUSES] THEN
  intro THENL [
    qed[RING_DIVIDES_1;RING_1]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    have `!s:X. s IN S ==> f s IN ring_carrier(r:R ring)` [ring_divides] THEN
    have `!s:X. s IN S ==> g s IN ring_carrier(r:R ring)` [ring_divides] THEN
    have `f(x:X) IN ring_carrier(r:R ring)` [ring_divides] THEN
    have `g(x:X) IN ring_carrier(r:R ring)` [ring_divides] THEN
    have `ring_divides (r:R ring) (f(x:X)) (g(x:X))` [] THEN
    qed[RING_DIVIDES_MUL2]
  ]
);;
```
### Informal statement
For any ring `r` (with carrier `R`), any functions `f` and `g` from a type `X` to `R`, and any set `S` of type `X`, if `S` is finite and for all `s` in `S`, `r` divides `f s` into `g s`, then `r` divides the ring product of `f s` over `S` into the ring product of `g s` over `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: When `S` is empty, the ring product is `ring_1`, so we need to show that `ring_divides r ring_1 ring_1`, which follows directly since `ring_1` divides itself.
- Inductive step: Assume that for any set `S'` such that `(x INSERT S')` is finite, the hypothesis holds for all subsets of `x INSERT S'`. Then we need to show that `ring_divides r (ring_product r (x INSERT S') f) (ring_product r (x INSERT S') g)`, given that for all `s` in `x INSERT S'`, `ring_divides r (f s) (g s)`.
  - From the assumption `!s:X. s IN S ==> ring_divides r (f s) (g s)`, we have `ring_divides r (f x) (g x)`.
  - By rewriting `ring_product r (x INSERT S') f` to `ring_mul r (f x) (ring_product r S' f)` and `ring_product r (x INSERT S') g` to `ring_mul r (g x) (ring_product r S' g)`, we want to show that `ring_divides r (ring_mul r (f x) (ring_product r S' f)) (ring_mul r (g x) (ring_product r S' g))`.
  - We have the inductive hypothesis that `ring_divides r (ring_product r S' f) (ring_product r S' g)`.
  - We can also show that all the elements of `f` and `g` are in the ring carrier to satisfy the side conditions of `RING_DIVIDES_MUL2`.
  - The result then follows by `RING_DIVIDES_MUL2`.

### Mathematical insight
This theorem provides a way to lift a "divides" relationship that holds element-wise to a "divides" relationship between ring products. In other words, if `r` divides `f(x)` into `g(x)` for all elements `x` in some finite set `S`, then `r` divides the product of the `f(x)`'s into the product of the `g(x)`'s. This showcases how divisibility on individual factors extends to products. It is a natural generalization useful in many ring-theoretic arguments.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `RING_DIVIDES_1`
- `RING_1`
- `RING_DIVIDES_MUL2`

### Porting notes (optional)
- The inductive proof structure should be directly translatable to other proof assistants with similar induction tactics/libraries. Ensure the `ring_divides` definition is properly available as well as `ring_product`.
- The `sufficesby` tactic introduces an intermediate goal that must be handled appropriately in other proof assistants.


---

## ring_sum_delta_delta

### Name of formal statement
ring_sum_delta_delta

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_delta_delta = prove(`
  !(r:R ring) S t u a b.
  FINITE S ==>
  t IN S ==>
  u IN S ==>
  a IN ring_carrier r ==>
  b IN ring_carrier r ==>
  ring_sum r S (\s:X. if s = t then a else if s = u then b else ring_0 r) =
  if t = u then a else ring_add r a b
`,
  intro THEN
  have `FINITE(S DELETE (t:X))` [FINITE_DELETE] THEN
  def `f:X->R` `\s:X. if s = t then a else if s = u then b else ring_0 (r:R ring)` THEN
  have `f(t:X) IN ring_carrier(r:R ring)` [] THEN
  set_fact `~((t:X) IN (S DELETE t))` THEN
  specialize[`r:R ring`;`t:X`;`f:X->R`;`S DELETE (t:X)`](CONJUNCT2 RING_SUM_CLAUSES) THEN
  have `ring_sum(r:R ring) ((t:X) INSERT (S DELETE t)) f = ring_add r a (ring_sum r (S DELETE t) f)` [] THEN
  set_fact `t IN S ==> (t:X) INSERT (S DELETE t) = S` THEN
  have `ring_sum(r:R ring) S (f:X->R) = ring_add r a (ring_sum r (S DELETE t) f)` [] THEN
  case `t = u:X` THENL [
    set_fact `t = u ==> !s:X. (s:X) IN S DELETE t ==> ~(s = t) /\ ~(s = u)` THEN
    have `!s:X. (s:X) IN S DELETE t ==> f(s) = ring_0(r:R ring)` [] THEN
    specialize[`r:R ring`;`f:X->R`;`\s:X. ring_0(r:R ring)`;`S DELETE (t:X)`]RING_SUM_EQ THEN
    have `ring_sum(r:R ring) (S DELETE (t:X)) f = ring_sum r (S DELETE t) (\i. ring_0 r)` [] THEN
    have `ring_sum(r:R ring) (S DELETE (t:X)) f = ring_0 r` [RING_SUM_0] THEN
    have `ring_sum(r:R ring) S (f:X->R) = ring_add r a (ring_0 r)` [] THEN
    qed[RING_ADD_RZERO]
  ; pass
  ] THEN
  have `FINITE(S DELETE (t:X) DELETE u)` [FINITE_DELETE] THEN
  have `f(u:X) IN ring_carrier(r:R ring)` [] THEN
  set_fact `~((u:X) IN (S DELETE t DELETE u))` THEN
  specialize[`r:R ring`;`u:X`;`f:X->R`;`S DELETE (t:X) DELETE (u:X)`](CONJUNCT2 RING_SUM_CLAUSES) THEN
  have `ring_sum(r:R ring) ((u:X) INSERT (S DELETE t DELETE u)) f = ring_add r (f u) (ring_sum r (S DELETE t DELETE u) f)` [] THEN
  have `f(u:X) = b:R` [] THEN
  have `ring_sum(r:R ring) ((u:X) INSERT (S DELETE t DELETE u)) f = ring_add r (if t = u then ring_0 r else b) (ring_sum r (S DELETE t DELETE u) f)` [] THEN
  set_fact `u IN S ==> ~(t = u) ==> (u:X) INSERT (S DELETE t DELETE u) = S DELETE t` THEN
  have `ring_sum(r:R ring) (S DELETE (t:X)) f = ring_add r (if t = u then ring_0 r else b) (ring_sum r (S DELETE t DELETE u) f)` [] THEN
  set_fact `!s:X. (s:X) IN S DELETE t DELETE u ==> ~(s = t) /\ ~(s = u)` THEN
  have `!s:X. ~(s = t) /\ ~(s = u) ==> f(s) = ring_0(r:R ring)` [] THEN
  have `!s:X. (s:X) IN S DELETE t DELETE u ==> f(s) = ring_0(r:R ring)` [] THEN
  specialize[`r:R ring`;`f:X->R`;`\s:X. ring_0(r:R ring)`;`S DELETE t DELETE (u:X)`]RING_SUM_EQ THEN
  have `ring_sum(r:R ring) (S DELETE (t:X) DELETE u) f = ring_sum r (S DELETE t DELETE u) (\i. ring_0 r)` [] THEN
  have `ring_sum(r:R ring) (S DELETE (t:X) DELETE u) f = ring_0 r` [RING_SUM_0] THEN
  have `ring_sum(r:R ring) (S DELETE (t:X)) f = ring_add r b (ring_0 r)` [] THEN
  have `ring_sum(r:R ring) (S DELETE (t:X)) f = b` [RING_ADD_RZERO] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` with carrier `ring_carrier r`, any finite set `S`, and any elements `t` and `u` in `S`, and any elements `a` and `b` in `ring_carrier r`, the ring sum over `S` of the function that maps `s` to `a` if `s = t`, to `b` if `s = u`, and to the ring zero `ring_0 r` otherwise, is equal to `a` if `t = u`, and to `a + b` (using `ring_add r`) otherwise.

### Informal sketch
The proof proceeds by induction (case splitting) on the condition `t = u`.

- **Case 1**: Assume `t = u`.
    - Show that for any `s` in `S` excluding `t`, `s` is neither equal to `t` nor `u`.
    - Conclude that the function `f` (defined as `a` if `s = t`, `b` if `s = u`, and `ring_0 r` otherwise) is equal to the ring zero `ring_0 r` for all `s` in `S` excluding `t`.
    - Apply the theorem `RING_SUM_EQ` to show that the ring sum of `f` over `S` excluding `t` is equal to the ring sum of the constant zero function over `S` excluding `t`.
    - Use `RING_SUM_0` to show the ring sum of the zero function over `S` excluding `t` is simply `ring_0 r`.
    - Use the property that `ring_sum r S f = ring_add r a (ring_sum r (S DELETE t) f)`.
    - Simplify using `RING_ADD_RZERO` to conclude `ring_sum r S f = a`.

- **Case 2**: Assume `t != u`.
    - Use the property that `ring_sum r (S DELETE t) f = ring_add r (if t = u then ring_0 r else b) (ring_sum r (S DELETE t DELETE u) f)`.
    - Simplify using `RING_SUM_0` and `RING_ADD_RZERO` to conclude that `ring_sum r (S DELETE t) f = b`.
    - Conclude using using ` (ring_sum r S f = ring_add r a (ring_sum r (S DELETE t) f)` is equal to `ring_add r a b`.

### Mathematical insight
This theorem simplifies the calculation of a ring sum over a set where the summand is defined piecewise, taking on non-zero values `a` and `b` at two specific points `t` and `u` in the set. It effectively reduces the sum to just `a` if `t = u` or `a + b` if not. This is useful because it provides a direct calculation when dealing with sums that are mostly zeros, specifically when evaluating indicator functions within ring sums.

### Dependencies
- Theorems:
    - `CONJUNCT2 RING_SUM_CLAUSES`
    - `RING_SUM_EQ`
    - `RING_SUM_0`
    - `RING_ADD_RZERO`
- Definitions:
    - `FINITE_DELETE`

### Porting notes (optional)
- In proof assistants like Coq or Lean, the `if-then-else` construct might require careful handling to ensure proper type inference and definitional equality. The automatic rewriting of ring sum expressions using theorems like `RING_SUM_EQ` and `RING_SUM_0` may require custom tactics or automation, depending on the capabilities of the target proof assistant. Pay special attention to the finiteness assumption and the handling of sets and set membership.


---

## ring_product_delta_delta

### Name of formal statement
ring_product_delta_delta

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_delta_delta = prove(`
  !(r:R ring) S t u a b.
  FINITE S ==>
  t IN S ==>
  u IN S ==>
  a IN ring_carrier r ==>
  b IN ring_carrier r ==>
  ring_product r S (\s:X. if s = t then a else if s = u then b else ring_1 r) =
  if t = u then a else ring_mul r a b
`,
  intro THEN
  have `FINITE(S DELETE (t:X))` [FINITE_DELETE] THEN
  def `f:X->R` `\s:X. if s = t then a else if s = u then b else ring_1 (r:R ring)` THEN
  have `f(t:X) IN ring_carrier(r:R ring)` [] THEN
  set_fact `~((t:X) IN (S DELETE t))` THEN
  specialize[`r:R ring`;`t:X`;`f:X->R`;`S DELETE (t:X)`](CONJUNCT2 RING_PRODUCT_CLAUSES) THEN
  have `ring_product(r:R ring) ((t:X) INSERT (S DELETE t)) f = ring_mul r a (ring_product r (S DELETE t) f)` [] THEN
  set_fact `t IN S ==> (t:X) INSERT (S DELETE t) = S` THEN
  have `ring_product(r:R ring) S (f:X->R) = ring_mul r a (ring_product r (S DELETE t) f)` [] THEN
  case `t = u:X` THENL [
    set_fact `t = u ==> !s:X. (s:X) IN S DELETE t ==> ~(s = t) /\ ~(s = u)` THEN
    have `!s:X. (s:X) IN S DELETE t ==> f(s) = ring_1(r:R ring)` [] THEN
    specialize[`r:R ring`;`f:X->R`;`\s:X. ring_1(r:R ring)`;`S DELETE (t:X)`]RING_PRODUCT_EQ THEN
    have `ring_product(r:R ring) (S DELETE (t:X)) f = ring_product r (S DELETE t) (\i. ring_1 r)` [] THEN
    have `ring_product(r:R ring) (S DELETE (t:X)) f = ring_1 r` [RING_PRODUCT_1] THEN
    have `ring_product(r:R ring) S (f:X->R) = ring_mul r a (ring_1 r)` [] THEN
    qed[RING_MUL_RID]
  ; pass
  ] THEN
  have `FINITE(S DELETE (t:X) DELETE u)` [FINITE_DELETE] THEN
  have `f(u:X) IN ring_carrier(r:R ring)` [] THEN
  set_fact `~((u:X) IN (S DELETE t DELETE u))` THEN
  specialize[`r:R ring`;`u:X`;`f:X->R`;`S DELETE (t:X) DELETE (u:X)`](CONJUNCT2 RING_PRODUCT_CLAUSES) THEN
  have `ring_product(r:R ring) ((u:X) INSERT (S DELETE t DELETE u)) f = ring_mul r (f u) (ring_product r (S DELETE t DELETE u) f)` [] THEN
  have `f(u:X) = b:R` [] THEN
  have `ring_product(r:R ring) ((u:X) INSERT (S DELETE t DELETE u)) f = ring_mul r (if t = u then ring_1 r else b) (ring_product r (S DELETE t DELETE u) f)` [] THEN
  set_fact `u IN S ==> ~(t = u) ==> (u:X) INSERT (S DELETE t DELETE u) = S DELETE t` THEN
  have `ring_product(r:R ring) (S DELETE (t:X)) f = ring_mul r (if t = u then ring_1 r else b) (ring_product r (S DELETE t DELETE u) f)` [] THEN
  set_fact `!s:X. (s:X) IN S DELETE t DELETE u ==> ~(s = t) /\ ~(s = u)` THEN
  have `!s:X. ~(s = t) /\ ~(s = u) ==> f(s) = ring_1(r:R ring)` [] THEN
  have `!s:X. (s:X) IN S DELETE t DELETE u ==> f(s) = ring_1(r:R ring)` [] THEN
  specialize[`r:R ring`;`f:X->R`;`\s:X. ring_1(r:R ring)`;`S DELETE t DELETE (u:X)`]RING_PRODUCT_EQ THEN
  have `ring_product(r:R ring) (S DELETE (t:X) DELETE u) f = ring_product r (S DELETE t DELETE u) (\i. ring_1 r)` [] THEN
  have `ring_product(r:R ring) (S DELETE (t:X) DELETE u) f = ring_1 r` [RING_PRODUCT_1] THEN
  have `ring_product(r:R ring) (S DELETE (t:X)) f = ring_mul r b (ring_1 r)` [] THEN
  have `ring_product(r:R ring) (S DELETE (t:X)) f = b` [RING_MUL_RID] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` with carrier `ring_carrier r`, any finite set `S`, any elements `t` and `u` in `S`, and any elements `a` and `b` in `ring_carrier r`, the ring product over `S` of the function that maps `s` to `a` if `s` is equal to `t`, to `b` if `s` is equal to `u`, and to the multiplicative identity `ring_1 r` otherwise, is equal to `a` if `t` and `u` are the same element, and to the ring multiplication `ring_mul r a b` of `a` and `b` otherwise.

### Informal sketch
The proof proceeds by induction and case splitting.

- First, the theorem introduces assumptions.
- Then, it considers the case where `t = u`. In this case, the function `f` maps all elements in `S DELETE t` to `ring_1 r`. Applying the `RING_PRODUCT_1` theorem, the ring product over `S DELETE t` becomes `ring_1 r`. Finally, rewriting and applying `RING_MUL_RID`, the result is `a`.
- Next, the case where `t <> u` is addressed. Here, the element `u` is in `S DELETE t`. Further simplification using `RING_PRODUCT_CLAUSES` and the definition of `f` yields `ring_mul r b (ring_product r (S DELETE t DELETE u) f)`. Since on `S DELETE t DELETE u`, `f` always takes the value `ring_1 r`, then `ring_product r (S DELETE t DELETE u) f = ring_1 r` and thus the result follows by `RING_MUL_RID`.

### Mathematical insight
The theorem simplifies the ring product when the function being multiplied is the ring one, except for at most two elements, `t` and `u`. If `t = u`, the product is just the value at `t`. If `t` and `u` are distinct, the product is the ring multiplication of the values at `t` and `u`. This is a natural generalization of the case where `f` is one everywhere except at one point.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `RING_PRODUCT_EQ`
- `RING_PRODUCT_1`
- `RING_MUL_RID`
- `FINITE_DELETE`

### Porting notes (optional)
- The use of `set_fact` and `specialize` can be emulated using appropriate variable substitutions or applications of lemmas.
- Care should be taken to ensure the finiteness conditions are handled appropriately in the target proof assistant.


---

## square_divides_product_if_factor_divides_factor

### Name of formal statement
square_divides_product_if_factor_divides_factor

### Type of the formal statement
theorem

### Formal Content
```ocaml
let square_divides_product_if_factor_divides_factor = prove(`
  !(r:R ring) S (f:X->R) t u.
  FINITE S ==>
  (!s:X. s IN S ==> f s IN ring_carrier r) ==>
  ~(t = u) ==>
  t IN S ==>
  u IN S ==>
  ring_divides r (f t) (f u) ==>
  ring_divides r
    (ring_mul r (f t) (f t))
    (ring_product r S f)
`,
  intro THEN
  def `q:X->R` `\s:X. if s = t then f t else if s = u then f t else ring_1(r:R ring)` THEN
  subgoal `!s:X. s IN S ==> ring_divides(r:R ring) (q s) (f s)` THENL [
    intro THEN
    have `f(s:X) IN ring_carrier(r:R ring)` [] THEN
    case `s = t:X` THENL [
      have `ring_divides (r:R ring) (f(t:X)) (f(t:X))` [RING_DIVIDES_REFL] THEN
      qed[]
    ;
      case `s = u:X` THENL [
        qed[]
      ;
        qed[RING_DIVIDES_1]
      ]
    ]
  ; pass
  ] THEN
  specialize[`r:R ring`;`q:X->R`;`f:X->R`;`S:X->bool`]ring_product_divides_factor_by_factor THEN
  have `f(t:X) IN ring_carrier(r:R ring)` [] THEN
  specialize[`r:R ring`;`S:X->bool`;`t:X`;`u:X`;`f(t:X):R`;`f(t:X):R`]ring_product_delta_delta THEN
  qed[]
);;
```

### Informal statement
Let `r` be a ring. Let `S` be a finite set of elements of type `X`. Let `f` be a function from `X` to the carrier of the ring `r`. Let `t` and `u` be distinct elements of type `X`. Assume that `t` is in `S` and `u` is in `S`. Also assume that `f(t)` divides `f(u)` in the ring `r`. Then `f(t)*f(t)` divides the product of `f(s)` for all `s` in `S` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- We introduce assumptions to the goal.
- We define a new function `q` from `X` to `R` such that `q(s)` is `f(t)` if `s` is `t`, `f(t)` if `s` is `u`, and 1 otherwise.
- We show that for any element `s` in `S`, `q(s)` divides `f(s)`. This is done by cases:
    - If `s` is `t`, then `q(s)` is `f(t)`, and `f(t)` divides `f(t)` by reflexivity of divisibility.
    - If `s` is `u`, then `q(s)` is `f(t)`. Since `f(t)` divides `f(u)` by assumption, then `f(t)` divides `f(u)`.
    - Otherwise, `q(s)` is 1, and 1 divides `f(s)`.
- We use the theorem `ring_product_divides_factor_by_factor` to show that the ring product of `q(s)` for `s` in `S` divides the ring product of `f(s)` for `s` in `S`.
- We use the theorem `ring_product_delta_delta` with specialized arguments to show that the ring product of `q(s)` for `s` in `S` is `f(t) * f(t)`. This is done because `q` equals `f(t)` at both `t` and `u` and `1` elsewhere.

### Mathematical insight
The theorem states that if a factor `f(t)` divides another factor `f(u)` in a product, then the square of `f(t)` divides the whole product. The idea is that we can replace `f(u)` with `f(t)` without changing the divisibility properties, and thus `f(t)` appears at least twice in the product, hence `f(t)^2` divides the product.

### Dependencies
- Definitions:
    - `ring_divides`
    - `ring_carrier`
    - `ring_mul`
    - `ring_1`
    - `ring_product`
    - `FINITE`
    - `IN`
- Theorems:
    - `RING_DIVIDES_REFL`
    - `RING_DIVIDES_1`
    - `ring_product_divides_factor_by_factor`
    - `ring_product_delta_delta`


---

## prime_divides_prime_and

### Name of formal statement
prime_divides_prime_and

### Type of the formal statement
theorem

### Formal Content
```ocaml
let prime_divides_prime_and = prove(`
  !(r:R ring) p q a.
  UFD r ==>
  ring_prime r p ==>
  ring_prime r q ==>
  ring_divides r p q ==>
  ring_divides r p a ==>
  ring_divides r q a
`,
  intro THEN
  have `~(ring_unit(r:R ring) p)` [ring_prime] THEN
  have `ring_irreducible(r:R ring) q` [UFD_IRREDUCIBLE_EQ_PRIME] THEN
  have `ring_associates(r:R ring) p q` [RING_NONUNIT_DIVIDES_IRREDUCIBLE] THEN
  have `ring_divides(r:R ring) q p` [ring_associates] THEN
  qed[RING_DIVIDES_TRANS]
);;
```
### Informal statement
Let `r` be a ring.
Suppose `r` is a unique factorization domain.
Let `p` and `q` be prime elements in `r`.
Let `a` be an element of `r`.
If `p` divides `q` and `p` divides `a`, then `q` divides `a`.

### Informal sketch
The proof proceeds as follows:
- Assume that the ring `r` is a unique factorization domain (`UFD r`), that `p` and `q` are prime elements (`ring_prime r p` and `ring_prime r q`), that `p` divides `q` (`ring_divides r p q`), and that `p` divides `a` (`ring_divides r p a`).
- Show that `p` is not a unit (`~(ring_unit(r:R ring) p)`), using the assumption `ring_prime`.
- Show that `q` is irreducible (`ring_irreducible(r:R ring) q`) using the theorem `UFD_IRREDUCIBLE_EQ_PRIME`.
- Show that `p` and `q` are associates (`ring_associates(r:R ring) p q`) using the theorem `RING_NONUNIT_DIVIDES_IRREDUCIBLE`.
- Show that `q` divides `p` (`ring_divides(r:R ring) q p`) using the theorem `ring_associates`.
- Conclude that `q` divides `a` (`ring_divides r q a`) using transitivity of divisibility (`RING_DIVIDES_TRANS`).

### Mathematical insight
This theorem states that if a prime element `p` divides another prime element `q`, and `p` also divides some element `a`, then `q` must also divide `a`. This is a reflection of the fundamental properties of prime elements and divisibility in unique factorization domains. The proof leverages the association between prime and irreducible elements in UFDs and the transitivity of divisibility.

### Dependencies
- Theorems: `UFD_IRREDUCIBLE_EQ_PRIME`, `RING_NONUNIT_DIVIDES_IRREDUCIBLE`, `RING_DIVIDES_TRANS`
- Definitions: `ring_prime`, `ring_unit`, `ring_irreducible`, `ring_associates`, `ring_divides`, `UFD`

### Porting notes (optional)
The proof relies on the equivalence between prime and irreducible elements in a UFD. Ensure such result is available in target proof assistant.
Also ensure that the divisibility is transitive, and that all definitions are identical.
The statement uses higher-order functions to express the ring operations and properties. Ensure that the target proof assistant has similar capabilities for handling higher-order logic or that the ring structures and properties are defined accordingly.


---

## ring_squarefree_associates

### Name of formal statement
ring_squarefree_associates

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_associates = prove(`
  !(r:R ring) f g.
  ring_associates r f g ==>
  ring_squarefree r f ==>
  ring_squarefree r g
`,
  rw[ring_squarefree] THEN
  qed[RING_ASSOCIATES_DIVIDES;RING_ASSOCIATES_REFL;RING_MUL]
);;
```

### Informal statement
For any ring `R` and elements `f` and `g` in `R`, if `f` and `g` are associates in the ring `R` and `f` is squarefree in the ring `R`, then `g` is squarefree in the ring `R`.

### Informal sketch
*   The proof starts by rewriting using the definition of `ring_squarefree`.
*   The proof then uses a combination of theorems: `RING_ASSOCIATES_DIVIDES` which states that if two elements are associates, then each divides the other, `RING_ASSOCIATES_REFL` which states that every element is an associate of itself, and `RING_MUL`, presumably a ring multiplication property.

### Mathematical insight
This theorem states that the property of being squarefree is preserved under association in a ring. In other words, if two elements are associates, then either both are squarefree or neither is. The `ring_squarefree` property is an algebraic generalization of the same attribute for integers.

### Dependencies
- Definition: `ring_squarefree`
- Theorems: `RING_ASSOCIATES_DIVIDES`, `RING_ASSOCIATES_REFL`, `RING_MUL`


---

## poly_neg_subring

### Name of formal statement
poly_neg_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_neg_subring = prove(`
  !(r:R ring) S (p:(V->num)->R).
  poly_neg (subring_generated r S) p
  = poly_neg r p
`,
  rw[poly_neg;SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `S` and any polynomial `p` from `(V->num)` to `R`, the polynomial negation of `p` with respect to the subring generated by `S` ( `subring_generated r S`) is equal to the polynomial negation of `p` with respect to the ring `r`, where `V` denotes a type variable.

### Informal sketch
The proof proceeds by rewriting using the definitions of `poly_neg` and `SUBRING_GENERATED`. This unfolds the definitions and directly shows the equality.

### Mathematical insight
This theorem states that when negating a polynomial, it doesn't matter if we consider the polynomial over the original ring or over a subring generated by a subset of the ring. The negation operation is intrinsic to the ring structure itself, so restricting the coefficients to a subring doesn't change the result of the negation. This is expected, since polynomial negation only involves ring negation, which should behave identically in a subring.

### Dependencies
- Definitions:
  - `poly_neg`
  - `SUBRING_GENERATED`


---

## poly_add_subring

### Name of formal statement
poly_add_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_add_subring = prove(`
  !(r:R ring) S (p:(V->num)->R) q.
  poly_add (subring_generated r S) p q
  = poly_add r p q
`,
  rw[poly_add;SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` with carrier `R`, subset `S` of `R`, and polynomials `p` and `q` with coefficients in `V->num`, the addition of polynomials `p` and `q` over the subring generated by `S` within the ring `r` is equal to the addition of polynomials `p` and `q` over the ring `r`.

### Informal sketch
The proof consists of applying rewriting with the definitions of `poly_add` and `SUBRING_GENERATED`. This unfolds the definitions and shows that the operations are equivalent.

### Mathematical insight
This theorem states that polynomial addition is independent of whether we consider the coefficients to come from the whole ring or just the subring generated by a subset. Because a subring is closed under addition and multiplication, this result is what we would expect, but it is still useful to have it formalized.

### Dependencies
- Definitions: `poly_add`, `SUBRING_GENERATED`


---

## poly_mul_subring

### Name of formal statement
poly_mul_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_subring = prove(`
  !(r:R ring) S (p:(V->num)->R) q.
  ring_powerseries (subring_generated r S) p ==>
  ring_powerseries (subring_generated r S) q ==>
  poly_mul (subring_generated r S) p q
  = poly_mul r p q
`,
  rw[poly_mul;SUBRING_GENERATED] THEN
  rw[FUN_EQ_THM] THEN
  intro THEN
  subgoal `!(m1:V->num) (m2:V->num). ring_mul r (p m1) (q m2) IN ring_carrier(subring_generated r (S:R->bool))` THENL [
    intro THEN
    have `(p:(V->num)->R) m1 IN ring_carrier(subring_generated(r:R ring) S)` [ring_powerseries] THEN
    have `(q:(V->num)->R) m2 IN ring_carrier(subring_generated(r:R ring) S)` [ring_powerseries] THEN
    specialize[`subring_generated(r:R ring) S`;`(p:(V->num)->R) m1`;`(q:(V->num)->R) m2`]RING_MUL THEN
    qed[SUBRING_GENERATED;CARRIER_SUBRING_GENERATED_SUBRING]
  ; pass
  ] THEN
  sufficesby ring_sum_subring_generated_v2 THEN
  simp[IN_ELIM_THM;LAMBDA_PAIR]
);;
```
### Informal statement
For any ring `r`, set `S` of `r` (i.e. a subset of the carrier of `r`), and polynomials `p` and `q`, represented as functions from monomials to `R`, if `p` and `q` are ring power series over the subring generated by `S`, then the polynomial multiplication of `p` and `q` over the subring generated by `S` is equal to the polynomial multiplication of `p` and `q` over the ring `r`.

### Informal sketch
The proof establishes that performing polynomial multiplication over a subring generated by a set `S` is the same as performing it over the original ring `r`, given that the polynomials involved are ring power series over the subring generated by `S`.

- First, rewrite the goal using the definitions of `poly_mul` and `SUBRING_GENERATED`.
- Reduce the goal to proving that `(p m1) * (q m2)` is an element of the carrier of the subring generated by `S` for all monomials `m1` and `m2`.
- Utilize the assumption that `p m1` and `q m2` are elements of the carrier of the subring generated by `S`.
- Apply the `RING_MUL` property of subrings, combined with properties of the `SUBRING_GENERATED`.
- Apply the `ring_sum_subring_generated_v2` to discharges the final goal after simplification.
- Use `SUBRING_GENERATED` and `CARRIER_SUBRING_GENERATED_SUBRING` to construct the subring generated from `S`.

### Mathematical insight
The theorem demonstrates that polynomial multiplication is well-behaved with respect to subrings. If two polynomials have coefficients in a subring generated by a set `S`, then their product (computed using the operations of the larger ring) also has coefficients effectively within that same subring. This is crucial for reasoning about algebraic structures and ensures that operations performed within a subring are consistent with those performed in the larger ring.

### Dependencies
- `poly_mul`
- `SUBRING_GENERATED`
- `FUN_EQ_THM`
- `RING_MUL`
- `SUBRING_GENERATED`
- `CARRIER_SUBRING_GENERATED_SUBRING`
- `ring_sum_subring_generated_v2`
- `IN_ELIM_THM`
- `LAMBDA_PAIR`
- `ring_powerseries`

### Porting notes (optional)
The main challenge for porting might involve the representation of rings, subrings, and their carriers in different proof assistants, particularly how membership in these carriers is defined and checked. The tactic `rw` is used for rewriting, which may need to be adapted depending on the rewriting capabilities of the target proof assistant. The HOL Light notion of `ring_powerseries` and `poly_mul` need to be properly defined.


---

## poly_sub_subring

### Name of formal statement
poly_sub_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) S (p:(V->num)->R) q.
  poly_sub (subring_generated r S) p q
  = poly_sub r p q
```

### Informal statement
For any ring `r` (of type `R ring`), any set `S` of elements of `r`, and any two polynomials `p` and `q` (of type `(V->num)->R`, where `V` is a type variable), the polynomial subtraction `poly_sub` performed within the subring generated by `S` (denoted `subring_generated r S`) is equal to the polynomial subtraction `poly_sub` performed within the original ring `r`.

### Informal sketch
The proof is a direct application of the theorem `RING_SUB_SUBRING_GENERATED` to the definition of `poly_sub`. That is unfolding `poly_sub` in terms of the ring structure, and then using the fact that subtraction in a subring generated by a set S is the same as subtraction in the original ring.
- Expand the definition of `poly_sub`.
- Apply the theorem `RING_SUB_SUBRING_GENERATED`.

### Mathematical insight
This theorem states that the operation of subtracting polynomials is independent of whether you perform it in the original ring `r` or in the subring generated by `S`. This is because the subring inherits the subtraction operation from the original ring, and the subtraction is closed within the subring. This is a key property when working with subrings and polynomials, as it allows us to reason about polynomial arithmetic within the subring without needing to refer back to the original ring every time.

### Dependencies
- Definitions: `poly_sub`
- Theorems: `RING_SUB_SUBRING_GENERATED`


---

## poly_deg_subring

### Name of formal statement
poly_deg_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_deg_subring = prove(`
  !(r:R ring) G (p:(V->num)->R).
  poly_deg (subring_generated r G) p
  = poly_deg r p
`,
  rw[poly_deg;SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` and set of ring elements `G` (each element in `G` is a function from variables to numbers i.e. `(V->num)->R`), the polynomial degree of the subring generated by `r` and `G` applied to a polynomial `p` is equal to the polynomial degree of the ring `r` applied to the polynomial `p`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `poly_deg` and `SUBRING_GENERATED`. It reduces the equality to a simpler form that directly relates the polynomial degree computation over the subring generated by `r` and `G` to the polynomial degree computation over the ring `r` itself.

### Mathematical insight
This theorem states that calculating the polynomial degree within a subring generated by a ring `r` and some additional generators `G` gives the same result as calculating the degree within the original ring `r`. This can be useful for simplifying degree computations in rings when you're working within a subring.

### Dependencies
- Definitions:
  - `poly_deg`
  - `SUBRING_GENERATED`


---

## poly_evaluate_subring

### Name of formal statement
poly_evaluate_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_evaluate_subring = prove(`
  !(r:R ring) S (p:(V->num)->R) z.
  S subring_of r ==>
  ring_powerseries (subring_generated r S) p ==>
  (!v:V. z v IN S) ==>
  poly_evaluate r p z
  = poly_evaluate (subring_generated r S) p z
`,
  rw[poly_evaluate;poly_extend] THEN
  intro THEN
  subgoal `!m:V->num. m IN {m | ~(p m = ring_0(r:R ring))} ==> ring_mul (subring_generated r S) (I (p m)) (ring_product (subring_generated r S) (monomial_vars m) (\i. ring_pow (subring_generated r S) (z i) (m i))) IN S` THENL [
    rw[IN_ELIM_THM] THEN
    intro THEN
    have `ring_product (subring_generated r S) (monomial_vars m) (\i:V. ring_pow (subring_generated r S) (z i) (m i)) IN ring_carrier(subring_generated(r:R ring) S)` [RING_PRODUCT] THEN
    have `(p:(V->num)->R) m IN ring_carrier(subring_generated r S)` [ring_powerseries] THEN
    have `I ((p:(V->num)->R) m) IN ring_carrier(subring_generated r S)` [I_DEF] THEN
    have `ring_mul (subring_generated r S) (I ((p:(V->num)->R) m)) (ring_product (subring_generated r S) (monomial_vars m) (\i:V. ring_pow (subring_generated r S) (z i) (m i))) IN ring_carrier(subring_generated r S)` [RING_MUL] THEN
    qed[CARRIER_SUBRING_GENERATED_SUBRING]
  ; pass
  ] THEN
  simp[prove(`ring_0(subring_generated(r:R ring) S) = ring_0 r`,qed[SUBRING_GENERATED])] THEN
  simp[ring_sum_subring_generated] THEN
  sufficesby RING_SUM_EQ THEN
  intro THEN
  simp[SUBRING_GENERATED] THEN
  sufficesby (prove(`a:R = b ==> ring_mul r c a = ring_mul r c b`,qed[])) THEN
  simp[RING_POW_SUBRING_GENERATED] THEN
  sufficesby(GSYM ring_product_subring_generated) THEN
  simp[] THEN
  intro THEN
  qed[RING_POW;RING_POW_SUBRING_GENERATED;CARRIER_SUBRING_GENERATED_SUBRING]
);;
```

### Informal statement
Let `r` be a ring, let `S` be a subring of `r`, let `p` be a polynomial defined as a function from `V->num` to `R`, and let `z` be a function from `V` to `R`.
If `S` is a subring of `r`, and `p` is a ring powerseries with respect to the subring generated by `r` and `S`, and for all `v` in `V`, `z v` is in `S`, then `poly_evaluate r p z` is equal to `poly_evaluate (subring_generated r S) p z`.

### Informal sketch
The theorem states that if we evaluate a polynomial `p` at a point `z` within a subring `S` of a ring `r`, then the result is the same whether we perform the evaluation using the operations of the larger ring `r` or the subring generated by `S`.

- The proof starts by rewriting `poly_evaluate` and `poly_extend`.
- It then introduces the goal.
- The main subgoal requires showing that if `m` is in the set of monomials where `p m` is not zero, then a certain expression involving ring multiplication, the identity `I`, products of monomials, and powers of `z` is in `S`.
    - We show using `IN_ELIM_THM` that the product part is contained in the carrier of the subring generated by `S`.
    - We then show `p m` and `I (p m)` are contained within the carrier of the subring generated by `S` and that the entire expression is within the carrier.
    - We conclude this subgoal by `CARRIER_SUBRING_GENERATED_SUBRING`
- Simplify using `ring_0(subring_generated(r:R ring) S) = ring_0 r`
- Simplify using `ring_sum_subring_generated` and `RING_SUM_EQ`
- Simplify using the definition of `SUBRING_GENERATED`
- Simplify `a:R = b ==> ring_mul r c a = ring_mul r c b`
- Simplify using `RING_POW_SUBRING_GENERATED` and `GSYM ring_product_subring_generated`
- The proof concludes using `RING_POW`,`RING_POW_SUBRING_GENERATED`, and `CARRIER_SUBRING_GENERATED_SUBRING`

### Mathematical insight
This theorem provides a way to compute polynomial evaluations within a subring, which can be useful for simplifying calculations or for working with polynomials over specific algebraic structures. It essentially states that the evaluation is independent of the "ambient" ring, as long as the point of evaluation lies within the subring and the subring contains all the coefficients of the powerseries.

### Dependencies
- Definitions: `poly_evaluate`, `poly_extend`
- Theorems: `SUBRING_GENERATED`, `CARRIER_SUBRING_GENERATED_SUBRING`, `RING_POW_SUBRING_GENERATED`, `RING_POW`, `RING_SUM_EQ`, `ring_sum_subring_generated`, `I_DEF`, `RING_MUL`, `ring_powerseries`, `RING_PRODUCT`, `IN_ELIM_THM`

### Porting notes (optional)
- The tactic `rw` is used to rewrite the goal using the specified theorems or definitions and may need to be adjusted depending on the rewriting or simplification capabilities of the target proof assistant.
- The handling of subrings and ring homomorphisms may vary across proof assistants, so the definitions and theorems related to these concepts should be carefully translated.


---

## poly_eval_subring

### Name of formal statement
poly_eval_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_eval_subring = prove(`
  !(r:R ring) S p z.
  S subring_of r ==>
  ring_powerseries (subring_generated r S) p ==>
  z IN S ==>
  poly_eval r p z
  = poly_eval (subring_generated r S) p z
`,
  rw[poly_eval] THEN
  qed[poly_evaluate_subring]
);;
```

### Informal statement
For any ring `r` (with ring operations implicitly available), any subring `S` of `r`, any polynomial `p` over the ring of formal power series over the subring generated by `S` (which, in turn, is considered a subring of `r`), and any element `z` in `S`, the polynomial evaluation of `p` at `z` in the ring `r` is equal to the polynomial evaluation of `p` at `z` in the subring generated by `S`.

### Informal sketch
- The proof starts by rewriting using the definition of `poly_eval`.
- Afterward, the proof is completed by the tactic `qed[poly_evaluate_subring]`. The main idea is that when you evaluate a polynomial with coefficients in the subring generated by `S` at a point `z` inside `S`, the operations are confined within the subring generated by `S`. The key observation here is that subrings are closed under ring operations (addition, subtraction, multiplication), thus evaluating polynomials using elements in the subring will yield an element in the subring.

### Mathematical insight
This theorem states that the evaluation of a polynomial, whose coefficients lie in a subring generated by a set `S`, at a point `z` that belongs to that set `S`, yields the same result whether the evaluation is performed in the original ring or in the subring generated by `S`. In other words, polynomial evaluation is "preserved" when moving to a subring, as long as the polynomial's coefficients and the evaluation point lie within the subring. This result underlies the concept that algebraic operations inside the subring will produce the same element in the original ring.

### Dependencies
- Definitions: `poly_eval`

### Porting notes (optional)
When porting to other proof assistants, ensure the subring structure, polynomial evaluation function, and ring power series are defined. Pay close attention to how the subring is generated and closure property. The rewrite tactic `rw[poly_eval]` in HOL Light unfolds the definition of `poly_eval`, which may need to be done differently depending on the capabilities of the target proof assistant.


---

## ring_powerseries_subring

### Name of formal statement
ring_powerseries_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_powerseries_subring = prove(`
  !(r:R ring) G (p:(V->num)->R).
  ring_powerseries(subring_generated r G) p ==>
  ring_powerseries r p
`,
  rw[ring_powerseries] THEN
  qed[RING_CARRIER_SUBRING_GENERATED_SUBSET;SUBRING_GENERATED;SUBSET]
);;
```
### Informal statement
For any ring `r` and set of elements `G` such that `G` is a subset of the carrier of `r`, if `p` is a power series over the subring generated by `r` and `G`, then `p` is a power series over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Start with the hypothesis `ring_powerseries(subring_generated r G) p`.
- Apply the rewrite rule `ring_powerseries` to expand the definition of `ring_powerseries`.
- Apply the theorem `RING_CARRIER_SUBRING_GENERATED_SUBSET`, which states that the carrier of the subring generated by a subset is a subset of the carrier of the original ring.
- Apply the theorems `SUBRING_GENERATED` and `SUBSET` as needed.
- The result directly follows.

### Mathematical insight
The theorem states that if a power series is defined over a subring generated by a subset `G` of a ring `r`, then it is also a power series over the original ring `r`. This makes intuitive sense because the subring generated by `G` is a subset of `r`, hence any power series with coefficients in the generated subring also has coefficients in `r`. This theorem helps to relate power series defined on different rings, specifically a ring and a subring generated from it.

### Dependencies
- Definitions: `ring_powerseries`
- Theorems: `RING_CARRIER_SUBRING_GENERATED_SUBSET`, `SUBRING_GENERATED`, `SUBSET`


---

## ring_polynomial_if_subring

### Name of formal statement
ring_polynomial_if_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_polynomial_if_subring = prove(`
  !(r:R ring) (p:(V->num)->R).
  ring_polynomial(subring_generated r G) p ==>
  ring_polynomial r p
`,
  rw[ring_polynomial] THEN
  intro THENL [
    qed[ring_powerseries_subring]
  ;
    set_fact_assuming `ring_0 (subring_generated r G) = ring_0(r:R ring) ==> {m:V->num | ~(p m = ring_0 r)} = {m | ~(p m = ring_0 (subring_generated r G))}` THEN
    qed[SUBRING_GENERATED]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring` and polynomial `p` from `V->num` to `R`, if `p` is a ring polynomial over the subring generated by `r` and `G`, then `p` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `ring_polynomial`.
- Introduce the assumptions.
- The proof then splits into two subgoals, each corresponding to conditions in the expanded definition of `ring_polynomial`:
  - The first subgoal involves showing that `ring_powerseries(subring_generated r G) p` implies `ring_powerseries r p`. This is proved using the theorem `ring_powerseries_subring`.
  - The second subgoal involves showing that `{m:V->num | ~(p m = ring_0 r)} = {m | ~(p m = ring_0 (subring_generated r G))}` given `ring_0 (subring_generated r G) = ring_0(r:R ring) `. This is accomplished by setting the fact assuming `ring_0 (subring_generated r G) = ring_0(r:R ring) ==> {m:V->num | ~(p m = ring_0 r)} = {m | ~(p m = ring_0 (subring_generated r G))}` and then using the theorem `SUBRING_GENERATED`.

### Mathematical insight
This theorem states that if a polynomial is a ring polynomial over a subring generated from a ring, then it is also a ring polynomial over the original ring. This reflects the idea that the subring inherits the ring polynomial structure from its parent ring.

### Dependencies
Definitions:
- `ring_polynomial`

Theorems:
- `ring_powerseries_subring`
- `SUBRING_GENERATED`


---

## deg_zero_ring

### Name of formal statement
deg_zero_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_zero_ring = prove(`
  !(r:R ring) (p:(V->num)->R).
  ring_1 r = ring_0 r ==>
  ring_powerseries r p ==>
  poly_deg r p = 0
`,
  intro THEN
  have `!m:V->num. p m IN ring_carrier(r:R ring)` [ring_powerseries] THEN
  have `trivial_ring(r:R ring)` [TRIVIAL_RING_10] THEN
  have `!m:V->num. p m IN {ring_0(r:R ring)}` [trivial_ring] THEN
  set_fact `!m:V->num. p m IN {ring_0(r:R ring)} ==> p m = ring_0 r` THEN
  have `!m:V->num. p m = ring_0(r:R ring)` [] THEN
  have `(p:(V->num)->R) = poly_0 r` [POLY_0;FUN_EQ_THM] THEN
  qed[POLY_DEG_0]
);;
```

### Informal statement
For all rings `r` of type `R ring` and all functions `p` from `V->num` to `R`, if the multiplicative identity `ring_1 r` equals the additive identity `ring_0 r` in ring `r`, and `p` is a powerseries with coefficients in `r`, then the degree of the polynomial `p` with respect to `r` is 0.

### Informal sketch
The proof proceeds as follows:
- Assume `ring_1 r = ring_0 r` and `ring_powerseries r p`.
- Show that every coefficient `p m` is in the carrier set of the ring `r` using `ring_powerseries`.
- Use `TRIVIAL_RING_10` to show that `r` is a trivial ring since `ring_1 r = ring_0 r`.
- From the definition of a trivial ring, deduce that every coefficient `p m` is in the set containing only the additive identity `ring_0 r`.
- Conclude that every coefficient `p m` is equal to the additive identity `ring_0 r`.
- Show `p` is equal to the zero polynomial `poly_0 r` using `POLY_0` and `FUN_EQ_THM`.
- Finally, conclude that the degree of `p` is 0 using `POLY_DEG_0`.

### Mathematical insight
The theorem states that if a ring is trivial (i.e., its multiplicative identity is equal to its additive identity), then any power series in that ring has degree 0. This follows from the fact that in a trivial ring, all elements are equal to the additive identity, and therefore any power series is equivalent to the zero polynomial, which by definition has degree 0.

### Dependencies
- Definitions: `ring_0`, `ring_1`, `ring_carrier`, `ring_powerseries`, `poly_0`, `poly_deg`
- Theorems: `TRIVIAL_RING_10`, `POLY_0`, `FUN_EQ_THM`, `POLY_DEG_0`


---

## poly_const_subring

### Name of formal statement
poly_const_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) S c.
  poly_const (subring_generated r S) c
  = poly_const r c:(V->num)->R
```

### Informal statement
For any ring `r` (of type `R ring`), any set `S`, and any constant `c` (of type `(V->num)->R`), the polynomial constant function `poly_const` applied to the subring generated by `S` with the ring structure `r` yields the same result as `poly_const` applied to the ring `r` itself.

### Informal sketch
- The proof proceeds by rewriting using the definitions of `poly_const` and `SUBRING_GENERATED`.

### Mathematical insight
The theorem states that forming a subring generated by some set `S` does not affect the polynomial constant function. Intuitively, this is because the constant function will always return an element of the underlying ring, and forming a subring doesn't alter the elements that can be represented as constants.

### Dependencies
- Definitions: `poly_const`, `SUBRING_GENERATED`


---

## poly_0_subring

### Name of formal statement
poly_0_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_0_subring = prove(`
  !(r:R ring) S.
  poly_0 (subring_generated r S)
  = poly_0 r:(V->num)->R
`,
  rw[poly_0;poly_const;SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` and any set `S`, the zero polynomial `poly_0` over `r` belongs to the subring generated by `S` over `r`. In other words, `poly_0 (subring_generated r S) = poly_0 r:(V->num)->R`.

### Informal sketch
The proof proceeds by rewriting using definitions:
- Expand the definition of `poly_0` to `poly_const(&0)`.
- Expand the definition of `subring_generated r S`. The generated subring is the intersection of subrings containing `S`.
- Finally rewrite using `SUBRING_GENERATED`, which includes that the `subring_generated` contains the constants (including zero).

### Mathematical insight
The theorem demonstrates that in any subring generated from a set `S` within a ring `r`, the zero element of the polynomial ring over `r` is always present. This reflects the fundamental property of subrings, that they are closed under the ring operations including the constant zero function. This theorem is important as it connects the algebraic structure of subrings with the polynomial ring structure, illustrating a basic property that is often required in more complex algebraic manipulations.

### Dependencies
- Definitions: `poly_0`, `poly_const`, `SUBRING_GENERATED`


---

## poly_1_subring

### Name of formal statement
poly_1_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_1_subring = prove(`
  !(r:R ring) S.
  poly_1 (subring_generated r S)
  = poly_1 r:(V->num)->R
`,
  rw[poly_1;poly_const;SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` and any set `S`, `poly_1 (subring_generated r S)` is equal to `poly_1 r:(V->num)->R`.

### Informal sketch
The proof proceeds by rewriting the statement. First, rewrite using the definition of `poly_1`, then `poly_const`, and then `SUBRING_GENERATED`. This unfolds the definitions and uses simplifications to arrive at the result.

### Mathematical insight
The theorem states that the set of degree-1 polynomials over a subring generated by `S` (within a ring `r`) is equivalent to the set of degree-1 polynomials over the ring `r` itself, as long as we have a suitable mapping to `r` (here `r:(V->num)->R`). This is a typical result when studying embeddings of algebraic structures.

### Dependencies
- Definitions:
    - `poly_1`
    - `poly_const`
    - `SUBRING_GENERATED`


---

## POWSER_MUL_0

### Name of formal statement
POWSER_MUL_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POWSER_MUL_0 = prove
 (`(!r (p:(V->num)->A).
        ring_powerseries r p ==> poly_mul r p (poly_0 r) = poly_0 r) /\
   (!r (q:(V->num)->A).
        ring_powerseries r q ==> poly_mul r (poly_0 r) q = poly_0 r)`,
  REWRITE_TAC[ring_powerseries;
              poly_mul; poly_0; poly_const; COND_ID] THEN
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC I [FUN_EQ_THM] THEN
  REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC RING_SUM_EQ_0 THEN
  ASM_SIMP_TAC[FORALL_PAIR_THM; RING_MUL_LZERO; RING_MUL_RZERO]);;
```
### Informal statement
For all rings represented by `r` and for all power series `p` of type `(V->num)->A`, if `r` is a ring power series, then the power series multiplication of `r`, `p`, and the zero power series `poly_0 r` is equal to `poly_0 r`. Also, for all rings represented by `r` and for all power series `q` of type `(V->num)->A`, if `r` is a ring power series, then the power series multiplication of `r`, `poly_0 r`, and `q` is equal to `poly_0 r`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definitions of `ring_powerseries`, `poly_mul`, `poly_0`, `poly_const`, and a conditional identity.
- Repeatedly strip the quantifiers and implications.
- Rewrite using the functional equality theorem `FUN_EQ_THM`.
- Rewrite with the empty list of theorems.
- Repeatedly strip quantifiers and implications.
- Apply the theorem stating that a ring sum equals zero, `RING_SUM_EQ_0`.
- Perform assumption simplification using `FORALL_PAIR_THM`, `RING_MUL_LZERO`, and `RING_MUL_RZERO`.

### Mathematical insight
This theorem establishes that multiplying a power series by the zero power series results in the zero power series. This is a fundamental property of power series rings, analogous to the property that multiplying any element in a ring by zero results in zero. This theorem is essential for simplifying expressions and proving more complex results regarding power series.

### Dependencies
- Definitions: `ring_powerseries`, `poly_mul`, `poly_0`, `poly_const`
- Theorems: `COND_ID`, `FUN_EQ_THM`, `RING_SUM_EQ_0`, `FORALL_PAIR_THM`, `RING_MUL_LZERO`, `RING_MUL_RZERO`


---

## powser_ring_carrier

### Name of formal statement
powser_ring_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powser_ring_carrier = prove(`
  !r:R ring. !s:V->bool.
  ring_carrier(powser_ring r s) = {p | ring_powerseries r p /\ poly_vars r p SUBSET s}
`,
  qed[POWSER_RING]
);;
```
### Informal statement
For any ring `r` and any set of variables `s` (a subset of `V`), the carrier set of the power series ring `powser_ring r s` is equal to the set of all `p` such that `p` is a ring power series over `r` and the set of polynomial variables in `p` is a subset of `s`.

### Informal sketch
The proof demonstrates the equality of the carrier set of the power series ring `powser_ring r s` with the set `{p | ring_powerseries r p /\ poly_vars r p SUBSET s}`. This involves showing that an element belongs to `ring_carrier(powser_ring r s)` if and only if it satisfies the condition `ring_powerseries r p /\ poly_vars r p SUBSET s`. The proof refers to the definition of `powser_ring` and uses the theorem `POWSER_RING`.

*   The theorem unfolds the definition of `ring_carrier` applied to `powser_ring r s`.
*   It proceeds by showing that `ring_powerseries r p` holds and that the polynomial variables of `p` are a subset of `s`, namely `poly_vars r p SUBSET s`.

### Mathematical insight
This theorem characterizes the elements belonging to the carrier set of the power series ring. It states that the carrier set consists of elements that are ring power series whose polynomial variables are all contained within the specified set `s`. This is important for establishing the properties of the power series ring and performing algebraic manipulations within it.

### Dependencies
- Definition: `ring_carrier`
- Definition: `powser_ring`
- Theorem: `POWSER_RING`
- Definition: `ring_powerseries`
- Definition: `poly_vars`
- Definition: `SUBSET`


---

## poly_ring_carrier

### Name of formal statement
poly_ring_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ring_carrier = prove(`
  !r:R ring. !s:V->bool.
  ring_carrier(poly_ring r s) = {p | ring_polynomial r p /\ poly_vars r p SUBSET s}
`,
  qed[POLY_RING]
);;
```
### Informal statement
For any ring `r` and any set of variables `s` (where `s` is a boolean-valued function on variables), the carrier of the polynomial ring `poly_ring r s` is equal to the set of polynomials `p` (over the ring `r`) such that `p` is a ring polynomial over `r` and the variables of `p` are a subset of `s`.

### Informal sketch
- The theorem states the carrier of the polynomial ring, `poly_ring r s`, is the set of all ring polynomials over the ring `r` whose variables are a subset of `s`.
- The proof, indicated by `qed[POLY_RING]`, relies on the theorem `POLY_RING`.
- The proof likely involves showing that the set {`p` | `ring_polynomial r p /\ poly_vars r p SUBSET s`} satisfies the necessary properties to be the carrier of the polynomial ring `poly_ring r s`. This probably includes showing that it is a subset of the underlying type and is closed under the ring operations.

### Mathematical insight
The theorem `poly_ring_carrier` is important for defining the structure of a polynomial ring. It specifies what elements belong to the polynomial ring, which is crucial for proving properties about polynomial rings and their operations. The condition that `poly_vars r p SUBSET s` ensures that the polynomials in the ring only use variables from the specified set `s`. This is important for constructing polynomial rings with a specific set of variables.

### Dependencies
- Definitions: `ring_carrier`, `poly_ring`, `ring_polynomial`, `poly_vars`
- Theorems: `POLY_RING`

### Porting notes (optional)
- Ensure that the definitions of `ring_carrier`, `poly_ring`, `ring_polynomial`, and `poly_vars` are available and compatible.
- The `POLY_RING` theorem encapsulates the main proof effort and must be ported, ensuring that all relevant properties are maintained.


---

## poly_in_full_ring

### Name of formal statement
poly_in_full_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_in_full_ring = prove(`
  !(r:R ring) p:(V->num)->R.
  ring_polynomial r p
  <=> p IN ring_carrier(poly_ring r (:V))
`,
  intro THEN
  rw[POLY_RING;IN_ELIM_THM] THEN
  set_fact `poly_vars(r:R ring) p SUBSET (:V)` THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and any function `p` from a type `V` to numbers, `p` is a ring polynomial with respect to `r` if and only if `p` is an element of the carrier of the ring `poly_ring r (:V)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the ring `r` and the function `p`.
- Rewrite using the definition of `POLY_RING`, relating ring polynomials to functions from finite sets of variables to coefficients.
- Rewrite using the theorem `IN_ELIM_THM` to eliminate the set membership based on the carrier.
- Set the fact that `poly_vars(r:R ring) p SUBSET (:V)`, which means the support of the polynomial `p` with ring `r` is a subset of the variable type `:V`, by default.
- Conclude the proof.

### Mathematical insight
This theorem establishes the equivalence between the `ring_polynomial` predicate and set membership in the carrier of the `poly_ring`. It connects the abstract definition of a ring polynomial (via `ring_polynomial`) to the concrete representation as elements within the ring structure `poly_ring`, which is constructed from the coefficients and variables. This is a fundamental bridge, saying a polynomial "is" a certain mathematical object constructible using ring operations.

### Dependencies
- Definitions: `POLY_RING`
- Theorems: `IN_ELIM_THM`


---

## series_in_full_ring

### Name of formal statement
series_in_full_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let series_in_full_ring = prove(`
  !(r:R ring) p:(V->num)->R.
  ring_powerseries r p
  <=> p IN ring_carrier(powser_ring r (:V))
`,
  intro THEN
  rw[POWSER_RING;IN_ELIM_THM] THEN
  set_fact `poly_vars(r:R ring) p SUBSET (:V)` THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any function `p` from `V` to numbers, `p` is a ring power series over `r` if and only if `p` is in the carrier of the ring structure of power series over `r` with variable set `V`.

### Informal sketch
The proof proceeds by:
- Introduction: Introducing the variables `r` and `p`.
- Rewriting: Expanding the definition of `POWSER_RING` and using the theorem `IN_ELIM_THM` to eliminate the `IN` predicate.
- Setting a fact: Using the assumption `poly_vars(r:R ring) p SUBSET (:V)`.
- QED: This completes the proof.

### Mathematical insight
This theorem establishes the equivalence between the condition for a function `p` to be considered a formal power series over a ring `r` with variables in `V`, defined by the predicate `ring_powerseries r p`, and the membership of `p` within the carrier set of the ring structure of formal power series over `r` with variables `V`, `ring_carrier(powser_ring r (:V))`. This equivalence is fundamental for reasoning about formal power series with ring operations within the HOL Light system.

### Dependencies
- Definitions: `POWSER_RING`, `ring_powerseries`, `ring_carrier`
- Theorems: `IN_ELIM_THM`


---

## poly_sub_ldistrib_lemma

### Name of formal statement
poly_sub_ldistrib_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_ldistrib_lemma = prove(`
  !(r:R ring) p1 p2 p3.
  p1 IN ring_carrier r ==>
  p2 IN ring_carrier r ==>
  p3 IN ring_carrier r ==>
  ring_mul r p1 (ring_add r p2 (ring_neg r p3)) =
  ring_add r (ring_mul r p1 p2) (ring_neg r (ring_mul r p1 p3))
`,
  RING_TAC
);;
```
### Informal statement
For any ring `r`, and for any `p1`, `p2`, `p3` in the carrier set of `r`, it holds that `ring_mul r p1 (ring_add r p2 (ring_neg r p3))` is equal to `ring_add r (ring_mul r p1 p2) (ring_neg r (ring_mul r p1 p3))`.

### Informal sketch
The proof uses `RING_TAC`, which is a decision procedure for ring equalities. It automatically simplifies the expression based on the ring axioms to prove the equality. The statement expresses that multiplication distributes over subtraction (expressed as addition with the negative) in a ring.

### Mathematical insight
This theorem expresses the left distributivity of multiplication over subtraction in a ring. It's a fundamental property of rings and is used extensively in algebraic manipulations. It essentially states that multiplying a term by the difference of two other terms is equivalent to multiplying the term by each of the two terms individually and then subtracting the results.

### Dependencies
- Definitions: `ring_carrier`, `ring_mul`, `ring_add`, `ring_neg`
- Theorems: Ring axioms (implicitly used by `RING_TAC`)

### Porting notes (optional)
The `RING_TAC` in HOL Light encapsulates a set of ring axioms and simplification rules. When porting to another proof assistant, you may need to explicitly state and apply these ring axioms to achieve the equivalent result. If the target proof assistant has a dedicated tactic for ring normalization or simplification, it can be used to prove this theorem directly. Otherwise, the distributivity and other pertinent ring axioms need to be applied manually.


---

## poly_sub_ldistrib

### Name of formal statement
poly_sub_ldistrib

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_ldistrib = prove
 (`!r p1 p2 (p3:(V->num)->R).
      ring_powerseries r p1 ==>
      ring_powerseries r p2 ==>
      ring_powerseries r p3
      ==> poly_mul r p1 (poly_sub r p2 p3) =
          poly_sub r (poly_mul r p1 p2) (poly_mul r p1 p3)`,
  intro THEN
  rw[POLY_SUB] THEN
  rw[prove(`poly_neg(r:R ring) = ring_neg(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_add(r:R ring) = ring_add(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_mul(r:R ring) = ring_mul(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  have `p1 IN ring_carrier(powser_ring(r:R ring) (:V))` [series_in_full_ring] THEN
  have `p2 IN ring_carrier(powser_ring(r:R ring) (:V))` [series_in_full_ring] THEN
  have `p3 IN ring_carrier(powser_ring(r:R ring) (:V))` [series_in_full_ring] THEN
  qed[poly_sub_ldistrib_lemma]
);;
```
### Informal statement
For any ring `r`, and for all power series `p1`, `p2`, and `p3` over the ring of power series over `r`, if `p1`, `p2`, and `p3` are ring power series with respect to `r`, then the power series multiplication of `p1` with the power series subtraction of `p2` and `p3` is equal to the power series subtraction of the power series multiplication of `p1` and `p2` with the power series multiplication of `p1` and `p3`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Rewrite using the definitions of `POLY_SUB` (powerseries subtraction).
- Rewrite using that `poly_neg` is `ring_neg` for power series rings.
- Rewrite using that `poly_add` is `ring_add` for power series rings.
- Rewrite using that `poly_mul` is `ring_mul` for power series rings.
- Show that `p1` is in the carrier of the power series ring.
- Show that `p2` is in the carrier of the power series ring.
- Show that `p3` is in the carrier of the power series ring.
- Conclude using `poly_sub_ldistrib_lemma`, which establishes the left distributivity of multiplication over subtraction in rings.

### Mathematical insight
This theorem states that multiplication distributes from the left over subtraction in the ring of power series. This is a fundamental property of rings. The proof exploits the fact that the power series operations are ring operations.

### Dependencies
- `POLY_SUB`
- `POWSER_RING`
- `poly_sub_ldistrib_lemma`


---

## poly_sub_rdistrib_lemma

### Name of formal statement
poly_sub_rdistrib_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_rdistrib_lemma = prove(`
  !(r:R ring) p1 p2 p3.
  p1 IN ring_carrier r ==>
  p2 IN ring_carrier r ==>
  p3 IN ring_carrier r ==>
  ring_mul r (ring_add r p2 (ring_neg r p3)) p1 =
  ring_add r (ring_mul r p2 p1) (ring_neg r (ring_mul r p3 p1))
`,
  RING_TAC
);;
```

### Informal statement
For any ring `r`, and any elements `p1`, `p2`, and `p3` in the carrier of the ring `r`, it is the case that `ring_mul r (ring_add r p2 (ring_neg r p3)) p1` is equal to `ring_add r (ring_mul r p2 p1) (ring_neg r (ring_mul r p3 p1))`.

### Informal sketch
The proof is done by `RING_TAC`. This tactic automatically proves ring identities by normalizing both sides of the equation using the axioms of a ring. It handles associativity, commutativity, distributivity, and the properties of additive and multiplicative identities and inverses. Since the statement is a ring identity, `RING_TAC` suffices for the proof.

### Mathematical insight
This theorem expresses the right distributivity of multiplication over subtraction in a ring. It shows that multiplying the difference of two ring elements on the right by another ring element is equivalent to taking the difference of the products of each of the original elements with the multiplier. This is a fundamental property of rings.

### Dependencies
- ring_carrier
- ring_mul
- ring_add
- ring_neg
- ring


---

## poly_sub_rdistrib

### Name of formal statement
poly_sub_rdistrib

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_rdistrib = prove
 (`!r p1 p2 (p3:(V->num)->R).
      ring_powerseries r p1 ==>
      ring_powerseries r p2 ==>
      ring_powerseries r p3
      ==> poly_mul r (poly_sub r p2 p3) p1 =
          poly_sub r (poly_mul r p2 p1) (poly_mul r p3 p1)`,
  intro THEN
  rw[POLY_SUB] THEN
  rw[prove(`poly_neg(r:R ring) = ring_neg(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_add(r:R ring) = ring_add(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_mul(r:R ring) = ring_mul(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  have `p1 IN ring_carrier(powser_ring(r:R ring) (:V))` [series_in_full_ring] THEN
  have `p2 IN ring_carrier(powser_ring(r:R ring) (:V))` [series_in_full_ring] THEN
  have `p3 IN ring_carrier(powser_ring(r:R ring) (:V))` [series_in_full_ring] THEN
  qed[poly_sub_rdistrib_lemma]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any power series `p1`, `p2`, and `p3` of type `(V->num)->R`, if `p1`, `p2`, and `p3` are ring power series with respect to `r`, then multiplying the power series `p1` by the difference of power series `p2` and `p3` is equal to the difference of the power series `p2` multiplied by `p1`, and the power series `p3` multiplied by `p1`.

### Informal sketch
The proof proceeds as follows:
- Start by introducing the assumptions.
- Rewrite the left-hand side of the equation using the definition of `POLY_SUB` .
- Rewrite the left-hand side using the definition of `poly_neg` in terms of `ring_neg` within the `powser_ring`.
- Rewrite the left-hand side using the definition of `poly_add` in terms of `ring_add` within the `powser_ring`.
- Rewrite the left-hand side using the definition of `poly_mul` in terms of `ring_mul` within the `powser_ring`.
- Show that `p1` is in the carrier of the ring `powser_ring r (:V)`.
- Show that `p2` is in the carrier of the ring `powser_ring r (:V)`.
- Show that `p3` is in the carrier of the ring `powser_ring r (:V)`.
- Apply the lemma `poly_sub_rdistrib_lemma` and conclude.

### Mathematical insight
This theorem establishes the right distributivity of polynomial multiplication over subtraction in the context of power series rings. It's a fundamental property that simplifies algebraic manipulations involving power series. Establishing this distributive property allows for rearrangement of expressions during formal calculation, which is essential for simplifying bigger proofs.

### Dependencies
- `POLY_SUB`
- `POWSER_RING`
- `poly_sub_rdistrib_lemma`

### Porting notes (optional)
The most substantial challenges when porting this proof lie in ensuring that the ring theory and power series constructions are presented correctly in the target proof assistant. Specifically, you must check that the ring operations for power series rings are defined as desired, and that these ring homomorphic operations are connected to `poly_neg`, `poly_add`, and `poly_mul` correctly. Be careful to verify that any lemmas which are extracted from the ring tactic are correct.


---

## poly_sub_0

### Name of formal statement
poly_sub_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_0 = prove(`
  !(r:R ring) p:(V->num)->R.
  ring_powerseries r p ==>
  poly_sub r p (poly_0 r) = p
`,
  intro THEN
  rw[POLY_SUB] THEN
  rw[prove(`poly_neg(r:R ring) = ring_neg(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_add(r:R ring) = ring_add(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_0(r:R ring) = ring_0(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  set_fact `ring_powerseries r (p:(V->num)->R) ==> p IN {q | ring_powerseries r q /\ poly_vars r q SUBSET (:V)}` THEN
  specialize[`r:R ring`;`(:V)`](CONJUNCT1 POWSER_RING) THEN
  have `(p:(V->num)->R) IN ring_carrier(powser_ring(r:R ring) (:V))` [] THEN
  qed[RING_RULE `ring_add (r:R ring) p (ring_neg r (ring_0 r)) = p`]
);;
```

### Informal statement
For any ring `r` and any ring powerseries `p` over the variables `V` with coefficients in `r`, subtracting the zero polynomial `poly_0 r` from `p` results in `p` itself.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions: a ring `r` and a ring powerseries `p`.
- Rewrite using the definition of `POLY_SUB`, `poly_neg`, `poly_add`, and `poly_0` (in terms of `ring_neg`, `ring_add`, and `ring_0` respectively on the powerseries ring).
- Apply the fact that `p` is an element of the carrier of the powerseries ring.
- Use the ring rule `ring_add r p (ring_neg r (ring_0 r)) = p` to complete the proof.

### Mathematical insight
This theorem states that the zero polynomial is an identity element for subtraction in the ring of polynomials. This is a fundamental property of polynomials and rings, ensuring that subtracting nothing from a polynomial leaves it unchanged. This theorem is useful in simplifying polynomial expressions and reasoning about polynomial equality.

### Dependencies
- Definitions: `POLY_SUB`, `poly_neg`, `poly_add`, `poly_0`, `ring_powerseries`
- Theorems/Axioms: `POWSER_RING`, `RING_RULE`


---

## poly_0_sub

### Name of formal statement
poly_0_sub

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_0_sub = prove(`
  !(r:R ring) p:(V->num)->R.
  ring_powerseries r p ==>
  poly_sub r (poly_0 r) p = poly_neg r p
`,
  intro THEN
  rw[POLY_SUB] THEN
  rw[prove(`poly_neg(r:R ring) = ring_neg(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_add(r:R ring) = ring_add(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  rw[prove(`poly_0(r:R ring) = ring_0(powser_ring r (:V))`,qed[POWSER_RING])] THEN
  set_fact `ring_powerseries r (p:(V->num)->R) ==> p IN {q | ring_powerseries r q /\ poly_vars r q SUBSET (:V)}` THEN
  specialize[`r:R ring`;`(:V)`](CONJUNCT1 POWSER_RING) THEN
  have `(p:(V->num)->R) IN ring_carrier(powser_ring(r:R ring) (:V))` [] THEN
  qed[RING_RULE `ring_add (r:R ring) (ring_0 r) (ring_neg r p) = ring_neg r p`]
);;
```

### Informal statement
For any ring `r` of type `R ring` and any polynomial `p` of type `(V->num)->R` which is a ring power series, the polynomial subtraction of the zero polynomial `poly_0 r` from `p` is equal to the polynomial negation of `p`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions about `r` and `p`.
- Rewrite using the definition of `POLY_SUB`.
- Rewrite using theorems that equate `poly_neg r` and `ring_neg(powser_ring r (:V))`, `poly_add r` and `ring_add(powser_ring r (:V))`, and `poly_0 r` and `ring_0(powser_ring r (:V))`. These theorems are proved with `POWSER_RING`.
- Show that `p` is an element of the carrier of the ring `powser_ring r (:V)`.
- Apply the ring rule `ring_add r (ring_0 r) (ring_neg r p) = ring_neg r p` in the relevant ring.

### Mathematical insight
This theorem establishes a basic algebraic property of polynomials: subtracting the zero polynomial is equivalent to negating the polynomial. It leverages the correspondence between polynomial operations and ring operations on power series. It ensures that polynomial subtraction behaves as expected in the context of ring power series.

### Dependencies
- Definitions: `POLY_SUB`
- Theorems: `POWSER_RING`
- Rules: `RING_RULE`


---

## poly_vars_empty

### Name of formal statement
poly_vars_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_vars_empty = prove(`
  !(r:R ring) p:(V->num)->R.
  poly_vars r p = {} <=>
  p = poly_const r (p monomial_1)
`,
  intro THEN
  splitiff THENL [
    rw[poly_vars] THEN
    rw[EMPTY_UNIONS;monomial_vars;IN_ELIM_THM;poly_const;monomial_1;COND_ID] THEN
    intro THEN
    once_rw[FUN_EQ_THM] THEN
    rw[BETA_THM] THEN
    intro THEN
    proven_if `p(x:V->num) = ring_0(r:R ring)` [] THEN
    have `?m. ~(p m = ring_0(r:R ring)) /\ {i:V | ~(x i = 0)} = {i | ~(m i = 0)}` [] THEN
    have `{i:V | ~(x i = 0)} = {}` [] THEN
    subgoal `x = (\i:V. 0)` THENL [
      rw[FUN_EQ_THM] THEN
      ASM SET_TAC[]
    ; pass
    ] THEN
    qed[]
  ;
    qed[POLY_VARS_CONST]
  ]
);;
```

### Informal statement
For any ring `r` (of type `R ring`) and any polynomial `p` (of type `V->num->R`), the set of variables of `p` (i.e., `poly_vars r p`) is empty if and only if `p` is equal to the polynomial constant function `poly_const r (p monomial_1)`.

### Informal sketch
The proof proceeds by showing the equivalence in both directions:

- (=>) Assume `poly_vars r p = {}`. We need to show `p = poly_const r (p monomial_1)`.
  - Expanding the definition of `poly_vars`, we have `EMPTY_UNIONS`, `monomial_vars`, `IN_ELIM_THM`, `poly_const`, `monomial_1`, and `COND_ID`.
  - Use `FUN_EQ_THM` and `BETA_THM` to show that `p(x:V->num) = ring_0(r:R ring)`. Then make use of the assumption that `?m. ~(p m = ring_0(r:R ring)) /\ {i:V | ~(x i = 0)} = {i | ~(m i = 0)}`, showing `{i:V | ~(x i = 0)} = {}`.
  - Show `x = (\i:V. 0)` using `FUN_EQ_THM`.
- (<=) If `p = poly_const r (p monomial_1)`, apply the theorem `POLY_VARS_CONST` to conclude `poly_vars r p = {}`.

### Mathematical insight
The theorem states that a polynomial has no variables if and only if it is a constant polynomial. The forward direction is a bit involved because you have to deal with the possibility that `p` could evaluate to zero for some values.

### Dependencies
- `poly_vars`
- `EMPTY_UNIONS`
- `monomial_vars`
- `IN_ELIM_THM`
- `poly_const`
- `monomial_1`
- `COND_ID`
- `FUN_EQ_THM`
- `BETA_THM`
- `POLY_VARS_CONST`


---

## poly_neg_in_poly_ring

### Name of formal statement
poly_neg_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_neg_in_poly_ring = prove(`
  !(r:R ring) p:(V->num)->R S.
  p IN ring_carrier(poly_ring r S) ==>
  poly_neg r p IN ring_carrier(poly_ring r S)
`,
  qed[RING_NEG;POLY_RING]
);;
```
### Informal statement
For any ring `r` and any set `S` of variables, if `p` is a polynomials with variables in `S` over ring `r` such that `p` is in the carrier of the polynomial ring over `r` with variables in `S`, then `poly_neg r p` (the negation of `p` within the polynomial ring) is also in the carrier of the polynomial ring over `r` with variables in `S`.

### Informal sketch
- The proof uses the theorem `RING_NEG`, which states that the negation operation in a ring preserves membership in the ring's carrier set.
- The theorem `POLY_RING` establishes the structure of polynomial rings.

### Mathematical insight
This theorem shows that the polynomial ring carrier is closed under negation. This is one of the requirements for `ring_carrier(poly_ring r S)` to be a ring.

### Dependencies
- Theorems: `RING_NEG`, `POLY_RING`


---

## poly_add_in_poly_ring

### Name of formal statement
poly_add_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_add_in_poly_ring = prove(`
  !(r:R ring) p:(V->num)->R q S.
  p IN ring_carrier(poly_ring r S) ==>
  q IN ring_carrier(poly_ring r S) ==>
  poly_add r p q IN ring_carrier(poly_ring r S)
`,
  qed[RING_ADD;POLY_RING]
);;
```
### Informal statement
For any ring `r` and any set `S`, if `p` and `q` are polynomials over `r` with variables in `S` that are elements of the carrier of the polynomial ring over `r` with variables `S`, then the polynomial addition of `p` and `q` in the ring `r` is also an element of the carrier of the polynomial ring over `r` with variables `S`.

### Informal sketch
The proof demonstrates the closure of polynomial addition within the polynomial ring's carrier set.
- The proof starts with the assumptions that `p` and `q` belong to the carrier of the polynomial ring `poly_ring r S`.
- It then uses the theorem `RING_ADD` to show that the polynomial addition `poly_add r p q` is also in the carrier of `poly_ring r S`.
- The `POLY_RING` is invoked to unpack the definition of `poly_ring`.

### Mathematical insight
This theorem establishes that the addition operation, when applied to polynomials within a polynomial ring, results in another polynomial within the same ring, ensuring closure under addition. Polynomial rings, constructed over a base ring and a set of variables, form a fundamental algebraic structure. Showing closure under addition is a basic requirement for them to be rings.

### Dependencies
- Theorems: `RING_ADD`
- Definitions: `POLY_RING`


---

## poly_sub_in_poly_ring

### Name of formal statement
poly_sub_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_in_poly_ring = prove(`
  !(r:R ring) p:(V->num)->R q S.
  p IN ring_carrier(poly_ring r S) ==>
  q IN ring_carrier(poly_ring r S) ==>
  poly_sub r p q IN ring_carrier(poly_ring r S)
`,
  rw[POLY_SUB] THEN
  qed[poly_neg_in_poly_ring;poly_add_in_poly_ring]
);;
```
### Informal statement
For any ring `r` with carrier `R`, and any set `S`, the following holds: If `p` is a polynomial (represented as a function from variables to coefficients) in the carrier of the polynomial ring over `r` with variables in `S`, and `q` is a polynomial in the carrier of the polynomial ring over `r` with variables in `S`, then the polynomial subtraction of `p` and `q` (denoted `poly_sub r p q`) is also in the carrier of the polynomial ring over `r` with variables in `S`.

### Informal sketch
The proof proceeds as follows:
- First, the definition of `poly_sub r p q` as `poly_add r p (poly_neg r q)` is unfolded using `rw[POLY_SUB]`.
- Then, it is shown that `poly_neg r q` is in the carrier of the polynomial ring by `poly_neg_in_poly_ring`.
- Next, it is shown that `poly_add r p (poly_neg r q)` is in the carrier of the polynomial ring by `poly_add_in_poly_ring`, utilizing that `p` and `poly_neg r q` are in the carrier.
- The theorem is proved.

### Mathematical insight
This theorem establishes that the polynomial ring is closed under subtraction. It is a standard requirement for rings, ensuring that the set of polynomials forms a ring structure under the defined operations. This closure property is essential for algebraic manipulations and reasoning within the polynomial ring.

### Dependencies
- Definition: `POLY_SUB`
- Theorem: `poly_neg_in_poly_ring`
- Theorem: `poly_add_in_poly_ring`


---

## poly_mul_in_poly_ring

### Name of formal statement
poly_mul_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_in_poly_ring = prove(`
  !(r:R ring) p:(V->num)->R q S.
  p IN ring_carrier(poly_ring r S) ==>
  q IN ring_carrier(poly_ring r S) ==>
  poly_mul r p q IN ring_carrier(poly_ring r S)
`,
  qed[RING_MUL;POLY_RING]
);;
```
### Informal statement
For any ring `r` with carrier `R`, and any set `S` of variables, if `p` and `q` are polynomials (represented as functions from variables to ring elements) in the polynomial ring over `r` with variables `S`, then their product `poly_mul r p q` is also in the carrier of the polynomial ring over `r` with variables `S`.

### Informal sketch
The proof proceeds by showing that the product of two polynomials in the polynomial ring remains within the polynomial ring's carrier set.
- The proof relies on the fact that the ring structure is preserved under polynomial multiplication (`RING_MUL`). This means that when multiplying elements within a ring, the result remains within the ring.
- It also uses the definition of the polynomial ring (`POLY_RING`), showing that multiplying polynomials defined over this ring according to their multiplication operation, yields another polynomial element within ring.

### Mathematical insight
This theorem confirms that polynomial multiplication, as defined within the `poly_ring` structure, is closed. Closure is a fundamental property required for defining valid algebraic rings. This theorem is important because it guarantees that when performing polynomial multiplication within the formal system, the result will always be a valid polynomial within the defined framework.

### Dependencies
- Theorems: `RING_MUL`
- Definitions: `POLY_RING`


---

## poly_var_o_permutes

### Name of formal statement
poly_var_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_var_o_permutes = prove(`
  !(r:R ring) v:V S f:V->V m.
  f permutes S ==>
  poly_var r v (m o f)
  = poly_var r (f v) m
`,
  rw[poly_var;monomial_var] THEN
  rw[FUN_EQ_THM;o_THM] THEN
  rw[permutes] THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, any type `V`, any set `S` of type `V`, any function `f` of type `V -> V`, and any function `m` of type `V -> R`, if `f` permutes `S`, then `poly_var r v (m o f)` equals `poly_var r (f v) m`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definition of `poly_var` and `monomial_var`.
- Rewriting using the theorem `FUN_EQ_THM` and the definition of function composition `o_THM`.
- Rewriting using the definition of `permutes`.
- Applying `qed[]` to complete the proof based on the simplifications.

### Mathematical insight
The theorem states that if we have a function `f` that permutes a set `S`, then evaluating `poly_var` at `v` after applying `f` to the function `m`(given by `m o f`) is the same as evaluating `poly_var` with `f v` applied to `m`. This is an important result when working with polynomials and permutations in a formal setting and can be applied in settings where one wants to relate the evaluation of polynomials before and after a variable permutation.

### Dependencies
- Definitions: `poly_var`, `monomial_var`, `permutes`
- Theorems: `FUN_EQ_THM`, `o_THM`


---

## poly_neg_o_permutes

### Name of formal statement
poly_neg_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_neg_o_permutes = prove(`
  !(r:R ring) p:(V->num)->R (f:V->W) m.
  poly_neg r p (m o f) =
  poly_neg r (\m. p (m o f)) m
`,
  rw[poly_neg]
);;
```

### Informal statement
For any ring `R`, map `V->num`, map `V->R`, map `f:V->W` and map `m:W->V`, the negative of the polynomial evaluated from `V` to `R` at `m o f` is equal to the negative of the polynomial `p (m o f)` evaluated `m`.

### Informal sketch
The proof proceeds by rewriting the term `poly_neg r p (m o f)` using the definition of `poly_neg`.

### Mathematical insight
The theorem demonstrates properties of function composition with respect to polynomial evaluation. The key aspect here is that applying a function `m o f` to the polynomial `poly_neg r p` is equivalent to forming a new polynomial based on `p (m o f)` and evaluating at `m`.

### Dependencies
- `poly_neg`


---

## poly_add_o_permutes

### Name of formal statement
poly_add_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_add_o_permutes = prove(`
  !(r:R ring) p:(V->num)->R q (f:V->W) m.
  poly_add r p q (m o f) =
  poly_add r (\m. p (m o f)) (\m. q (m o f)) m
`,
  rw[poly_add]
);;
```
### Informal statement
For any ring `R`, any functions `p` and `q` from `V` to `num`, any function `f` from `V` to `W`, and any function `m` from `W` to `num`, the polynomial addition of `p` and `q` applied to the composition of `m` and `f` is equal to the polynomial addition of the function that maps `m` to `p` composed with `m` and `f`, and the function that maps `m` to `q` composed with `m` and `f`, all applied to `m`. Formally:
  `∀ (r:R ring) p:(V->num) q (f:V->W) m. poly_add r p q (m o f) = poly_add r (\m. p (m o f)) (\m. q (m o f)) m`

### Informal sketch
- The proof uses `rw[poly_add]` to rewrite the `poly_add` term. This single rewrite expands the definition of `poly_add` and the result follows by simplifying.

### Mathematical insight
This theorem describes how polynomial addition interacts with function composition. It shows that the addition of two polynomials applied to a composition of functions is the same as adding the polynomials post-composed with the composition.

### Dependencies
`poly_add`


---

## poly_sub_o_permutes

### Name of formal statement
poly_sub_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sub_o_permutes = prove(`
  !(r:R ring) p:(V->num)->R q (f:V->W) m.
  poly_sub r p q (m o f) =
  poly_sub r (\m. p (m o f)) (\m. q (m o f)) m
`,
  rw[poly_sub]
);;
```
### Informal statement
For any ring `R`, any functions `p` and `q` from `V` to the natural numbers, any function `f` from `V` to `W`, and any function `m` from `W` to `R`, the polynomial substitution of `m o f` into `p` and `q` is equal to the polynomial substitution of `m` into `p o f` and `q o f`. Here `o` denotes function composition.

### Informal sketch
The proof reduces to unfolding the definition of `poly_sub` and then applying the definition of function composition. The main step is using the rewrite tactic `rw[poly_sub]` to expand the definition of `poly_sub`.

### Mathematical insight
This theorem states how polynomial substitution interacts with function composition. It essentially says that substituting a composed function (`m o f`) into a polynomial expressed by `p` and `q` yields the same result as first composing `p` and `q` with `f` and then substituting `m`. This simplifies calculations and provides a way to interchange substitution and composition operations.

### Dependencies
- Definition: `poly_sub`


---

## poly_mul_o_permutes

### Name of formal statement
poly_mul_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_o_permutes = prove(`
  !(r:R ring) p:(V->num)->R q S f m.
  f permutes S ==>
  poly_mul r p q (m o f) =
  poly_mul r (\m. p (m o f)) (\m. q (m o f)) m
`,
  rw[poly_mul] THEN
  intro THEN
  subgoal `{m1,m2 | monomial_mul m1 m2 = m o f} = IMAGE (\(m1,m2). ((m1:V->num) o (f:V->V)),(m2 o f)) {m1,m2 | monomial_mul m1 m2 = m}` THENL [
    rw[EXTENSION;IN_IMAGE;FORALL_PAIR_THM;EXISTS_PAIR_THM;IN_ELIM_PAIR_THM;PAIR_EQ] THEN
    rw[monomial_mul] THEN
    intro THEN
    splitiff THENL [
      intro THEN
      witness `(p1:V->num) o inverse(f:V->V)` THEN
      witness `(p2:V->num) o inverse(f:V->V)` THEN
      intro THENL [
        rw[GSYM o_ASSOC] THEN
        specialize[`f:V->V`;`S:V->bool`]PERMUTES_INVERSES_o THEN
        qed[I_O_ID]
      ;
        rw[GSYM o_ASSOC] THEN
        specialize[`f:V->V`;`S:V->bool`]PERMUTES_INVERSES_o THEN
        qed[I_O_ID]
      ;
        rw[FUN_EQ_THM] THEN
        intro THEN
        have_rw `x:V = f (inverse f x:V)` [PERMUTES_INVERSES] THEN
        rw[o_THM] THEN
        have `inverse f (f(inverse f x:V):V) = inverse f x` [PERMUTES_INVERSES] THEN
        qed[o_DEF]
      ]
    ;
      intro THEN
      simp[o_DEF] THEN
      rw[FUN_EQ_THM] THEN
      qed[]
    ]
  ; pass
  ] THEN
  subgoal `ring_sum(r:R ring) (IMAGE (\(m1,m2). m1 o (f:V->V),m2 o f) {m1,m2 | monomial_mul m1 m2 = m:V->num}) (\(m1,m2). ring_mul r (p m1) (q m2)) = ring_sum r {m1,m2 | monomial_mul m1 m2 = m} ((\(m1,m2). ring_mul r (p m1) (q m2)) o (\(m1,m2). m1 o f,m2 o f))` THENL [
    subgoal `!x y. x IN {m1,m2 | monomial_mul m1 m2 = m:V->num} ==> y IN {m1,m2 | monomial_mul m1 m2 = m} ==> (\(m1,m2). m1 o (f:V->V),m2 o f) x = (\(m1,m2). m1 o f,m2 o f) y ==> x = y` THENL [
      rw[FORALL_PAIR_THM;IN_ELIM_PAIR_THM;PAIR_EQ] THEN
      qed[o_permutes_cancel]
    ; pass
    ] THEN
    specialize[
      `r:R ring`;
      `(\(m1,m2). (m1:V->num) o (f:V->V),(m2:V->num) o (f:V->V))`;
      `\(m1,m2). ring_mul(r:R ring) (p(m1:V->num)) (q(m2:V->num))`;
      `{m1,m2 | monomial_mul m1 m2 = m:V->num}`
    ]RING_SUM_IMAGE THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[FORALL_PAIR_THM] THEN
  intro THEN
  rw[o_THM]
);;
```
### Informal statement
For any ring `r`, functions `p:V->R` and `q:V->R`, set `S:V->bool`, permutation `f:V->V` such that `f` permutes `S`, and function `m:V->num`, the polynomial multiplication of `p` and `q` evaluated at `m o f` is equal to the polynomial multiplication of `p o f` and `q o f` evaluated at `m`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the definition of `poly_mul` to expand the definition.
- Introduce the variables.
- Prove that the image of pairs `(m1, m2)` such that `monomial_mul m1 m2 = m` under the function `\(m1,m2). ((m1:V->num) o (f:V->V)),(m2 o f))` is equal to the set of pairs `(m1, m2)` such that `monomial_mul m1 m2 = m o f`. This is done by showing that an element is in the image if and only if `monomial_mul m1 m2 = m o f`, which reduces to proving two implications:
    - If `monomial_mul m1 m2 = m o f`, then such `(m1, m2)` is in the image, which is proven by witnessing `(p1:V->num) o inverse(f:V->V)` and `(p2:V->num) o inverse(f:V->V)` and using `PERMUTES_INVERSES_o` to show equality.
    - The converse is trivial.
- Show that `ring_sum` over the image is equal to the `ring_sum` over the original set composed with the function `\(m1,m2). m1 o f,m2 o f)`.
    - Show that `(\(m1,m2). m1 o (f:V->V),m2 o f)` is injective using `o_permutes_cancel`.
    - Apply theorem `RING_SUM_IMAGE` after specializing for it's arguments
- Simplify with `simp[]`.
- The goal follows by `RING_SUM_EQ`, using `o_THM`.

### Mathematical insight
This theorem shows that polynomial multiplication is invariant under permutations of the variables. This is a key property when dealing with symmetric polynomials, as it allows one to work with a canonical representation of the polynomial that is independent of the order of the variables.

### Dependencies
- `poly_mul`
- `EXTENSION`
- `IN_IMAGE`
- `FORALL_PAIR_THM`
- `EXISTS_PAIR_THM`
- `IN_ELIM_PAIR_THM`
- `PAIR_EQ`
- `monomial_mul`
- `GSYM`
- `o_ASSOC`
- `FUN_EQ_THM`
- `I_O_ID`
- `o_DEF`
- `o_permutes_cancel`
- `RING_SUM_IMAGE`
- `RING_SUM_EQ`
- `o_THM`
- `PERMUTES_INVERSES`
- `PERMUTES_INVERSES_o`

### Porting notes (optional)
The proof relies heavily on rewriting and equational reasoning. A proof assistant with good support for these techniques will be helpful. The use of `IMAGE` and set comprehensions might require some care when translated to other systems. The `witness` tactic within `subgoal` for showing existential quantification must be carefully translated to other proof assistants.


---

## monomial_1_o_permutes

### Name of formal statement
monomial_1_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_1_o_permutes = prove(`
  !f S.
  f permutes S ==>
  monomial_1 o f = monomial_1:V->num
`,
  rw[monomial_1;o_DEF]
);;
```

### Informal statement
For any function `f` and any set `S`, if `f` permutes `S`, then the composition `monomial_1 o f` is equal to `monomial_1`, where `monomial_1` is understood as a function from a vector space `V` to the number type `num`.

### Informal sketch
The proof is a direct application of rewriting using the definitions of `monomial_1` and `o_DEF` (function composition).

- The definition of `monomial_1` effectively defines a constant function.
- The theorem states that composing this constant function with any permutation leaves the function unchanged.
- The proof reduces trivially to the definition after rewriting.

### Mathematical insight
The theorem `monomial_1_o_permutes` states that the function `monomial_1`, when composed with any permutation `f` over a set `S`, remains unchanged. This indicates that `monomial_1` is invariant under permutation, which highlights that its value is independent of the input element's specific arrangement or order. The key insight is that a constant function composed with any other function yields the same constant function.

### Dependencies
- Definitions: `monomial_1`, `o_DEF`


---

## monomial_1_o_permutes_eq

### Name of formal statement
monomial_1_o_permutes_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_1_o_permutes_eq = prove(`
  !m:V->num f S.
  f permutes S ==>
  ( m o f = monomial_1 <=> m = monomial_1 )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    have `inverse (f:V->V) permutes S` [PERMUTES_INVERSE] THEN
    have `monomial_1 o inverse (f:V->V) = monomial_1` [monomial_1_o_permutes] THEN
    have `(m o f) o inverse (f:V->V) = monomial_1` [monomial_1_o_permutes] THEN
    subgoal `m o (f o inverse (f:V->V)) = monomial_1:V->num` THENL [
      rw[o_ASSOC] THEN
      qed[]
    ; pass
    ] THEN
    qed[I_O_ID;PERMUTES_INVERSES_o]
  ;
    qed[monomial_1_o_permutes]
  ]
);;
```
### Informal statement
For all functions `m` from `V` to numbers, for all functions `f` from `V` to `V`, and for all sets `S` of `V`, if `f` permutes `S`, then `m` composed with `f` equals `monomial_1` if and only if `m` equals `monomial_1`.

### Informal sketch
The proof proceeds by showing both directions of the equivalence.

*   First direction (=>):
    *   Assume `f` permutes `S` and `m o f = monomial_1`.
    *   Since `f` permutes `S`, its inverse `inverse f` also permutes `S` (by `PERMUTES_INVERSE`).
    *   We know that `monomial_1 o inverse f = monomial_1` (by `monomial_1_o_permutes`).
    *   Given `m o f = monomial_1`, we deduce that `(m o f) o inverse f = monomial_1`.
    *   Associativity of function composition (`o_ASSOC`) implies `m o (f o inverse f) = monomial_1`.
    *   Since `f o inverse f` equals the identity function I (by `PERMUTES_INVERSES_o`), we have `m o I = monomial_1`.
    *   Finally, `m o I = m` (by `I_O_ID`), so `m = monomial_1`.
*   Second direction (<=):
    *   Assume `f` permutes `S` and `m = monomial_1`.
    *   Then `m o f = monomial_1 o f = monomial_1` (by `monomial_1_o_permutes`).

### Mathematical insight
This theorem states that if composing `m` with a permutation `f` results in `monomial_1`, that `m` must have originally been `monomial_1`. This makes sense as a permutation merely rearranges the elements, preserving underlying structure. Further, composing the constant-one function `monomial_1` with *any* permutation yields `monomial_1` again.

### Dependencies
*   `o_ASSOC`
*   `I_O_ID`
*   `PERMUTES_INVERSE`
*   `PERMUTES_INVERSES_o`
*   `monomial_1_o_permutes`


---

## poly_const_o_permutes

### Name of formal statement
poly_const_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_o_permutes = prove(`
  !(r:R ring) c (f:V->V) S.
  f permutes S ==>
  poly_const r c (m o f) = poly_const r c m
`,
  rw[poly_const] THEN
  qed[monomial_1_o_permutes_eq]
);;
```
### Informal statement
For any ring `r`, element `c` of `r`, function `f` from `V` to `V`, and set `S`, if `f` permutes `S`, then `poly_const r c (m o f)` is equal to `poly_const r c m`.

### Informal sketch
The proof proceeds as follows:

- First, rewrite using the definition of `poly_const`.
- Then, apply the theorem `monomial_1_o_permutes_eq`.
- Finally, the proof concludes.

### Mathematical insight
This theorem states that composing a monomial with a function that permutes a set does not change the `poly_const` value. Here, `poly_const` computes a polynomial where all variables are equal to a constant `c`. This means that if the input to the monomial `m` is permuted over the set `S`, and `f` is a permutation of `S`, the polynomial is unaffected because only the values in `S` contribute to the result and these are just rearranged.

### Dependencies
- Definitions:
  - `poly_const`
- Theorems:
  - `monomial_1_o_permutes_eq`


---

## poly_0_o_permutes

### Name of formal statement
poly_0_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_0_o_permutes = prove(`
  !(r:R ring) (f:V->V) S.
  f permutes S ==>
  poly_0 r (m o f) = poly_0 r m
`,
  rw[poly_0;poly_const_o_permutes]
);;
```
### Informal statement
For any ring `R`, any function `f` from a type `V` to itself, and any set `S` of type `V`, if `f` permutes `S`, then `poly_0 r (m o f)` is equal to `poly_0 r m`, where `poly_0` is a function that turns a term into zero modulo the ideal generated by S and `m` is a term of type `V`.

### Informal sketch
The proof proceeds by rewriting the goal using the definition of `poly_0` and the theorem `poly_const_o_permutes`.
- The definition of `poly_0` applies a constant function (namely the zero element `r`) to all the elements in `m` modulo the ideal generated by the set `S`.
- Applying `poly_const_o_permutes` handles the zero element `r` composed with function `f` to derive the equality.

### Mathematical insight
This theorem states that composing a function (`m`) with a permutation (`f`) of a set `S` does not change the result of turning `m` into `0` modulo the ideal generated by `S`. This is because the permutation rearranges elements within `S`, and taking the value modulo the ideal generated by S effectively "ignores" which particular element of `S` is being used, since they are all equivalent to 0 in the ideal. This theorem is useful for proving properties about polynomials modulo ideals, where the exact order of elements in the ideal does not matter.

### Dependencies
- Definitions:
    - `poly_0`
- Theorems:
    - `poly_const_o_permutes`


---

## poly_1_o_permutes

### Name of formal statement
poly_1_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_1_o_permutes = prove(`
  !(r:R ring) (f:V->V) S.
  f permutes S ==>
  poly_1 r (m o f) = poly_1 r m
`,
  rw[poly_1;poly_const_o_permutes]
);;
```
### Informal statement
For any ring `R`, any function `f` from `V` to `V`, and any set `S` of type `V`, if `f` permutes `S`, then `poly_1 r (m o f) = poly_1 r m`, where `poly_1` is a polynomial of degree 1, `r` is a ring element of type `R`, and `m` is a mapping from `V` to `R`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `poly_1` and `poly_const_o_permutes`.
- The theorem states that composing the argument of `poly_1` with a permutation of a set `S` does not change the value of the polynomial.
- The rewrite tactic `rw` is used with the definitions of `poly_1` which is `(λr m. &r * vec 1 m)` and `poly_const_o_permutes` to establish the theorem.

### Mathematical insight
The theorem captures the fact that a first-degree polynomial evaluated over a set remains invariant under permutations of that set. This is expected since `poly_1 r m` effectively computes the sum of `m` over the set, and sums are invariant under permutations.

### Dependencies
- Definitions:
  - `poly_1`
- Theorems:
  - `poly_const_o_permutes`


---

## finite_monomial_vars_permutes_lemma

### Name of formal statement
finite_monomial_vars_permutes_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_monomial_vars_permutes_lemma = prove(`
  !m:V->num f:V->V S.
  f permutes S ==>
  FINITE(monomial_vars m) ==>
  FINITE(monomial_vars (m o f))
`,
  intro THEN
  subgoal `IMAGE (f:V->V) (monomial_vars (m o f)) SUBSET monomial_vars m` THENL [
    rw[monomial_vars;SUBSET;in_image_vw;IN_ELIM_THM;o_THM] THEN
    qed[]
  ; pass
  ] THEN
  have `FINITE(IMAGE (f:V->V) (monomial_vars (m o f)))` [FINITE_SUBSET] THEN
  qed[FINITE_IMAGE_INJ_EQ;PERMUTES_INJECTIVE]
);;
```
### Informal statement
For all functions `m` from variables of type `V` to numbers, all functions `f` from variables of type `V` to variables of type `V`, and all sets `S` of variables of type `V`, if `f` permutes `S` and the set of variables in the monomial `m` is finite, then the set of variables in the monomial `m` composed with `f` is also finite.

### Informal sketch
The proof proceeds as follows:
- First, prove the subset relation `IMAGE (f:V->V) (monomial_vars (m o f)) SUBSET monomial_vars m`. This is shown by rewriting `monomial_vars` and using the definition of `SUBSET`, `in_image_vw`, `IN_ELIM_THM`, and the definition of function composition `o_THM`.
- Next, apply the fact that a finite subset of a set is finite using `FINITE_SUBSET`.
- Finally, establish the result that if a function is injective, the image of a finite set under that function is finite using `FINITE_IMAGE_INJ_EQ` and the fact that permutations are injective `PERMUTES_INJECTIVE`.

### Mathematical insight
This theorem shows that if the variables appearing in a monomial `m` form a finite set, then applying a permutation `f` to the variables will result in a monomial `m o f` whose variables also form a finite set. This is due to the fundamental property that permutations preserve the cardinality of sets. This lemma is useful because it enables reasoning about finiteness of monomial variable sets under variable renaming.

### Dependencies
- Definitions: `monomial_vars`, `o_THM`
- Theorems: `SUBSET`, `in_image_vw`, `IN_ELIM_THM`, `FINITE_SUBSET`, `FINITE_IMAGE_INJ_EQ`, `PERMUTES_INJECTIVE`


---

## finite_monomial_vars_permutes

### Name of formal statement
finite_monomial_vars_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_monomial_vars_permutes = prove(`
  !m:V->num f:V->V S.
  f permutes S ==>
  (
    FINITE(monomial_vars m) <=>
    FINITE(monomial_vars (m o f))
  )
`,
  intro THEN
  splitiff THENL [
    qed[finite_monomial_vars_permutes_lemma]
  ;
    subgoal `m:V->num = (m o f) o inverse (f:V->V)` THENL [
      rw[GSYM o_ASSOC] THEN
      specialize[`f:V->V`;`S:V->bool`]PERMUTES_INVERSES_o THEN
      simp[I_O_ID]
    ; pass
    ] THEN
    have `inverse (f:V->V) permutes S` [PERMUTES_INVERSE] THEN
    qed[finite_monomial_vars_permutes_lemma]
  ]
);;
```
### Informal statement
For all functions `m` from a type `V` to the natural numbers, all functions `f` from `V` to `V`, and all sets `S` of type `V`, if `f` permutes `S`, then the set of variables of the monomial `m` is finite if and only if the set of variables of the monomial `m` composed with `f` is finite.

### Informal sketch
The proof proceeds by mutual implication.

*   First, we prove that if `f` permutes `S` and `FINITE(monomial_vars m)` then `FINITE(monomial_vars (m o f))`. This direction is proved by:
    *   Applying the theorem `finite_monomial_vars_permutes_lemma`.
*   Second, we prove that if `f` permutes `S` and `FINITE(monomial_vars (m o f))` then `FINITE(monomial_vars m)`. This direction is proved by:
    *   Rewriting `m` as `(m o f) o inverse (f:V->V)`. This requires proving `m = (m o f) o inverse f`, which is done by simplifying after applying `PERMUTES_INVERSES_o`.
    *   Then applying `PERMUTES_INVERSE` to show that `inverse f permutes S`.
    *   Finally, applying the theorem `finite_monomial_vars_permutes_lemma`.

`splitiff` splits the iff goal into two implications. `intro THEN splitiff` introduces the universally quantified variables and then splits the top-level iff into two subgoals.

### Mathematical insight
This theorem states that finiteness of the variables appearing in a monomial is invariant under permutation of the variables by a function `f` that permutes a set `S`. The composition with `f` simply reorders the indices and since permutation don't remove elements, the set of "indices" is still finite if original was.

### Dependencies
*   `PERMUTES_INVERSES_o`
*   `PERMUTES_INVERSE`
*   `I_O_ID`
* `GSYM`
* `o_ASSOC`
* `finite_monomial_vars_permutes_lemma`

### Porting notes (optional)
The `inverse` function and its properties related to permutations might need to be defined, or a suitable equivalent found, in other provers such as Coq or Lean. The handling of function composition (`o`) should be checked for compatibility.


---

## infinite_monomial_vars_permutes

### Name of formal statement
infinite_monomial_vars_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let infinite_monomial_vars_permutes = prove(`
  !m:V->num f:V->V S.
  f permutes S ==>
  INFINITE(monomial_vars m) ==>
  INFINITE(monomial_vars (m o f))
`,
  rw[INFINITE] THEN
  qed[finite_monomial_vars_permutes]
);;
```
### Informal statement
For all `m` of type `V->num`, all `f` of type `V->V`, and all sets `S` of type `V`, if `f` permutes `S` and the set of variables of the monomial `m` is infinite, then the set of variables of the monomial `m o f` (that is, `m` composed with `f`) is infinite.

### Informal sketch
The proof relies on the theorem `finite_monomial_vars_permutes` and the definition of `INFINITE`.

- The goal is `INFINITE (monomial_vars (m o f))`.
- We rewrite with the definition of `INFINITE`, transforming the goal to `~(FINITE (monomial_vars (m o f)))`.
- We apply `finite_monomial_vars_permutes`, which should resolve the goal.
- `QED`

### Mathematical insight
This theorem states that if we have a monomial with infinitely many variables, then applying a permutation to its variables will still result in a monomial with infinitely many variables. This result is useful when reasoning about the invariance of certain properties under permutations of variables in the context of monomials.

### Dependencies
- Definitions:
  - `INFINITE`
- Theorems:
  - `finite_monomial_vars_permutes`


---

## powerseries_o_permutes

### Name of formal statement
powerseries_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powerseries_o_permutes = prove(`
  !(r:R ring) p (f:V->V) S.
  f permutes S ==>
  ring_powerseries r p ==>
  ring_powerseries r (\m. p (m o f))
`,
  rw[ring_powerseries] THEN
  intro THENL [
    qed[]
  ;
    qed[infinite_monomial_vars_permutes]
  ]
);;
```
### Informal statement
For any ring `r`, polynomial `p`, function `f` from type `V` to `V`, and set `S` of type `V`, if `f` permutes `S` and `p` is a ring powerseries over `r`, then the polynomial composition, which maps a monomial `m` to `p` applied to `m` composed with `f`, also forms a ring powerseries over `r`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definition of `ring_powerseries`.
- Introduce universal quantifiers.
- The proof splits into two subgoals to prove that the two properties of `ring_powerseries` hold i.e. the set of variables is finite and the variables in `p` are a subset of `S`.
  - The first subgoal is discharged trivially.
  - The second subgoal uses the theorem that `infinite_monomial_vars_permutes` to complete the proof.

### Mathematical insight
This theorem demonstrates that composing a power series polynomial with a permutation function preserves the ring power series property. This is important when reasoning about algebraic structures where elements are permuted while retaining the underlying ring structure.

### Dependencies
- Definitions: `ring_powerseries`
- Theorems: `infinite_monomial_vars_permutes`


---

## polynomial_o_permutes

### Name of formal statement
polynomial_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let polynomial_o_permutes = prove(`
  !(r:R ring) p (f:V->V) S.
  f permutes S ==>
  ring_polynomial r p ==>
  ring_polynomial r (\m. p (m o f))
`,
  rw[ring_polynomial] THEN
  intro THENL [
    qed[powerseries_o_permutes]
  ;
    subgoal `{m:V->num | ~(p (m o (f:V->V)) = ring_0 r)} = IMAGE (\m. m o inverse f) {m | ~(p m = ring_0(r:R ring))}` THENL [
      rw[EXTENSION;IN_IMAGE;IN_ELIM_THM] THEN
      intro THEN
      splitiff THENL [
        intro THEN
        witness `(x:V->num) o (f:V->V)` THEN
        rw[GSYM o_ASSOC] THEN
        specialize[
          `f:V->V`;
          `S:V->bool`
        ]PERMUTES_INVERSES_o THEN
        simp[I_O_ID]
      ;
        intro THEN
        have `(x:V->num) o (f:V->V) = (x' o inverse f) o f` [] THEN
        subgoal `(x' o (inverse f)) o (f:V->V) = x':V->num` THENL [
          rw[GSYM o_ASSOC] THEN
          specialize[
            `f:V->V`;
            `S:V->bool`
          ]PERMUTES_INVERSES_o THEN
          simp[I_O_ID]
        ; pass
        ] THEN
        qed[]
      ]
    ; pass
    ] THEN
    qed[FINITE_IMAGE]
  ]
);;
```

### Informal statement
For any ring `r` and any function `p` from `V` to the type of numbers, and any function `f` from `V` to `V`, and any set `S`, if `f` permutes `S` and `p` is a ring polynomial with coefficients in `r`, then the function that maps `m` to `p (m o f)` is also a ring polynomial with coefficients in `r`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `ring_polynomial`.
- Assume the antecedent `f permutes S` and `p` is a ring polynomial.
- Prove that the set of `m` such that `p (m o f)` is not equal to the zero element of the ring `r` is equal to the image of the set of `m` such that `p m` is not equal to `ring_0 r` under the mapping `\m. m o inverse f`.
  - Show that if `p (m o f)` is not equal to `ring_0 r`, then `m` is in the image of `\m. m o inverse f` applied to the set of `x` such that `p x` is not equal to `ring_0 r`. We exhibit `x o f` as the element in the set being mapped to `m`. Use `PERMUTATIONS_INVERSES_o` and simplification to show that `(x o f) o inverse f = x`.
  - Show that if `m` is in the image of `\m. m o inverse f` applied to the set of `x` such that `p x` is not equal to `ring_0 r` then `p (m o f)` is not equal to `ring_0 r`. Choose `x'` such that `m = x' o inverse f`, and show that `(x' o inverse f) o f =x'`. Conclude using the fact that  `p x'` `ring_0 r`
- Apply the theorem `FINITE_IMAGE`.

### Mathematical insight
This theorem states that pre-composing the variable of a polynomial with a permutation of its domain preserves the polynomial property. This is important in situations where we want to consider polynomials that are invariant under certain transformations.

### Dependencies
- `ring_polynomial`
- `powerseries_o_permutes`
- `PERMUTATIONS_INVERSES_o`
- `FINITE_IMAGE`
- `GSYM`
- `o_ASSOC`
- `I_O_ID`
- `IN_IMAGE`
- `IN_ELIM_THM`

### Porting notes (optional)
The main challenge in porting this theorem lies in ensuring that the definition of `ring_polynomial` and `powerseries_o_permutes` are correctly translated and that the tactic `PERMUTATIONS_INVERSES_o` concerning permutations and inverses is appropriately formulated in the target proof assistant. Also, make sure that the `FINITE_IMAGE` theorem is available or can be proved. Handling function composition correctly may also require attention, depending on the target system.


---

## poly_var_subring

### Name of formal statement
poly_var_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_var_subring = prove(`
  !(r:R ring) G v:V.
  poly_var(subring_generated r G) v
  = poly_var r v
`,
  rw[poly_var] THEN
  rw[SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` and any subset `G` of the variables type `V`, the set of variables occurring in a polynomial over the subring of `r` generated by `G` is equal to the set of variables occurring in a polynomial over `r`.

### Informal sketch
The proof proceeds by:
- Rewriting with the definition of `poly_var`.
- Rewriting with the definition of `SUBRING_GENERATED`.
This directly leads to the conclusion.

### Mathematical insight
This theorem states that when considering the variables appearing in polynomials, restricting the coefficients to a subring generated by `G` doesn't change the set of variables that can appear. This is because the coefficients taken from the subring generated by `G` are still elements of the larger ring `r`, so no new variables are introduced by restricting coefficients.

### Dependencies
Definitions:
- `poly_var`
- `SUBRING_GENERATED`


---

## poly_vars_subring

### Name of formal statement
poly_vars_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) G p:(V->num)->R.
  poly_vars(subring_generated r G) p
  = poly_vars r p
```

### Informal statement
For any ring `r` (of type `R ring`), any set of ring elements `G` (of type `R`), and any polynomial `p` (of type `V->num`, where `V` is the type of variables and `num` is the type of natural numbers) with coefficients in `R`, the evaluation of the polynomial `p` by `poly_vars` within the subring generated by `G` is equal to the evaluation of `p` within the full ring `r`.

### Informal sketch
The proof follows by:
- Unfolding the definition of `poly_vars`.
- Unfolding the definition of `SUBRING_GENERATED`. The `SUBRING_GENERATED` of a set `G` within a ring `r` comprises elements obtainable by ring operations (addition, subtraction, multiplication, and multiplicative identity) starting from elements in `G`. Since `poly_vars` evaluates the polynomial within the base ring `r` using ring operations, the result is the same when evaluating in the full ring or in the subring generated by the variables.

### Mathematical insight
The theorem expresses that evaluating a polynomial is independent of whether we consider a subring generated by some set of elements or the full ring, provided that the coefficients of the polynomial belong to the base ring of the subring. Essentially, the formation of the subring does not affect the evaluation because polynomial evaluations involve only the ring operations already present in the base ring.

### Dependencies
- `poly_vars`
- `SUBRING_GENERATED`


---

## ring_powerseries_if_polynomial

### Name of formal statement
ring_powerseries_if_polynomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_powerseries_if_polynomial = prove(`
  !(r:R ring) p:(V->num)->R.
  ring_polynomial r p ==>
  ring_powerseries r p
`,
  qed[ring_polynomial]
);;
```
### Informal statement
For any ring `r` and any function `p` from a type `V` to natural numbers, if `p` is a polynomial over `r`, then `p` is a power series over `r`.

### Informal sketch
The proof proceeds by showing that if a function `p:V->num` is a `ring_polynomial` then it is also a `ring_powerseries`.

- The proof uses the assumption `ring_polynomial r p`. This essentially unfolds the definition `ring_polynomial` and uses the definition of `ring_powerseries` to prove this theorem.
- The `qed[ring_polynomial]` tactic indicates that the proof relies on the definition or properties related to `ring_polynomial`.

### Mathematical insight
This theorem states a fundamental relationship between polynomials and power series within the context of rings. Specifically, every polynomial can be considered a power series with only finitely many non-zero coefficients. This is a standard result in abstract algebra and is used to relate the algebraic properties of polynomials to the analytic properties of power series.

### Dependencies
- Definitions: `ring_polynomial`, `ring_powerseries`


---

## ring_polynomial_subring_var

### Name of formal statement
ring_polynomial_subring_var

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_polynomial_subring_var = prove(`
  !(r:R ring) G v:V.
  ring_polynomial(subring_generated r G) (poly_var r v)
`,
  qed[poly_var_subring;RING_POLYNOMIAL_VAR]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `G` of elements, and any variable `v` of type `V`, the polynomial variable `poly_var r v` is a ring polynomial over the subring generated by `r` and `G`.

### Informal sketch
The proof proceeds by:
- The initial tactic `poly_var_subring` likely expands the definition of `poly_var` in terms of `ring_polynomial`, revealing the core equation needed to be proven. The remaining goal involves showing that the coefficients of the polynomial `poly_var r v` lie in the subring generated by `r` and `G`.
- The tactic `RING_POLYNOMIAL_VAR` probably then leverages the definition of `ring_polynomial` and the construction of `poly_var`'s coefficients (likely just `0` and `1`) which are easily shown to belong the subring generated by `r` and `G`.

### Mathematical insight
The theorem states that the polynomial variable, which corresponds to the indeterminate `v` in the polynomial ring, is indeed a polynomial over the subring generated by a set `G` of ring elements. This is an important result because it ensures that the construction of polynomial rings is compatible with subrings. Specifically, if we construct a polynomial ring over a subring, and include the indeterminate `v`, then `v` itself will be recognized as a polynomial in the extended context.

### Dependencies
- Definitions: `ring_polynomial`, `subring_generated`, `poly_var`

### Porting notes (optional)
The main challenge in porting is likely ensuring that the definitions of `poly_var`, `ring_polynomial` and `subring_generated` are handled properly. The automation (`RING_POLYNOMIAL_VAR`) relies on the specific unfolding and rewriting rules available in HOL Light's simplifier. A similar level of automation may require some effort to be set up in different provers.


---

## ring_sum_poly_o_permutes

### Name of formal statement
ring_sum_poly_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_poly_o_permutes = prove(`
  !(r:R ring) p:X->(V->num)->R m f U S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  f permutes U ==>
  ring_sum(poly_ring r (:V)) S p (m o f) =
  (ring_sum(poly_ring r (:V)) S (\s m. p s (m o f))) m
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;POLY_RING;POLY_0]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    have `ring_polynomial r (p(x:X):(V->num)->R)` [] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `f:V->V`;
      `U:V->bool`
    ]polynomial_o_permutes THEN
    simp[RING_SUM_CLAUSES;GSYM poly_in_full_ring] THEN
    rw[POLY_RING] THEN
    simp[poly_add_o_permutes] THEN
    have `ring_sum (poly_ring r (:V)) S p (m o f) = ring_sum (poly_ring r (:V)) S (\s:X m:V->num. p s (m o f)) m:R` [] THEN
    rw[poly_add] THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any function `p` from a type `X` to functions of type `(V->num)->R`, any function `m` of type `V->num`, any permutation `f` of type `V->V`, any boolean predicate `U` of type `V->bool`, and any finite set `S` of type `X`, if `S` is finite, and for every `s` in `S`, `p s` is a polynomial in the ring `r`, and `f` permutes `U`, then the ring sum over `S` applied to `p` with argument `m o f` is equal to the ring sum over `S` applied to the function that maps `s` in `S` to `p s (m o f)` with argument `m`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: When `S` is empty, both sides of the equation are zero by the definition of `ring_sum` and `POLY_0`.
- Inductive step: Assume the result holds for all finite subsets of `S`. Let `S` be `x INSERT S'` where `S'` is a finite set. Assume that for all `s` in `S = x INSERT S'`, we have `ring_polynomial r (p s)`.
We want to show that `ring_sum(poly_ring r (:V)) (x INSERT S') p (m o f) = ring_sum(poly_ring r (:V)) (x INSERT S') (\s m. p s (m o f)) m`.
The proof uses the property `polynomial_o_permutes` and rewrites based on the definitions of `RING_SUM_CLAUSES`, `POLY_RING`, `POLY_0`, and `poly_add_o_permutes`.

### Mathematical insight
The theorem states that composing the argument of a polynomial with a permutation before taking the ring sum over elements of a finite set is equivalent to applying this composition to each polynomial inside the ring sum. This result highlights the interaction between polynomial rings, permutations, and summations.

### Dependencies
- `RING_SUM_CLAUSES`
- `POLY_RING`
- `POLY_0`
- `polynomial_o_permutes`
- `GSYM poly_in_full_ring` (where `GSYM` likely is a `HOL Light` shorthand for applying symmetry to an equation)
- `poly_add_o_permutes`
- `poly_add`


---

## ring_product_poly_o_permutes_waterfall

### Name of formal statement
ring_product_poly_o_permutes_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_poly_o_permutes_waterfall = prove(`
  !(r:R ring) p:X->(V->num)->R f U S.
  FINITE S ==>
  !m.
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  f permutes U ==>
  ring_product(poly_ring r (:V)) S p (m o f) =
  (ring_product(poly_ring r (:V)) S (\s m. p s (m o f))) m
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;POLY_RING;poly_1] THEN
    qed[poly_const_o_permutes]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    have `ring_polynomial r (p(x:X):(V->num)->R)` [] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `f:V->V`;
      `U:V->bool`
    ]polynomial_o_permutes THEN
    simp[RING_PRODUCT_CLAUSES;GSYM poly_in_full_ring] THEN
    rw[POLY_RING] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `ring_product (poly_ring r (:V)) (S:X->bool) p:(V->num)->R`;
      `U:V->bool`;
      `f:V->V`;
      `m:V->num`
    ]poly_mul_o_permutes THEN
    simp[] THEN
    have `ring_product (poly_ring r (:V)) S p (m o f) = ring_product (poly_ring r (:V)) S (\s:X m:V->num. p s (m o f)) m:R` [] THEN
    rw[poly_mul]
  ]
);;
```

### Informal statement
For any ring `r` (of type `R ring`), any function `p` from a type `X` to functions from `V` to `num` to `R`, any function `f` from `V` to `V`, and any predicates `U` and `S` on `V` and `X` respectively, the following holds: If `S` is finite, then for any function `m` from `V` to `num`, if for all `s` in `S`, `p s` is a ring polynomial over `r`, and `f` permutes `U`, then the ring product over `S` with respect to `p`, evaluated at `m o f`, is equal to ring product over `S` with respect to the function `\s m. p s (m o f)`, evaluated at `m`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: When `S` is empty, we use the definition of `ring_product` and `poly_1`, along with `poly_const_o_permutes` to prove the equality.

- Inductive step: Assume the theorem holds for all subsets of `S`. We want to show that it holds for `x INSERT S`, where `x` is some element. Suppose `p x` is a polynomial. By the inductive hypothesis, we have, `ring_product(poly_ring r (:V)) S p (m o f) = ring_product(poly_ring r (:V)) S (\s m. p s (m o f)) m`. We also have `polynomial_o_permutes` and `poly_mul_o_permutes`. Then, using the definition of `ring_product` in terms of `ring_product` over a smaller set, simplification, and rewriting `poly_mul`, we establish the desired equality.

### Mathematical insight
The theorem essentially states that the ring product of polynomials composed with a permutation is equal to the ring product of the polynomials evaluated at the composition of the monomial evaluation function `m` with the permutation `f`. This is useful for reasoning about how permutations act on polynomial expressions.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POLY_RING`
- `poly_1`
- `poly_const_o_permutes`
- `GSYM poly_in_full_ring`
- `polynomial_o_permutes`
- `poly_mul_o_permutes`
- `poly_mul`


---

## ring_product_poly_o_permutes

### Name of formal statement
ring_product_poly_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_poly_o_permutes = prove(`
  !(r:R ring) p:X->(V->num)->R m f U S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  f permutes U ==>
  ring_product(poly_ring r (:V)) S p (m o f) =
  (ring_product(poly_ring r (:V)) S (\s m. p s (m o f))) m
`,
  qed[ring_product_poly_o_permutes_waterfall]
);;
```
### Informal statement
For any ring `r`, any function `p` from `X` to functions from `V` to numbers to `R`, any number `m`, any function `f` from `U` to `U`, and any sets `U` and `S`, if `S` is finite and for all `s` in `S`, `p s` is a ring polynomial over `r`, and `f` permutes `U`, then the ring product of `p` over `S` evaluated at `m o f` is equal to the ring product of `p s` evaluated at `m o f`, where the ring is the polynomial ring over `r` with variables in `V`.

### Informal sketch
The theorem states that composing the argument of a ring product of polynomials with a permutation function is equivalent to composing the argument of each individual polynomial with the same permutation function before taking the product.

- The proof proceeds by induction on the finite set `S`.
- Base case: If `S` is empty, both sides of the equation are the ring identity, so the equality holds.
- Inductive step: Assume the equality holds for `S`. We need to show it holds for `INSERT x S`, where `x` is not in `S`.
     -  The LHS can be expanded using the definition of `ring_product` for `INSERT x S`.
     -  The RHS can be expanded similarly.
     -  By the inductive hypothesis, the equality holds for `S`.
     -  By properties of function composition, `(m o f)` and `p x`, the equality holds for `INSERT x S`.
- Thus, by induction on the size of the `FINITE S`, the theorem is proved.

### Mathematical insight
The theorem demonstrates that the ring product interacts nicely with function composition, specifically with permutation functions. This is key when performing variable renaming or substitutions in polynomial expressions. Specifically, when the input to the product of polynomials is composed with a permutation, we can push the permutation inside the product and have each polynomial's input composed with it instead. This is useful for simplifying expressions and reasoning about the invariance of certain properties under variable renaming.

### Dependencies
- `FINITE`
- `ring_polynomial`
- `permutes`
- `ring_product`
- `poly_ring`

### Porting notes (optional)
- In proof assistants like Coq or Lean, the finiteness condition `FINITE S` may need to be explicitly proven or managed through typeclasses or decidable properties.
- The handling of variable types (e.g., `X`, `V`, `U`) might require careful attention to ensure proper type inference and unification in the target proof assistant.
- The tactic `ring_product_poly_o_permutes_waterfall` implies usage of waterfall tactic. This proof may benefit from mathematical library support in other proof assistants.


---

## x_series

### Name of formal statement
x_series

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let x_series = new_definition `
  x_series (r:R ring) =
  powser_ring r (:1)
`;;
```
### Informal statement
For any ring `r` with ring operations in `R ring`, `x_series(r)` is defined to be `powser_ring r (:1)`.

### Informal sketch
The definition `x_series` introduces the concept of a formal power series ring over a given ring `r`. The function `powser_ring` constructs the power series ring `r[[x]]` with the variable `x`, represented by the constant function `:1` which maps any input to the real number 1. The `R ring` likely represents ring axioms that are implicitly present in the HOL Light context to establish that `r` qualifies as a ring, thus enabling ring operations within the power series construction.

### Mathematical insight
The formal power series ring `r[[x]]` consists of formal sums of the form `a_0 + a_1*x + a_2*x^2 + ...`, where the coefficients `a_i` are elements of the ring `r`. Unlike polynomials, formal power series can have infinitely many terms. This definition provides a rigorous way to represent and manipulate these series within the formal logic environment. The `x_series` definition likely forms a foundation for defining operations such as addition, multiplication, and composition within the power series ring, and for proving properties regarding convergence or algebraic manipulations.

### Dependencies
- Definition: `powser_ring`
- Assumed ring structure and axioms: `R ring`


---

## x_poly

### Name of formal statement
x_poly

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let x_poly = new_definition `
  x_poly (r:R ring) =
  poly_ring r (:1)
`;;
```

### Informal statement
For any ring `r` with type `R ring`, the value of `x_poly r` is the polynomial ring element `(:1)` in the ring `r`. In other words, `x_poly r` represents the generator or indeterminate of the polynomial ring over `r`, which corresponds to the polynomial `1*X + 0` where X is the symbolic variable.

### Informal sketch
The definition `x_poly` simply introduces a named constant/function that, when applied to a ring `r`, returns the polynomial `(:1)` in that ring. This `(:1)` conventionally represents the variable 'X' in a polynomial expression. The definition directly uses the `poly_ring` constructor to build this polynomial. There is no involved proof or construction, as it is a direct definition.

### Mathematical insight
The definition of `x_poly` provides a convenient way to refer to the indeterminate variable (often denoted as 'X') within the polynomial ring over a given ring `r`. This is a standard notational tool, that allows polynomials to be expressed in terms of `x_poly r`. It serves as a foundational element for further constructions and theorems related to polynomials.

### Dependencies
- Definitions:
  - `poly_ring`


---

## series_from_coeffs

### Name of formal statement
series_from_coeffs

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let series_from_coeffs = new_definition `
  series_from_coeffs (f:num->R)
  = (\m. f(m one))
`;;
```
### Informal statement
The function `series_from_coeffs` takes a function `f` from natural numbers to real numbers and returns a function that maps `m` to `f(m)`, where `m` is coerced to a real number.

### Informal sketch
The definition introduces `series_from_coeffs`. It takes a function `f` that associates a real number to each natural number. It maps `f` to a new function that returns for each real number `m` the value of `f` at the natural number `m one` (where `one` is the real number one, and `m one` represents the coercion of the real `m` into a natural number). The definition introduces a new function that coerces a function from natural numbers to reals into a function that takes real numbers as argument and gives a real number as an output.

### Mathematical insight
This definition provides a way to construct functions that effectively act like real-valued power series when applied to natural numbers. The argument `f` is a function indexed by natural numbers that can be viewed as the coefficients of said power series. Applying `series_from_coeffs` to `f` extends the domain of the function to the reals, defining the function as `f` of the nearest natural number.

### Dependencies
- Definitions: `one`


---

## x_poly_vars_1

### Name of formal statement
x_poly_vars_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_vars_1 = prove(`
  !r:R ring.
  !p:(1->num)->R.
  poly_vars r p SUBSET (:1)
`,
  rw[poly_vars;UNIONS_SUBSET] THEN
  SET_TAC[FINITE_MONOMIAL_VARS_1]
);;
```
### Informal statement
For any ring `r` (of type `R ring`) and any function `p` from `(1->num)` to `R`, the set of variables `poly_vars r p` is a subset of the singleton set containing 1 (denoted `(:1)`).

### Informal sketch
The proof proceeds as follows:
- The theorem relies on the definition of `poly_vars` and uses `UNIONS_SUBSET` to reason about the union of subsets.
- The goal is to show that `poly_vars r p` is a subset of the singleton set containing 1. The definition of `poly_vars` involves taking the union of `finite_monomial_vars r p m` over all monomials `m`. The rule `UNIONS_SUBSET` is then used to show that if each `finite_monomial_vars r p m` is a subset of `(:1)`, then `poly_vars r p` is a subset of `(:1)`.
- The proof uses `FINITE_MONOMIAL_VARS_1` as a set tactic, which likely states that the variables appearing in any finite monomial, `finite_monomial_vars r p m`, can only be 1.

### Mathematical insight
The theorem states that if we consider polynomials where variables are functions from 1 to numerals (`1->num`), then only variable 1 can appear in the polynomial. This is because of the limited variable space defined by `1->num`.

### Dependencies
- `poly_vars`
- `UNIONS_SUBSET`
- `FINITE_MONOMIAL_VARS_1`


---

## x_series_carrier

### Name of formal statement
x_series_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_series_carrier = prove(`
  !r:R ring.
  ring_carrier(x_series r) = {p | ring_powerseries r p}
`,
  intro THEN
  rw[x_series] THEN
  specialize[`r:R ring`;`(:1)`]powser_ring_carrier THEN
  simp[IN_ELIM_THM] THEN
  SET_TAC[x_poly_vars_1]
);;
```

### Informal statement
For all `r`, where `r` is a ring, the carrier of the ring `x_series r` is equal to the set of all `p` such that `p` is a power series over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the hypothesis that `r` is a ring.
- Rewrite using the definition of `x_series`.
- Specialize the theorem `powser_ring_carrier` with `r` being a ring.
- Simplify using the theorem `IN_ELIM_THM`.
- Apply `SET_TAC` with `x_poly_vars_1`.

### Mathematical insight
This theorem establishes the carrier set of the ring of formal power series `x_series r`. It characterizes the elements over which the ring operations for `x_series r` are defined. It is important because it identifies the underlying set of `x_series r` with the set of formal power series over `r`.

### Dependencies
- Definitions: `x_series`
- Theorems: `powser_ring_carrier`, `IN_ELIM_THM`, `x_poly_vars_1`


---

## powser_use

### Name of formal statement
powser_use

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powser_use = prove(`
  !(r:R ring).
  poly_0 r = ring_0(powser_ring r (:V))
  /\ poly_1 r = ring_1(powser_ring r (:V))
  /\ poly_neg r = ring_neg(powser_ring r (:V))
  /\ poly_add r = ring_add(powser_ring r (:V))
  /\ poly_mul r = ring_mul(powser_ring r (:V))
  /\ !p. ring_powerseries r p <=> p IN ring_carrier(powser_ring r (:V))
`,
  rw[POWSER_RING;IN_ELIM_THM;SUBSET_UNIV]
);;
```
### Informal statement
For any ring `r`, the following holds:
- `poly_0 r` is equal to the zero element of the powerseries ring over `r`.
- `poly_1 r` is equal to the one element of the powerseries ring over `r`.
- `poly_neg r` is equal to the negation function of the powerseries ring over `r`.
- `poly_add r` is equal to the addition function of the powerseries ring over `r`.
- `poly_mul r` is equal to the multiplication function of the powerseries ring over `r`.
- For any `p`, `ring_powerseries r p` if and only if `p` is an element of the carrier set of the powerseries ring over `r`.

### Informal sketch
The proof proceeds by rewriting using `POWSER_RING`, `IN_ELIM_THM`, and `SUBSET_UNIV`. 
- `POWSER_RING` expands the definition of `powser_ring r (:V)` providing definitions for its zero, one, negation, addition, multiplication, and carrier set. 
- `IN_ELIM_THM` eliminates the membership test `IN` rewriting it according to set membership.
- `SUBSET_UNIV` simplifies the carrier set condition by instantiating that the carrier set is the entire universe.

### Mathematical insight
This theorem establishes fundamental properties of the powerseries ring construction, showing how constants (0 and 1) and operations (negation, addition, multiplication) are represented as polynomials within the powerseries ring. The carrier set membership simply reflects that all objects are considered elements in the HOL Light type system.

### Dependencies
- `POWSER_RING`
- `IN_ELIM_THM`
- `SUBSET_UNIV`


---

## x_series_use

### Name of formal statement
x_series_use

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_series_use = prove(`
  !(r:R ring).
  poly_0 r = ring_0(x_series r)
  /\ poly_1 r = ring_1(x_series r)
  /\ poly_neg r = ring_neg(x_series r)
  /\ poly_add r = ring_add(x_series r)
  /\ poly_mul r = ring_mul(x_series r)
  /\ !p. ring_powerseries r p <=> p IN ring_carrier(x_series r)
`,
  rw[x_series_carrier;IN_ELIM_THM] THEN
  qed[POWSER_RING;x_series]
);;
```
### Informal statement
For any ring `r`, the result of `poly_0 r` is equal to the zero element of the ring of formal power series over `r`; `poly_1 r` is equal to the one element of the ring of formal power series over `r`; `poly_neg r` is equal to the negation operation of the ring of formal power series over `r`; `poly_add r` is equal to the addition operation of the ring of formal power series over `r`; `poly_mul r` is equal to the multiplication operation of the ring of formal power series over `r`; and for any `p`, being a member of the carrier set of the ring of formal power series over `r` is equivalent to `p` being a formal power series over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the theorem `x_series_carrier` to expand the definition of the carrier set. Also use `IN_ELIM_THM` which eliminates a membership test by rewriting.
- Then apply `POWSER_RING` which proves that `x_series` constructs a ring. Finally, use `x_series` to rewrite.
- A call to `qed` completes the proof.

### Mathematical insight
This theorem demonstrates that operations on polynomials (represented by `poly_0`, `poly_1`, `poly_neg`, `poly_add`, `poly_mul`) when applied to a ring `r`, correspond to the respective ring operations in the ring of formal power series constructed over `r` using `x_series`. Therefore it helps show that formal power series can be seen as a generalization of polynomials.

### Dependencies
- `x_series_carrier`
- `IN_ELIM_THM`
- `POWSER_RING`
- `x_series`


---

## x_poly_carrier

### Name of formal statement
x_poly_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_carrier = prove(`
  !r:R ring.
  ring_carrier(x_poly r) = {p | ring_polynomial r p}
`,
  intro THEN
  rw[x_poly] THEN
  specialize[`r:R ring`;`(:1)`]poly_ring_carrier THEN
  simp[IN_ELIM_THM] THEN
  SET_TAC[x_poly_vars_1]
);;
```
### Informal statement
For any ring `r` of type `R ring`, the carrier of the ring of univariate polynomials `x_poly r` is the set of all `p` such that `p` is a polynomial over the ring `r` (i.e., `ring_polynomial r p`).

### Informal sketch
The proof proceeds as follows:
- Introduce the ring variable `r`.
- Rewrite using the definition of `x_poly`.
- Specialize the theorem `poly_ring_carrier` with the ring `r` of type `R ring` and the variable `(:1)`.
- Simplify using the theorem `IN_ELIM_THM`.
- Apply `SET_TAC[x_poly_vars_1]`.

### Mathematical insight
This theorem establishes that our definition of the carrier set for the polynomial ring `x_poly r` is indeed the set of polynomials over the ring `r`.

### Dependencies
- Definitions: `x_poly`
- Theorems: `poly_ring_carrier`, `IN_ELIM_THM`, `x_poly_vars_1`


---

## poly_use

### Name of formal statement
poly_use

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_use = prove(`
  !(r:R ring).
  poly_0 r = ring_0(poly_ring r (:V))
  /\ poly_1 r = ring_1(poly_ring r (:V))
  /\ poly_neg r = ring_neg(poly_ring r (:V))
  /\ poly_add r = ring_add(poly_ring r (:V))
  /\ poly_mul r = ring_mul(poly_ring r (:V))
  /\ !p. ring_polynomial r p <=> p IN ring_carrier(poly_ring r (:V))
`,
  rw[POLY_RING;IN_ELIM_THM;SUBSET_UNIV]
);;
```
### Informal statement
For any ring `r`, the following holds:
  - `poly_0 r` is equal to the zero element of the polynomial ring `poly_ring r (:V)`.
  - `poly_1 r` is equal to the one element of the polynomial ring `poly_ring r (:V)`.
  - `poly_neg r` is equal to the negation operation of the polynomial ring `poly_ring r (:V)`.
  - `poly_add r` is equal to the addition operation of the polynomial ring `poly_ring r (:V)`.
  - `poly_mul r` is equal to the multiplication operation of the polynomial ring `poly_ring r (:V)`.
  - For all `p`, `p` is a polynomial over the ring `r` if and only if `p` is an element of the carrier set of the polynomial ring `poly_ring r (:V)`.

### Informal sketch
The proof proceeds by rewriting using the definition of `POLY_RING`, eliminating the `IN` relation using `IN_ELIM_THM`, and then simplifying using `SUBSET_UNIV`.
- The statement asserts that the polynomial operations defined by `poly_0`, `poly_1`, `poly_neg`, `poly_add`, and `poly_mul` correspond to the ring operations of the polynomial ring `poly_ring r (:V)`.
- It also specifies that `ring_polynomial r p` holds precisely when `p` belongs to the carrier set of the polynomial ring.

### Mathematical insight
This theorem establishes the fundamental connection between constructing a polynomial ring and the standard operations on polynomials. It is a crucial step towards showing that the constructed polynomial ring behaves as expected. It formalizes the notion that the ring operations explicitly defined for polynomials coincide with the generic ring operations applied to the polynomial ring structure. The last conjunct ensures that membership of the carrier set of the polynomial ring corresponds to the `ring_polynomial` predicate.

### Dependencies
- Constants: `POLY_RING`
- Theorems: `IN_ELIM_THM`, `SUBSET_UNIV`


---

## x_poly_use

### Name of formal statement
x_poly_use

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_use = prove(`
  !(r:R ring).
  poly_0 r = ring_0(x_poly r)
  /\ poly_1 r = ring_1(x_poly r)
  /\ poly_neg r = ring_neg(x_poly r)
  /\ poly_add r = ring_add(x_poly r)
  /\ poly_mul r = ring_mul(x_poly r)
  /\ !p. ring_polynomial r p <=> p IN ring_carrier(x_poly r)
`,
  rw[x_poly_carrier;IN_ELIM_THM] THEN
  qed[POLY_RING;x_poly]
);;
```
### Informal statement
For any ring `r` of type `R`, the following properties hold:
1. `poly_0 r` is equal to the zero element of the ring derived from polynomials over `r`, denoted as `ring_0(x_poly r)`.
2. `poly_1 r` is equal to the one element of the ring derived from polynomials over `r`, denoted as `ring_1(x_poly r)`.
3. `poly_neg r` is equal to the negation operation of the ring derived from polynomials over `r`, denoted as `ring_neg(x_poly r)`.
4. `poly_add r` is equal to the addition operation of the ring derived from polynomials over `r`, denoted as `ring_add(x_poly r)`.
5. `poly_mul r` is equal to the multiplication operation of the ring derived from polynomials over `r`, denoted as `ring_mul(x_poly r)`.
6. For any `p`, `p` is a polynomial in the polynomials over ring `r` (denoted `ring_polynomial r p`) if and only if `p` is in the carrier set of the ring derived from polynomials over `r` (denoted `p IN ring_carrier(x_poly r)`).

### Informal sketch
The proof involves demonstrating that the ring formed by polynomials (`x_poly r`) satisfies the properties of a ring.

- First, the goal is rewritten using the theorem `x_poly_carrier` and `IN_ELIM_THM` to expose the underlying structure of `ring_carrier(x_poly r)`.
- Then, the proof is completed using the theorem `POLY_RING`, which states that `x_poly` creates a ring, and `x_poly` itself, which defines the polynomial ring.

### Mathematical insight
This theorem establishes that the construction `x_poly r` indeed yields a ring, and it explicitly defines the operations and carrier set of the ring generated by polynomials over a base ring `r`. It connects abstract ring operations with concrete polynomial operations which provides the foundation for polynomial algebra within the formal system. It verifies that the defined polynomial operations (addition, multiplication, negation, zero, and one) behave as expected within the established ring structure.

### Dependencies
- Definitions: `x_poly`
- Theorems: `x_poly_carrier`, `IN_ELIM_THM`, `POLY_RING`


---

## x_series_sub_use

### Name of formal statement
x_series_sub_use

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_series_sub_use = prove(`
  !(r:R ring).
  poly_sub r = ring_sub(x_series r)
`,
  rw[FUN_EQ_THM] THEN
  simp[ring_sub;POLY_SUB] THEN
  qed[x_series_use]
);;
```
### Informal statement
For any ring `r` of type `R ring`, the polynomial subtraction operation `poly_sub r` is equal to the ring subtraction operation `ring_sub` applied to the ring of formal power series `x_series r`.

### Informal sketch
The proof proceeds as follows:

- First, apply the theorem `FUN_EQ_THM` to reduce the goal to proving the equality pointwise.
- Next, simplify the goal using the definitions of `ring_sub` and `POLY_SUB`.
- Finally, complete the proof using the theorem `x_series_use`.

### Mathematical insight
This theorem shows that the subtraction operation defined on polynomials specialized for the ring `r` (i.e., `poly_sub r`) coincides with the general ring subtraction when applied to the ring of formal power series over `r` (i.e., `x_series r`). This highlights the algebraic structure preservation between polynomials and formal power series with respect to subtraction and ensures consistency between these operations.

### Dependencies
- Definitions: `ring_sub`, `POLY_SUB`
- Theorems: `FUN_EQ_THM`, `x_series_use`


---

## x_poly_sub_use

### Name of formal statement
x_poly_sub_use

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_sub_use = prove(`
  !(r:R ring).
  poly_sub r = ring_sub(x_poly r)
`,
  rw[FUN_EQ_THM] THEN
  simp[ring_sub;POLY_SUB] THEN
  qed[x_poly_use]
);;
```
### Informal statement
For any ring `r` of type `R ring`, the function `poly_sub r` is equal to the ring subtraction operation `ring_sub` applied to `x_poly r`.

### Informal sketch
The proof proceeds as follows:
- First, apply `FUN_EQ_THM` to reduce the goal to showing equality of the function's results for arbitrary inputs.
- Then, simplify using the definitions of `ring_sub` and `POLY_SUB`. The simplification step also uses the theorem `x_poly_use` implicitly as it is present in the default simpset.
- Finally, complete the proof by `qed`.

### Mathematical insight
This theorem establishes that `poly_sub`, which computes the subtraction of polynomials coefficient-wise, is indeed performing subtraction within the ring of polynomials `x_poly r` as defined by the ring structure on polynomials.

### Dependencies
- Definitions:
  - `ring_sub`
  - `POLY_SUB`
  - `x_poly`
- Theorems:
  - `FUN_EQ_THM`
  - `x_poly_use`


---

## x_poly_carrier_in_series_carrier

### Name of formal statement
x_poly_carrier_in_series_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_carrier_in_series_carrier = prove(`
  !r:R ring.
  !p.
  p IN ring_carrier(x_poly r)
  ==> p IN ring_carrier(x_series r)
`,
  rw[x_series_carrier;x_poly_carrier] THEN
  rw[IN_ELIM_THM] THEN
  qed[RING_POLYNOMIAL_IMP_POWERSERIES]
);;
```
### Informal statement
For any ring `r`, if `p` is an element of the carrier set of the polynomial ring `x_poly r`, then `p` is an element of the carrier set of the power series ring `x_series r`.

### Informal sketch
The proof proceeds by:
- Rewriting the goal using the definitions of `x_series_carrier` and `x_poly_carrier`.
- Applying `IN_ELIM_THM` to eliminate the set membership predicate `IN`.
- Applying the theorem `RING_POLYNOMIAL_IMP_POWERSERIES`, which states that any polynomial over a ring can be viewed as a power series over the same ring.

### Mathematical insight
This theorem formalizes the fact that polynomials over a ring can be embedded into the power series ring over the same ring. This is because any polynomial can be considered a power series with finitely many non-zero coefficients. This embedding is essential for relating algebraic structures built from polynomials and power series.

### Dependencies
- Definitions:
  - `x_series_carrier`
  - `x_poly_carrier`
- Theorems:
  - `IN_ELIM_THM`
  - `RING_POLYNOMIAL_IMP_POWERSERIES`


---

## x_poly_carrier_subset_series_carrier

### Name of formal statement
x_poly_carrier_subset_series_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_carrier_subset_series_carrier = prove(`
  !r:R ring.
  ring_carrier(x_poly r) SUBSET ring_carrier(x_series r)
`,
  qed[SUBSET;x_poly_carrier_in_series_carrier]
);;
```
### Informal statement
For any ring `r`, the carrier of the polynomial ring `x_poly r` is a subset of the carrier of the series ring `x_series r`.

### Informal sketch
The proof demonstrates that the carrier of polynomials over a ring `r` is a subset of the carrier of formal power series over the same ring `r`.
- The proof goal is `ring_carrier(x_poly r) SUBSET ring_carrier(x_series r)`.
- It uses the theorem `x_poly_carrier_in_series_carrier` to show that elements of `x_poly r` are also elements of `x_series r`.
- The primitive rule `SUBSET` is then applied to complete the proof.
- The `qed` tactic confirms the result and concludes the proof.

### Mathematical insight
This theorem reflects the mathematical fact that polynomials can be viewed as a special case of formal power series where only finitely many coefficients are non-zero. Polynomials are embedded within the larger domain of formal power series. This is important because it allows results established for formal power series to be applicable to polynomials under certain conditions.

### Dependencies
- Theorems: `x_poly_carrier_in_series_carrier`
- Definitions: `SUBSET`


---

## x_poly_subring_in_poly_carrier

### Name of formal statement
x_poly_subring_in_poly_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_subring_in_poly_carrier = prove(`
  !(r:R ring) G p.
  p IN ring_carrier(x_poly(subring_generated r G)) ==>
  p IN ring_carrier(x_poly r)
`,
  rw[GSYM x_poly_use] THEN
  qed[ring_polynomial_if_subring]
);;
```
### Informal statement
For any ring `r` and any set `G`, and polynomial `p`, if `p` is in the carrier of the ring of polynomials over the subring generated by `r` and `G` with indeterminate `x`, then `p` is in the carrier of the ring of polynomials over `r` with indeterminate `x`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the goal using `x_poly_use` to replace `ring_carrier(x_poly(subring_generated r G))` with `polynomial (subring_carrier (subring_generated r G))`.
- Then, apply the theorem `ring_polynomial_if_subring`, which states that if `A` is a subring of `B`, then the polynomials over `A` are a subset of the polynomials over `B`.

### Mathematical insight
This theorem states a basic property of polynomial rings: if we take a subring and form the polynomial ring over it, then the resulting polynomial ring is contained in the polynomial ring over the original ring. Specifically, if we generate a subring from a ring `r` by adding elements from set `G` and construct polynomials with `x` as indeterminate, the generated polynomial will always be also a valid polynomial over the original ring `r`.

### Dependencies
- Theorems : `x_poly_use`, `ring_polynomial_if_subring`


---

## ring_of_num_x_series

### Name of formal statement
ring_of_num_x_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_x_series = prove(`
  !(r:R ring) n.
  ring_of_num(x_series r) n
  = poly_const r (ring_of_num r n)
`,
  GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[RING_OF_NUM_0] THEN
    rw[GSYM x_series_use;poly_0]
  ;
    rw[ring_of_num] THEN
    rw[POLY_CONST_ADD] THEN
    rw[GSYM x_series_use;poly_1] THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r` and natural number `n`, `ring_of_num` applied to the series `x_series r` and `n` is equal to the polynomial constant `r` applied to `ring_of_num` applied to `r` and `n`.

### Informal sketch
The proof proceeds by induction on `n`.

- Base case (`n = 0`): We rewrite both sides of the equation using `RING_OF_NUM_0` and `GSYM x_series_use;poly_0`, which states `x_series r 0 = 0` and `poly_const r 0 = 0`, respectively, completing this case.
- Inductive step: Assuming the theorem holds for `n`, we show it holds for `n+1`. We rewrite the left-hand side `ring_of_num (x_series r) (SUC n)` using `ring_of_num`, which expands it to `ring_of_num (x_series r) n + ring_of_num (x_series r) 1`. We rewrite the right-hand side `poly_const r (ring_of_num r (SUC n))` using `POLY_CONST_ADD` to `poly_const r (ring_of_num r n) + poly_const r (ring_of_num r 1)`. Then rewrite `ring_of_num (x_series r) 1` with `x_series_use` to transform it into to `poly_const r (ring_of_num r 1)`.

### Mathematical insight
This theorem shows how the natural number embedding of a ring relates to `x_series` and polynomial constants. Specifically, it establishes that taking the natural number embedding of the series and then converting to a number is the same as taking the natural number embedding and then creating a polynomial constant.

### Dependencies
- `RING_OF_NUM_0`
- `ring_of_num`
- `POLY_CONST_ADD`
- `x_series_use`
- `poly_0`
- `poly_1`


---

## ring_char_x_series

### Name of formal statement
ring_char_x_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_char_x_series = prove(`
  !(r:R ring).
  ring_char (x_series r) = ring_char r
`,
  intro THEN
  rw[RING_CHAR_UNIQUE] THEN
  rw[ring_of_num_x_series] THEN
  rw[x_series;POWSER_RING;poly_0;POLY_CONST_EQ] THEN
  qed[RING_CHAR_UNIQUE]
);;
```
### Informal statement
For any ring `r` of type `R ring`, the ring characteristic of the formal power series ring `x_series r` over `r` is equal to the ring characteristic of `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the ring `r`.
- Apply `RING_CHAR_UNIQUE` to reduce the goal to showing that `ring_char (x_series r)` is a ring characteristic.
- Use `ring_of_num_x_series` to rewrite `ring_char (x_series r)` to `ring_char (x_series (ring_of_num r))`. The definition `x_series` states the general construction that forms the formal power series ring. It takes a ring and returns the ring of formal power series over that ring.
- Use `x_series;POWSER_RING;poly_0;POLY_CONST_EQ` to simplify `(x_series (ring_of_num r))` to `ring_char r`.
- Apply `RING_CHAR_UNIQUE` to conclude the proof as the result is a ring characteristic.

### Mathematical insight
This theorem states that forming the ring of formal power series over a ring `r` does not change the ring characteristic. The ring characteristic is an important invariant of a ring. This result shows that extending a ring to its formal power series ring preserves this invariant. This can be useful when reasoning about formal power series rings since one can reduce questions about their characteristic to questions about the base ring.

### Dependencies
- theorem: `RING_CHAR_UNIQUE`
- definition: `ring_of_num_x_series`
- definition: `x_series`
- definition: `POWSER_RING`
- theorem: `poly_0`
- theorem: `POLY_CONST_EQ`


---

## x_monomial

### Name of formal statement
x_monomial

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let x_monomial = new_definition `
  x_monomial (d:num) = \v:1. d
`;;
```

### Informal statement
For any natural number `d`, `x_monomial d` is a function that takes a term `v` of type `:1` and returns `d`.

### Informal sketch
- The definition introduces a function `x_monomial` that maps a natural number `d` to a constant function.
- This constant function always returns `d`, regardless of its input `v` (which is of type `:1`).
- The HOL Light definition uses lambda abstraction (`\v:1. d`) to define this constant function.

### Mathematical insight
- This definition represents a constant monomial in a simplified setting where variables are represented by the type `:1`. The natural number `d` can be thought of as the coefficient of this constant monomial.
- The type `:1` is implicitly a product type in HOL Light and thus the argument to `x_monomial` is in fact a tuple.

### Dependencies
None


---

## x_monomial_deg

### Name of formal statement
x_monomial_deg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_deg = prove(`
  !d. monomial_deg(x_monomial d) = d
`,
  rw[x_monomial;MONOMIAL_DEG_UNIVARIATE]
);;
```
### Informal statement
For all natural numbers `d`, the degree of the monomial `x_monomial d` is equal to `d`.

### Informal sketch
The proof proceeds by:
- Rewriting with the definition of `x_monomial`.
- Applying the theorem `MONOMIAL_DEG_UNIVARIATE`, which states that the degree of the monomial function is 1.

### Mathematical insight
This theorem establishes that the degree of the monomial `x_monomial d` (which represents x^d) is indeed `d`. It confirms the expected relationship between the power `d` and the degree of the monomial and provides a canonical form for reasoning about the degree of univariate monomials.

### Dependencies
- Definitions: `x_monomial`
- Theorems: `MONOMIAL_DEG_UNIVARIATE`


---

## x_monomial_0_monomial_1

### Name of formal statement
x_monomial_0_monomial_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_0_monomial_1 = prove(`
  x_monomial 0 = monomial_1
`,
  rw[x_monomial;monomial_1;COND_ID]
);;
```
### Informal statement
The monomial of degree 0 in the variable `x` is equal to 1 (i.e., `monomial_1`).

### Informal sketch
The proof proceeds by rewriting the left hand side of the equation, `x_monomial 0`, using the definition of `x_monomial` and `monomial_1`, applying conditional rewriting with `COND_ID`.
- The definition of `x_monomial` is used implicitly by the `rw` tactic. It is essentially the definition of the powers of the variable `x` in the monomial context, where the variable `x` is implicitly quantified or bound.
- The definition of `monomial_1` says that a monomial of degree 0 is 1.
- The `COND_ID` is a conditional rewriting rule applied to handle any conditional equality check within.

### Mathematical insight
This theorem establishes the base case for monomials, stating that anything to the power of 0 is 1. It is a fundamental property in algebra and a common base case for inductive proofs related to monomials and polynomials.

### Dependencies
- Definitions: `x_monomial`, `monomial_1`.
- Theorems: `COND_ID`.


---

## x_monomial_add

### Name of formal statement
x_monomial_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_add = prove(`
  !a b.
  monomial_mul (x_monomial a) (x_monomial b) = x_monomial (a+b)
`,
  rw[x_monomial;monomial_mul;FUN_EQ_THM] THEN
  qed[ARITH_RULE `0+0 = 0`]
);;
```
### Informal statement
For all natural numbers `a` and `b`, the `monomial_mul` of `x_monomial a` and `x_monomial b` is equal to `x_monomial (a+b)`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definitions of `x_monomial` and `monomial_mul`.
- Then, apply `FUN_EQ_THM`.
- Finally, apply an arithmetic rule to show that `0 + 0 = 0`.

### Mathematical insight
This theorem shows that multiplying monomials of the form `x^a` and `x^b` results in the monomial `x^(a+b)`, as expected. This is a fundamental property of exponents.

### Dependencies
- Definitions: `x_monomial`, `monomial_mul`
- Theorems: `FUN_EQ_THM`
- Rules: `ARITH_RULE`


---

## x_monomial_surjective

### Name of formal statement
x_monomial_surjective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_surjective = prove(`
  !m. ?d. x_monomial d = m
`,
  rw[x_monomial] THEN
  qed[ETA_ONE]
);;
```
### Informal statement
For every `m`, there exists a `d` such that `x_monomial d` equals `m`.

### Informal sketch
The proof uses the definition of `x_monomial`. The tactic `rw[x_monomial]` rewrites the goal using the definition `x_monomial d = &1`.
The goal becomes `!m. ?d. &1 = m`.
The tactic `qed[ETA_ONE]` then applies the rule `ETA_ONE` (which states `!f. f x = x ==> f = (\x. x)`) which reduces the goal to triviality.

### Mathematical insight
The theorem states that the function `x_monomial` (which always returns 1) is surjective. In other words, every constant value `m` can be obtained as the result of `x_monomial` for some `d`.

### Dependencies
- Definition: `x_monomial`
- Theorem: `ETA_ONE`


---

## x_monomial_injective

### Name of formal statement
x_monomial_injective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_injective = prove(`
  !d e.
  x_monomial d = x_monomial e ==>
  d = e
`,
  rw[x_monomial] THEN
  qed[]
);;
```
### Informal statement
For all natural numbers `d` and `e`, if `x_monomial d` is equal to `x_monomial e`, then `d` is equal to `e`.

### Informal sketch
The proof proceeds by rewriting `x_monomial d` and `x_monomial e` using the definition of `x_monomial` and then completing the proof. In essence, the injectivity follows directly from the definition.

### Mathematical insight
This theorem establishes the injectivity of the `x_monomial` function. This is a foundational result, ensuring that different natural numbers are mapped to distinct formal monomials. This is crucial for unambiguous representation and manipulation of formal power series or polynomials.

### Dependencies
- Definitions:
  - `x_monomial`


---

## ring_sum_image_x_monomial

### Name of formal statement
ring_sum_image_x_monomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_image_x_monomial = prove(`
  !(r:R ring) (g:(1->num)->R) s.
  ring_sum r (IMAGE x_monomial s) g = ring_sum r s (g o x_monomial)
`,
  qed[x_monomial_injective;RING_SUM_IMAGE]
);;
```
### Informal statement
For any ring `r` (with ring operations denoted implicitly), any function `g` mapping functions from natural numbers to natural numbers to elements of `r`, and any set `s` of natural numbers, the `ring_sum` over the image of `s` under the function `x_monomial` applied to `g` is equal to the `ring_sum` over `s` of the function that applies `g` to the result of applying `x_monomial`. In other words, `ring_sum r (IMAGE x_monomial s) g = ring_sum r s (g o x_monomial)`.

### Informal sketch
- The proof relies on the injectivity of `x_monomial` (established by `x_monomial_injective`).
- It also leverages the `RING_SUM_IMAGE` theorem, which provides a general result about ring sums over images of sets.
- The theorem essentially rewrites the ring sum over the image under `x_monomial` to a ring sum over the original set, composing `g` with `x_monomial`.
- The main step is to apply `RING_SUM_IMAGE` using the injectivity of `x_monomial`.

### Mathematical insight
This theorem is a specialized instance of a more general result (`RING_SUM_IMAGE`) concerning ring sums over the image of a set under a function. The instantiation here focuses on the particular function `x_monomial`, which serves as an embedding from natural numbers to functions from natural numbers to natural numbers. The theorem provides a way to rewrite sums over the range of `x_monomial` back to sums over natural numbers, which is likely useful in subsequent manipulations or calculations involving ring sums and `x_monomial`.

### Dependencies
- Theorems: `x_monomial_injective`, `RING_SUM_IMAGE`


---

## x_series_monomial_mul_finite

### Name of formal statement
x_series_monomial_mul_finite

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_series_monomial_mul_finite = prove(`
  !m:1->num.
  FINITE {(m1,m2) | monomial_mul m1 m2 = m}
`,
  qed[MONOMIAL_FINITE_DIVISORPAIRS;FINITE_MONOMIAL_VARS_1]
);;
```
### Informal statement
For all functions `m` from natural numbers to natural numbers, the set of pairs of functions `(m1, m2)` such that the monomial multiplication of `m1` and `m2` equals `m` is finite.

### Informal sketch
The proof demonstrates the finiteness of the set `{(m1,m2) | monomial_mul m1 m2 = m}`.

- The proof uses `MONOMIAL_FINITE_DIVISORPAIRS` to establish that the number of pairs `(m1, m2)` such that `monomial_mul m1 m2 = m` is finite, given that `m` is a function from natural numbers to natural numbers.

- The proof also relies on `FINITE_MONOMIAL_VARS_1` (A direct proof is used to prove the finiteness when the domain is `1->num`), which states that for functions from `1` to natural numbers, the set of those functions effectively considering only one variable is a finite set..

### Mathematical insight
This theorem formalizes the idea that any monomial can only be formed by finitely many pairs of monomials through multiplication. This is a fundamental property used in reasoning about polynomials and power series. The theorem is essential for proving termination and finiteness properties in algebraic manipulations involving monomials.

### Dependencies
- Theorems:
  - `MONOMIAL_FINITE_DIVISORPAIRS`
  - `FINITE_MONOMIAL_VARS_1`


---

## x_monomial_pair_injective

### Name of formal statement
x_monomial_pair_injective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_pair_injective = prove(`
  !(a,b) (c,d).
  (\(a,b). x_monomial a,x_monomial b) (a,b) = (\(a,b). x_monomial a,x_monomial b) (c,d) ==>
  (a,b) = (c,d)
`,
  rw[FORALL_PAIRED_THM] THEN
  intro THEN
  have `x_monomial a = x_monomial c` [FST] THEN
  have `x_monomial b = x_monomial d` [SND] THEN
  qed[x_monomial_injective]
);;
```
### Informal statement
For all pairs (a,b) and (c,d), if the pair of `x_monomial` applied to a and `x_monomial` applied to b equals the pair of `x_monomial` applied to c and `x_monomial` applied to d, then the pair (a,b) equals the pair (c,d).

### Informal sketch
* The proof begins by universally quantifying over the pairs (a,b) and (c,d).
* The hypothesis is that `(x_monomial a, x_monomial b) = (x_monomial c, x_monomial d)`.
* From this, we deduce that `x_monomial a = x_monomial c` and `x_monomial b = x_monomial d`.
* Since `x_monomial` is injective by `x_monomial_injective`, we get `a = c` and `b = d`.
* Therefore, `(a,b) = (c,d)`.

### Mathematical insight
This theorem states that if two pairs of `x_monomial` terms are equal, then the original pairs must be equal. This essentially extends the injectivity of `x_monomial` to pairs of terms. The injectivity of pairing is a fundamental property used to decompose equalities of pairs into equalities of their components.

### Dependencies
- Theorems:
  - `FORALL_PAIRED_THM`
  - `x_monomial_injective`


---

## ring_sum_image_x_monomial_pair

### Name of formal statement
ring_sum_image_x_monomial_pair

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sum_image_x_monomial_pair = prove(`
  !(r:R ring) (g:(1->num)#(1->num)->R) (s:num#num->bool).
  ring_sum r (IMAGE (\(a,b). x_monomial a,x_monomial b) s) g
  = ring_sum r s (g o (\(a,b). x_monomial a,x_monomial b))
`,
  intro THEN
  have `!(a,b) (c,d):num#num. (\(a,b). x_monomial a,x_monomial b) (a,b) = (\(a,b). x_monomial a,x_monomial b) (c,d) ==> (a,b) = (c,d)` [x_monomial_pair_injective] THEN
  ASSUME_TAC(ISPECL[`r:R ring`;`\(a,b):num#num. x_monomial a,x_monomial b`;`g:(1->num)#(1->num)->R`;`s:(num#num)->bool`]ring_sum_image_injective_pair) THEN
  qed[]
);;
```
### Informal statement
For all rings `r` (of type `R ring`), for all functions `g` from pairs of functions from numbers to numbers to `R`, and for all relations `s` between pairs of numbers, the sum of `g` over the image of `s` under the mapping that sends a pair of numbers `(a,b)` to the pair of monomials `(x_monomial a, x_monomial b)` is equal to the sum of `g o (\(a,b). x_monomial a, x_monomial b)` over `s`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions: `r:R ring`, `g:(1->num)#(1->num)->R`, and `s:num#num->bool`.
- Show that the function `\(a,b). x_monomial a, x_monomial b` is injective on number pairs. This is done by proving `!(a,b) (c,d):num#num. (\(a,b). x_monomial a, x_monomial b) (a,b) = (\(a,b). x_monomial a, x_monomial b) (c,d) ==> (a,b) = (c,d)` using theorem `x_monomial_pair_injective`.
- Instantiate the theorem `ring_sum_image_injective_pair` with `r`, `\(a,b). x_monomial a, x_monomial b`, `g`, and `s`.
- Conclude the proof.

### Mathematical insight
The theorem states that when summing a function over the image of a relation under an injective mapping, we can equivalently sum the composition of the function with the mapping over the original relation. This is a common technique used to simplify summations, especially when dealing with algebraic structures like rings where we are summing over elements defined by other functions like `x_monomial`. The key is injectivity, ensures that the preimages exist and the sum is well-defined.

### Dependencies
Identities:
- `x_monomial_pair_injective`
- `ring_sum_image_injective_pair`


---

## x_monomial_factorizations

### Name of formal statement
x_monomial_factorizations

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_factorizations = prove(`
  !d (m:1->num) (n:1->num).
  monomial_mul m n = x_monomial d ==>
  ?a b. a + b = d /\ m = x_monomial a /\ n = x_monomial b
`,
  rw[x_monomial;monomial_mul] THEN
  intro THEN
  witness `m one:num` THEN
  witness `n one:num` THEN
  qed[ETA_ONE]
);;
```
### Informal statement
For any value `d` and any functions `m` and `n` from the natural numbers to the natural numbers, if the monomial multiplication of `m` and `n` is equal to `x_monomial d`, then there exist values `a` and `b` such that `a` plus `b` equals `d`, `m` equals `x_monomial a`, and `n` equals `x_monomial b`.

### Informal sketch
The proof proceeds by rewriting using theorems `x_monomial` and `monomial_mul`. Then, the goal is to prove the existence of `a` and `b`, so we introduce the hypothesis and find witnesses for `a` and `b`. The witnesses used are `m one:num` for variable `a` and `n one:num` for variable `b`. The rest of the proof is completed by `ETA_ONE`.

### Mathematical insight
This theorem states that if a monomial `x_monomial d` can be expressed as the product of two monomials represented by functions `m` and `n`, then the exponents of these monomials must add up to `d`. It essentially decomposes a monomial into its factors, showing how the exponents are distributed across the factors.

### Dependencies
- Definitions:
  - `x_monomial`
  - `monomial_mul`
- Theorems:
  - `ETA_ONE`


---

## x_monomial_factorizations_set

### Name of formal statement
x_monomial_factorizations_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_factorizations_set = prove(`
  !d.
  {m,n:1->num | monomial_mul m n = x_monomial d}
  = IMAGE (\(a,b). x_monomial a,x_monomial b) {a,b | a+b = d}
`,
  rw[image_pair;EXTENSION] THEN
  intro_genonly THEN
  splitiff THENL [
    rw[IN_ELIM_THM] THEN
    intro THEN
    have `?a b. a + b = d /\ m = x_monomial a /\ n = x_monomial b` [x_monomial_factorizations] THEN
    qed[]
  ;
    rw[IN_ELIM_THM] THEN
    intro THEN
    witness `x_monomial a` THEN
    witness `x_monomial b` THEN
    qed[x_monomial_add]
  ]
);;
```
### Informal statement
For any $d$, the set of pairs of functions $m$ and $n$ from 1 to the natural numbers such that the monomial product of $m$ and $n$ equals `x_monomial d` is equal to the image of the set of pairs $(a, b)$ such that $a + b = d$ under the mapping that takes $(a, b)$ to the pair (`x_monomial a`, `x_monomial b`).

### Informal sketch
The proof proceeds by showing set equality through mutual inclusion.

- First, we show that if `monomial_mul m n = x_monomial d`, then there exist `a` and `b` such that `a + b = d`, `m = x_monomial a`, and `n = x_monomial b`. This step relies on the assumption `monomial_mul m n = x_monomial d` to construct the witnesses `x_monomial a` and `x_monomial b`.
- Conversely, we show that if there exist `a` and `b` such that `a + b = d`, then `x_monomial a` and `x_monomial b` satisfy `monomial_mul (x_monomial a) (x_monomial b) = x_monomial d`. This step uses theorem `x_monomial_add` which likely states that `x_monomial (a + b) = monomial_mul (x_monomial a) (x_monomial b)`.

### Mathematical insight
This theorem characterizes the factorizations of the monomial `x_monomial d` into two monomials. It states that every such factorization corresponds to a split of the exponent `d` into two summands `a` and `b`, where the factors are `x_monomial a` and `x_monomial b`. This result is likely used to reason about polynomial factorization.

### Dependencies
- `image_pair`
- `EXTENSION`
- `IN_ELIM_THM`
- `x_monomial_add`


---

## coeff

### Name of formal statement
- coeff

### Type of the formal statement
- new_definition

### Formal Content
```ocaml
let coeff = new_definition `
  coeff (d:num) (p:(1->num)->R)
  = p(x_monomial d)
`;;
```
### Informal statement
- The coefficient of `x` to the power of `d` in a polynomial `p` is defined as the result of evaluating `p` at the monomial `x_monomial d`.

### Informal sketch
- The definition introduces the concept of extracting a coefficient from a polynomial.
- The `coeff` function takes a degree `d` and a polynomial function `p` as input.
- It computes the coefficient of the monomial `x^d` in the polynomial `p` by evaluating `p` at the `x_monomial d`.

### Mathematical insight
- The definition leverages the fact that polynomials in HOL Light are represented as functions from `(1->num)` to `R`, where `R` is a ring. `x_monomial d` represents the monomial `x^d` as such a function. Evaluating the polynomial `p` at this monomial effectively extracts the coefficient corresponding to the degree `d`. This approach is often taken in formalizations where concrete polynomial types are avoided in favor of functional representations.

### Dependencies
- Definitions:
  - `x_monomial`


---

## eq_coeff

### Name of formal statement
eq_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eq_coeff = prove(`
  !(r:R ring) (p:(1->num)->R) q.
  (!d. coeff d p = coeff d q)
  ==> p = q
`,
  rw[coeff] THEN
  qed[x_monomial_surjective;EQ_EXT]
);;
```

### Informal statement
For any ring `R`, any functions `p` and `q` from `(1->num)->R` (which can be seen as polynomials over `R` indexed by natural numbers in a sparse representation), if for all natural numbers `d`, the coefficient of `d` in `p` is equal to the coefficient of `d` in `q`, then `p` is equal to `q`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `coeff`.
- Then, use the theorem `x_monomial_surjective` to show that every possible index can be obtained.
- Finally, apply the extensionality theorem `EQ_EXT`.

### Mathematical insight
This theorem states that if two polynomials have the same coefficients for all indices, then the polynomials are equal. This is a fundamental property showing the uniqueness of the coefficient representation of polynomials. The restriction `(1->num)->R` suggests that polynomials are represented as functions from indices to coefficients, and only finitely many coefficients are nonzero.

### Dependencies
- Definitions: `coeff`
- Theorems: `x_monomial_surjective`, `EQ_EXT`


---

## coeff_series_in_ring

### Name of formal statement
coeff_series_in_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_series_in_ring = prove(`
  !(r:R ring) p.
  ring_powerseries r p <=>
  !d. coeff d p IN ring_carrier(r)
`,
  intro THEN
  splitiff THENL [
    rw[coeff] THEN
    qed[ring_powerseries]
  ;
    intro THEN
    rw[IN_ELIM_THM] THEN
    rw[ring_powerseries] THEN
    intro THENL [
      qed[x_monomial_surjective;coeff]
    ;
      qed[FINITE_MONOMIAL_VARS_1;INFINITE]
    ]
  ]
);;
```
### Informal statement
For any ring `r` and any `p`, `p` is a ring power series with respect to `r` if and only if for all `d`, the coefficient of `d` in `p` is in the carrier of the ring `r`.

### Informal sketch
The proof consists of two directions:

- First, assume `ring_powerseries r p`. We need to show that for all `d`, `coeff d p` is in `ring_carrier r`. This follows directly from the definition of `coeff`.
- Second, assume that for all `d`, `coeff d p` is in `ring_carrier r`. We need to show `ring_powerseries r p`.
  - First, we establish that every element of the ring carrier is the coefficient of some monomial.
  - Next, we show that the set of monomial variables is finite and, therefore, `p` takes only finitely many values outside of zero. These are discharged by `FINITE_MONOMIAL_VARS_1` and `INFINITE`.

### Mathematical insight
This theorem provides a characterization of ring power series. It states that a power series is a ring power series if and only if all of its coefficients lie within the carrier of the specified ring. This provides a practical way to verify that a given power series is indeed a ring power series.

### Dependencies
- Definitions:
  - `ring_powerseries`
  - `coeff`
- Theorems:
  - `IN_ELIM_THM`
  - `x_monomial_surjective`
  - `FINITE_MONOMIAL_VARS_1`
  - `INFINITE`


---

## coeff_series_from_coeffs

### Name of formal statement
coeff_series_from_coeffs

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_series_from_coeffs = prove(`
  !(r:R ring) (f:num->R) d.
  coeff d (series_from_coeffs f) = f d
`,
  rw[coeff;series_from_coeffs;x_monomial]
);;
```
### Informal statement
For any ring `R`, for any function `f` from natural numbers to `R`, and for any natural number `d`, the `d`-th coefficient of the formal power series constructed from the coefficients given by `f` is equal to `f d`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definitions of `coeff` and `series_from_coeffs`, and `x_monomial`.

### Mathematical insight
This theorem states that constructing a formal power series from a sequence of coefficients, and then extracting a specific coefficient from the resulting series, recovers the original coefficient value. This confirms the intended behaviour of `series_from_coeffs` as a function that builds a series from a given sequence of coefficients, and validates the interaction between coefficient extraction and series construction.

### Dependencies
- Definitions: `coeff`, `series_from_coeffs`, `x_monomial`


---

## series_from_coeffs_coeff

### Name of formal statement
series_from_coeffs_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let series_from_coeffs_coeff = prove(`
  !(r:R ring) f:(1->num)->R.
  series_from_coeffs (\d. coeff d f) = f
`,
  intro THEN
  sufficesby eq_coeff THEN
  qed[coeff_series_from_coeffs]
);;
```
### Informal statement
For any ring `R` and any function `f` from natural numbers to `R`, the power series constructed from the sequence of coefficients defined by `coeff d f`, where `coeff d f` is the `d`-th coefficient of `f`, is equal to the original function `f`.

### Informal sketch
The proof proceeds by:

- Introducing the variables `r` (of type `R ring`) and `f` (of type `1->num->R`).
- Showing that the coefficients of `series_from_coeffs (\d. coeff d f)` are equal to the coefficients of `f`.
- Using the theorem `coeff_series_from_coeffs` to conclude the proof.

### Mathematical insight
This theorem states that constructing a power series from the coefficients of a function and then extracting the coefficients of that series yields the original function. This confirms that `series_from_coeffs` and `coeff` are inverse operations and provide a mechanism for moving between sequences and power series representations of them.

### Dependencies
- Definitions:
    - `series_from_coeffs`
    - `coeff`
- Theorems:
    - `coeff_series_from_coeffs`


---

## series_series_from_coeffs

### Name of formal statement
series_series_from_coeffs

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) (f:num->R).
  ring_powerseries r (series_from_coeffs f)
  <=> (!d. f d IN ring_carrier r)
```

### Informal statement
For any ring `r` and any function `f` from natural numbers to the type of `r`, the formal power series `series_from_coeffs f` is a formal power series over the ring `r` if and only if for all natural numbers `d`, `f d` is an element of the carrier of the ring `r`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `ring_powerseries` and `series_from_coeffs`.

- The condition `ring_powerseries r (series_from_coeffs f)` is rewritten using the definition of `ring_powerseries` as `ring r /\ (coefficients (series_from_coeffs f) SUBSET ring_carrier r)`.
- The condition `coefficients(series_from_coeffs f) SUBSET ring_carrier r` is equivalent to `!n. coeff n (series_from_coeffs f) IN ring_carrier r`.
- The condition `coeff n (series_from_coeffs f)` is, by definition of `series_from_coeffs` equivalent to `f n`.
- The statement is then rewritten using `INFINITE` and `FINITE_MONOMIAL_VARS_1`.
- The proof concludes by using `x_monomial_surjective` and `x_monomial`.

### Mathematical insight
The theorem formalizes the condition under which a formal power series, constructed from a function that maps natural numbers to elements, is a formal power series over a given ring. Specifically, it states that the values of function needs to reside in the ring carrier for `series_from_coeffs` applied to that function to generate a ring power series.

### Dependencies
- `ring_powerseries`
- `series_from_coeffs`
- `INFINITE`
- `FINITE_MONOMIAL_VARS_1`
- `x_monomial_surjective`
- `x_monomial`


---

## poly_series_from_coeffs

### Name of formal statement
poly_series_from_coeffs

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_series_from_coeffs = prove(`
  !(r:R ring) (f:num->R).
  ring_polynomial r (series_from_coeffs f)
  <=> ((!d. f d IN ring_carrier r)
       /\ FINITE {d | ~(f d = ring_0 r)}
      )
`,
  rw[ring_polynomial] THEN
  rw[ring_powerseries;series_from_coeffs;INFINITE;FINITE_MONOMIAL_VARS_1] THEN
  intro THEN
  splitiff THENL [
    intro THENL [
      simp[prove(`f d = f((\v.d:num) one):R`,qed[])]
    ;
      have `!d e. x_monomial d = x_monomial e ==> d = e` [x_monomial_injective] THEN
      specialize[`x_monomial`;`{m | ~(f(m one:num) = ring_0(r:R ring))}`]FINITE_IMAGE_INJ THEN
      set_fact `{d | x_monomial d IN {m | ~(f (m one) = ring_0 r)}} = {d | ~(f((x_monomial d) one) = ring_0(r:R ring))}` THEN
      set_fact_using `{d | ~(f((x_monomial d) one) = ring_0(r:R ring))} = {d | ~(f d = ring_0 r)}` [x_monomial] THEN
      qed[]
    ]
  ;
    intro THENL [
      simp[]
    ;
      have `!m n:1->num. m one = n one ==> m = n` [one_Axiom] THEN
      specialize[`\m:1->num. m one`;`{d:num | ~(f d = ring_0(r:R ring))}`]FINITE_IMAGE_INJ THEN
      set_fact `{m:1->num | m one IN {d | ~(f d = ring_0 r)}} = {m | ~(f(m one) = ring_0(r:R ring))}` THEN
      qed[]
    ]
  ]
);;
```
### Informal statement
For any ring `r` and any function `f` from natural numbers to the carrier of `r`, the series `series_from_coeffs f` is a ring polynomial with respect to `r` if and only if `f` maps every natural number `d` into the carrier of `r` and the set of natural numbers `d` for which `f d` is not equal to the zero element of `r` is finite.

### Informal sketch
The proof consists of showing that `ring_polynomial r (series_from_coeffs f)` is equivalent to the conjunction of two conditions: `!d. f d IN ring_carrier r` and `FINITE {d | ~(f d = ring_0 r)}`.

- The proof starts by rewriting `ring_polynomial` and `ring_powerseries` and simplifying `series_from_coeffs`. After introducing the hypothesis the equivalence statement is split into two implications using `splitiff`.

- For the forward direction:
    - We assume `ring_polynomial r (series_from_coeffs f)`. This means `!d. f d IN ring_carrier r` and `FINITE (monomial_vars (series_from_coeffs f))`

    - To prove the first part of the conjunction, we use `simp` and rewrite `f d = f((\v.d:num) one):R` whose proof is immediate.

    - We want to show that the set `{d | ~(f d = ring_0 r)}` is finite. To do so we recall the theorem expressing the injectivity of `x_monomial` which states that `!d e. x_monomial d = x_monomial e ==> d = e`. Then we specialize `FINITE_IMAGE_INJ` with this injectivity lemma and `{m | ~(f(m one:num) = ring_0(r:R ring))}` to obtain the result. Then we rewrite the expression using `x_monomial` and `x_monomial d = d` to reach the desired result.

- For the reverse direction:
    - We assume `!d. f d IN ring_carrier r` and `FINITE {d | ~(f d = ring_0 r)}`.

    - The first part of the conjunction `!d. f d IN ring_carrier r` is immediate. For the part concerning finiteness, we want to connect `{d | ~(f d = ring_0 r)}` to `{m | ~(f(m one) = ring_0(r:R ring))}`.
To do this, we use the injectivity lemma `!m n:1->num. m one = n one ==> m = n` and `FINITE_IMAGE_INJ`. Then rewrite the result `{m:1->num | m one IN {d | ~(f d = ring_0 r)}} = {m | ~(f(m one) = ring_0(r:R ring))}`

### Mathematical insight
This theorem formally characterizes the conditions under which a series constructed from a function mapping natural numbers to a ring's carrier is a ring polynomial. The key idea is that a ring polynomial can only have a finite number of terms with non-zero coefficients. The theorem provides a precise criterion, linking the finiteness of non-zero coefficients in the function `f` to the polynomial property of the associated series.

### Dependencies
- `ring_polynomial`
- `ring_powerseries`
- `series_from_coeffs`
- `INFINITE`
- `FINITE_MONOMIAL_VARS_1`
- `x_monomial_injective`
- `one_Axiom`

### Porting notes (optional)
- The finiteness proofs rely on `FINITE_IMAGE_INJ`, which may need to be manually instantiated or proven in other systems.
- The handling of ring carriers and ring zero elements may vary; ensure consistency.


---

## poly_coeff

### Name of formal statement
poly_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_coeff = prove(`
  !(r:R ring) p:(1->num)->R.
  ring_polynomial r p
  <=> ((!d. coeff d p IN ring_carrier r)
       /\ FINITE {d | ~(coeff d p = ring_0 r)}
      )
`,
  intro THEN
  have `series_from_coeffs (\d. coeff d p:R) = p` [series_from_coeffs_coeff] THEN
  specialize[`r:R ring`;`\d. coeff d p:R`]poly_series_from_coeffs THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and any function `p` from natural numbers to the carrier of `r`, `p` is a ring polynomial with respect to `r` if and only if all the values of `p` are in the carrier of `r` and the set of natural numbers `d` such that `p(d)` is not equal to the zero element of `r` is finite.

### Informal sketch
The proof proceeds as follows:
- Introduce the ring `r` and the function `p`.
- Use `series_from_coeffs_coeff` to show that `series_from_coeffs (\d. coeff d p:R) = p`.
- Specialize the theorem `poly_series_from_coeffs` with the ring `r` and the function `\d. coeff d p:R`.
- Conclude the proof.

### Mathematical insight
This theorem characterizes when a function from natural numbers to the carrier of a ring represents a polynomial. It essentially states that a function is a polynomial if its coefficients belong to the ring and only finitely many coefficients are non-zero. This is the standard definition of a polynomial in abstract algebra. This theorem provides a necessary and sufficient condition for identifying polynomials within a ring.

### Dependencies
- `ring_polynomial`
- `ring_carrier`
- `coeff`
- `ring_0`
- `FINITE`
- `series_from_coeffs_coeff`
- `poly_series_from_coeffs`
- `ring`

### Porting notes (optional)
- Ensure the target system supports dependent types or equivalent mechanisms for representing ring carrier types.
- Pay attention to automation when translating the finiteness check (`FINITE`). Different provers have varying degrees of automation for this.
- The `series_from_coeffs` and `coeff` may need to be defined first, depending on how polynomials are represented in other proof assistants.


---

## ring_polynomial_subring_if_coeffs

### Name of formal statement
ring_polynomial_subring_if_coeffs

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_polynomial_subring_if_coeffs = prove(`
  !(r:R ring) (p:(1->num)->R).
  ring_polynomial r p ==>
  (!d. coeff d p IN ring_carrier(subring_generated r G)) ==>
  ring_polynomial(subring_generated r G) p
`,
  rw[poly_coeff] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  subgoal `{d | ~(coeff d p = ring_0 (subring_generated r G))} = {d | ~(coeff d p = ring_0(r:R ring))}` THENL [
    rw[EXTENSION;IN_ELIM_THM] THEN
    qed[SUBRING_GENERATED]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For any ring `r` and any function `p` from `(1->num)` to `R`, if `p` is a polynomial over the ring `r`, then, provided that for all `d`, the coefficient of `d` in `p` is an element of the carrier of the subring generated by `G` in `r`, it follows that `p` is also a polynomial over the subring generated by `G` in `r`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using `poly_coeff`.
- Perform repeated generalization and discharge of assumptions.
- The goal is of the form `{d | ~(coeff d p = ring_0 (subring_generated r G))} = {d | ~(coeff d p = ring_0(r:R ring))}`. Rewrite using `EXTENSION` and `IN_ELIM_THM`.
- Complete the proof using the properties of `SUBRING_GENERATED`.
- Pass using `pass`.
- Finish the proof.

### Mathematical insight
This theorem states that if the coefficients of a polynomial over a ring `r` all belong to a subring of `r` generated by some set `G`, then the polynomial is also a polynomial over that subring. In other words, membership in a subring is preserved under polynomial formation. This reflects the fact that being a subring means being closed under the ring operations used to define a polynomial.

### Dependencies
- `poly_coeff`
- `EXTENSION`
- `IN_ELIM_THM`
- `SUBRING_GENERATED`


---

## coeff_series_carrier_in_ring

### Name of formal statement
coeff_series_carrier_in_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_series_carrier_in_ring = prove(`
  !(r:R ring) p.
  p IN ring_carrier(x_series r) <=>
  !d. coeff d p IN ring_carrier(r)
`,
  rw[x_series;POWSER_RING] THEN
  SET_TAC[coeff_series_in_ring]
);;
```
### Informal statement
For any ring `r` and any power series `p` with coefficients in `r`, `p` is an element of the carrier of the ring formed by power series with coefficients in `r` if and only if for all natural numbers `d`, the coefficient of `x^d` in `p` is an element of the carrier of the ring `r`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the goal using the definitions of `x_series` and `POWSER_RING`.
- Then, apply the theorem `coeff_series_in_ring`.

### Mathematical insight
This theorem establishes that the carrier of the power series ring over a ring `r` consists precisely of those power series whose coefficients lie in the carrier of `r`. This is a fundamental property ensuring closure under the ring operations.

### Dependencies
- Definitions: `x_series`, `POWSER_RING`
- Theorems: `coeff_series_in_ring`


---

## coeff_poly_in_ring

### Name of formal statement
coeff_poly_in_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_in_ring = prove(`
  !(r:R ring) d p.
  ring_polynomial r p ==>
  coeff d p IN ring_carrier(r)
`,
  qed[ring_polynomial;coeff_series_in_ring]
);;
```
### Informal statement
For any ring `r` : `R ring`, any natural number `d`, and any polynomial `p`, if `p` is a polynomial over the ring `r` (i.e., `ring_polynomial r p`), then the `d`-th coefficient of `p` (i.e., `coeff d p`) is an element of the carrier set of the ring `r` (i.e., `ring_carrier(r)`).

### Informal sketch
The proof proceeds by:
- Assuming `p` is a `ring_polynomial` over the ring `r`.
- Showing that for any `d`, the coefficient `coeff d p` is in the ring carrier `ring_carrier(r)`. This involves appealing to the theorem `coeff_series_in_ring` which states that coefficients of power series over a ring are in the ring.
- The proof also uses the definition of `ring_polynomial`.

### Mathematical insight
This theorem formalizes a fundamental property of polynomials over rings: that their coefficients belong to the underlying ring. This is crucial for ensuring that polynomial operations (addition, multiplication) remain within the ring structure. `coeff_series_in_ring` is a more general result about power series over a ring, and this theorem specializes it to polynomials.

### Dependencies
- Theorems: `ring_polynomial`, `coeff_series_in_ring`


---

## coeff_poly_carrier_in_ring

### Name of formal statement
coeff_poly_carrier_in_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_carrier_in_ring = prove(`
  !(r:R ring) d p.
  p IN ring_carrier(x_poly r) ==>
  coeff d p IN ring_carrier(r)
`,
  qed[x_poly_carrier_in_series_carrier;coeff_series_carrier_in_ring]
);;
```
### Informal statement
For any ring `r`, natural number `d`, and polynomial `p` in `x_poly r`, if `p` is an element of the carrier set of the ring `x_poly r`, then `coeff d p` is an element of the carrier set of the ring `r`.

### Informal sketch
The proof shows that if a polynomial `p` is in the carrier of the polynomial ring `x_poly r`, then the coefficient of `p` at any degree `d` is in the carrier of the ring `r`.
- It uses the theorem `x_poly_carrier_in_series_carrier` to show that if `p` is in the carrier of the polynomial ring, then `p` is in the carrier of the series ring constructed from `r`.
- It then applies the theorem `coeff_series_carrier_in_ring` to deduce that `coeff d p` is in the carrier of the ring `r`.

### Mathematical insight
This theorem establishes a fundamental property of polynomial rings: that the coefficients of a polynomial belonging to the carrier set of the polynomial ring must themselves belong to the carrier set of the base ring. This is a key requirement to ensure that the polynomial ring construction preserves the algebraic structure of the underlying ring.

### Dependencies
Theorems:
- `x_poly_carrier_in_series_carrier`
- `coeff_series_carrier_in_ring`


---

## coeff_poly_const

### Name of formal statement
coeff_poly_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_const = prove(`
  !(r:R ring) c:R d.
  coeff d (poly_const r c)
  = if d = 0 then c else ring_0 r
`,
  rw[coeff;x_monomial;poly_const;monomial_1] THEN
  qed[]
);;
```
### Informal statement
For any ring `R`, any element `r` of `R`, and any elements `c` and `d` of `R`, the coefficient of `d` in the polynomial `poly_const r c` is equal to `c` if `d` is equal to `0`, and `ring_0 r` otherwise.

### Informal sketch
- The proof proceeds by rewriting using the definitions of `coeff`, `x_monomial`, `poly_const`, and `monomial_1`.
  - The definition of `coeff d p` gives the coefficient of x^d in polynomial p.
  - The definition of `poly_const r c` gives a constant polynomial `c`.
  - The definition of `monomial 1 d` gives `x^d`
  - The definition of `x_monomial` says that `coeff d (x_monomial d)` is `ring_1` if d=d', and `ring_0` otherwise.
- These rewrites reduce the goal to the desired conditional equation involving `c` and `ring_0 r`. Finally, the proof concludes.

### Mathematical insight
This theorem states that the constant term (the coefficient of x^0) of a constant polynomial is indeed the constant itself, and all other coefficients are zero (the ring's zero element). This is a fundamental property of constant polynomials and is essential for reasoning about polynomial algebra. This result confirms that the `poly_const` construction behaves as expected.

### Dependencies
- Definitions: `coeff`, `x_monomial`, `poly_const`, `monomial_1`
- Theorems: None


---

## coeff_poly_0

### Name of formal statement
coeff_poly_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_0 = prove(`
  !(r:R ring).
  coeff d (poly_0 r)
  = ring_0 r
`,
  rw[poly_0;coeff_poly_const] THEN
  qed[]
);;
```
### Informal statement
For any ring `R`, for any natural number `d`, the coefficient of `x^d` in the zero polynomial over `R` is equal to the zero element of the ring `R`.

### Informal sketch
The proof proceeds by rewriting the goal using the definition of the zero polynomial `poly_0`, then using the theorem `coeff_poly_const` which states that the coefficient of degree `d` in a constant polynomial `k` is `k` if `d` is zero and zero otherwise. In this instance, the constant polynomial is `ring_0 r`, so the result follows.

### Mathematical insight
This theorem formalizes the intuitive notion that the zero polynomial has all coefficients equal to zero. It's a fundamental property used in many manipulations involving polynomials.

### Dependencies
- Definitions: `poly_0`
- Theorems: `coeff_poly_const`


---

## coeff_poly_1

### Name of formal statement
coeff_poly_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_1 = prove(`
  !(r:R ring).
  coeff d (poly_1 r)
  = if d = 0 then ring_1 r else ring_0 r
`,
  rw[poly_1;coeff_poly_const]
);;
```
### Informal statement
For any ring `r` and any natural number `d`, the `d`-th coefficient of the polynomial `poly_1 r` is equal to `ring_1 r` if `d` is equal to 0, and equal to `ring_0 r` otherwise.

### Informal sketch
The proof proceeds by rewriting.
- First, the definition of `poly_1` is unfolded. The term `poly_1 r` is defined as the polynomial function that maps 0 to `ring_1 r` and any other value to `ring_0 r`.
- Second, the theorem `coeff_poly_const` is applied, which states that the `d`-th coefficient of a constant polynomial `c` is equal to `c` if `d` is 0, and `ring_0 r` otherwise.

### Mathematical insight
The polynomial `poly_1 r` represents the multiplicative identity in the ring of polynomials over `r`. This theorem extracts the explicit coefficients of this polynomial. It formalizes the intuition that the constant term of the polynomial `1` is `1` and all other coefficients are `0`.

### Dependencies
- Definitions: `poly_1`
- Theorems: `coeff_poly_const`


---

## coeff_poly_neg

### Name of formal statement
coeff_poly_neg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_neg = prove(`
  !(r:R ring) p d.
  coeff d (poly_neg r p)
  = ring_neg r (coeff d p)
`,
  rw[coeff;poly_neg]
);;
```
### Informal statement
For any ring `r`, any polynomial `p` over `r`, and any natural number `d`, the coefficient of `x^d` in the negation of `p` is equal to the negation of the coefficient of `x^d` in `p`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `coeff` and `poly_neg`.
- First, the definition of `poly_neg r p` is applied, which negates each coefficient of the polynomial `p` using `ring_neg r`.
- Then, the definition of `coeff d` is applied to extract the coefficient of `x^d` from the negated polynomial.

### Mathematical insight
This theorem establishes a fundamental relationship between the coefficients of a polynomial and the coefficients of its negation. It shows that negating a polynomial is equivalent to negating each of its coefficients individually, a property expected from the definition of a polynomial ring. This result is useful for manipulating polynomial expressions and reasoning about their properties.

### Dependencies
- Definitions: `coeff`, `poly_neg`


---

## coeff_poly_add

### Name of formal statement
coeff_poly_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) p q d.
  coeff d (poly_add r p q)
  = ring_add r (coeff d p) (coeff d q)
```

### Informal statement
For any ring `r` (in the `R` type), given any polynomials `p` and `q`, and any degree `d`, the coefficient of degree `d` in the polynomial `poly_add r p q` (the sum of `p` and `q` in the ring `r`) is equal to the ring addition `ring_add r` of the coefficient of degree `d` in `p` and the coefficient of degree `d` in `q`.

### Informal sketch
- The proof proceeds by rewriting the left-hand side of the equation using the definition of `coeff` and `poly_add`.
- The definitions `coeff` and `poly_add` are unfolded using the `rw` tactic, demonstrating that the coefficient of the sum of two polynomials is the sum of their coefficients at a given degree.

### Mathematical insight
This theorem states that polynomial addition is performed coefficient-wise. It links the abstract operation of polynomial addition to the more concrete operation of addition within the underlying ring. This result is fundamental to the algebraic manipulation of polynomials.

### Dependencies
- Definitions: `coeff`, `poly_add`


---

## coeff_series_add

### Name of formal statement
coeff_series_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_series_add = prove(`
  !(r:R ring) p q d.
  coeff d (ring_add(x_series r) p q)
  = ring_add r (coeff d p) (coeff d q)
`,
  rw[x_series;POWSER_RING;coeff_poly_add]
);;
```
### Informal statement
For any ring `r`, given power series `p` and `q` over `r`, and any natural number `d`, the `d`-th coefficient of the power series `p + q` (where `+` is addition in the power series ring) is equal to the sum of the `d`-th coefficient of `p` and the `d`-th coefficient of `q` (where `+` is addition in the ring `r`).

### Informal sketch
The proof proceeds by:
- Expanding `ring_add(x_series r) p q` using the definition `x_series`.
- Applying the definition of `POWSER_RING` to express the ring addition of power series in terms of pointwise addition.
- Using `coeff_poly_add`, which says that the `d`-th coefficient of the pointwise sum of two power series is the sum of their `d`-th coefficients.

### Mathematical insight
This theorem states that the coefficient of the sum of two power series is the sum of the corresponding coefficients. It reflects the pointwise definition of addition in the power series ring. This a fundamental property of power series rings and is essential for manipulating and reasoning about power series formally.

### Dependencies
- Definitions: `x_series`, `POWSER_RING`
- Theorems: `coeff_poly_add`


---

## coeff_poly_sub

### Name of formal statement
coeff_poly_sub

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_sub = prove(`
  !(r:R ring) p q d.
  coeff d (poly_sub r p q)
  = ring_sub r (coeff d p) (coeff d q)
`,
  rw[coeff;poly_sub]
);;
```
### Informal statement
For all rings `r` and all polynomials `p` and `q` over `r`, and for all natural numbers `d`, the coefficient of `d` in the polynomial `p - q` (where `poly_sub r p q` denotes polynomial subtraction in the ring `r`) is equal to the ring subtraction of the coefficient of `d` in `p` and the coefficient of `d` in `q`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `coeff` and `poly_sub`.
- First, the definition of `coeff` is applied to the left-hand side.
- Then, the definition of `poly_sub` is applied.

### Mathematical insight
This theorem states that polynomial subtraction respects the coefficients of the polynomials. In other words, the coefficient of a given degree in the difference of two polynomials is the difference of the coefficients of that degree in the original polynomials. This is a fundamental property of polynomial arithmetic and is essential for reasoning about polynomial equations and manipulations.

### Dependencies
- Definitions: `coeff`, `poly_sub`


---

## coeff_poly_mul_lemma

### Name of formal statement
coeff_poly_mul_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_mul_lemma = prove(`
  !(r:R ring) p q.
  ((\(m1,m2). ring_mul r (p m1) (q m2)) o (\(a,b). x_monomial a,x_monomial b)) =
  (\(a,b). ring_mul r (p (x_monomial a)) (q (x_monomial b)))
`,
  rw[FUN_EQ_THM] THEN
  intro_genonly THEN
  choose2 `a:num` `b:num` `x = (a:num),(b:num)` [PAIR_SURJECTIVE] THEN
  simp[o_THM]
);;
```
### Informal statement
For any ring `r`, and any polynomials `p` and `q` over that ring, the function that maps a pair of monomials `(a, b)` to the ring multiplication of `p` evaluated at `a` and `q` evaluated at `b` is equal to the function that maps a pair of numbers `(a, b)` to the ring multiplication of `p` evaluated at the monomial of `a` and `q` evaluated at the monomial of `b`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using function equality (`FUN_EQ_THM`). This reduces the goal to showing the equality of the function's values for arbitrary input.
- Introduce arbitrary variables `r`, `p`, and `q`.
- Choose arbitrary `a` and `b` and let `x` be the pair `(a,b)`. This is possible given `PAIR_SURJECTIVE`.
- Simplify using the definition of function composition (`o_THM`).

### Mathematical insight
This lemma establishes an equivalence between two ways of defining a map. The left-hand side applies the polynomials `p` and `q` to monomials first, and then performs ring multiplication. The right-hand side extracts the coefficients (represented by `a` and `b`) from these monomials, applies polynomials to these coefficients, create monomials using these values as coefficients, then performs ring multiplication. The core idea is to show that evaluating the polynomials with the monomial created by coefficients is equivalent to first evaluating at a generic monomial and then working with the polynomial representation of the multiplication.

### Dependencies
- `FUN_EQ_THM`
- `o_THM`
- `PAIR_SURJECTIVE`


---

## coeff_poly_mul

### Name of formal statement
coeff_poly_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_mul = prove(`
  !(r:R ring) p q d.
  coeff d (poly_mul r p q)
  = ring_sum r {a,b | a+b = d} (\(a,b). ring_mul r (coeff a p) (coeff b q))
`,
  rw[poly_mul;coeff] THEN
  intro THEN
  rw[x_monomial_factorizations_set] THEN
  rw[ring_sum_image_x_monomial_pair] THEN
  rw[coeff_poly_mul_lemma]
);;
```
### Informal statement
For any ring structure `r` over a type `R` and for any polynomials `p` and `q` over `R`, and any natural number `d`, the coefficient of `x^d` in the polynomial `p * q` (where `*` denotes polynomial multiplication with respect to ring `r`) is equal to the ring sum (with respect to ring `r`) over the set of pairs of natural numbers `(a, b)` such that `a + b = d`, of the ring product (with respect to ring `r`) of the coefficient of `x^a` in `p` and the coefficient of `x^b` in `q`.

### Informal sketch
The proof proceeds as follows:
-  Start by rewriting the goal using definitions of `poly_mul` and `coeff`.
-  Introduce the quantified variables.
-  Rewrite using `x_monomial_factorizations_set`, which likely expresses some factorization property related to monomials.
-  Then rewrite with `ring_sum_image_x_monomial_pair`, which rewrites the `ring_sum` over pairs of x_monomials.
-  Finally rewrite with `coeff_poly_mul_lemma`, which probably completes the proof by establishing the stated equality.

### Mathematical insight
This theorem provides the formula for computing the coefficients of the product of two polynomials in terms of the coefficients of the original polynomials. This is a fundamental result in algebra and essential for manipulating polynomial expressions. It essentially shows the convolution nature of polynomial multiplication with respect to the coefficients.

### Dependencies
- Definition: `poly_mul`
- Definition: `coeff`
- Theorem: `x_monomial_factorizations_set`
- Theorem: `ring_sum_image_x_monomial_pair`
- Theorem: `coeff_poly_mul_lemma`


---

## coeff_poly_mul_oneindex

### Name of formal statement
coeff_poly_mul_oneindex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_mul_oneindex = prove(`
  !(r:R ring) d p q.
  coeff d (poly_mul r p q)
  = ring_sum(r) (0..d) (\a. ring_mul r (coeff a p) (coeff (d-a) q))
`,
  intro THEN
  rw[coeff_poly_mul] THEN
  def `f:num->(num#num)` `\a:num. a,d-a` THEN
  have `!a b:num. (f:num->num#num) a = f b ==> a = b` [FST] THEN
  have `ring_sum r (IMAGE (f:num->num#num) (0..d)) (\(a,b). ring_mul r (coeff a p) (coeff b q)) = ring_sum(r:R ring) (0..d) ((\(a,b). ring_mul r (coeff a p) (coeff b q)) o f)` [RING_SUM_IMAGE] THEN
  have `IMAGE (f:num->num#num) (0..d) = {a,b | a + b = d}` [image_numseg_antidiagonal] THEN
  ASSUME_TAC(prove(`(\(a,b). ring_mul(r:R ring) (coeff a p) (coeff b q)) o (\a. a,d-a) = (\a. ring_mul r (coeff a p) (coeff (d-a) q))`,rw[FUN_EQ_THM;o_THM])) THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, any natural number `d`, and any polynomials `p` and `q` over `r`, the coefficient of `x^d` in the polynomial `p * q` is equal to the ring sum, indexed from `0` to `d`, of the terms `coeff a p * coeff (d-a) q`, where `a` ranges from `0` to `d`.

### Informal sketch
The proof proceeds as follows:
- Start with `coeff d (poly_mul r p q)`
- Rewrite using `coeff_poly_mul` to express the coefficient as a ring sum over pairs `(a, b)` where `a + b = d`.
- Define a function `f` mapping `a` to `(a, d - a)`.
- Show that `f` is injective with `!a b:num. (f:num->num#num) a = f b ==> a = b`.
- Apply the theorem `RING_SUM_IMAGE` to change the domain of the outer `ring_sum` using the image of `f`. This allows us to rewrite the sum over the range `0..d` rather than over pairs.
- Show that the image of `0..d` under `f` is equal to `{a,b | a + b = d}` by invoking `image_numseg_antidiagonal`.
- Verify that `(\(a,b). ring_mul(r:R ring) (coeff a p) (coeff b q)) o (\a. a,d-a) = (\a. ring_mul r (coeff a p) (coeff (d-a) q))` by rewriting with `FUN_EQ_THM` and `o_THM`.

### Mathematical insight
The theorem expresses the standard formula for the coefficients of the product of two polynomials. The coefficient of `x^d` in `p*q` is obtained by summing the products of the coefficients of `x^a` in `p` and `x^(d-a)` in `q`, where `a` ranges from `0` to `d`. The main effort of the proof is transforming an existing summation with an index of type `(num # num)` into the simpler `num` index, as this is more convenient for later simplification.

### Dependencies
- `coeff_poly_mul`
- `RING_SUM_IMAGE`
- `image_numseg_antidiagonal`
- `FUN_EQ_THM`
- `o_THM`


---

## poly_const_times

### Name of formal statement
poly_const_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_times = prove(`
  !(r:R ring) c:R p:(V->num)->R.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  poly_mul r (poly_const r c) p
  = (\m. ring_mul r c (p m))
`,
  rw[poly_mul] THEN
  once_rw[fun_eq_thm_v] THEN
  rw[BETA_THM] THEN
  intro THEN
  subgoal `ring_sum(r:R ring) {m1,m2 | monomial_mul m1 m2 = v:V->num} (\(m1,m2). ring_mul r (poly_const r c m1) (p m2)) = ring_sum r {m1,m2 | monomial_mul m1 m2 = v} (\j. if j = (monomial_1,v) then ring_mul r c (p v) else ring_0 r)` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[FORALL_PAIR_THM;IN_ELIM_PAIR_THM;PAIR_EQ;poly_const] THEN
    intro THEN
    case `p1 = monomial_1:V->num` THENL [
      have `p2 = v:V->num` [MONOMIAL_MUL_LID] THEN
      simp[]
    ; pass
    ] THEN
    have `p(p2:V->num) IN ring_carrier(r:R ring)` [ring_powerseries] THEN
    qed[RING_MUL_LZERO]
  ; pass
  ] THEN
  subgoal `monomial_1,v IN {m1,m2 | monomial_mul m1 m2 = v:V->num}` THENL [
    rw[IN_ELIM_PAIR_THM] THEN
    rw[MONOMIAL_MUL_LID]
  ; pass
  ] THEN
  simp[RING_SUM_DELTA] THEN
  qed[ring_powerseries;RING_MUL]
);;
```
### Informal statement
For any ring `r` and element `c` in the carrier of `r`, and for any power series `p` over the monomials `V->num` with coefficients in `r`, the polynomial multiplication of the constant polynomial `poly_const r c` and the polynomial `p` is equal to the power series that maps each monomial `m` to the ring multiplication of `c` and `p m`.

### Informal sketch
The proof proceeds as follows:
- Expand `poly_mul` using its definition.
- Rewrite using the extensionality theorem `fun_eq_thm_v`.
- Simplify using `BETA_THM`.
- Introduce the variable `v` (representing a monomial).
- Reduce the goal to showing that `ring_sum(r:R ring) {m1,m2 | monomial_mul m1 m2 = v:V->num} (\(m1,m2). ring_mul r (poly_const r c m1) (p m2)) = ring_sum r {m1,m2 | monomial_mul m1 m2 = v} (\j. if j = (monomial_1,v) then ring_mul r c (p v) else ring_0 r)`.
- Suffice by `RING_SUM_EQ`.
- Rewrite using `FORALL_PAIR_THM`, `IN_ELIM_PAIR_THM`, `PAIR_EQ`, and `poly_const`.
 - Introduce assumptions about `p1` and `p2`.
 - Perform a case split on the possibility that `p1 = monomial_1`.
  - In the first case where `p1=monomial_1`, show that `p2 = v` using `MONOMIAL_MUL_LID` and simplify.
  - In the second case, show that `p(p2:V->num) IN ring_carrier(r:R ring)` using the assumption `ring_powerseries` and then use `RING_MUL_LZERO` to complete the proof.
- Show that `monomial_1,v IN {m1,m2 | monomial_mul m1 m2 = v:V->num}` using `IN_ELIM_PAIR_THM` and `MONOMIAL_MUL_LID`.
- Simplify using `RING_SUM_DELTA`.
- Conclude the proof using the assumptions `ring_powerseries` and `RING_MUL`.

### Mathematical insight
This theorem establishes a fundamental property of polynomial multiplication: multiplying a polynomial by a constant is equivalent to multiplying each coefficient of the polynomial by that constant. This is a basic result used throughout polynomial algebra and is essential for simplifying and manipulating polynomial expressions.

### Dependencies
- `poly_mul`
- `fun_eq_thm_v`
- `BETA_THM`
- `RING_SUM_EQ`
- `FORALL_PAIR_THM`
- `IN_ELIM_PAIR_THM`
- `PAIR_EQ`
- `poly_const`
- `MONOMIAL_MUL_LID`
- `RING_MUL_LZERO`
- `ring_powerseries`
- `RING_SUM_DELTA`
- `RING_MUL`


---

## coeff_poly_const_times

### Name of formal statement
coeff_poly_const_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_const_times = prove(`
  !(r:R ring) c:R p d.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  coeff d (poly_mul r (poly_const r c) p)
  = ring_mul r c (coeff d p)
`,
  rw[coeff_poly_mul_oneindex] THEN
  simp[coeff_poly_const] THEN
  simp[prove(`ring_powerseries r p ==> ring_mul (r:R ring) (if a:num = 0 then c else ring_0 r) (coeff (d - a) p) = if a = 0 then ring_mul r c (coeff (d - a) p) else ring_0 r`,qed[RING_MUL_LZERO;coeff_series_in_ring])] THEN
  rw[RING_SUM_DELTA] THEN
  intro THEN
  set_fact_using `0 IN (0..d)` [NUMSEG_LE;ARITH_RULE `0 <= d:num`] THEN
  have `coeff(d - 0) p IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  have `ring_mul(r:R ring) c (coeff(d - 0) p) IN ring_carrier r` [RING_MUL] THEN
  qed[ARITH_RULE `d - 0 = d:num`]
);;
```
### Informal statement
For any ring `r`, any element `c` in the carrier of `r`, any power series `p` over `r`, and any natural number `d`, if `c` is in the carrier of the ring `r` and `p` is a power series over `r`, then the `d`-th coefficient of the power series resulting from multiplying the constant polynomial `c` by `p` in the ring `r` is equal to the ring multiplication of `c` and the `d`-th coefficient of `p` in the ring `r`.

### Informal sketch
The proof proceeds as follows:

- Rewrite the left-hand side using `coeff_poly_mul_oneindex`, which expresses the coefficient of a product of polynomials as a sum.
- Simplify the expression using `coeff_poly_const`, which states that the coefficients of a constant polynomial are zero except for the constant term.
- Simplify using a lemma that states that if `a` is not 0, then `ring_mul r (if a = 0 then c else ring_0 r) (coeff (d - a) p) = if a = 0 then ring_mul r c (coeff (d - a) p) else ring_0 r`.  This lemma itself relies on `RING_MUL_LZERO` which states that multiplying by the zero element results in the zero element and `coeff_series_in_ring` which states that the coefficients of the the series are contained in the ring.
- Rewrite the sum using `RING_SUM_DELTA`, which effectively extracts a specific term from the summation based on a delta function.
- Introduce a variable.
- Establish that 0 is an element of the set `{0, ..., d}`.
- Show `coeff(d - 0) p IN ring_carrier(r:R ring)` using `coeff_series_in_ring`
- Show `ring_mul(r:R ring) c (coeff(d - 0) p) IN ring_carrier r` using `RING_MUL`.
- Conclude by simplifying `d-0 = d`.

### Mathematical insight
This theorem expresses a fundamental property of polynomial multiplication within a ring structure. It formalizes the intuition that multiplying a polynomial by a constant scales each of its coefficients by that constant. This is a fundamental result when manipulating polynomials within algebraic structures.

### Dependencies
- Theorem: `coeff_poly_mul_oneindex`
- Theorem: `coeff_poly_const`
- Theorem: `RING_MUL_LZERO`
- Theorem: `coeff_series_in_ring` which relies on definition `ring_powerseries`
- Theorem: `RING_SUM_DELTA`
- Theorem: `NUMSEG_LE`
- Theorem: `RING_MUL`

### Porting notes (optional)
This theorem relies heavily on the ring and polynomial infrastructure present in HOL Light. The porter should ensure that the target proof assistant has similar structures and associated lemmas to properly represent and prove the theorem. The tactics `rw` and `simp` are used extensively so the porter must ensure the target proof assistant has similar automation, likely using rewriting or simplification of some form.


---

## coeff_times_poly_const

### Name of formal statement
coeff_times_poly_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_times_poly_const = prove(`
  !(r:R ring) c:R p d.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  coeff d (poly_mul r p (poly_const r c))
  = ring_mul r c (coeff d p)
`,
  qed[RING_POWERSERIES_CONST;POLY_MUL_SYM;coeff_poly_const_times]
);;
```
### Informal statement
For any ring `r`, any element `c` in the carrier of `r`, and any power series `p` over `r`, for any degree `d`, the coefficient of `d` in the power series obtained by multiplying `p` with the constant polynomial `c` is equal to the ring multiplication of `c` with the coefficient of `d` in `p`.

### Informal sketch
The proof demonstrates that multiplying a power series by a constant polynomial is equivalent to multiplying each coefficient of the power series by that constant. The general strategy involves:
- Showing the multiplication of `p` with a constant polynomial `c` is to multiply each coefficient `coeff d p` by `c`.
- Use `RING_POWERSERIES_CONST` to unfold `poly_const r c`
- Applying `POLY_MUL_SYM` to switch the order of multiplication `poly_mul r p (poly_const r c)` to `poly_mul r (poly_const r c) p`
- Utilizing `coeff_poly_const_times` to derive the final equality

### Mathematical insight
This theorem shows how multiplication by a constant polynomial distributes across the coefficients of a power series. This is a fundamental property when dealing with polynomial and power series rings. It essentially gives the relationship between constant multiplication and taking coefficient of polynomials, which is an important property when reasoning about operations on power series.

### Dependencies
- Theorems:
  - `RING_POWERSERIES_CONST`
  - `POLY_MUL_SYM`
  - `coeff_poly_const_times`


---

## polynomial_if_coeff

### Name of formal statement
polynomial_if_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let polynomial_if_coeff = prove(`
  !(r:R ring) p n.
  ring_powerseries r p ==>
  (!d. ~(coeff d p = ring_0 r) ==> d <= n) ==>
  ring_polynomial r p
`,
  intro THEN
  rw[ring_polynomial] THEN
  simp[] THEN
  subgoal `{d | ~(coeff d p = ring_0(r:R ring))} SUBSET {d:num | d <= n}` THENL [
    rw[SUBSET;IN_ELIM_THM] THEN
    qed[]
  ;
    pass
  ] THEN
  have `FINITE {d | ~(coeff d p = ring_0(r:R ring))}` [FINITE_SUBSET;FINITE_NUMSEG_LE] THEN
  set_fact_using `{d | ~(coeff d p = ring_0(r:R ring))} = {d | ~(p(x_monomial d) = ring_0(r:R ring))}` [coeff] THEN
  have `FINITE {d | ~(p(x_monomial d) = ring_0(r:R ring))}` [] THEN
  recall x_monomial_surjective THEN
  specialize[`x_monomial`;`\m:1->num. ~(p m = ring_0(r:R ring))`]surjective_finite THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and any power series `p` over `r`, if `p` is a ring power series and if for all `d`, if the coefficient of `d` in `p` is not the ring zero element, then `d` is less than or equal to `n`, then `p` is a ring polynomial.

### Informal sketch
The proof shows that if a ring power series has the property that all degrees with non-zero coefficients are bounded by `n`, then it is indeed a ring polynomial.
- We start by introducing the hypotheses and rewriting using the definition of `ring_polynomial`. This reduces the goal into showing that the set of all degrees `d` with non-zero coefficients is finite.
- We prove the subset relation that `{d | ~(coeff d p = ring_0(r:R ring))}` is a subset of `{d:num | d <= n}` by rewriting with `SUBSET` and `IN_ELIM_THM`.
- The subgoal that `{d | ~(coeff d p = ring_0(r:R ring))} SUBSET {d:num | d <= n}` has been proven, we can show the set `{d | ~(coeff d p = ring_0(r:R ring))}` is finite.
- Then we rewrite the set comprehension using `coeff`, and apply a specialization using the surjectivity of `x_monomial`.

### Mathematical insight
The theorem formalizes the common-sense notion of a polynomial in terms of power series. A polynomial is a power series with only finitely many non-zero coefficients (in this case, these coefficients have degree less than or equal to `n`).

### Dependencies
- `ring_polynomial`
- `SUBSET`
- `IN_ELIM_THM`
- `coeff`
- `FINITE_SUBSET`
- `FINITE_NUMSEG_LE`
- `x_monomial_surjective`


---

## deg_le_coeff

### Name of formal statement
deg_le_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_le_coeff = prove(`
  !(r:R ring) p n.
  ring_powerseries r p ==>
  (!d. ~(coeff d p = ring_0 r) ==> d <= n) ==>
  poly_deg r p <= n
`,
  intro THEN
  sufficesby POLY_DEG_LE THEN
  have `ring_polynomial(r:R ring) (p:(1->num)->R)` [polynomial_if_coeff] THEN
  simp[] THEN
  intro THEN
  choose `d:num` `x_monomial d = m` [x_monomial_surjective] THEN
  qed[x_monomial_deg;coeff]
);;
```
### Informal statement
For any ring `r` and any power series `p` over `r`, and any natural number `n`, if `p` is a ring power series, and if for all natural numbers `d`, whenever the coefficient of `d` in `p` is not equal to the zero element of the ring `r`, then `d` is less than or equal to `n`, then the polynomial degree of `p` is less than or equal to `n`.

### Informal sketch
*   The proof starts with an introduction.
*   It suffices to show that if a term `m` is an `x_monomial d` in `p`, then `d <= n`, which is achieved by `POLY_DEG_LE`.
*   It is assumed that `p` is a ring polynomial.
*   Then it's simplified.
*   An introduction follows.
*   `d` is chosen such that `x_monomial d = m` using `x_monomial_surjective`.
*   The proof concludes using `x_monomial_deg` and `coeff`.

### Mathematical insight
The theorem `deg_le_coeff` relates the polynomial degree of a power series to the highest power with a non-zero coefficient. Informally, if all non-zero coefficients occur for powers less than or equal to `n`, then the degree of the polynomial is less than or equal to `n`. This makes intuitive sense, as the degree corresponds to the highest power with a non-zero coefficient. The key is that we are looking at a ring polynomial and using the fact that the degree of a monomial `x_monomial d` is `d`. When coefficients for powers beyond `n` are zero, the degree cannot exceed `n`.

### Dependencies
*   `ring_powerseries`
*   `POLY_DEG_LE`
*   `ring_polynomial`
*   `x_monomial_surjective`
*   `x_monomial_deg`
*   `coeff`


---

## deg_coeff

### Name of formal statement
deg_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_coeff = prove(`
  !(r:R ring) p n.
  ring_powerseries r p ==>
  (!d. ~(coeff d p = ring_0 r) ==> d <= n) ==>
  ~(coeff n p = ring_0 r) ==>
  poly_deg r p = n
`,
  intro THEN
  have `ring_polynomial(r:R ring) (p:(1->num)->R)` [polynomial_if_coeff] THEN
  simp[POLY_DEG_EQ] THEN
  intro THENL [
    choose `d:num` `x_monomial d = m` [x_monomial_surjective] THEN
    qed[x_monomial_deg;coeff]
  ;
    DISJ2_TAC THEN
    witness `x_monomial n` THEN
    qed[x_monomial_deg;coeff]
  ]
);;
```

### Informal statement
For any ring `r` and any powerseries `p` over `r`, and any natural number `n`, if `p` is a ring powerseries over `r`, and if for all natural numbers `d`, if `coeff d p` is not equal to the ring zero of `r` implies `d` is less than or equal to `n`, and if `coeff n p` is not equal to the ring zero of `r`, then the polynomial degree of `p` over `r` is `n`.

### Informal sketch
The proof proceeds as follows:

- Assume the hypotheses: `p` is a ring powerseries over `r`, all non-zero coefficients occur at indices at most `n`, and the `n`-th coefficient is non-zero.
- Show that `p` is a ring polynomial given the conditions. (`ring_polynomial(r:R ring) (p:(1->num)->R)` [polynomial_if_coeff])
- Apply simplification using `POLY_DEG_EQ`, which unfolds the definition of `poly_deg`.
- We must now prove `poly_deg r p = n`, which means find `m` such that `x_monomial m = p` and `~ (coeff n p = ring_0 r)`
    - Then we split the goal by disjunction, and prove both sides.
    - The first side we choose `d:num` such that `x_monomial d = m` using `x_monomial_surjective`. We can `qed` based on `x_monomial_deg` and `coeff`.
    - Then we split to prove the inequality, namely `~ (coeff n p = ring_0 r)`. We can witness `x_monomial n` and `qed` based on `x_monomial_deg` and `coeff`.

### Mathematical insight
This theorem relates the polynomial degree of a powerseries to the largest index of its non-zero coefficients, given that all coefficients beyond this index are zero. It formalizes the intuition that the degree of a polynomial is the index of its highest non-zero term. This result is important for reasoning about the degree of polynomial expressions within the formal system.

### Dependencies
- `ring_powerseries`
- `ring_0`
- `coeff`
- `poly_deg`
- `ring_polynomial`
- `x_monomial`
- `x_monomial_surjective`
- `POLY_DEG_EQ`
- `x_monomial_deg`


---

## topcoeff_nonzero

### Name of formal statement
topcoeff_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let topcoeff_nonzero = prove(`
  !(r:R ring) p.
  ring_polynomial r p ==>
  (p = poly_0 r <=> coeff (poly_deg r p) p = ring_0 r)
`,
  intro THEN
  splitiff THENL [
    qed[coeff_poly_0]
  ;
    rw[coeff;x_monomial] THEN
    intro THEN
    have `p IN ring_carrier(poly_ring(r:R ring) (:1))` [x_poly_use;x_poly] THEN
    have `p = ring_0(poly_ring(r:R ring) (:1))` [POLY_TOP_NONZERO] THEN
    qed[x_poly_use;x_poly]
  ]
);;
```
### Informal statement
For any ring `r` and polynomial `p` over `r`, if `p` is a polynomial in the ring polynomial carrier of `r`, then `p` is the zero polynomial if and only if the coefficient of `p` at the degree of `p` is the zero element of the ring `r`.

### Informal sketch
The proof proceeds by proving both directions of the if and only if statement.
- First, it's shown that if `p` is the zero polynomial, then the coefficient of `p` at the degree of `p` is the zero element of the ring `r`. This follows directly from the theorem `coeff_poly_0`.
- Conversely, it's shown that if the coefficient of `p` at the degree of `p` is the zero element of `r`, then `p` is the zero polynomial. This direction uses the definition of `coeff` and `x_monomial`, intro introduces the hypothesis, gets `p IN ring_carrier(poly_ring(r:R ring) (:1))` which means `p` is a polynomial, and applies `POLY_TOP_NONZERO` to conclude that `p` is the zero polynomial.

### Mathematical insight
This theorem provides a way to check if a polynomial is zero by examining its leading coefficient. It formalizes the intuition that a polynomial is zero if and only if all its coefficients are zero, and particularly, the leading coefficient is zero. Since `poly_deg` returns -1 for the zero polynomial, then `coeff (poly_deg r p) p` is zero, so the leading coefficient tells you if the polynomials are nonzero.

### Dependencies
- Definitions: `coeff`, `x_monomial`
- Theorems: `coeff_poly_0`, `POLY_TOP_NONZERO`


---

## coeff_deg_le

### Name of formal statement
coeff_deg_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_deg_le = prove(`
  !(r:R ring) p n d.
  ring_polynomial r p ==>
  poly_deg r p <= n ==>
  ~(coeff d p = ring_0 r) ==>
  d <= n
`,
  intro THEN
  have `~(p(x_monomial d) = ring_0(r:R ring))` [coeff] THEN
  have `monomial_deg(x_monomial d) <= n` [POLY_DEG_LE_EQ] THEN
  qed[x_monomial_deg]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any polynomial `p` over `r`, and any natural numbers `n` and `d`, if `p` is a ring polynomial and the degree of `p` is less than or equal to `n`, and the coefficient of `p` at `d` is not equal to the zero element of the ring `r`, then `d` is less than or equal to `n`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a ring polynomial, `poly_deg r p <= n`, and `~(coeff d p = ring_0 r)`.
- Deduce that `~(p(x_monomial d) = ring_0(r:R ring))` using the assumption `~(coeff d p = ring_0 r)`.The hypothesis `~(coeff d p = ring_0 r)` is sufficient to derive the same for `x_monomial d`.
- Prove that `monomial_deg(x_monomial d) <= n` by applying `POLY_DEG_LE_EQ` to the assumption `poly_deg r p <= n`.
- Finally, conclude that `d <= n` by applying `x_monomial_deg` to the previous inequality, `monomial_deg(x_monomial d) <= n`.

### Mathematical insight
This theorem states that if the degree of a polynomial `p` is bounded by `n`, and the coefficient at index `d` is non-zero, then `d` must also be bounded by `n`. This is a fundamental property related to the degree of polynomials: any term with a non-zero coefficient must have a degree that is no larger than the polynomial's overall degree. This theorem connects the degree of a polynomial to the indices of its non-zero coefficients.

### Dependencies
- `ring_polynomial`
- `poly_deg`
- `coeff`
- `ring_0`
- `x_monomial`
- `monomial_deg`
- `POLY_DEG_LE_EQ`
- `x_monomial_deg`


---

## coeff_le_deg

### Name of formal statement
coeff_le_deg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_le_deg = prove(`
  !(r:R ring) p d.
  ring_polynomial r p ==>
  ~(coeff d p = ring_0 r) ==>
  d <= poly_deg r p
`,
  intro THEN
  num_linear_fact `poly_deg(r:R ring) (p:(1->num)->R) <= poly_deg r p` THEN
  qed[coeff_deg_le]
);;
```
### Informal statement
For any ring `r`, polynomial `p` over `r`, and natural number `d`, if `p` is a ring polynomial over `r` and the coefficient of `x^d` in `p` is not equal to the zero element of the ring `r`, then `d` is less than or equal to the degree of `p`.

### Informal sketch
The proof proceeds as follows:
- Introduction of assumptions.
- Apply `num_linear_fact` lemma `poly_deg(r:R ring) (p:(1->num)->R) <= poly_deg r p`.
- `qed` which uses the `coeff_deg_le` theorem to complete the proof.

### Mathematical insight
This theorem states a fundamental property of polynomials: if the coefficient of `x^d` in a polynomial `p` is non-zero, then the degree of polynomial `p` must be at least `d`. In other words, This guarantees that non-zero components contribute to the degree in polynomials.

### Dependencies
- Theorems:
  - `coeff_deg_le`


---

## finite_coeff

### Name of formal statement
finite_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_coeff = prove(`
  !(r:R ring) p.
  ring_polynomial r p ==>
  FINITE {d | ~(coeff d p = ring_0 r)}
`,
  intro THEN
  specialize[`poly_deg r (p:(1->num)->R)`]FINITE_NUMSEG_LE THEN
  have `!d. ~(coeff d p = ring_0 r) ==> d <= poly_deg (r:R ring) p` [coeff_le_deg] THEN
  set_fact `(!d. ~(coeff d p = ring_0 r) ==> d <= poly_deg (r:R ring) p) ==> {d | ~(coeff d p = ring_0 r)} SUBSET {d | d <= poly_deg (r:R ring) p}` THEN
  qed[FINITE_SUBSET]
);;
```
### Informal statement
For any ring `r` and any polynomial `p` over that ring, if `p` is a ring polynomial, then the set of degrees `d` for which the coefficient of `d` in `p` is not equal to the ring zero of `r` is finite.

### Informal sketch
The proof proceeds as follows:
- Introduce the ring `r` and polynomial `p`. Assume `p` is a ring polynomial via `intro`.
- Specialize the theorem `FINITE_NUMSEG_LE` with the degree of the polynomial `poly_deg r p`. This result states that the set of natural numbers less than or equal to `poly_deg r p` is finite.
- Prove that if the coefficient of degree `d` in polynomial `p` is not the ring zero of `r`, then `d` must be less than or equal to the degree of `p`. This is done using `coeff_le_deg`.
- Show that the set of degrees `d` for which `coeff d p` is not the ring zero is a subset of the set of natural numbers less than or equal to the degree of `p`.
- Finally, apply the theorem that any subset of a finite set is finite (`FINITE_SUBSET`) to conclude that the set of degrees whose coefficients are non-zero is finite.

### Mathematical insight
This theorem formalizes the intuition that a polynomial has finitely many non-zero coefficients. The finiteness of the set `{d | ~(coeff d p = ring_0 r)}` is essential for performing various operations and reasoning about polynomials in a well-defined manner.

### Dependencies
- `ring_polynomial`
- `ring_0`
- `coeff`
- `poly_deg`
- `FINITE_NUMSEG_LE`
- `coeff_le_deg`
- `FINITE_SUBSET`


---

## poly_if_coeff

### Name of formal statement
poly_if_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_if_coeff = prove(`
  !(r:R ring) p n.
  ring_powerseries r p ==>
  (!d. n <= d ==> coeff d p = ring_0 r) ==>
  ring_polynomial r p
`,
  intro THEN
  rw[ring_polynomial] THEN
  subgoal `{m | ~(p m = ring_0(r:R ring))} SUBSET IMAGE x_monomial (0..n)` THENL [
    rw[SUBSET;IN_IMAGE;IN_ELIM_THM] THEN
    intro THEN
    choose `d:num` `x_monomial d = x` [x_monomial_surjective] THEN
    witness `d:num` THEN
    case `n <= d:num` THENL [
      have `p(x_monomial d) = ring_0(r:R ring)` [coeff] THEN
      qed[]
    ; pass
    ] THEN
    num_linear_fact `~(n <= d:num) ==> d <= n` THEN
    have `d IN 0..n` [IN_NUMSEG_0] THEN
    qed[]
  ; pass
  ] THEN
  qed[FINITE_IMAGE;FINITE_SUBSET;FINITE_NUMSEG]
);;
```
### Informal statement
For any ring `r` and any powerseries `p` over `r`, if `p` is a powerseries over the ring `r` and for all `d`, if `n` is less than or equal to `d` implies that the coefficient of `d` in `p` is the zero element of the ring `r`, then `p` is a polynomial over the ring `r`.

### Informal sketch
The proof proceeds by showing that if the coefficients of the powerseries `p` are zero beyond a certain point `n`, then the set of monomials `x` such that `p(x)` is not zero is a subset of the image of the interval `0..n` under the `x_monomial` function, which maps a natural number `d` to the monomial `x^d`.

- Initially, assume the hypotheses hold: `p` is a powerseries, and for all `d`, `n <= d` implies `coeff d p = 0`. The goal is to show that `p` is a polynomial.
- This amounts to showing that the set of `x` such that `p x` is nonzero is a finite subset of the set of monomials.
- Consider an arbitrary `x` such that `p x` is not equal to zero. The goal then is to prove that `x` is of the form `x_monomial d` for some `d` in the range `0..n`.
- By `x_monomial_surjective`, there exists a `d` such that `x_monomial d = x`.
- Now consider two cases based on whether `n <= d` or not.
    - If `n <= d`, then `coeff d p = 0` by the assumption. Since `x = x_monomial d`, we would have `p x = p (x_monomial d) = 0`, giving a contradiction because `p x` is non-zero, so this case is impossible.
    - If it is not the case that `n <= d`, then `d <= n`. This means `d` is a natural number within the range `0..n`, as required.
- From there, apply theorems for *FINITE_IMAGE*, *FINITE_SUBSET*, *FINITE_NUMSEG* to conclude that the set is finite and thus `p` is polynomial.

### Mathematical insight
This theorem essentially states that a powerseries is a polynomial if its coefficients are zero beyond a certain degree. It links the notions of powerseries and polynomials by establishing a sufficient condition for a powerseries to be considered a polynomial. This is a fundamental result for relating the two constructs in the context of rings and their associated algebraic structures.

### Dependencies
- `ring_polynomial`
- `x_monomial_surjective`
- `SUBSET`
- `IN_IMAGE`
- `IN_ELIM_THM`
- `IN_NUMSEG_0`
- `FINITE_IMAGE`
- `FINITE_SUBSET`
- `FINITE_NUMSEG`

### Porting notes (optional)
- The `choose` tactic relies on the axiom of choice. If the target proof assistant does not have the axiom of choice, the user must provide an alternative means to extract the `d` from the surjectivity of `x_monomial`.
- The `num_linear_fact` tactic applies linear arithmetic reasoning over natural numbers, which may need to be implemented in the target proof assistant.


---

## deg_coeff_from_le

### Name of formal statement
deg_coeff_from_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_coeff_from_le = prove(`
  !(r:R ring) p n.
  ring_polynomial r p ==>
  poly_deg r p <= n ==>
  ~(coeff n p = ring_0 r) ==>
  poly_deg r p = n
`,
  intro THEN
  have `!d. ~(coeff d p = ring_0(r:R ring)) ==> d <= n` [coeff_le_deg;LE_TRANS] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  qed[deg_coeff]
);;
```
### Informal statement
For any ring `r`, polynomial `p` over `r`, and natural number `n`, if `p` is a polynomial over `r`, the degree of `p` is less than or equal to `n`, and the coefficient of `p` at `n` is not equal to the zero element of `r`, then the degree of `p` is equal to `n`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a polynomial and the degree of `p` is less than or equal to `n` and the `n`th coefficient of `p` is not zero.
- Show that for all `d`, if the coefficient of `p` at `d` is nonzero, then `d <= n`. This is done using `coeff_le_deg` to establish that if `~(coeff d p = ring_0 r)` then ` degree p <= n`, and then using transitivity of `<=`.
- Show that `p` is a ring power series (trivially true because it is a `ring_polynomial`).
- Use the theorem `deg_coeff`, which states that if `p` is a ring power series and for all `d`, if the coefficient of `p` at `d` is nonzero implies `d <= n`, then the degree of `p` is `n` if and only if the coefficient of `p` at `n` is not zero.

### Mathematical insight
This theorem establishes a convenient way to determine the exact degree of a polynomial. If we know that the degree is at most `n`, and that the coefficient at `n` is non-zero, then the precise degree must be `n`. This is a useful result when bounding polynomial degrees.

### Dependencies
- Theorems:
  - `coeff_le_deg`
  - `LE_TRANS`
  - `deg_coeff`
- Definitions:
  - `ring_polynomial`


---

## poly_eval_expand_coeff

### Name of formal statement
poly_eval_expand_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_eval_expand_coeff = prove(`
  !(r:R ring) p x n.
  ring_polynomial r p ==>
  x IN ring_carrier r ==>
  poly_deg r p <= n ==>
  poly_eval r p x
  = ring_sum r (0..n)
      (\d. ring_mul r (coeff d p) (ring_pow r x d))
`,
  intro THEN
  set_fact `ring_polynomial r p ==> p IN {q | ring_polynomial(r:R ring) (q:(1->num)->R)}` THEN
  have `(p:(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_carrier] THEN
  have `(p:(1->num)->R) IN ring_carrier(poly_ring r (:1))` [x_poly] THEN
  simp[POLY_EVAL_EXPAND] THEN
  simp[ring_sum_numseg_le_expand] THEN
  sufficesby RING_SUM_EQ THEN
  simp[GSYM coeff;GSYM x_monomial] THEN
  qed[RING_POW;RING_MUL_LZERO;coeff_le_deg]
);;
```

### Informal statement
For any ring `r`, polynomial `p` over `r`, element `x` in the carrier of `r`, and natural number `n`, if `p` is a polynomial over `r`, `x` is in the carrier of `r`, and the degree of `p` is less than or equal to `n`, then the evaluation of `p` at `x` in the ring `r` is equal to the ring sum from 0 to `n` of the terms obtained by multiplying the `d`th coefficient of `p` by `x` raised to the power of `d` in `r`.

### Informal sketch
The proof expands the polynomial evaluation `poly_eval r p x` into a summation using `POLY_EVAL_EXPAND`. Then the summation is expanded using `ring_sum_numseg_le_expand`. The goal is then reduced to showing that the evaluation can be expressed as `ring_sum r (0..n)(\d. ring_mul r (coeff d p) (ring_pow r x d))`. This is proved by simplifying the `ring_sum` and using `RING_SUM_EQ`. Finally, it uses the properties of `coeff`, `RING_POW`, `RING_MUL_LZERO`, and `coeff_le_deg` to complete the proof.

- It is first shown that `p` is in the carrier of the `x_poly r` ring and `poly_ring r (:1)` ring.
- The theorem `POLY_EVAL_EXPAND` is used to expand the polynomial evaluation.
- The theorem `ring_sum_numseg_le_expand` expands the limits of summation.
- The term is simplified using `GSYM coeff; GSYM x_monomial`.
- `RING_SUM_EQ` is used, then `RING_POW`, `RING_MUL_LZERO` and `coeff_le_deg` are used.

### Mathematical insight
This theorem expresses the evaluation of a polynomial as a summation of terms, each corresponding to a coefficient multiplied by a power of the variable `x`. This is the standard and expected way to compute polynomial evaluation, effectively implementing Horner's method. The representation emphasizes that the polynomial evaluation respects the ring operations.

### Dependencies
- `ring_polynomial`
- `ring_carrier`
- `poly_deg`
- `poly_eval`
- `ring_sum`
- `ring_mul`
- `ring_pow`
- `coeff`
- `POLY_EVAL_EXPAND`
- `ring_sum_numseg_le_expand`
- `RING_SUM_EQ`
- `x_monomial`
- `RING_POW`
- `RING_MUL_LZERO`
- `coeff_le_deg`
- `x_poly_carrier`
- `x_poly`
### Porting notes (optional)
- Ensure that the target proof assistant has a similar definition of polynomial evaluation and summation over a ring.
- The tactic `GSYM` is reversing the order of rewriting by a theorem, the target proof assistant would require the equivalent tactic or a direct reordering of rewriting steps.


---

## deg_mul_const_le

### Name of formal statement
deg_mul_const_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_mul_const_le = prove(`
  !(r:R ring) (p:(V->num)->R) c.
  ring_polynomial r p ==>
  c IN ring_carrier r ==>
  poly_deg r (poly_mul r p (poly_const r c))
  <= poly_deg r p
`,
  intro THEN
  have `ring_polynomial r (poly_const r c:(V->num)->R)` [RING_POLYNOMIAL_CONST] THEN
  have `poly_deg r (poly_const r c:(V->num)->R) = 0` [POLY_DEG_CONST] THEN
  specialize[`r:R ring`;`p:(V->num)->R`;`poly_const r c:(V->num)->R`]POLY_DEG_MUL_LE THEN
  num_linear_fact `poly_deg r (p:(V->num)->R) + 0 = poly_deg r (p:(V->num)->R)` THEN
  qed[]
);;
```

### Informal statement
For any ring `r` and any polynomial `p` over the ring `r`, if `c` is an element of the carrier of the ring `r`, then the degree of the polynomial resulting from the multiplication of `p` and the constant polynomial `c` in the ring `r` is less than or equal to the degree of `p`.

### Informal sketch
- Assume `r` is a ring, `p` is a polynomial over `r`, and `c` is an element of the carrier of `r`.
- Show that multiplying the polynomial `p` by the constant polynomial `c` does not increase the degree of `p`.
- First, establish that `poly_const r c` is a ring polynomial using `RING_POLYNOMIAL_CONST`.
- Next, prove that the degree of the constant polynomial `poly_const r c` is 0 using `POLY_DEG_CONST`.
- Specialize the theorem `POLY_DEG_MUL_LE` for `r`, `p`, and `poly_const r c` which tells us that `poly_deg r (poly_mul r p (poly_const r c)) <= poly_deg r p + poly_deg r (poly_const r c)`.
- Use the fact that `poly_deg r (poly_const r c) = 0` to simplify the right hand side to `poly_deg r p + 0`.
- Finally, simplify `poly_deg r p + 0` to `poly_deg r p` using `num_linear_fact`, concluding that `poly_deg r (poly_mul r p (poly_const r c)) <= poly_deg r p`.

### Mathematical insight
This theorem states that multiplying a polynomial by a constant cannot increase its degree. This is a fundamental property of polynomials and their degrees. The degree can only stay the same or decrease if the constant is zero, which would annihilate the leading term in the case of a non-zero polynomial. Otherwise, the degree stays the same.

### Dependencies
- `RING_POLYNOMIAL_CONST`
- `POLY_DEG_CONST`
- `POLY_DEG_MUL_LE`
- `ring_carrier`
- `ring_polynomial`
- `poly_deg`
- `poly_mul`
- `poly_const`
- `num_linear_fact`


---

## deg_const_mul_le

### Name of formal statement
deg_const_mul_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_const_mul_le = prove(`
  !(r:R ring) (p:(V->num)->R) c.
  ring_polynomial r p ==>
  c IN ring_carrier r ==>
  poly_deg r (poly_mul r (poly_const r c) p)
  <= poly_deg r p
`,
  qed[deg_mul_const_le;RING_POLYNOMIAL_CONST;ring_polynomial;POLY_MUL_SYM]
);;
```
### Informal statement
For any ring `r` with carrier `ring_carrier r`, any ring polynomial `p` over `r`, and any constant `c` in the carrier of `r`, the degree of the polynomial obtained by multiplying the constant polynomial `c` by `p` is less than or equal to the degree of `p`.

### Informal sketch
The proof demonstrates that multiplying a polynomial by a constant does not increase its degree.
- First, use `deg_mul_const_le` to establish that `poly_deg r (poly_mul r p (poly_const r c))` is less than or equal to `poly_deg r p`.
- Then, use `RING_POLYNOMIAL_CONST` to state `ring_polynomial r (poly_const r c)`.
- Finally, apply `POLY_MUL_SYM` with rewrite `ring_polynomial` to commute the order of multiplication `poly_mul r (poly_const r c) p`, which finishes the proof.

### Mathematical insight
This theorem states a fundamental property of polynomial degrees: multiplying a polynomial by a constant cannot increase its degree. In essence, multiplying by a constant can only scale the coefficients, but cannot introduce higher-order terms. This is a key property used in many polynomial manipulations.

### Dependencies
- Theorems: `deg_mul_const_le`, `POLY_MUL_SYM`
- Definitions: `ring_polynomial`, `RING_POLYNOMIAL_CONST`


---

## poly_mul_const_const

### Name of formal statement
poly_mul_const_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_const_const = prove(`
  !(r:R ring) (p:(V->num)->R) c d.
  ring_polynomial r p ==>
  c IN ring_carrier r ==>
  d IN ring_carrier r ==>
  poly_mul r (poly_mul r p (poly_const r c)) (poly_const r d)
  = poly_mul r p (poly_const r (ring_mul r c d))
`,
  qed[ring_polynomial;RING_POLYNOMIAL_CONST;POLY_MUL_ASSOC;POLY_CONST_MUL]
);;
```
### Informal statement
For any ring `r` with carrier set `ring_carrier r`, and for any polynomial `p` over `r` (i.e., `ring_polynomial r p`), and for any elements `c` and `d` in the carrier set of `r` (i.e., `c IN ring_carrier r` and `d IN ring_carrier r`), the polynomial multiplication of `p` multiplied by the constant polynomial `poly_const r c` multiplied by the constant polynomial `poly_const r d` is equal to the polynomial multiplication of `p` multiplied by the constant polynomial `poly_const r (ring_mul r c d)`, where `ring_mul r c d` denotes the multiplication of `c` and `d` in the ring `r`.

### Informal sketch
The proof establishes the associativity of polynomial multiplication with constant polynomials: `(p * c) * d = p * (c * d)`.
- The proof relies on the associativity of polynomial multiplication (`POLY_MUL_ASSOC`).
- It also uses the result `POLY_CONST_MUL`, which states that `(poly_const r c) * (poly_const r d) = poly_const r (ring_mul r c d)`.
- The theorem `ring_polynomial` ensures we are working with valid polynomials over the ring `r`.
- The theorem `RING_POLYNOMIAL_CONST` likely states that a constant is a ring polynomial.

### Mathematical insight
This theorem demonstrates that multiplying a polynomial by consecutive constant polynomials is equivalent to multiplying it by the constant polynomial that is the product of those constants within the underlying ring. This is a fundamental property for simplifying and manipulating polynomial expressions.

### Dependencies
- Definition: `ring_polynomial`
- Theorem: `RING_POLYNOMIAL_CONST`
- Theorem: `POLY_MUL_ASSOC`
- Theorem: `POLY_CONST_MUL`


---

## poly_mul_const_const_1

### Name of formal statement
poly_mul_const_const_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_const_const_1 = prove(`
  !(r:R ring) (p:(V->num)->R) c d.
  ring_polynomial r p ==>
  c IN ring_carrier r ==>
  d IN ring_carrier r ==>
  ring_mul r c d = ring_1 r ==>
  poly_mul r (poly_mul r p (poly_const r c)) (poly_const r d)
  = p
`,
  simp[poly_mul_const_const] THEN
  rw[GSYM poly_1] THEN
  intro THEN
  set_fact `ring_polynomial r (p:(V->num)->R) ==> p IN {q | ring_polynomial r q /\ poly_vars r q SUBSET (:V)}` THEN
  have `(p:(V->num)->R) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET (:V)}` [] THEN
  havetac `(p:(V->num)->R) IN ring_carrier(poly_ring r (:V))` (simp[POLY_RING_CLAUSES]) THEN
  qed[RING_MUL_RID;POLY_RING_CLAUSES]
);;
```
### Informal statement
For any ring `r` with carrier set `ring_carrier r`, ring multiplication operation `ring_mul r`, and multiplicative identity `ring_1 r`, and for any polynomial `p` over `r` with variables in `V`, and any constants `c` and `d` in the carrier of `r`, if `ring_mul r c d = ring_1 r`, then the polynomial obtained by multiplying `p` by the constant polynomial `c`, and then multiplying the result by the constant polynomial `d`, is equal to `p`.

### Informal sketch
The proof proceeds as follows:
- It starts by simplifying using the theorem `poly_mul_const_const`. After simplification, the goal is to prove `poly_mul r (poly_const r c) (poly_const r d) = poly_const r (ring_mul r c d)`.
- Then rewrite using `poly_1`, and the goal becomes to prove `ring_mul r c d = ring_1 r`
- By assumption `ring_mul r c d = ring_1 r`
- Introduce the assumption that `p` is a ring polynomial with variables in `V`.
- Use the fact that if `p` is a ring polynomial, then it is both a member of the carrier of the polynomial ring and its variables are a subset of `V`.
- Establish that p is an element of `ring_carrier(poly_ring r (:V))`.
- Finally, apply `RING_MUL_RID` and `POLY_RING_CLAUSES` to complete the proof.

### Mathematical insight
The theorem formalizes the idea that multiplying a polynomial by two constants whose product is the multiplicative identity has no effect on the polynomial. It leverages the properties of polynomial rings and the behavior of constants within those rings. This is a basic algebraic manipulation that is essential for simplifying and reasoning about polynomial expressions.

### Dependencies
- `ring_polynomial`
- `ring_carrier`
- `ring_mul`
- `ring_1`
- `poly_mul`
- `poly_const`
- `poly_mul_const_const`
- `POLY_RING_CLAUSES`
- `RING_MUL_RID`
- `POLY_RING_CLAUSES`
- `GSYM poly_1`

### Porting notes (optional)
This theorem relies on the definition of polynomial rings and associated operations such as multiplication and constants. Porting would require ensuring that the target proof assistant has equivalent definitions and theorems. The use of `simp` and `rw` tactics indicates simplification steps and rewriting with equalities, which will need equivalent tactics in the target system.


---

## deg_mul_const_const_1

### Name of formal statement
deg_mul_const_const_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_mul_const_const_1 = prove(`
  !(r:R ring) (p:(V->num)->R) c d.
  ring_polynomial r p ==>
  c IN ring_carrier r ==>
  d IN ring_carrier r ==>
  ring_mul r c d = ring_1 r ==>
  poly_deg r (poly_mul r p (poly_const r c))
  = poly_deg r p
`,
  intro THEN
  def `q:(V->num)->R` `poly_mul r (p:(V->num)->R) (poly_const r c)` THEN
  have `ring_polynomial r (q:(V->num)->R)` [RING_POLYNOMIAL_CONST;RING_POLYNOMIAL_MUL] THEN
  have `poly_deg r (q:(V->num)->R) <= poly_deg r (p:(V->num)->R)` [deg_mul_const_le] THEN
  have `(p:(V->num)->R) = poly_mul r q (poly_const r d)` [poly_mul_const_const_1] THEN
  have `poly_deg r (p:(V->num)->R) <= poly_deg r (q:(V->num)->R)` [deg_mul_const_le] THEN
  qed[ARITH_RULE `a <= b /\ b <= a ==> a = b:num`]
);;
```
### Informal statement
For all ring structures `r` of type `R ring`, and for all polynomials `p` from `V->num` to `R`, and for all elements `c` and `d` in the carrier of the ring `r`, if the ring multiplication of `c` and `d` in ring `r` equals the ring's multiplicative identity `1`, then the degree of the polynomial resulting from multiplying `p` by the constant polynomial `c` in ring `r` is equal to the degree of `p` in ring `r`.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent conditions: `r` is a ring, `p` is a polynomial, `c` and `d` are elements in the carrier of `r`, and `ring_mul r c d = ring_1 r`.
- Define `q` as the polynomial resulting from multiplying `p` with the constant polynomial `c` in ring `r`.
- Show that `q` is also a polynomial, using the fact that constant polynomials and products of polynomials are polynomials (`RING_POLYNOMIAL_CONST` and `RING_POLYNOMIAL_MUL`).
- Show that `poly_deg r q <= poly_deg r p` using `deg_mul_const_le`.
- Establish that `p` can be expressed as the product of `q` and the constant polynomial `d`, leveraging `poly_mul_const_const_1`.
- Show that `poly_deg r p <= poly_deg r q` using `deg_mul_const_le`.
- Conclude from `poly_deg r q <= poly_deg r p` and `poly_deg r p <= poly_deg r q` that `poly_deg r q = poly_deg r p` by applying an arithmetic rule (`ARITH_RULE`).
- Therefore, `poly_deg r (poly_mul r p (poly_const r c)) = poly_deg r p`.

### Mathematical insight
This theorem states that if the ring element `c` has a multiplicative inverse `d`, then multiplying a polynomial `p` by the constant polynomial `c` does not change the degree of `p`. This is crucial for reasoning about polynomial degrees in rings, as it tells us precisely when multiplying by a constant preserves the degree. It allows us to simplify expressions and draw conclusions about polynomial behavior.

### Dependencies
- Definitions: `ring_polynomial`, `poly_deg`, `ring_mul`, `poly_mul`, `poly_const`, `ring_carrier`, `ring_1`
- Theorems: `RING_POLYNOMIAL_CONST`, `RING_POLYNOMIAL_MUL`, `deg_mul_const_le`, `poly_mul_const_const_1`, `ARITH_RULE`


---

## deg_mul_unit_const

### Name of formal statement
deg_mul_unit_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_mul_unit_const = prove(`
  !(r:R ring) (p:(V->num)->R) c.
  ring_polynomial r p ==>
  ring_unit r c ==>
  poly_deg r (poly_mul r p (poly_const r c))
  = poly_deg r p
`,
  intro THEN
  choose `d:R` `d IN ring_carrier(r:R ring) /\ ring_mul r c d = ring_1 r` [ring_unit] THEN
  have `c IN ring_carrier(r:R ring)` [ring_unit] THEN
  qed[deg_mul_const_const_1]
);;
```
### Informal statement
For any ring `r` and any polynomial `p` over `r`, if `p` is a ring polynomial and `c` is a ring unit in `r`, then the degree of the polynomial resulting from multiplying `p` by the constant polynomial `c` is equal to the degree of `p`.

### Informal sketch
*   The proof starts by assuming the ring polynomial property of `p` and the ring unit property of `c`.
*   Then choose `d`, an element of the carrier of the ring `r` such that `ring_mul r c d = ring_1 r` (where `c` is a unit).
*   Then show that `c` is in the carrier of the ring `r`.
*   Finally, use the theorem `deg_mul_const_const_1` to conclude the proof.

### Mathematical insight
This theorem states that multiplying a polynomial by a constant unit element of the ring does not change the degree of the polynomial. A unit element is invertible, so multiplication by it is essentially a scaling operation that preserves the highest-degree term. This property is useful when simplifying polynomial expressions, especially when dealing with leading coefficients and polynomial division.

### Dependencies
- Theorems: `ring_unit`, `deg_mul_const_const_1`


---

## associates_if_mul_unit_const

### Name of formal statement
associates_if_mul_unit_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let associates_if_mul_unit_const = prove(`
  !(r:R ring) (p:(V->num)->R) c.
  ring_polynomial r p ==>
  ring_unit r c ==>
  ring_associates(poly_ring r (:V)) p (poly_mul r p (poly_const r c))
`,
  intro THEN
  rw[ring_associates;ring_divides] THEN
  intro THENL [
    qed[RING_POLYNOMIAL]
  ;
    qed[ring_unit;RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_CONST;RING_POLYNOMIAL]
  ;
    witness `poly_const r c:(V->num)->R` THEN
    have `c IN ring_carrier(r:R ring)` [ring_unit] THEN
    qed[RING_POLYNOMIAL_CONST;RING_POLYNOMIAL;POLY_CLAUSES]
  ;
    have `c IN ring_carrier(r:R ring)` [ring_unit] THEN
    qed[RING_POLYNOMIAL;POLY_CLAUSES;RING_POLYNOMIAL_CONST;RING_POLYNOMIAL_MUL]
  ;
    qed[POLY_CLAUSES;RING_POLYNOMIAL]
  ;
    witness `poly_const r (ring_inv r c):(V->num)->R` THEN
    have `c IN ring_carrier(r:R ring)` [ring_unit] THEN
    have `ring_inv r c IN ring_carrier(r:R ring)` [RING_INV] THEN
    intro THENL [
      qed[RING_POLYNOMIAL;RING_POLYNOMIAL_CONST]
    ;
      have `ring_mul r c (ring_inv r c) = ring_1(r:R ring)` [ring_div;ring_div_refl] THEN
      rw[GSYM POLY_CLAUSES] THEN
      qed[poly_mul_const_const_1]
    ]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any ring polynomial `p` over `r` of type `(V->num)->R`, and any constant `c` in `r`, if `c` is a ring unit in `r`, then `p` and the polynomial obtained by multiplying `p` by the constant polynomial `c` are ring associates in the polynomial ring over `r`.

### Informal sketch
The proof demonstrates that if a polynomial `p` is multiplied by a constant polynomial `c` where `c` is a unit in the ring, then the resulting polynomial is an associate of `p`. The proof relies on showing that `p` divides `poly_mul r p (poly_const r c)` and `poly_mul r p (poly_const r c)` divides `p`.

- First, establish that `p` divides `poly_mul r p (poly_const r c)`. This follows directly from the definition of `ring_divides`. It's shown that `p` is equal to `p` multiplied by the constant polynomial `ring_1 r`.
- Next, we need to show that `poly_mul r p (poly_const r c)` divides `p`. This is achieved by demonstrating that there exists a polynomial `q` such that `p = poly_mul r (poly_mul r p (poly_const r c)) q`. Let `q` be `poly_const r (ring_inv r c)`. Then show that `ring_mul r c (ring_inv r c) = ring_1 r`, implying `poly_mul r (poly_const r c) (poly_const r (ring_inv r c)) = poly_const r (ring_1 r)`. Finally, simplify the expression to show that `p = poly_mul r (poly_mul r p (poly_const r c)) (poly_const r (ring_inv r c))`.

### Mathematical insight
This theorem essentially states that multiplying a polynomial by a unit does not change its algebraic properties up to association. Ring associates share many important properties (e.g., roots, irreducibility in integral domains). This is important in polynomial ring theory.

### Dependencies
- `ring_associates`
- `ring_divides`
- `ring_polynomial`
- `ring_unit`
- `RING_POLYNOMIAL_MUL`
- `RING_POLYNOMIAL_CONST`
- `POLY_CLAUSES`
- `RING_INV`
- `ring_div`
- `ring_div_refl`
- `poly_mul_const_const_1`


---

## const_x_pow

### Name of formal statement
const_x_pow

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let const_x_pow = new_definition `
  const_x_pow (r:R ring) (c:R) (d:num)
  = \m. if m one = d then c else ring_0 r
`;;
```
### Informal statement
For any ring `R`, value `c` in `R`, and natural number `d`, `const_x_pow r c d` is defined as a function from natural numbers to `R`, such that for any natural number `m`, if `m` equals `d`, then the result is `c`; otherwise the result is the ring zero element in `R`.

### Informal sketch
The definition introduces a function that maps natural numbers to ring elements. The function `const_x_pow r c d` takes a ring `r`, a ring element `c`, and a natural number `d` as inputs. It returns a function that evaluates to `c` when its argument `m` is equal to `d` and to the ring zero element otherwise. The definition proceeds by directly constructing the function using a lambda abstraction and a conditional statement based on equality.

### Mathematical insight
This definition represents a function that is zero everywhere except at a single point `d`, where it takes the value `c`. This can be viewed as a monomial `c * x^d` where all the coefficients are zero except for the coefficient of `x^d`, which is `c`. This is a building block for representing polynomials in a formal setting.

### Dependencies
- ring: `ring_0`, `ring_1`
- num: `one`


---

## const_x_pow_0

### Name of formal statement
const_x_pow_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_x_pow_0 = prove(`
  !(r:R ring) c.
  const_x_pow r c 0 = poly_const r c
`,
  rw[const_x_pow;poly_const;monomial_1] THEN
  rw[FUN_EQ_THM] THEN
  qed[one]
);;
```
### Informal statement
For any ring `r` and any constant `c` in `r`, `const_x_pow r c 0` is equal to `poly_const r c`.

### Informal sketch
The proof proceeds by rewriting the left-hand side `const_x_pow r c 0` using the definitions of `const_x_pow`, `poly_const`, and `monomial_1`, and then applying functional equality to complete the proof with `one`.

- First, `const_x_pow r c 0` is rewritten using its definition.
- Second, `poly_const r c` is rewritten.
- Third, `monomial_1` is rewritten.
- Finally, functional equality (`FUN_EQ_THM`) is applied, and the remaining goal is proven by reflexivity.

### Mathematical insight
This theorem states that the polynomial constructed by `const_x_pow`, which represents the polynomial `c * x^0`, is equivalent to the polynomial constructed by `poly_const`, which directly creates a constant polynomial `c`. This is a fundamental property linking polynomial construction with constant coefficients.

### Dependencies
- Definitions: `const_x_pow`, `poly_const`, `monomial_1`
- Theorems: `FUN_EQ_THM`, `one`


---

## const_0_x_pow

### Name of formal statement
const_0_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_0_x_pow = prove(`
  !(r:R ring) n.
  const_x_pow r (ring_0 r) n = poly_0 r
`,
  rw[const_x_pow;poly_0;poly_const;FUN_EQ_THM;COND_ID]
);;
```
### Informal statement
For any ring `r` and any natural number `n`, the polynomial obtained by raising the constant polynomial `ring_0 r` to the power of `n` using the `const_x_pow` operation, is equal to the zero polynomial `poly_0 r`.

### Informal sketch
The theorem states that raising the constant polynomial `ring_0 r` to any power `n` results in the zero polynomial `poly_0 r`. The proof proceeds by rewriting the left-hand side of the equation `const_x_pow r (ring_0 r) n` using the definition of `const_x_pow`, which in turn makes use of rewriting with the definitions of `poly_0` and `poly_const`. Applying `FUN_EQ_THM` and `COND_ID` completes the proof.

### Mathematical insight
This theorem formalizes the basic algebraic fact that zero raised to any power is zero. In the context of polynomials, the constant zero polynomial is the additive identity, and raising it to any natural number power also yields the zero polynomial. This is a necessary property for polynomials to behave as expected under exponentiation.

### Dependencies
- Definitions: `const_x_pow`, `poly_0`, `poly_const`
- Theorems: `FUN_EQ_THM`, `COND_ID`


---

## const_x_pow_series

### Name of formal statement
const_x_pow_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_x_pow_series = prove(`
  !(r:R ring) c d.
  c IN ring_carrier r ==>
  ring_powerseries r (const_x_pow r c d)
`,
  intro THEN
  rw[const_x_pow;ring_powerseries] THEN
  qed[RING_0;FINITE_MONOMIAL_VARS_1;INFINITE]
);;
```

### Informal statement
For any ring `r` and elements `c` and `d` in `r`, if `c` is in the carrier of the ring `r`, then the power series `const_x_pow r c d` is a ring power series in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Assume that `c` is in the carrier of ring `r`.
- Rewrite the goal using the definitions of `const_x_pow` and `ring_powerseries`.
- The resulting proof obligations are discharged by appealing to the theorems `RING_0`, `FINITE_MONOMIAL_VARS_1`, and `INFINITE`.

### Mathematical insight
The theorem `const_x_pow_series` asserts that given a ring `r`, and two elements `c` and `d` of `r`, where `c` is an element of the ring's carrier, then the power series which has constant term `c` and coefficient `d` for the variable `X` raised to the power 1, and zero coefficients everywhere else, is indeed a valid power series over `r`. This is a basic but important result to ensure that constant and linear powerseries are well-formed.

### Dependencies
- Definitions: `const_x_pow`, `ring_powerseries`
- Theorems: `RING_0`, `FINITE_MONOMIAL_VARS_1`, `INFINITE`


---

## const_x_pow_poly_lemma

### Name of formal statement
const_x_pow_poly_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_x_pow_poly_lemma = prove(`
  !(r:R ring) d:num.
  {m:1->num | ~((if m one = d then c else ring_0 r) = ring_0 r)} SUBSET {\v. d}
`,
  rw[SUBSET;IN_ELIM_THM;IN_SING] THEN
  qed[ETA_ONE]
);;
```
### Informal statement
For any ring `r` and any natural number `d`, the set of all functions `m` from `{one}` to the natural numbers such that `m one` is not equal to `d` if `m one` equals `d` and `c` otherwise `ring_0 r`, is a subset of the set containing only `d`.

### Informal sketch
The proof shows that if `m` is a function from `{one}` to the natural numbers such that it is not the case that (`m one` is equal to `d` then `c` else `ring_0 r`) is equal to `ring_0 r`, then `m` is an element of the set `{v | v = d}`.  It uses rewriting with `SUBSET`, `IN_ELIM_THM` and `IN_SING` and eta reduction rule.

### Mathematical insight
This lemma seems to express a condition under which functions from a singleton `{one}` to naturals are contained within a singleton set `{d:num}`. It is related to properties of polynomials and constraints involving the ring's zero element.

### Dependencies
- Theorems: `SUBSET`, `IN_ELIM_THM`, `IN_SING`, `ETA_ONE`


---

## const_x_pow_poly_lemma2

### Name of formal statement
const_x_pow_poly_lemma2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_x_pow_poly_lemma2 = prove(`
  !(r:R ring) d:num.
  FINITE {m:1->num | ~((if m one = d then c else ring_0 r) = ring_0 r)}
`,
  qed[const_x_pow_poly_lemma;FINITE_SING;FINITE_SUBSET]
);;
```
### Informal statement
For any ring `r` and any natural number `d`, the set of functions from the singleton type `{1}` to natural numbers, `m`, such that `(if m one = d then c else ring_0 r)` is not equal to `ring_0 r`, is finite. Here, `c` is implicitly a term that depends on `m`, `r`, and `one`.

### Informal sketch
The proof proceeds by:
- Using lemma `const_x_pow_poly_lemma`, which likely establishes a connection between the polynomial and its constituents.
- Applying `FINITE_SING` to show that a singleton set is finite.
- Using `FINITE_SUBSET` to demonstrate that a subset of a finite set is also finite.

### Mathematical insight
The lemma states that within a ring structure, the set of functions that produce nonzero terms is finite. This is related to the finite nature of polynomials of a bounded degree. This result could be used to prove finiteness results about polynomials.

### Dependencies
- Theorems: `const_x_pow_poly_lemma`
- Theorems: `FINITE_SING`
- Theorems: `FINITE_SUBSET`


---

## const_x_pow_poly

### Name of formal statement
const_x_pow_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_x_pow_poly = prove(`
  !(r:R ring) c d.
  c IN ring_carrier r ==>
  ring_polynomial r (const_x_pow r c d)
`,
  intro THEN
  rw[ring_polynomial] THEN
  conjunction THENL [qed[const_x_pow_series]; pass] THEN
  rw[const_x_pow] THEN
  qed[const_x_pow_poly_lemma2]
);;
```
### Informal statement
For any ring `r` and elements `c` and `d` such that `c` is in the carrier of `r`, the polynomial `const_x_pow r c d` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds as follows:
- Intro: Introduce the ring `r` and elements `c` and `d`.
- Rewrite: Rewrite the goal using the definition of `ring_polynomial`.
- Split into two subgoals using conjunction.
  - Prove the first subgoal, which states `const_x_pow_series`.
  - Pass on the second subgoal (meaning we don't need to do anything with it).
- Rewrite: Rewrite using the definition of `const_x_pow`.
- Prove: Prove the final goal using lemma `const_x_pow_poly_lemma2`.

### Mathematical insight
This theorem states that `const_x_pow r c d`, which represents the polynomial term `c * x^d` over the ring `r`, is indeed a polynomial over `r`, which can be represented as a `series`. This is a fundamental result needed to build more complex polynomials.

### Dependencies
- Definitions: `ring_polynomial`, `const_x_pow`
- Theorems: `const_x_pow_series`, `const_x_pow_poly_lemma2`


---

## coeff_const_x_pow

### Name of formal statement
coeff_const_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_const_x_pow = prove(`
  !(r:R ring) c d e.
  coeff e (const_x_pow r c d)
  = if e = d then c else ring_0 r
`,
  rw[const_x_pow;coeff;x_monomial]
);;
```
### Informal statement
For any ring `r`, and for any `c` and `d` in the ring, the coefficient of `e` in the polynomial `const_x_pow r c d` is equal to `c` if `e` equals `d`, and equal to the ring zero `ring_0 r` otherwise.

### Informal sketch
The proof proceeds by rewriting using the definitions of `const_x_pow`, `coeff`, and `x_monomial`.

- First, `const_x_pow r c d` is rewritten to `c %: X**d`.
- Then, we use the definition of `coeff e (c %: X**d)`, which is `if e = d then c else ring_0 r`.
- The definitions of `coeff` and `x_monomial` are combined to calculate the coefficient of the monomial `X**d`.

### Mathematical insight
This theorem determines the coefficients of a polynomial of the form `c * x^d`. It states that the coefficient of the term `x^d` is `c`, and the coefficient of any other term `x^e` (where `e` is different from `d`) is zero. This is a basic but important result for working with polynomials in a formal setting.

### Dependencies
- Definitions: `const_x_pow`, `coeff`, `x_monomial`


---

## coeff_const_x_pow_times

### Name of formal statement
coeff_const_x_pow_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_const_x_pow_times = prove(`
  !(r:R ring) c d p e.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  coeff e (poly_mul r (const_x_pow r c d) p)
  = if e < d then ring_0 r else ring_mul r c (coeff (e - d) p)
`,
  rw[coeff_poly_mul_oneindex] THEN
  simp[coeff_const_x_pow] THEN
  simp[prove(`ring_powerseries r p ==> ring_mul (r:R ring) (if a:num = d then c else ring_0 r) (coeff (e - a) p) = if a = d then ring_mul r c (coeff (e - a) p) else ring_0 r`,qed[RING_MUL_LZERO;coeff_series_in_ring])] THEN
  rw[RING_SUM_DELTA] THEN
  intro THEN
  have `coeff (e - d) p IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  have `ring_mul r c (coeff (e - d) p) IN ring_carrier(r:R ring)` [RING_MUL] THEN
  set_fact_using `d IN (0..e) <=> d <= e` [NUMSEG_LE] THEN
  qed[ARITH_RULE `d:num <= e <=> ~(e < d)`]
);;
```
### Informal statement
For any ring `r`, any elements `c` and `d` in the carrier of `r`, any power series `p` over `r`, and any natural number `e`, if `c` is an element of the ring carrier of `r` and `p` is a powerseries over `r`, then the `e`-th coefficient of the powerseries which is the product of `const_x_pow r c d` and `p` is equal to `ring_0 r` if `e` is less than `d`, and is equal to `ring_mul r c (coeff (e - d) p)` if `e` is not less than `d`.

### Informal sketch
The proof proceeds by:
- Rewriting the left hand side using `coeff_poly_mul_oneindex`. This expresses the coefficient of the product as a sum.
- Simplifying using `coeff_const_x_pow`. This gives a conditional expression for the coefficients of `const_x_pow`.
- Simplifying using the fact that multiplying by zero yields zero, allowing us to remove the conditional statement within the summation.
- Rewriting using `RING_SUM_DELTA`. This selects the single term in the sum where `a = d`.
- Introducing the variables.
- Applying `coeff_series_in_ring` to show that `coeff (e - d) p` is in the ring carrier.
- Applying `RING_MUL` to derive that `ring_mul r c (coeff (e - d) p)` is in the ring carrier.
- Using `NUMSEG_LE` to rewrite `d IN (0..e)` as `d <= e`.
- Completing the proof by using `ARITH_RULE` to rewrite `d <= e` as the negation `~(e < d)`.

### Mathematical insight
This theorem shows how multiplication of a power series by a constant times a power of `x` affects the coefficients of the resulting power series. It is a key result for manipulating and reasoning about power series.

### Dependencies
- `coeff_poly_mul_oneindex`
- `coeff_const_x_pow`
- `RING_MUL_LZERO`
- `coeff_series_in_ring`
- `RING_SUM_DELTA`
- `RING_MUL`
- `NUMSEG_LE`
- `ARITH_RULE`


---

## deg_const_x_pow_le

### Name of formal statement
deg_const_x_pow_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_const_x_pow_le = prove(`
  !(r:R ring) c d.
  c IN ring_carrier r ==>
  poly_deg r (const_x_pow r c d) <= d
`,
  intro THEN
  have `ring_powerseries(r:R ring) (const_x_pow r c d)` [const_x_pow_series] THEN
  have `!e. ~(coeff e (const_x_pow(r:R ring) c d) = ring_0 r) ==> e <= d` [coeff_const_x_pow;ARITH_RULE `d <= d:num`] THEN
  qed[deg_le_coeff]
);;
```
### Informal statement
For any ring `r` and any elements `c` and natural number `d`, if `c` is an element of the carrier of the ring `r`, then the degree of the polynomial `const_x_pow r c d` is less than or equal to `d`.

### Informal sketch
- The proof starts by introducing the assumptions.
- It then utilizes the theorem `ring_powerseries` to show that `const_x_pow r c d` is a power series.
- It then utilizes the theorem `coeff_const_x_pow` to show that if a coefficient `e` of `const_x_pow r c d` is not equal to the zero element of the ring `r`, then `e` is less than or equal to `d`. It uses `ARITH_RULE` to show that `d <= d:num`.
- Finally, it applies the theorem `deg_le_coeff` to conclude that the degree of `const_x_pow r c d` is less than or equal to `d`.

### Mathematical insight
The theorem states that the degree of the polynomial `const_x_pow r c d` is less than or equal to `d`. The polynomial `const_x_pow r c d` represents `c * x^d`. Therefore, this theorem establishes an upper bound on the degree of the polynomial.

### Dependencies
- Theorems: `ring_powerseries`, `coeff_const_x_pow`, `deg_le_coeff`
- Definitions: `poly_deg`, `const_x_pow`, `ring_carrier`, `ring_0`
- Rules: `ARITH_RULE`


---

## deg_const_x_pow

### Name of formal statement
deg_const_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_const_x_pow = prove(`
  !(r:R ring) c d.
  c IN ring_carrier r ==>
  ~(c = ring_0 r) ==>
  poly_deg r (const_x_pow r c d) = d
`,
  intro THEN
  have `ring_powerseries(r:R ring) (const_x_pow r c d)` [const_x_pow_series] THEN
  have `!e. ~(coeff e (const_x_pow(r:R ring) c d) = ring_0 r) ==> e <= d` [coeff_const_x_pow;ARITH_RULE `d <= d:num`] THEN
  have `~(coeff d (const_x_pow r c d) = ring_0(r:R ring))` [coeff_const_x_pow] THEN
  qed[deg_coeff]
);;
```

### Informal statement
For all rings `r` and all elements `c` and natural numbers `d`, if `c` is in the carrier of the ring `r` and `c` is not equal to the zero element of `r`, then the degree of the polynomial `const_x_pow r c d` is equal to `d`.

### Informal sketch
The proof proceeds as follows:
- Introduce the quantified variables `r`, `c`, and `d`.
- Show that `const_x_pow r c d` is a ring power series, using `const_x_pow_series`.
- Establish that if the coefficient `e` of `const_x_pow r c d` is not equal to the zero element of the ring `r`, then `e` is less than or equal to `d`. This uses `coeff_const_x_pow` and arithmetic reasoning.
- Show that the coefficient `d` of `const_x_pow r c d` is not equal to the zero element of `r`. This again uses `coeff_const_x_pow`.
- Conclude that the degree of `const_x_pow r c d` is equal to `d`, using `deg_coeff`.

### Mathematical insight
This theorem states that the degree of the polynomial `c * x^d` is `d` if `c` is a non-zero element of the ring. It formalizes a basic property of polynomials.

### Dependencies
- `const_x_pow_series`
- `coeff_const_x_pow`
- `deg_coeff`


---

## eval_const_x_pow

### Name of formal statement
eval_const_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_const_x_pow = prove(`
  !(r:R ring) c n x.
  c IN ring_carrier r ==>
  x IN ring_carrier r ==>
  poly_eval r (const_x_pow r c n) x
  = ring_mul r c (ring_pow r x n)
`,
  intro THEN
  have `ring_polynomial(r:R ring) (const_x_pow r c n)` [const_x_pow_poly] THEN
  have `poly_deg(r:R ring) (const_x_pow r c n) <= n` [deg_const_x_pow_le] THEN
  specialize[`r:R ring`;`const_x_pow(r:R ring) c n`;`x:R`;`n:num`]poly_eval_expand_coeff THEN
  simp[coeff_const_x_pow] THEN
  specialize[`r:R ring`;`0..n`;`n:num`;`ring_mul(r:R ring) c (ring_pow r x a)`]RING_SUM_DELTA THEN
  have `!a. a IN (0..n) ==> ring_mul(r:R ring) (if a = n then c else ring_0 r) (ring_pow r x a) = if a = n then ring_mul r c (ring_pow r x a) else ring_0 r` [RING_MUL_LZERO;RING_POW] THEN
  specialize[`r:R ring`;`\a. ring_mul(r:R ring) (if a = n then c else ring_0 r) (ring_pow r x a)`;`\a. if a = n then ring_mul r c (ring_pow r x a) else ring_0(r:R ring)`;`0..n`]RING_SUM_EQ THEN
  have `n IN 0..n` [IN_NUMSEG_0;ARITH_RULE `n <= n:num`] THEN
  simp[] THEN
  qed[RING_MUL;RING_POW]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any `c` and `x` in the carrier of `r`, and any natural number `n`, the evaluation of the polynomial `const_x_pow r c n` at `x` is equal to `c` multiplied by `x` raised to the power of `n`, where all operations are performed within the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions `r`, `c`, `n`, and `x`, as well as the membership conditions `c IN ring_carrier r` and `x IN ring_carrier r`.
- Prove that `const_x_pow r c n` is a ring polynomial using `const_x_pow_poly`.
- Prove that the degree of `const_x_pow r c n` is less than or equal to `n` using `deg_const_x_pow_le`.
- Expand the polynomial evaluation using `poly_eval_expand_coeff`.
- Simplify using `coeff_const_x_pow`: The coefficients of `const_x_pow r c n` are zero except for the coefficient of `x^n`, which is `c`.
- Apply `RING_SUM_DELTA` to isolate the `n`-th term in the sum. Specifically, `RING_SUM_DELTA` rewrites the ring sum into a conditional expression based on the equality `a = n`.
- Prove that if `a` is in the range `0..n`, then `ring_mul(r:R ring) (if a = n then c else ring_0 r) (ring_pow r x a) = if a = n then ring_mul r c (ring_pow r x a) else ring_0 r` using `RING_MUL_LZERO` and `RING_POW`.
- Use `RING_SUM_EQ` to move the conditional outside of the sum.
- Show `n IN 0..n`.
- Simplify using `RING_MUL` and `RING_POW` to complete the proof.

### Mathematical insight
The theorem `eval_const_x_pow` provides a direct way to evaluate a simple polynomial of the form `c * x^n` within a ring `r`. It demonstrates how polynomial evaluation interacts with the ring's multiplicative and power operations, and reduces polynomial evaluation to scalar multiplication and exponentiation. This result is a fundamental connection between polynomial algebra and ring theory.

### Dependencies
- `const_x_pow_poly`
- `deg_const_x_pow_le`
- `poly_eval_expand_coeff`
- `coeff_const_x_pow`
- `RING_SUM_DELTA`
- `RING_MUL_LZERO`
- `RING_POW`
- `RING_SUM_EQ`
- `IN_NUMSEG_0`
- `ARITH_RULE`
- `RING_MUL`


---

## subring_const_x_pow

### Name of formal statement
subring_const_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_const_x_pow = prove(`
  !(r:R ring) S c n.
  const_x_pow (subring_generated r S) c n
  = const_x_pow r c n
`,
  rw[const_x_pow] THEN
  rw[SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r`, any subring `S` of `r`, any `c`, and any natural number `n`, the polynomial `const_x_pow` over the subring generated by `S` with coefficient `c` and degree `n` is equal to the polynomial `const_x_pow` over the ring `r` with coefficient `c` and degree `n`.

### Informal sketch
- The proof proceeds by rewriting the left-hand side using the definition of `const_x_pow`.
- Then, the definition of `SUBRING_GENERATED` is unfolded to expose the equivalence between the definitions.

### Mathematical insight
This theorem states that forming a `const_x_pow` polynomial with a constant coefficient *c* and degree *n* over the subring generated by a set *S* is equivalent to forming the same polynomial over the parent ring. This makes intuitive sense because the subring generated by *S* is still a ring, and the `const_x_pow` construction only depends on the ring structure itself.

### Dependencies
- Definitions: `const_x_pow`, `SUBRING_GENERATED`
- Theorems: `const_x_pow`


---

## const_1_x_pow

### Name of formal statement
const_1_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let const_1_x_pow = prove(`
  !(r:R ring).
  const_x_pow r (ring_1 r) 0 = poly_1 r
`,
  intro THEN
  sufficesby eq_coeff THEN
  rw[coeff_const_x_pow;coeff_poly_1]
);;
```
### Informal statement
For any ring `r` of type `R ring`, the polynomial obtained by multiplying the constant polynomial `poly_1 r` (representing the multiplicative identity in the ring `r`) with the formal power series `const_x_pow r` (representing x raised to the power of 0), is equal to the constant polynomial `poly_1 r`.

### Informal sketch
The proof proceeds by:
- Introducing the variable `r` representing a ring.
- Showing that it suffices to prove the equality by demonstrating that the coefficients of the two polynomials are equal.
- Rewriting using the definition of `coeff_const_x_pow` and `coeff_poly_1` to show that the coefficients are indeed equal.

### Mathematical insight
This theorem formalizes the basic polynomial identity that $1 \cdot x^0 = 1$ in the context of formal power series over a ring. The formal power series `const_x_pow r` represents a monomial, and multiplying by 1 does not change this monomial's value. The identity is fundamental for reasoning algebraically with polynomials.

### Dependencies
- Definitions:
  - `ring_1`
  - `const_x_pow`
  - `poly_1`
  - `coeff_const_x_pow`
  - `coeff_poly_1`

### Porting notes (optional)
- The definitions of `ring_1`, `const_x_pow`, and `poly_1` will be required, along with the corresponding properties of their coefficients, when porting this theorem. Make sure that the coefficient functions (`coeff_const_x_pow` and `coeff_poly_1`) are properly defined to reflect the intended mathematical semantics.


---

## x_pow

### Name of formal statement
x_pow

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let x_pow = new_definition `
  x_pow (r:R ring) (d:num)
  = const_x_pow r (ring_1 r) d
`;;
```

### Informal statement
For any ring `r` and natural number `d`, `x_pow r d` is defined to be `const_x_pow r (ring_1 r) d`.

### Informal sketch
The definition introduces `x_pow`, exponentiation for ring elements raised to a natural number power.
- The definition relies on the `const_x_pow` function, which presumably implements the repeated multiplication.
- The ring's multiplicative identity `ring_1 r` serves as a starting value for the repeated multiplications.

### Mathematical insight
The definition `x_pow r d = const_x_pow r (ring_1 r) d` defines exponentiation of an element `r` in a ring to a natural number `d`, i.e., `r^d`. It uses an auxiliary function `const_x_pow` that likely implements the algorithm for computing the power by repeated multiplication. Starting from the ring's multiplicative identity `ring_1 r`, one computes `r^d` by multiplying identity by `r` repeatedly, `d` times.

### Dependencies
- Definition: `const_x_pow`
- Definition: `ring_1`


---

## x_pow_1

### Name of formal statement
x_pow_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_1 = prove(`
  !(r:R ring).
  x_pow r 1 = poly_var r one
`,
  rw[x_pow;const_x_pow;poly_var;monomial_var;FUN_EQ_THM] THEN
  qed[ETA_ONE;one]
);;
```

### Informal statement
For any ring `R` and any element `r` of `R`, `x_pow r 1` equals `poly_var r one`.

### Informal sketch
The proof proceeds by rewriting the left-hand side of the equation using the definitions of `x_pow`, `const_x_pow`, `poly_var` and `monomial_var`. Then, the goal `!f. (fun x. f x) = f` is rewritten. Finally, the goal `1 = 1` is proven.

- The definition of `x_pow` is applied.
- Reduce `const_x_pow`.
- Reduce `poly_var` with `monomial_var`.
- The goal simplifies to proving equality of two functions, so `FUN_EQ_THM` is used to reduce to proving equality of function applications.
- Simplify `ETA_ONE`.
- Prove `one = one`.

### Mathematical insight
This theorem states that the first power of a variable `x` represented as a polynomial (`x_pow r 1`) is equal to the polynomial variable `x`, which is represented by `poly_var r one`, where `one` is the coefficient of the linear term. This aligns with the intuitive understanding of polynomials.

### Dependencies
- `x_pow`
- `const_x_pow`
- `poly_var`
- `monomial_var`
- `FUN_EQ_THM`
- `ETA_ONE`
- `one`

### Porting notes (optional)
- The main challenge in porting this theorem lies in ensuring that the definitions of `x_pow`, `poly_var`, and `monomial_var` are consistent with HOL Light's.
- The `FUN_EQ_THM` tactic is used implicitly, which might need to be made explicit in other proof assistants.


---

## x_pow_0

### Name of formal statement
x_pow_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_0 = prove(`
  !(r:R ring).
  x_pow r 0 = poly_1 r
`,
  rw[x_pow;const_x_pow_0;poly_1]
);;
```
### Informal statement
For all rings `r` of type `R`, `x_pow r 0` is equal to `poly_1 r`.

### Informal sketch
The proof involves rewriting the statement using the definition of `x_pow`, then applying `const_x_pow_0`, and finally using the definition of `poly_1`.
- First, the definition of `x_pow` is applied.
- Then, `const_x_pow_0` is used to reduce `x_pow r 0` to `&1`.
- Finally, the definition of `poly_1` is used which states that `poly_1 r` is equal to `&1`.

### Mathematical insight
This theorem formalizes that for any ring `r`, raising `x` to the power of 0 results in a constant polynomial equal to 1.

### Dependencies
- Definitions: `x_pow`, `poly_1`
- Theorems: `const_x_pow_0`


---

## x_pow_poly

### Name of formal statement
x_pow_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_poly = prove(`
  !(r:R ring) d.
  ring_polynomial r (x_pow r d)
`,
  qed[x_pow;const_x_pow_poly;RING_1]
);;
```

### Informal statement
For all rings `r` and all natural numbers `d`, the function `x_pow r d` generates a ring polynomial in `r`.

### Informal sketch
The proof shows that `x_pow r d` is a ring polynomial. The proof proceeds by induction on `d`.
- Base case (`d = 0`): The term `x_pow r 0` simplifies to `RING_1 r`, which is a ring polynomial by the theorem `const_x_pow_poly`.
- Inductive step: Assume `x_pow r d` is a ring polynomial, and prove that `x_pow r (SUC d)` is a ring polynomial. From the definition of `x_pow`, `x_pow r (SUC d)` is equal to `&1 * x_pow r d`, so the goal follows.

### Mathematical insight
This theorem establishes that the function `x_pow` (which represents exponentiation by natural numbers in a ring) produces ring polynomials. This is a crucial step in developing the theory of polynomials over rings. This result is non-trivial, as not every function necessarily generates a ring polynomial.

### Dependencies
- Definitions: `x_pow`
- Theorems: `const_x_pow_poly`, `RING_1`


---

## x_pow_series

### Name of formal statement
x_pow_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_series = prove(`
  !(r:R ring) d.
  ring_powerseries r (x_pow r d)
`,
  qed[ring_polynomial;x_pow_poly]
);;
```
### Informal statement
For any ring `r` and any function `d` from natural numbers to the carrier of `r`, the powerseries `x_pow r d` is a ring powerseries over the ring `r`.

### Informal sketch
The proof establishes that `x_pow r d` satisfies the defining properties of a ring powerseries. It leverages the fact that ring polynomials are ring powerseries (`ring_polynomial`) and the definition of `x_pow` in terms of `x_pow_poly`.

- The goal is `ring_powerseries r (x_pow r d)`.
- The theorem `ring_polynomial` states that any ring polynomial is a ring powerseries.
- `x_pow r d` is defined via `x_pow_poly` as the sequence of coefficients of a polynomial.
- Thus, using `x_pow_poly` and `ring_polynomial` proves `x_pow_series`.

### Mathematical insight
This theorem confirms that the construction `x_pow` yields a valid powerseries representation within the formalization. It's an important step in building the theory of power series over rings by showing that specific constructions (polynomials) give rise to valid powerseries.

### Dependencies
- Theorems: `ring_polynomial`
- Definitions: `x_pow_poly`


---

## coeff_x_pow

### Name of formal statement
coeff_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_pow = prove(`
  !(r:R ring) d e.
  coeff e (x_pow r d)
  = if e = d then ring_1 r else ring_0 r
`,
  rw[x_pow;coeff_const_x_pow]
);;
```
### Informal statement
For any ring `r`, and for any natural numbers `d` and `e`, the coefficient of `x` to the power of `e` in the polynomial `x` to the power of `d` (in the ring `r`) is equal to the multiplicative identity of the ring `r` if `e` is equal to `d`, and it is equal to the additive identity of the ring `r` if `e` is not equal to `d`.

### Informal sketch
- The proof proceeds by rewriting using the definition of `x_pow` and `coeff_const_x_pow`. 
- `x_pow r d` is defined as the polynomial representing `x^d` in the ring `r`.
- The theorem `coeff_const_x_pow` likely handles the generic case of coefficients of constant multiples of powers of `x`.

### Mathematical insight
This theorem formalizes the basic fact that the polynomial `x^d` has a coefficient of 1 for the term `x^d` and a coefficient of 0 for all other terms `x^e` where `e` is different from `d`. It connects the algebraic notion of polynomial representation with coefficients.

### Dependencies
- Definitions: `x_pow`
- Theorems: `coeff_const_x_pow`


---

## coeff_x_pow_times

### Name of formal statement
coeff_x_pow_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_pow_times = prove(`
  !(r:R ring) d p e.
  ring_powerseries r p ==>
  coeff e (poly_mul r (x_pow r d) p)
  = if e < d then ring_0 r else coeff (e - d) p
`,
  intro THEN
  have `ring_1 r IN ring_carrier(r:R ring)` [RING_1] THEN
  rw[x_pow] THEN
  qed[coeff_const_x_pow_times;RING_MUL_LID;coeff_series_in_ring]
);;
```
### Informal statement
For any ring `r`, any natural number `d`, and any power series `p` over `r`, if `p` is a ring power series, then the `e`-th coefficient of the power series resulting from multiplying the power series represented by `x` raised to the power of `d` with the power series `p` is equal to the ring's zero element if `e` is less than `d`; otherwise, it is equal to the `(e - d)`-th coefficient of `p`.

### Informal sketch
The theorem states a property about the coefficients of power series. The proof proceeds as follows:
- Introduce the assumptions.
- Show that the ring's multiplicative identity `ring_1 r` is in the ring's carrier set `ring_carrier(r:R ring)`.
- Rewrite `x_pow r d` to its definition using `rw[x_pow]`.
- Apply the theorems `coeff_const_x_pow_times`, `RING_MUL_LID`, and `coeff_series_in_ring` to complete the proof.

### Mathematical insight
The theorem describes how multiplying a power series by `x^d` affects the coefficients. It essentially shifts the coefficients of the original power series, so the coefficient of `x^e` in the resulting power series is the coefficient of `x^(e-d)` in the original power series if `e >= d`, and 0 otherwise.

### Dependencies
- Theorems:
  - `coeff_const_x_pow_times`
  - `RING_MUL_LID`
  - `coeff_series_in_ring`
- Definitions:
  - `x_pow`
  - `poly_mul`
  - `ring_powerseries`
  - `coeff`
  - `ring_0`
  - `R ring`
  - `ring_1`

### Porting notes (optional)
- The most challenging aspect of porting this theorem might be ensuring that the definitions of power series, coefficients, and multiplication are consistent with the target proof assistant. The rewriting rules involving `coeff_*` lemmas are crucial and need to be carefully adapted or re-proven in the new environment.
- It would be very helpful to have a library for dealing with rings and power series already available.


---

## x_pow_add

### Name of formal statement
x_pow_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_add = prove(`
  !(r:R ring) m n.
  x_pow r (m+n)
  = poly_mul r (x_pow r m) (x_pow r n)
`,
  intro THEN
  sufficesby eq_coeff THEN
  simp[coeff_x_pow_times;x_pow_series] THEN
  rw[coeff_x_pow] THEN
  qed[ARITH_RULE `d = m + n <=> (~(d < m) /\ d - m = n:num)`]
);;
```
### Informal statement
For any ring `r` and any natural numbers `m` and `n`, `x_pow r (m+n)` is equal to `poly_mul r (x_pow r m) (x_pow r n)`.

### Informal sketch
The proof proceeds by induction on the coefficients, relying on the equality of coefficients.
- First, introduce the assumptions.
- It suffices to show that the coefficients are equal.
- Simplify using `coeff_x_pow_times` and `x_pow_series`.
- Rewrite using `coeff_x_pow`.
- Apply an arithmetic rule to prove `d = m + n <=> (~(d < m) /\ d - m = n)`.

### Mathematical insight
This theorem establishes the property that multiplying polynomials `x^m` and `x^n` (where polynomial multiplication is performed using the ring `r`'s operations) results in the polynomial `x^(m+n)`. This is a fundamental property of polynomials and exponentiation. This is an important result regarding the behavior of formal power series represented as polynomials.

### Dependencies
- Definitions: `x_pow`, `poly_mul`
- Theorems: `coeff_x_pow_times`, `x_pow_series`, `coeff_x_pow`
- Rules: `ARITH_RULE`


---

## deg_x_pow_le

### Name of formal statement
deg_x_pow_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_pow_le = prove(`
  !(r:R ring) d.
  poly_deg r (x_pow r d) <= d
`,
  qed[x_pow;deg_const_x_pow_le;RING_1]
);;
```
### Informal statement
For any ring `r` of type `R` and any natural number `d`, the degree of the polynomial `x_pow r d` is less than or equal to `d`.  Here, `x_pow r d` denotes the polynomial representation of x to the power of d in the ring `r`.

### Informal sketch
The proof proceeds by induction on `d`.

- **Base Case (d = 0):** We need to show that `poly_deg r (x_pow r 0) <= 0`.  Since `x_pow r 0` is the constant polynomial `RING_1 r`, its degree is 0. The theorem `deg_const_x_pow_le` addresses the base case.
- **Inductive Step:** Assume `poly_deg r (x_pow r d) <= d`. We need to show that `poly_deg r (x_pow r (SUC d)) <= SUC d`. The term `x_pow r (SUC d)` is equivalent to `x * x_pow r d`. The theorem `x_pow` is used to decompose `x_pow r (SUC d)` as `x_pow r d * x r`. Then, from the inductive hypothesis and the properties of polynomial degrees, the degree of `x_pow r (SUC d)` can be shown to be less than or equal to `SUC d`.

The tactic `prove` in HOL Light manages this proof structure.

### Mathematical insight
This theorem establishes a fundamental property of the degree of polynomials. It asserts that raising `x` to the power of `d` in a ring yields a polynomial whose degree is at most `d`. This is a key result when reasoning about polynomial manipulations and their degrees. Because `x_pow r d` produces a sparse representation of polynomials (i.e., `X^d`), the degree of the polynomial is exactly `d` but this is not required in the statement.

### Dependencies
- `x_pow`
- `deg_const_x_pow_le`
- `RING_1`


---

## deg_x_pow

### Name of formal statement
deg_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_pow = prove(`
  !(r:R ring) d.
  ~(ring_1 r = ring_0 r) ==>
  poly_deg r (x_pow r d) = d
`,
  simp[x_pow;deg_const_x_pow;RING_1]
);;
```
### Informal statement
For any ring `r` such that the ring identity `ring_1 r` is not equal to the ring zero `ring_0 r`, the degree of the polynomial `x_pow r d` is `d`. Here `x_pow r d` represents the monomial x to the power of `d` in ring `r`.

### Informal sketch
The proof proceeds by simplification using the following steps:

- Simplify using the definition of `x_pow`.
- Simplify using the theorem `deg_const_x_pow`, which provides a way to compute the degree of a constant multiple of `x_pow`.
- Simplify using the property `RING_1` which likely refers to ring axioms or simplifications related to the multiplicative identity.

The proof relies on showing that the leading coefficient of `x_pow r d` is the ring identity `ring_1 r`, and that it does not equal the ring zero `ring_0 r` based on the assumption `~(ring_1 r = ring_0 r)`.

### Mathematical insight
This theorem formalizes the intuitive notion that the degree of the monomial `x^d` is simply `d`, provided that the ring is non-trivial. The condition `~(ring_1 r = ring_0 r)` ensures that we are not dealing with the trivial ring where 0 = 1, which would invalidate the degree calculation.

### Dependencies
- Definitions: `x_pow`
- Theorems: `deg_const_x_pow`, `RING_1`


---

## eval_x_pow

### Name of formal statement
eval_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_x_pow = prove(`
  !(r:R ring) n x.
  x IN ring_carrier r ==>
  poly_eval r (x_pow r n) x
  = ring_pow r x n
`,
  intro THEN
  rw[x_pow] THEN
  have `ring_1(r:R ring) IN ring_carrier r` [RING_1] THEN
  simp[eval_const_x_pow] THEN
  qed[RING_POW;RING_MUL_LID]
);;
```
### Informal statement
For any ring `r` and any natural number `n`, for all `x`, if `x` is in the carrier of ring `r`, then evaluating the polynomial `x_pow r n` at `x` using the ring `r` equals the `n`-th power of `x` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions: `r`, `n`, and `x` such that `x` belongs to the carrier of the ring `r`.
- Rewrite using the definition of `x_pow`.
- Establish that `ring_1 r` is in the carrier of `r` based on the properties of rings.
- Simplify using the definition `eval_const_x_pow`.
- Apply `RING_POW` to handle the power operation and `RING_MUL_LID` to handle the multiplicative identity.

### Mathematical insight
This theorem establishes the equivalence between evaluating the polynomial representation of `x^n` at the value `x` and directly computing `x^n` using the ring's power operation. It essentially verifies that the polynomial representation built using `x_pow` correctly represents exponentiation within the ring. This is important for relating polynomial operations to ring operations.

### Dependencies
- Definitions:
    - `x_pow`
    - `poly_eval`
    - `ring_pow`
    - `ring_carrier`
    - `ring_1`

- Theorems:
    - `RING_POW`
    - `RING_MUL_LID`
    - `eval_const_x_pow`


---

## subring_x_pow

### Name of formal statement
subring_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) S n.
  x_pow (subring_generated r S) n
  = x_pow r n
```

### Informal statement
For any ring `r`, any subset `S` of the carrier of `r`, and any natural number `n`, the `n`-th power function applied to the subring generated by `S` with respect to the ring `r` is equal to the `n`-th power function applied to the ring `r`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `x_pow`, `const_x_pow` and `SUBRING_GENERATED`.
- The definition of `x_pow` is unfolded.
- The definition of `const_x_pow` is then applied.
- Finally, the definition of `SUBRING_GENERATED` is expanded.

### Mathematical insight
This theorem states that the power function defined on a ring is inherited by any subring generated from it, maintaining consistency in the result. The subring generated from a set `S` will have the same power function as the original ring because the generated subring resides inside the original ring. This basically means that the power operation is preserved down to the generated subring.

### Dependencies
- Definitions:
  - `x_pow`
  - `const_x_pow`
  - `SUBRING_GENERATED`


---

## x_minus_const

### Name of formal statement
x_minus_const

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let x_minus_const = new_definition `
  x_minus_const (r:R ring) (c:R)
  = poly_sub r (x_pow r 1) (poly_const r c)
`;;
```

### Informal statement
For any ring `r` and element `c` of the ring `R`, `x_minus_const r c` is defined to be the polynomial subtraction of `x_pow r 1` (which represents the polynomial x) and `poly_const r c` (which represents the constant polynomial c).

### Informal sketch
The definition introduces a function `x_minus_const` that constructs a polynomial representing 'x - c' where 'x' is represented by `x_pow r 1` (i.e., x to the power of 1, which gives x) and 'c' by `poly_const r c` (i.e., a constant polynomial with value c). The function leverages `poly_sub` to perform polynomial subtraction.

*   The definition constructs the polynomial "x - c" in the ring `r`.
*   It uses the existing functions `x_pow`, `poly_const`, and `poly_sub` from the polynomial library.
*   `x_pow r 1` is 'x' as a polynomial, and `poly_const r c` is the constant polynomial 'c'.
*   `poly_sub r (x_pow r 1) (poly_const r c)` then subtracts the constant polynomial 'c' from the polynomial 'x', resulting in the polynomial 'x - c'.

### Mathematical insight
This definition provides a convenient shorthand for representing the simple polynomial "x - c" within the formal system.

### Dependencies
- `R` (Type representing a ring)
- `x_pow`
- `poly_const`
- `poly_sub`


---

## x_minus_const_poly

### Name of formal statement
x_minus_const_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_minus_const_poly = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ring_polynomial r (x_minus_const r c)
`,
  qed[x_minus_const;RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_CONST;x_pow_poly]
);;
```
### Informal statement
For any ring `r` and any element `c` in the carrier of the ring `r`, the polynomial `x_minus_const r c` is a ring polynomial over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Start with the definition of `x_minus_const r c`, which is `SUB r (x r) (CONST r c)`.
- Use `RING_POLYNOMIAL_SUB` to show that if `x r` and `CONST r c` are ring polynomials over `r`, then their difference `SUB r (x r) (CONST r c)` is also a ring polynomial over `r`.
- Use `RING_POLYNOMIAL_CONST` to show `CONST r c` is a ring polynomial given that `c` is in the ring carrier.
- Finally, use `x_pow_poly` to prove `x r` is a ring polynomial.
- Combine the above results to conclude that `x_minus_const r c` is a ring polynomial over `r`.

### Mathematical insight
The theorem establishes that the polynomial `x - c`, constructed using the ring operations of `r`, is indeed a ring polynomial over `r`. This is a fundamental result needed when dealing with polynomial rings and their properties, such as polynomial factorization. The function `x_minus_const` constructs the polynomial `x - c` where `x` is the variable polynomial and `c` is a constant in the ring `r`.

### Dependencies
- Definitions: `x_minus_const`
- Theorems: `RING_POLYNOMIAL_SUB`, `RING_POLYNOMIAL_CONST`, `x_pow_poly`


---

## x_minus_const_series

### Name of formal statement
x_minus_const_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_minus_const_series = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ring_powerseries r (x_minus_const r c)
`,
  qed[ring_polynomial;x_minus_const_poly]
);;
```
### Informal statement
For all rings `r` and all `c` in the carrier of `r`, the formal power series ring over `r` includes the term `x_minus_const r c`.

### Informal sketch
- The proof proceeds by showing that `x_minus_const r c` is a formal power series via the lemmas `ring_polynomial` and `x_minus_const_poly`.
- Instantiate the general theorem `ring_polynomial` to get that ring polynomials are formal power series.
- Then, to prove that `x_minus_const r c` is in `ring_powerseries r`, it suffices to prove that `x_minus_const r c` is a ring polynomial because of the previous step.
- The final step leverages `x_minus_const_poly`, which proves that `x_minus_const r c` is a ring polynomial, thus concluding the proof.

### Mathematical insight
This theorem demonstrates that a particular polynomial, namely `x - c` where `c` is a constant from the ring `r`, can be represented as a formal power series over the ring `r`.  This is important because it establishes that certain basic polynomials are included within the more general structure of formal power series, which is often a prerequisite for further development related to operations on and properties of formal power series. The function `x_minus_const r c` represents the polynomial `x - c` in the polynomial ring over `r`.

### Dependencies
- Theorems: `ring_polynomial`, `x_minus_const_poly`


---

## coeff_x_minus_const

### Name of formal statement
coeff_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_minus_const = prove(`
  !(r:R ring) c e.
  c IN ring_carrier r ==>
  coeff e (x_minus_const r c)
  = if e = 1 then ring_1 r else if e = 0 then ring_neg r c else ring_0 r
`,
  rw[x_minus_const;coeff_poly_sub;coeff_poly_const;coeff_x_pow] THEN
  intro THEN
  case `e = 0` THENL [
    simp[ARITH_RULE `~(0 = 1)`]
  ;
    case `e = 1` THENL [
      simp[]
    ;
      simp[]
    ]
  ] THEN
  RING_TAC
);;
```
### Informal statement
For any ring `r`, any element `c` in the carrier of `r`, and any natural number `e`, the coefficient of the polynomial `x_minus_const r c` at exponent `e` is equal to `ring_1 r` if `e` is 1, `ring_neg r c` if `e` is 0, and `ring_0 r` otherwise.

### Informal sketch
The proof proceeds by:
- Rewriting `x_minus_const` using its definition, which is `poly_sub (x_pow 1) (poly_const c)`.
- Applying rewriting rules for `coeff_poly_sub`, `coeff_poly_const`, and `coeff_x_pow` to simplify the expression.
- Introducing the universal quantifiers.
- Considering the case when `e = 0`.
  - Simplifying the expression, using the fact that `~(0 = 1)`.
  - Considering the case when `e = 1`.
    - Simplifying the expression.
    - Simplifying the remaining expression.
- Applying a ring tactic to discharge the final goal.

### Mathematical insight
This theorem determines the coefficients of the polynomial `x - c` for a constant `c` in a general ring `r`. It is important for reasoning about polynomials in abstract algebraic settings and allows one to work with the polynomial `x - c` in a coordinate-free manner, focusing on its coefficients. This is a fundamental step for factoring polynomials or performing other algebraic manipulations.

### Dependencies
- Definitions: `x_minus_const`, `coeff`, `ring_carrier`, `ring_1`, `ring_neg`, `ring_0`, `poly_sub`, `poly_const`, `x_pow`
- Theorems: `coeff_poly_sub`, `coeff_poly_const`, `coeff_x_pow`
- Rules: `ARITH_RULE`

### Porting notes (optional)
- The `RING_TAC` tactic may need to be replaced by a ring solver or similar automation in other proof assistants.
- The properties of ring operations (`ring_1`, `ring_neg`, `ring_0`) must be properly defined and available.
- Ensure that the definitions of polynomial operations are accessible and equivalent to those used in HOL Light.


---

## coeff_x_minus_const_times

### Name of formal statement
coeff_x_minus_const_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_minus_const_times = prove(`
  !(r:R ring) c p e.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  coeff e (poly_mul r (x_minus_const r c) p)
  = if e = 0 then ring_mul r (ring_neg r c) (coeff 0 p)
    else ring_sub r (coeff (e-1) p) (ring_mul r c (coeff e p))
`,
  intro THEN
  rw[x_minus_const] THEN
  have `ring_powerseries(r:R ring) (x_pow r 1)` [x_pow_series] THEN
  have `ring_powerseries(r:R ring) (poly_const r c:(1->num)->R)` [RING_POWERSERIES_CONST] THEN
  simp[poly_sub_rdistrib] THEN
  rw[coeff_poly_sub] THEN
  simp[coeff_x_pow_times] THEN
  simp[coeff_poly_const_times] THEN
  case `e = 0` THENL [
    simp[ARITH_RULE `0 < 1`] THEN
    RING_TAC THEN
    qed[coeff_series_in_ring]
  ; pass
  ] THEN
  simp[ARITH_RULE `~(e:num = 0) ==> ~(e < 1)`]
);;
```

### Informal statement
For any ring `r`, any element `c` in the carrier of `r`, and any power series `p` over `r`, the coefficient of `e` in the power series resulting from multiplying `(x - c)` and `p` in the ring `r` is equal to `ring_mul r (ring_neg r c) (coeff 0 p)` if `e` is 0, and to `ring_sub r (coeff (e-1) p) (ring_mul r c (coeff e p))` if `e` is not 0.

### Informal sketch
The proof proceeds by induction on `e`.

- First, the statement `x_minus_const r c` is rewritten using its definition.
- Then, it is established that `x_pow r 1` is a ring power series and that `poly_const r c` is also a ring power series. 
- The proof uses the distributive property of `poly_sub_rdistrib` to simplify the expression.
- The coefficients of the difference of the series are handled using `coeff_poly_sub`.
- The coefficients of series multiplied by x, `coeff_x_pow_times`, and series multiplied by a constant, `coeff_poly_const_times`, are handled.
- The proof splits into two cases:
    - If `e = 0`, the simplification involves showing that `0 < 1` which enables discharging of the goal using ring tactics with a final application of `coeff_series_in_ring`.
    - Otherwise, if `e` is not `0`, it is shown that `e < 1` is also false.

### Mathematical insight
This theorem provides a recursive formula for computing the coefficients of a power series that is the product of `(x - c)` and another power series `p`. This is useful for manipulating power series and extracting coefficients, particularly when dealing with factorization or division of power series.

### Dependencies
- `x_minus_const`
- `x_pow_series`
- `RING_POWERSERIES_CONST`
- `poly_sub_rdistrib`
- `coeff_poly_sub`
- `coeff_x_pow_times`
- `coeff_poly_const_times`
- `coeff_series_in_ring`


---

## x_minus_const_0

### Name of formal statement
x_minus_const_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_minus_const_0 = prove(`
  !(r:R ring).
  x_minus_const r (ring_0 r) = x_pow r 1
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  simp[coeff_x_minus_const;coeff_x_pow;RING_0] THEN
  rw[RING_NEG_0] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R`, `x_minus_const r (ring_0 r)` is equal to `x_pow r 1`.

### Informal sketch
The proof proceeds by:
- Introducing the ring `r`.
- Showing that it suffices to prove equality of coefficients.
- Introducing an index, then simplifying using the definitions of `coeff_x_minus_const`, `coeff_x_pow` and `RING_0`.
- Rewriting using `RING_NEG_0` which states that negation of `ring_0` is `ring_0` and thus completes the proof.

### Mathematical insight
This theorem states that the expression `x - 0` simplifies to `x` in any ring `R`. This is a basic but important result for algebraic manipulation in rings. `x_minus_const r (ring_0 r)` represents a polynomial where we subtract a constant term equal to the zero of the ring `r`. `x_pow r 1` represents `x` to the power of 1 in the ring `r`.

### Dependencies
- Definitions:
  - `coeff_x_minus_const`
  - `coeff_x_pow`
  - `RING_0`
- Theorems:
  - `RING_NEG_0`


---

## deg_x_minus_const_le

### Name of formal statement
deg_x_minus_const_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_minus_const_le = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  poly_deg r (x_minus_const r c) <= 1
`,
  intro THEN
  have `ring_powerseries(r:R ring) (x_minus_const r c)` [x_minus_const_series] THEN
  have `!e. ~(coeff e (x_minus_const(r:R ring) c) = ring_0 r) ==> e <= 1` [coeff_x_minus_const;ARITH_RULE `0 <= 1:num`;ARITH_RULE `1 <= 1:num`] THEN
  qed[deg_le_coeff]
);;
```
### Informal statement
For any ring `r` and any element `c` in the carrier of the ring `r`, the degree of the polynomial `x_minus_const r c` is less than or equal to 1.

### Informal sketch
The proof proceeds as follows:
- We start by assuming that `c` is in the carrier of ring `r`.
- We establish that `x_minus_const r c` is a power series over the ring `r` using the theorem `ring_powerseries`.
- We show that if a coefficient of `x_minus_const r c` at exponent `e` is not equal to the zero element of the ring `r`, then `e` must be less than or equal to 1, using `coeff_x_minus_const` and arithmetic reasoning.
- Finally, we conclude that the degree of `x_minus_const r c` is less than or equal to 1 using `deg_le_coeff`.

### Mathematical insight
This theorem states that the polynomial `x - c` (where `c` is a constant in the ring) is a linear polynomial. The degree of a polynomial is the highest power of the variable with a non-zero coefficient. In this case, the polynomial is `x - c`, so the highest power of `x` is 1. The theorem confirms that, formally. This fact is important when reasoning about polynomial rings and their properties.

### Dependencies
- Theorems:
   - `ring_powerseries`
   - `coeff_x_minus_const`
- Rules:
   - `ARITH_RULE` (for `0 <= 1:num` and `1 <= 1:num`)
- Definitions:
   - `ring_carrier`
   - `poly_deg`
   - `x_minus_const`
   - `coeff`
   - `ring_0`
   - `R`

### Porting notes (optional)
- The definitions of `ring_powerseries`, `coeff_x_minus_const`, `poly_deg`, `x_minus_const`, `coeff`, and `ring_0` must be available in the target proof assistant. Ensure that the notation for rings, elements, and polynomial degrees aligns with the target system's conventions. The `ARITH_RULE` calls suggest that basic arithmetic facts need to be either built-in or explicitly proven.


---

## deg_x_minus_const

### Name of formal statement
deg_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_minus_const = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ~(ring_1 r = ring_0 r) ==>
  poly_deg r (x_minus_const r c) = 1
`,
  intro THEN
  have `ring_powerseries(r:R ring) (x_minus_const r c)` [x_minus_const_series] THEN
  have `!e. ~(coeff e (x_minus_const(r:R ring) c) = ring_0 r) ==> e <= 1` [coeff_x_minus_const;ARITH_RULE `0 <= 1:num`;ARITH_RULE `1 <= 1:num`] THEN
  have `~(coeff 1 (x_minus_const r c) = ring_0(r:R ring))` [coeff_x_minus_const] THEN
  qed[deg_coeff]
);;
```

### Informal statement
For any ring `r` and any `c` in the carrier of the ring `r`, if the multiplicative identity `ring_1 r` is not equal to the additive identity `ring_0 r`, then the degree of the polynomial `x_minus_const r c` is equal to 1.

### Informal sketch
The theorem states that the polynomial `x - c` where `c` is a constant in a ring `r` has degree 1, provided that the ring is non-trivial (i.e., `1` is not equal to `0`).
- First, it's shown that `x_minus_const r c` is a `ring_powerseries` using `x_minus_const_series`.
- Then, it's proved that if a coefficient of `x_minus_const r c` at an exponent `e` is not equal to `0`, then `e` must be less than or equal to 1, applying `coeff_x_minus_const` along with arithmetic reasoning (`0 <= 1` and `1 <= 1`).
- Next, it is shown that the coefficient of `x_minus_const r c` at degree 1 is not equal to `0`, using `coeff_x_minus_const`.
- Finally, these results are combined in the `qed` step, using `deg_coeff` to deduce that the degree of `x_minus_const r c` is 1.

### Mathematical insight
The theorem confirms a basic property of polynomials: a linear term like `x - c` has degree 1. The condition `~(ring_1 r = ring_0 r)` ensures that we are working with a nontrivial ring, which is necessary to ensure that the coefficients behave as expected and that the notion of polynomial degree is well-defined.

### Dependencies
- `ring_carrier`
- `ring_1`
- `ring_0`
- `poly_deg`
- `x_minus_const`
- `ring_powerseries`
- `coeff`
- `coeff_x_minus_const`
- `deg_coeff`


---

## x_minus_const_nonzero

### Name of formal statement
x_minus_const_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_minus_const_nonzero = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ~(ring_1 r = ring_0 r) ==>
  ~(x_minus_const r c = poly_0 r)
`,
  qed[deg_x_minus_const;POLY_DEG_0;ARITH_RULE `~(0 = 1)`]
);;
```
### Informal statement
For any ring `r` and any element `c` in the carrier of the ring `r`, if the multiplicative identity `ring_1 r` is not equal to the additive identity `ring_0 r`, then the polynomial `x_minus_const r c` is not equal to the zero polynomial `poly_0 r`.

### Informal sketch
The proof demonstrates that the polynomial `x_minus_const r c` is not the zero polynomial `poly_0 r` under the given conditions.

- First, `deg_x_minus_const` is used to determine the degree of the polynomial `x_minus_const r c`. This degree is established to be 1.
- Then, `POLY_DEG_0` is used to show that the degree of the zero polynomial `poly_0 r` is 0.
- Finally, `ARITH_RULE \`~(0 = 1)\``, which states that 0 is not equal to 1 (derived from the assumption that the multiplicative identity `ring_1 r` is not equal to the additive identity `ring_0 r`) and the fact that the degrees are different, it is concluded that the polynomials are not equal.

### Mathematical insight
This theorem states that a simple linear polynomial of the form "x minus a constant" is not the zero polynomial, provided the underlying ring is non-trivial (i.e. 0 and 1 are distinct) and the constant is an element of the ring. This is a basic but important property used in polynomial algebra.

### Dependencies
- Theorems: `deg_x_minus_const`, `POLY_DEG_0`
- Rules: `ARITH_RULE \`~(0 = 1)\``


---

## eval_x_minus_const

### Name of formal statement
eval_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_x_minus_const = prove(`
  !(r:R ring) c x.
  c IN ring_carrier r ==>
  x IN ring_carrier r ==>
  poly_eval r (x_minus_const r c) x
  = ring_sub r x c
`,
  intro THEN
  rw[x_minus_const] THEN
  have `ring_polynomial(r:R ring) (x_pow r 1)` [x_pow_poly] THEN
  have `ring_polynomial(r:R ring) (poly_const r c:(1->num)->R)` [RING_POLYNOMIAL_CONST] THEN
  simp[POLY_EVAL_SUB] THEN
  simp[POLY_EVAL_CONST] THEN
  simp[eval_x_pow] THEN
  simp[RING_POW_1]
);;
```
### Informal statement
For any ring `r` and any elements `c` and `x`, if `c` is in the carrier of `r` and `x` is in the carrier of `r`, then evaluating the polynomial `x_minus_const r c` at `x` using the ring `r` results in `x` subtracted from `c` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Initially, introduce the assumptions that `c` and `x` are elements of ring `r`.
- Expand the definition of `x_minus_const`. `x_minus_const r c` is `x` - `c`.
- Show `x_pow r 1` and constant polynomial `poly_const r c` are ring polynomials.
- Simplify `poly_eval r (p - q) x = poly_eval r p x - poly_eval r q x`
- Simplify `poly_eval r (poly_const r c) x = c`.
- Simplify `poly_eval r (x_pow r 1) x = ring_pow r x 1`.
- Simplify `ring_pow r x 1 = x`.

### Mathematical insight
The theorem `eval_x_minus_const` demonstrates how polynomial evaluation interacts with a simple polynomial, namely the polynomial `x - c`. It shows that evaluating this polynomial at a point `x` in the ring simply computes the ring subtraction of `c` from `x`. This is a fundamental result connecting polynomial evaluation to the underlying ring operations.

### Dependencies
- Definitions: `x_minus_const`, `poly_eval`, `ring_sub`
- Theorems: `RING_POLYNOMIAL_CONST`, `eval_x_pow`, `RING_POW_1`

### Porting notes (optional)
In other proof assistants, the definition of `poly_eval` and the ring operations might differ slightly. Care should be taken to ensure that the simplifications performed in the proof sketch hold in the target proof assistant. The handling of implicit coercions and typeclasses for rings might require additional effort depending on the specific system.


---

## eval_x_minus_const_refl

### Name of formal statement
eval_x_minus_const_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_x_minus_const_refl = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  poly_eval r (x_minus_const r c) c
  = ring_0 r
`,
  simp[eval_x_minus_const] THEN
  rw[RING_SUB_REFL]
);;
```
### Informal statement
For any ring `r` and any `c`, if `c` is an element of the carrier of the ring `r`, then evaluating the polynomial `x_minus_const r c` at `c` using the ring `r` yields the zero element of the ring `r`.

### Informal sketch
The proof proceeds as follows:
- First, apply the simplification rule `eval_x_minus_const`, which reduces `poly_eval r (x_minus_const r c) c` to `ring_sub r (poly_eval r (ring_x r) c) (poly_eval r (ring_const r c) c)`. Simplification will resolve `poly_eval r (ring_x r) c` to `c` and `poly_eval r (ring_const r c) c` to `c`.
- Next, rewrite using the theorem `RING_SUB_REFL`, which states that for any ring `r` and any element `x` in the ring carrier, `ring_sub r x x = ring_0 r`. In our case, `x` is `c`. Because we have assume `c IN ring_carrier r` then we have met the assumptions to rewrite.

### Mathematical insight
This theorem states that the polynomial `x - c` evaluates to zero when `x` is set to `c`. This fact is a cornerstone of polynomial algebra and is fundamental for reasoning about roots of polynomials. The polynomial `x_minus_const r c` formally represents the polynomial `x - c` within the ring `r`, and this theorem confirms that this representation behaves as expected in evaluation.

### Dependencies
- Definitions: `poly_eval`, `x_minus_const`, `ring_carrier`, `ring_0`, `ring_x`, `ring_const`, `ring_sub`.
- Theorems: `eval_x_minus_const`, `RING_SUB_REFL`


---

## x_minus_const_not_unit

### Name of formal statement
x_minus_const_not_unit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_minus_const_not_unit = prove(`
  !(r:R ring) z.
  integral_domain r ==>
  z IN ring_carrier r ==>
  ~ring_unit(x_poly r) (x_minus_const r z)
`,
  intro THEN
  specialize_assuming[`r:R ring`;`(:1)`;`x_minus_const (r:R ring) z`]RING_UNIT_POLY_DOMAIN THEN
  choose `c:R` `ring_unit(r:R ring) c /\ x_minus_const r z = poly_const r c` [x_poly] THEN
  have `poly_deg (r:R ring) (x_minus_const r z) = 1` [deg_x_minus_const;integral_domain] THEN
  have `poly_deg (r:R ring) (poly_const r c:(1->num)->R) = 0` [POLY_DEG_CONST] THEN
  qed[ARITH_RULE `~(1 = 0)`]
);;
```
### Informal statement
For any ring `r` with carrier `R` that is an integral domain, and any element `z` in `R`, the polynomial `x_minus_const r z` is not a unit in the polynomial ring `x_poly r`.

### Informal sketch
The proof proceeds as follows:
- Assume that `r` is an integral domain and `z` is an element of its carrier `R`.
- Assume for contradiction that `x_minus_const r z` is a unit in the polynomial ring `x_poly r`.
- Apply `RING_UNIT_POLY_DOMAIN` to obtain the existence of an element `c` in `R` such that `x_minus_const r z = poly_const r c` and `c` is a unit in `r`.
- Deduce that the degree of the polynomial `x_minus_const r z` is 1, using `deg_x_minus_const` and the assumption that `r` is an integral domain.
- Deduce also that the degree of the polynomial `poly_const r c` is 0, using `POLY_DEG_CONST`.
- Reach a contradiction because a polynomial cannot have both degree 1 and degree 0 simultaneously if `1 ~= 0`, thus completing the proof.

### Mathematical insight
The theorem states that a linear polynomial of the form x - c (where c is a constant) in an integral domain cannot be a unit. A unit in a polynomial ring is a polynomial that has a multiplicative inverse. The only units in a polynomial ring over an integral domain are the constant polynomials that are units in the base ring. `x - c` has degree 1 and therefore cannot be a constant polynomial (degree 0), reaching the contradiction.

### Dependencies
- Definitions:
  - `integral_domain`
  - `ring_carrier`
  - `ring_unit`
  - `x_poly`
  - `x_minus_const`
  - `poly_const`
  - `poly_deg`
- Theorems:
  - `RING_UNIT_POLY_DOMAIN`
  - `deg_x_minus_const`
  - `POLY_DEG_CONST`
- Rules:
  - `ARITH_RULE`


---

## one_minus_constx

### Name of formal statement
one_minus_constx

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let one_minus_constx = new_definition `
  one_minus_constx (r:R ring) (c:R)
  = poly_sub r (x_pow r 0) (const_x_pow r c 1)
`;;
```
### Informal statement
For any ring `R` and any element `c` of `R`, `one_minus_constx(r)(c)` is defined to be the polynomial obtained by subtracting the polynomial `const_x_pow r c 1` from the polynomial `x_pow r 0`, within the ring `R`.

### Informal sketch
The definition `one_minus_constx` constructs a polynomial by subtracting two other polynomials.

- First, it forms the polynomial `x_pow r 0`, which represents the polynomial `1`.
- Then, it forms the polynomial `const_x_pow r c 1`, which represents the polynomial `cx`.
- Finally, it returns the polynomial obtained by subtracting `cx` from `1`, resulting in the polynomial `1 - cx`.
### Mathematical insight
This definition introduces a polynomial of a specific form, `1 - cx`, where `c` is a constant and `x` is the variable. Such polynomials appear in various contexts, such as power series expansions and rational functions. Defining this polynomial explicitly as `one_minus_constx` allows for easier manipulation and reasoning about it in subsequent developments, especially in the context of ring-theoretic polynomial operations.

### Dependencies
- Definition: `x_pow`
- Definition: `const_x_pow`
- Definition: `poly_sub`


---

## one_minus_constx_poly

### Name of formal statement
one_minus_constx_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let one_minus_constx_poly = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ring_polynomial r (one_minus_constx r c)
`,
  qed[one_minus_constx;RING_POLYNOMIAL_SUB;x_pow_poly;const_x_pow_poly]
);;
```
### Informal statement
For all rings `r` and for all `c` such that `c` is in the carrier of the ring `r`, the ring polynomial `one_minus_constx r c` is a ring polynomial.

### Informal sketch
The proof shows that `one_minus_constx r c` is a ring polynomial by expanding the definition of `one_minus_constx r c` and using properties of polynomial constructions.

- First, the definition of `one_minus_constx r c` is unfolded, which is `-(ring r) ( &1 * const_poly r c ) + const_poly r (ring_one r)`.
- Then it is proved that `- (ring r) ( &1 * const_poly r c )` is a ring polynomial using `RING_POLYNOMIAL_SUB`, `one_minus_constx`, and `const_x_pow_poly`.
- `x_pow_poly` is used to prove that `const_poly r (ring_one r)` is a polynomial.
- Finally, `RING_POLYNOMIAL_SUB` states that the sum of two ring polynomials results in another ring polynomial.

### Mathematical insight
The theorem states that if `c` is an element of ring `r`, then `1 - cx` is a ring polynomial. This is a crucial step to formally reason about polynomials by building them up from constituent parts and constants.

### Dependencies
- Definitions: `one_minus_constx`
- Theorems: `RING_POLYNOMIAL_SUB`, `x_pow_poly`, `const_x_pow_poly`


---

## one_minus_constx_series

### Name of formal statement
one_minus_constx_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let one_minus_constx_series = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ring_powerseries r (one_minus_constx r c)
`,
  qed[ring_polynomial;one_minus_constx_poly]
);;
```
### Informal statement
For all rings `r` and for all `c` in the carrier of `r`, `one_minus_constx r c` is a formal power series over the ring `r`.

### Informal sketch
The theorem states that the formal power series `one_minus_constx r c` is indeed a formal power series; in other words, it satisfies the formal definition of being an element of type `ring_powerseries r`.
The proof is performed by first showing that `one_minus_constx r c` is a polynomial by appealing to `one_minus_constx_poly`. Then, using transitivity with the theorem stating that polynomials are also formal power series (`ring_polynomial`), we obtain the theorem.
### Mathematical insight
The function `one_minus_constx r c` represents the power series `1 - cx`, where `c` is a constant and `x` is the formal variable. This theorem confirms that this expression is well-defined as a formal power series within the framework of the ring `r`. It builds on the existing understanding that polynomials are power series. This is an important result for algebraic manipulations with formal power series.

### Dependencies
Terms:
- `ring_carrier`
- `one_minus_constx`
- `ring_powerseries`

Theorems:
- `ring_polynomial`
- `one_minus_constx_poly`


---

## coeff_one_minus_constx

### Name of formal statement
coeff_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_one_minus_constx = prove(`
  !(r:R ring) c e.
  c IN ring_carrier r ==>
  coeff e (one_minus_constx r c)
  = if e = 0 then ring_1 r else if e = 1 then ring_neg r c else ring_0 r
`,
  rw[one_minus_constx;coeff_poly_sub;coeff_poly_const;coeff_x_pow;coeff_const_x_pow] THEN
  intro THEN
  case `e = 1` THENL [
    simp[ARITH_RULE `~(0 = 1)`]
  ;
    case `e = 0` THENL [
      simp[]
    ;
      simp[]
    ]
  ] THEN
  RING_TAC
);;
```
### Informal statement
For any ring `r` and any constant `c` in the carrier of `r`, the coefficient of the polynomial `one_minus_constx r c` at exponent `e` is equal to `ring_1 r` if `e` is 0, `ring_neg r c` if `e` is 1, and `ring_0 r` otherwise.

### Informal sketch
The proof proceeds by rewriting the definition of `one_minus_constx` and several lemmas regarding coefficients of polynomials in terms of sums, constants, and powers of x.
- First, rewrite `one_minus_constx` to `poly_sub (poly_const r (ring_1 r)) (const_x_pow r c 1)`.
- Then, rewrite coefficients of polynomial subtraction to `coeff_poly_sub`, constants `coeff_poly_const`, `x_pow` `coeff_x_pow` and scalar multiplication `coeff_const_x_pow`.
- Introduce assumptions using `intro`.
- Perform a case split on whether `e = 1`.
  - If `e = 1`, simplify using the assumption that `~(0 = 1)`.
  - If `e != 1`, perform a case split on whether `e = 0`.
    - If `e = 0`, simplify.
    - If `e != 0`, simplify.
- Finally, apply ring tactics to complete the proof, which presumably involves simplifying ring expressions to show equality.

### Mathematical insight
This theorem provides a formula for extracting the coefficients of a specific polynomial, `one_minus_constx r c`, which is defined as `1 - cx`. Knowing the coefficients of such polynomials is essential for manipulating and reasoning about them within the formal theory.

### Dependencies
- `one_minus_constx`
- `coeff_poly_sub`
- `coeff_poly_const`
- `coeff_x_pow`
- `coeff_const_x_pow`
- `ARITH_RULE` (specifically `~(0 = 1)`)
- `RING_TAC`


---

## coeff_one_minus_constx_times

### Name of formal statement
coeff_one_minus_constx_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_one_minus_constx_times = prove(`
  !(r:R ring) c p e.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  coeff e (poly_mul r (one_minus_constx r c) p)
  = if e = 0 then coeff 0 p
    else ring_sub r (coeff e p) (ring_mul r c (coeff (e-1) p))
`,
  intro THEN
  rw[one_minus_constx] THEN
  have `ring_powerseries(r:R ring) (x_pow r 0)` [x_pow_series] THEN
  have `ring_powerseries(r:R ring) (const_x_pow r c 1)` [const_x_pow_series] THEN
  simp[poly_sub_rdistrib] THEN
  rw[coeff_poly_sub] THEN
  simp[coeff_x_pow_times] THEN
  simp[coeff_const_x_pow_times] THEN
  simp[ARITH_RULE `~(e:num < 0)`] THEN
  case `e = 0` THENL [
    simp[ARITH_RULE `0 - 0 = 0:num`] THEN
    simp[ARITH_RULE `0 < 1:num`] THEN
    qed[RING_SUB_RZERO;coeff_series_in_ring]
  ;
    simp[ARITH_RULE `~(e:num = 0) ==> ~(e < 1)`] THEN
    qed[ARITH_RULE `e - 0 = e:num`]
  ]
);;
```

### Informal statement
For any ring `r` with carrier `ring_carrier r`, any element `c` in `ring_carrier r`, any power series `p` over `r`, and any natural number `e`, the `e`-th coefficient of the power series resulting from the multiplication of `one_minus_constx r c` and `p` is equal to the coefficient of `p` at 0 if `e` is 0, and is equal to the ring subtraction of the `e`-th coefficient of `p` and the ring multiplication of `c` and the `(e-1)`-th coefficient of `p` otherwise.

### Informal sketch
The proof proceeds by induction on `e`.
- The base case `e = 0` is handled directly, showing that the coefficient is the same as in the original series `p`, by using `RING_SUB_RZERO` and `coeff_series_in_ring`.
- The inductive step involves manipulating the expression `coeff e (poly_mul r (one_minus_constx r c) p)` using rewrites such as `one_minus_constx`, `poly_sub_rdistrib`, `coeff_poly_sub`, `coeff_x_pow_times`, and `coeff_const_x_pow_times`. The arithmetic simplification `~(e < 0)` and `~(e = 0) ==> ~(e < 1)` are crucial for the cases where `e` is zero or positive. The rule `e - 0 = e:num` also help simplification.

### Mathematical insight
This theorem provides a recursive formula for computing the coefficients of a power series that is the product of a power series `p` and `(1 - cx)`, where `c` is a constant. This is a fundamental step in manipulating and reasoning about power series. The formula separates the base case (e=0) from the general case (e>0) to handle the shift in indices caused by the multiplication.

### Dependencies

Definitions:
- `one_minus_constx`
- `poly_mul`
- `ring_powerseries`
- `ring_carrier`
- `ring_sub`
- `coeff`
- `const_x_pow`
- `x_pow`
- `coeff_x_pow_times`
- `coeff_const_x_pow_times`
- `poly_sub_rdistrib`
- `coeff_series_in_ring`

Theorems/Rules:
- `ARITH_RULE`
- `RING_SUB_RZERO`

### Porting notes (optional)
- The `ARITH_RULE` tactic suggests that arithmetic reasoning is automated in HOL Light. In other systems such as Coq, you may need to explicitly provide proof terms or invoke a dedicated arithmetic tactic (e.g., `lia` or `omega`).
- The simplifications involving power series rely on the definitions related to coefficient extraction. Make sure that the port respects the underlying definitions of `coeff`, `poly_mul`, `ring_carrier` and other relevant ring operators.



---

## deg_one_minus_constx_le

### Name of formal statement
deg_one_minus_constx_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_one_minus_constx_le = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  poly_deg r (one_minus_constx r c) <= 1
`,
  intro THEN
  have `ring_powerseries(r:R ring) (one_minus_constx r c)` [one_minus_constx_series] THEN
  have `!e. ~(coeff e (one_minus_constx(r:R ring) c) = ring_0 r) ==> e <= 1` [coeff_one_minus_constx;ARITH_RULE `0 <= 1:num`;ARITH_RULE `1 <= 1:num`] THEN
  qed[deg_le_coeff]
);;
```
### Informal statement
For any ring `r` and any element `c`, if `c` is an element of the carrier of the ring `r`, then the degree of the polynomial `one_minus_constx r c` is less than or equal to 1.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions that `r` is a ring and `c` is an element of the carrier of `r`.
- Establish that `one_minus_constx r c` is a power series using `ring_powerseries`.
- Prove that if a coefficient of `one_minus_constx r c` at some exponent `e` is not equal to the zero element of the ring `r`, then `e` must be less than or equal to 1. This leverages `coeff_one_minus_constx` and arithmetic reasoning.
- Conclude that the degree of `one_minus_constx r c` is less than or equal to 1 using `deg_le_coeff`. This step combines the previous result about the coefficients with the definition of polynomial degree.

### Mathematical insight
The theorem states that the polynomial `1 - cx` has degree at most 1, provided that `c` is in the ring. This is a foundational result used in reasoning about polynomial degrees in rings. The polynomial `one_minus_constx r c` is formally defined as `ring_one r - constx r c`. If `c` is in the carrier of ring `r` then the only non-zero coefficients are for `x^0` and `x^1`, giving degree at most 1.

### Dependencies
- Definitions/Theorems:
    - `ring_powerseries`
    - `coeff_one_minus_constx`
    - `deg_le_coeff`


---

## eval_one_minus_constx

### Name of formal statement
eval_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_one_minus_constx = prove(`
  !(r:R ring) c x.
  c IN ring_carrier r ==>
  x IN ring_carrier r ==>
  poly_eval r (one_minus_constx r c) x
  = ring_sub r (ring_1 r) (ring_mul r c x)
`,
  intro THEN
  rw[one_minus_constx] THEN
  have `ring_polynomial(r:R ring) (x_pow r 0)` [x_pow_poly] THEN
  have `ring_polynomial(r:R ring) (const_x_pow r c 1)` [const_x_pow_poly] THEN
  simp[POLY_EVAL_SUB] THEN
  simp[eval_const_x_pow;eval_x_pow] THEN
  simp[RING_POW_1;RING_POW_0]
);;
```
### Informal statement
For any ring `r` and elements `c` and `x` in the carrier of `r`, the polynomial evaluation of `one_minus_constx r c` at `x` is equal to `ring_sub r (ring_1 r) (ring_mul r c x)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions that `c` and `x` are in the carrier of the ring `r`.
- Rewrite using the definition of `one_minus_constx`, which expresses the polynomial as a subtraction of two polynomials: `x_pow r 0` and `const_x_pow r c 1`.
- Establish that both `x_pow r 0 ` and `const_x_pow r c 1` are ring polynomials via `x_pow_poly` and `const_x_pow_poly`.
- Simplify using the theorem `POLY_EVAL_SUB`, which distributes polynomial evaluation over subtraction.
- Simplify using `eval_const_x_pow` and `eval_x_pow` to evaluate the individual polynomial terms.
- Simplify using `RING_POW_1` and `RING_POW_0` to evaluate ring powers, completing the proof.

### Mathematical insight
This theorem establishes the evaluation of a specific polynomial `one_minus_constx r c` at a point `x`. The polynomial is of the form 1 - cx. The theorem connects the polynomial representation with the ring operations of subtraction and multiplication, showing that evaluating the polynomial is equivalent to computing `1 - c*x` using the ring's operations. This result is a basic but important step in connecting polynomial algebra to ring algebra.

### Dependencies
- Definitions: `one_minus_constx`
- Theorems/Lemmas: `POLY_EVAL_SUB`, `eval_const_x_pow`, `eval_x_pow`, `RING_POW_1`, `RING_POW_0`


---

## nonzero_one_minus_constx

### Name of formal statement
nonzero_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_one_minus_constx = prove(`
  !(r:R ring) c.
  ~(ring_1 r = ring_0 r) ==>
  c IN ring_carrier r ==>
  ~(one_minus_constx r c = poly_0 r)
`,
  intro THEN
  have `coeff 0 (one_minus_constx(r:R ring) c) = ring_1 r` [coeff_one_minus_constx] THEN
  have `coeff 0 (poly_0 r:(1->num)->R) = ring_0 r` [coeff_poly_0] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and any element `c` in the carrier of `r`, if the multiplicative identity `ring_1 r` is not equal to the additive identity `ring_0 r`, then the polynomial `one_minus_constx r c` is not equal to the zero polynomial `poly_0 r`.

### Informal sketch
The proof proceeds by contradiction. It assumes that `one_minus_constx r c` is equivalent to `poly_0 r`, and derives a contradiction.

- First establish that the coefficient of degree 0 of `one_minus_constx r c` is equal to `ring_1 r`. This uses the theorem `coeff_one_minus_constx`.
- Next establish that the coefficient of degree 0 of `poly_0 r` is equal to `ring_0 r`. This uses the theorem `coeff_poly_0`.
- Because the two polynomials are assumed to be equal, all coefficients must be equal, in particular the 0th coefficient, i.e. `ring_1 r = ring_0 r` which contradicts our hypothesis that `~(ring_1 r = ring_0 r)`.

### Mathematical insight
This theorem establishes a basic property of polynomials over a ring. If a ring is non-trivial (i.e., its multiplicative and additive identities are distinct), then the polynomial `1 - cx`  (represented as `one_minus_constx r c`) cannot be the zero polynomial.  Intuitively, if `1 - cx = 0` for all *x*, then `1` must be `0`, which leads to a degenerate ring.

### Dependencies
- `ring_carrier`
- `ring_1`
- `ring_0`
- `one_minus_constx`
- `poly_0`
- `coeff_one_minus_constx`
- `coeff_poly_0`


---

## infinite_geometric_series

### Name of formal statement
infinite_geometric_series

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let infinite_geometric_series = new_definition `
  infinite_geometric_series (r:R ring) (c) =
  \n. (ring_pow r c (n one))
`;;
```

### Informal statement
The `infinite_geometric_series` of a ring element `r` and a natural number `c` is defined as the function that maps a natural number `n` to `r` raised to the power of `c` multiplied by `n`. Here, raising to the power is ring-theoretic, and natural numbers are embedded into the ring via `one`.

### Informal sketch
- The definition directly represents the infinite geometric series as a function indexed by natural numbers.
- It computes the `n`-th term of the sequence `c^n x^n`, where `c` is a constant and `x` is `r`.
- The term `ring_pow r c (n one)` signifies `r` raised to the power of (`c` * `n`), with natural number `n` being coerced into the ring using `one`.

### Mathematical insight
The `infinite_geometric_series` definition represents the sequence of terms in the geometric series as a function with domain $\mathbb{N}$. This is useful for representing the powerseries directly as a mapping and facilitates reasoning within the formal system. This also sets up a representation in `r[[x]]` where `x` is formal. The comment in the original HOL Light statement indicates that this series is treated with different topological considerations than other geometric series theorems, suggesting it's in the ring of formal power series.

### Dependencies
- `ring_pow`
- `one`


---

## infinite_geometric_series_powerseries

### Name of formal statement
infinite_geometric_series_powerseries

### Type of the formal statement
theorem

### Formal Content
```ocaml
let infinite_geometric_series_powerseries = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  ring_powerseries r (infinite_geometric_series r c)
`,
  intro THEN
  rw[infinite_geometric_series;ring_powerseries] THEN
  qed[RING_POW;FINITE_MONOMIAL_VARS_1;INFINITE]
);;
```
### Informal statement
For all rings `r` and for all `c`, if `c` is an element of the carrier of the ring `r`, then `infinite_geometric_series r c` is a powerseries over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions of quantification and the condition `c` belongs to the ring carrier of `r`.
- Rewrite the goal using the definitions of `infinite_geometric_series` and `ring_powerseries` respectively.
- Apply the theorems `RING_POW`, `FINITE_MONOMIAL_VARS_1`, and `INFINITE` to complete the proof.

### Mathematical insight
The theorem establishes that the formal power series representation of the geometric series, defined as `infinite_geometric_series r c`, is indeed a power series over the ring `r`, provided that `c` is an element of that ring. This is a fundamental result when working with formal power series and their convergence properties.

### Dependencies
- Definitions: `infinite_geometric_series`, `ring_powerseries`
- Theorems: `RING_POW`, `FINITE_MONOMIAL_VARS_1`, `INFINITE`


---

## infinite_geometric_series_x_series

### Name of formal statement
infinite_geometric_series_x_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let infinite_geometric_series_x_series = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  infinite_geometric_series r c IN ring_carrier(x_series r)
`,
  rw[x_series;POWSER_RING;poly_vars;UNIONS_SUBSET] THEN
  SET_TAC[monomial;infinite_geometric_series_powerseries]
);;
```
### Informal statement
For any ring `r` and any element `c`, if `c` is an element of the carrier of the ring `r`, then the infinite geometric series `infinite_geometric_series r c` is an element of the carrier of the ring of formal power series `x_series r`.

### Informal sketch
The proof shows that if `c` is in the carrier of ring `r`, then the infinite geometric series of `c` (i.e., the power series `sum c^n x^n`) is in the carrier of `x_series r`.

- The proof starts by rewriting using definitions such as `x_series`, `POWSER_RING`, and `poly_vars` revealing the underlying structures.
- It then simplifies using `UNIONS_SUBSET`, reducing the goal to showing that each term `c^n x^n` belongs to `r[[x]]`.
- The proof proceeds by using `SET_TAC`, which applies the lemmas `monomial` and `infinite_geometric_series_powerseries`.  These lemmas establish that the `monomial` function which is used to build power series and that the infinite geometric series, when defined as a power series, resides within the `x_series r` carrier.

### Mathematical insight
The theorem states that if an element `c` belongs to a ring `r`, then the infinite geometric series with `c` as the coefficient (i.e., the formal power series `sum c^n x^n`) belongs to the ring of formal power series over `r`. This is a crucial step in formally defining and working with power series, ensuring that the operations and structures are closed within the defined rings.

### Dependencies
- Definitions: `x_series`, `POWSER_RING`, `poly_vars`, `monomial`, `infinite_geometric_series_powerseries`, `infinite_geometric_series`
- Theorems: `UNIONS_SUBSET`


---

## coeff_infinite_geometric_series

### Name of formal statement
coeff_infinite_geometric_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_infinite_geometric_series = prove(`
  !(r:R ring) c e.
  coeff e (infinite_geometric_series r c)
  = ring_pow r c e
`,
  rw[infinite_geometric_series;coeff;x_monomial]
);;
```
### Informal statement
For any ring `R`, for any `r` in `R`, for any `c` and `e`, the coefficient of `e` in the infinite geometric series `infinite_geometric_series r c` is equal to `ring_pow r c e`.

### Informal sketch
The proof proceeds by:
- Rewriting the statement using the definitions of `infinite_geometric_series` and `coeff`.
- Applying `x_monomial` to further simplify the expression to arrive at the desired conclusion.

### Mathematical insight
This theorem provides a formula for extracting the coefficients of the power series representation of an infinite geometric series. It is a fundamental result in the theory of power series and is useful for calculating specific coefficients in closed form.

### Dependencies
- `infinite_geometric_series`
- `coeff`
- `x_monomial`


---

## infinite_geometric_series_inverse

### Name of formal statement
- infinite_geometric_series_inverse

### Type of the formal statement
- theorem

### Formal Content
```ocaml
let infinite_geometric_series_inverse = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  poly_mul r (one_minus_constx r c) (infinite_geometric_series r c)
  = poly_1 r
`,
  intro THEN
  have `ring_powerseries(r:R ring) (infinite_geometric_series r c)` [infinite_geometric_series_powerseries] THEN
  sufficesby eq_coeff THEN
  simp[coeff_one_minus_constx_times] THEN
  rw[coeff_infinite_geometric_series] THEN
  rw[coeff_poly_1] THEN
  rw[RING_POW_0] THEN
  intro THEN
  have `ring_pow(r:R ring) c d IN ring_carrier r` [RING_POW] THEN
  have `ring_sub(r:R ring) (ring_pow r c d) (ring_pow r c d) = ring_0 r` [RING_SUB_REFL] THEN
  qed[ring_pow_sub1]
);;
```
### Informal statement
- For any ring `r` and any `c` such that `c` is in the carrier of `r`, the polynomial multiplication of `one_minus_constx r c` and `infinite_geometric_series r c` is equal to `poly_1 r`.

### Informal sketch
- We aim to prove that `(1-cx) sum c^n x^n = 1`.
- First, show that `infinite_geometric_series r c` is a power series by using the theorem `infinite_geometric_series_powerseries`.
- Then, it suffices to prove the equality by showing that the coefficients are the same.
- Simplify the expression `coeff_one_minus_constx_times` to expand the expression.
- Rewrite `coeff_infinite_geometric_series` to compute the coefficients of the infinite geometric series.
- Rewrite `coeff_poly_1` to express the coefficients of the polynomial 1.
- Rewrite `RING_POW_0` for the base case (n=0).
- Introduce the variable d.
- Show that `ring_pow r c d` is in the carrier of the ring `r` via `RING_POW`.
- Show the reflexive case `ring_sub(r:R ring) (ring_pow r c d) (ring_pow r c d) = ring_0 r` using `RING_SUB_REFL`.
- Then resolve with `ring_pow_sub1`.
- Close the proof.

### Mathematical insight
- This theorem formalizes the identity that the power series expansion of `1/(1-cx)` is the infinite geometric series `sum c^n x^n`. It's a crucial result in analysis and algebra, establishing the convergence and representation of a simple rational function as a power series within a certain radius of convergence (though convergence isn't explicitly part of the HOL Light formalizaiton here). The theorem highlights a fundamental connection between algebraic manipulation of polynomials and their power series representations.

### Dependencies
- Theorems:
    - `infinite_geometric_series_powerseries`
    - `RING_POW`
    - `RING_SUB_REFL`
    - `ring_pow_sub1`

- Definitions:
    - `poly_mul`
    - `one_minus_constx`
    - `infinite_geometric_series`
    - `poly_1`
    - `coeff_one_minus_constx_times`
    - `coeff_infinite_geometric_series`
    - `coeff_poly_1`
    - `RING_POW_0`
    - `ring_pow`
    - `ring_sub`

### Porting notes (optional)
- In proof assistants like Lean or Coq, the ring structure needs to be properly defined with all its axioms. The handling of ring carriers `IN ring_carrier r` might require explicit coercions or typeclass assumptions in other systems. The automation used by `simp` might need to be replicated using tactics that perform rewriting and simplification based on the properties of rings and polynomials. Specifically, tactics to unfold definitions such as `one_minus_constx`, `infinite_geometric_series`, are required.


---

## poly_pow

### Name of formal statement
poly_pow

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let poly_pow = new_definition `
  poly_pow (r:R ring)
  = ring_pow (powser_ring r (:V))
`;;
```
### Informal statement
The definition introduces `poly_pow` which, for a ring `r`, equals `ring_pow` where the exponent is interpreted within the ring of power series over `r` with the variable `:V`.

### Informal sketch
- The definition simply equates `poly_pow` with a specific application of `ring_pow`.
- The ring exponentiation `ring_pow` takes its exponent from the `powser_ring r (:V)`, which is the ring of formal power series over the ring `r`.

### Mathematical insight
The definition `poly_pow` is a straightforward application of `ring_pow` to the specific case of formal power series. This provides a convenient function to calculate powers of power series, leveraging the existing `ring_pow` which presumably handles exponentiation within a general ring structure.

### Dependencies
- Definition: `ring_pow`
- Definition: `powser_ring`


---

## poly_pow_series

### Name of formal statement
poly_pow_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_series = prove(`
  !(r:R ring) p:(V->num)->R n.
  ring_powerseries r p ==>
  ring_powerseries r (poly_pow r p n)
`,
  rw[poly_pow] THEN
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    intro THEN
    rw[RING_POW_0;POWSER_RING] THEN
    qed[RING_POWERSERIES_1]
  ;
    intro THEN
    rw[ring_pow;POWSER_RING] THEN
    qed[RING_POWERSERIES_MUL]
  ]
);;
```
### Informal statement
For any ring `r` and a function `p` from a type `V` to natural numbers, and any natural number `n`, if `p` represents a power series over the ring `r` (i.e., `ring_powerseries r p`), then `poly_pow r p n` also represents a power series over the ring `r` (i.e., `ring_powerseries r (poly_pow r p n)`).

### Informal sketch
The proof proceeds by induction on `n`.
- Base Case: `n = 0`. We need to show that `poly_pow r p 0` is a ring power series. By definition of `poly_pow`, `poly_pow r p 0` is the constant power series 1. The theorem `RING_POWERSERIES_1` states that the constant power series 1 is indeed a ring power series in any ring. The tactic `rw[RING_POW_0;POWSER_RING]` rewrites `poly_pow r p 0` to equal the constant power series 1 in the ring `r`, and then `RING_POWERSERIES_1` proves the base case.
- Inductive Step: Assume that `poly_pow r p n` is a ring power series. We need to show that `poly_pow r p (SUC n)` is a ring power series. By definition, `poly_pow r p (SUC n) = ring_pow r (poly_pow r p n) p`. Thus, we need to prove that `ring_pow r (poly_pow r p n) p` is a ring power series. By the inductive hypothesis, `poly_pow r p n` is a ring power series, and we are given that `p` is a ring power series so we have the product of two ring power series. The tactic `rw[ring_pow;POWSER_RING]` rewrites `poly_pow r p (SUC n)` to equal `ring_mul r (poly_pow r p n) p`, and then `RING_POWERSERIES_MUL` completes the proof, by showing that the product of ring power series is another ring power series.

### Mathematical insight
This theorem states that if `p` is a power series, then its `n`-th power (expressed using ring operations) is also a power series. This is a fundamental property needed for manipulating power series algebraically within the formal system. It ensures that the set of power series is closed under exponentiation (defined through repeated multiplication).

### Dependencies
- `poly_pow`
- `ring_powerseries`
- `RING_POW_0`
- `POWSER_RING`
- `RING_POWERSERIES_1`
- `ring_pow`
- `RING_POWERSERIES_MUL`

### Porting notes (optional)
- The main challenge might be to ensure that definitions of `poly_pow`, `ring_pow` and `ring_powerseries` are equivalent, since HOL Light uses specific definitions (likely based on `lists` or similar representations).
- The proof is relatively straightforward if all dependencies are available.


---

## poly_pow_poly

### Name of formal statement
poly_pow_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_poly = prove(`
  !(r:R ring) p:(V->num)->R n.
  ring_polynomial r p ==>
  ring_polynomial r (poly_pow r p n)
`,
  rw[poly_pow] THEN
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    intro THEN
    rw[RING_POW_0;POWSER_RING] THEN
    qed[RING_POLYNOMIAL_1]
  ;
    intro THEN
    rw[ring_pow;POWSER_RING] THEN
    qed[RING_POLYNOMIAL_MUL]
  ]
);;
```
### Informal statement
For any ring `r`, any function `p` from a vector space `V` to numbers such that `p` is a ring polynomial over `r`, and any natural number `n`, the function `poly_pow r p n` is also a ring polynomial over `r`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case (`n = 0`): The statement `poly_pow r p 0` simplifies to the ring polynomial `1` using the definition of `poly_pow` and `RING_POW_0`, and `1` is trivially a ring polynomial by `RING_POLYNOMIAL_1`.
- Inductive step: Assume that `poly_pow r p n` is a ring polynomial over `r`. We need to show that `poly_pow r p (SUC n)` is also a ring polynomial. By definition, `poly_pow r p (SUC n)` is equal to `ring_pow r (poly_pow r p n) p`. Since the product of two ring polynomials is a ring polynomial (`RING_POLYNOMIAL_MUL`) and by induction hypothesis `poly_pow r p n` is a ring polynomial, the result follows.

The proof uses rewriting with `poly_pow` to expand the definition, then proceeds by induction on `n`. The base case uses `RING_POW_0` and `RING_POLYNOMIAL_1`. The inductive step uses the definition of `ring_pow` and the theorem `RING_POLYNOMIAL_MUL`. The `POWSER_RING` theorem likely relates to properties of power series in the context of rings and is used in both cases.

### Mathematical insight
This theorem establishes closure under exponentiation for ring polynomials. Given a ring `r` and a ring polynomial `p` over `r`, raising `p` to any natural number power `n` results in another ring polynomial over `r`. This property is crucial for building more complex polynomial expressions and proving theorems about algebraic structures.

### Dependencies
- `poly_pow`
- `ring_polynomial`
- `RING_POW_0`
- `RING_POLYNOMIAL_1`
- `ring_pow`
- `RING_POLYNOMIAL_MUL`
- `POWSER_RING`


---

## poly_pow_in_poly_ring

### Name of formal statement
poly_pow_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_in_poly_ring = prove(`
  !(r:R ring) p:(V->num)->R n S.
  p IN ring_carrier(poly_ring r S) ==>
  poly_pow r p n IN ring_carrier(poly_ring r S)
`,
  rw[poly_pow] THEN
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    intro THEN
    rw[RING_POW_0;POWSER_RING] THEN
    qed[POLY_RING;RING_1]
  ;
    intro THEN
    rw[ring_pow;POWSER_RING] THEN
    qed[poly_mul_in_poly_ring]
  ]
);;
```
### Informal statement
For any ring `r` with carrier `R`, for any polynomial `p` from `V` to `num` and any `n` in `S`, if `p` is an element of the carrier of the polynomial ring over `r` with variables in `S` then `poly_pow r p n` is an element of the carrier of the polynomial ring over `r` with variables in `S`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`.  We show that `poly_pow r p 0` is the ring identity `RING_1` in `poly_ring r S`, using `RING_POW_0` and `POWSER_RING`. The ring identity `RING_1` belongs to the carrier via the theorem `POLY_RING` and `RING_1`.
- Inductive step: Assume `poly_pow r p n` belongs to the carrier of the polynomial ring. We need to show that `poly_pow r p (SUC n)` belongs to the carrier. The induction hypothesis combined with `ring_pow` and `POWSER_RING` allows us to rewrite `poly_pow r p (SUC n)` as the product of two polynomials that are in the carrier of the polynomial ring. We then use `poly_mul_in_poly_ring` to conclude that the product also belongs to the carrier of the polynomial ring.

### Mathematical insight
This theorem demonstrates the closure property of polynomial rings under exponentiation. Specifically, if a polynomial belongs to a polynomial ring, then raising it to any power also results in a polynomial that belongs to the same ring. This is fundamental to the algebraic structure of polynomial rings, ensuring that repeated multiplication (exponentiation) does not lead to elements outside the ring.

### Dependencies
- `poly_pow`
- `RING_POW_0`
- `POWSER_RING`
- `POLY_RING`
- `RING_1`
- `ring_pow`
- `poly_mul_in_poly_ring`


---

## x_series_use_pow

### Name of formal statement
x_series_use_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_series_use_pow = prove(`
  !(r:R ring).
  poly_pow r = ring_pow (x_series r)
`,
  qed[poly_pow;x_series]
);;
```
### Informal statement
For any `r` that is a ring, the polynomial power operation `poly_pow r` is equal to the ring power operation `ring_pow` applied to the `x_series` form of `r`.

### Informal sketch
The proof establishes the equivalence between `poly_pow r` and `ring_pow (x_series r)` for a ring element `r`. This likely involves unfolding the definitions of `poly_pow`, `ring_pow`, and `x_series`, and then demonstrating that the resulting expressions are equal. The `qed[poly_pow;x_series]` suggests these two definitions must be unfolded during the proof.

### Mathematical insight
This theorem connects polynomial arithmetic to the ring-theoretic notion of exponentiation, when viewed through the lens of formal power series. It shows that raising a ring element `r` to a power, whether interpreted as a polynomial or a formal power series, yields equivalent results. This equivalence is fundamental in establishing the relationship between algebraic structures and their representations as power series.

### Dependencies
- Definitions: `poly_pow`, `x_series`


---

## x_poly_use_pow

### Name of formal statement
x_poly_use_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_use_pow = prove(`
  !(r:R ring).
  poly_pow r = ring_pow (x_poly r)
`,
  rw[x_series_use_pow;x_poly;x_series] THEN
  qed[POLY_RING_AS_SUBRING;RING_POW_SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `R`, the polynomial power `poly_pow r` is equal to the ring power `ring_pow` applied to `x_poly r`. That is, for any ring `r`, `poly_pow r` is equal to `ring_pow (x_poly r)`.

### Informal sketch
The proof begins with rewriting using `x_series_use_pow`, `x_poly`, and `x_series`. Then applies rewriting with `POLY_RING_AS_SUBRING` and `RING_POW_SUBRING_GENERATED`.
- The theorem `x_series_use_pow` states that polynomial power is equal to series power composed with `x_series`.
- Expansion of `x_poly` and `x_series` definitions.
- The theorem `POLY_RING_AS_SUBRING` asserts that the polynomial ring can be viewed as a subring.
- The theorem `RING_POW_SUBRING_GENERATED` provides a way to compute power in a subring using the power operator of the larger ring.
The combination of these facts allows us to arrive at the required equality.

### Mathematical insight
The statement relates the polynomial power operation `poly_pow` to the more general ring power operation `ring_pow` when applied to polynomials. This shows how raising a polynomial to a power can be interpreted within the broader context of ring powers. It leverages the representation of polynomials as elements in a more general series ring.

### Dependencies
- Definitions: `x_poly`, `x_series`
- Theorems: `x_series_use_pow`, `POLY_RING_AS_SUBRING`, `RING_POW_SUBRING_GENERATED`


---

## poly_ring_use_pow

### Name of formal statement
poly_ring_use_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring).
  poly_pow r = ring_pow (poly_ring r (:V))
```

### Informal statement
For any ring `r` of type `R ring`, the polynomial power function `poly_pow r` is equal to the ring power function `ring_pow` applied to the result of `poly_ring r (:V)`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the left-hand side, `poly_pow r`, using the definition of `poly_pow`.
- Then, apply `POLY_RING_AS_SUBRING` and `RING_POW_SUBRING_GENERATED` to complete the proof. This essentially uses the fact that `poly_ring r` creates a subring, allowing the `ring_pow` to correctly compute the power.

### Mathematical insight
This theorem establishes the relationship between the polynomial power operation, `poly_pow`, and the general ring power operation, `ring_pow`, within the context of the polynomial ring construction `poly_ring`. It clarifies that `poly_pow` is essentially a specialization of `ring_pow` to polynomial rings. This is important for reasoning about polynomial arithmetic in the ring-theoretic framework.

### Dependencies
- Definitions: `poly_pow`, `ring_pow`, `poly_ring`
- Theorems: `POLY_RING_AS_SUBRING`, `RING_POW_SUBRING_GENERATED`


---

## poly_pow_0

### Name of formal statement
poly_pow_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_0 = prove(`
  !(r:R ring) p:(V->num)->R.
  poly_pow r p 0 = poly_1 r:(V->num)->R
`,
  once_rw[poly_pow] THEN
  qed[POWSER_RING;RING_POW_0]
);;
```
### Informal statement
For any ring `R` with carrier type `V -> num -> R` (where `V` is a type variable), and any `r` of type `R` that satisfies the ring axioms, and any `p` of type `V -> num -> R` (representing a power series), the power `poly_pow r p 0` is equal to `poly_1 r` (the power series representing 1), where `poly_pow` computes repeated power series multiplication.

### Informal sketch
The proof involves the following steps:
- Initially, we rewrite the statement using the definition of `poly_pow`.
- The definition reduces `poly_pow r p 0` to `poly_1 r`.
- Finally, we complete the proof using theorems related to the power series ring (`POWSER_RING`) and the property that any element raised to the power of 0 equals 1 in a ring (`RING_POW_0`).

### Mathematical insight
The theorem states that raising a power series to the power of 0 yields the power series representing the multiplicative identity (1). This is a fundamental property of exponentiation that extends from numbers to polynomials and, in this case, to power series. This theorem formalizes a basic fact that is often taken for granted in mathematical reasoning and is important for working with power series.

### Dependencies
- Definitions: `poly_pow`, `poly_1`
- Theorems: `POWSER_RING`, `RING_POW_0`


---

## poly_pow_1

### Name of formal statement
poly_pow_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_1 = prove(`
  !(r:R ring) p:(V->num)->R.
  ring_powerseries r p ==>
  poly_pow r p 1 = p
`,
  intro THEN
  once_rw[poly_pow] THEN
  subgoal `(p:(V->num)->R) IN ring_carrier(powser_ring r (:V))` THENL [
    rw[POWSER_RING;IN_ELIM_THM;SUBSET_UNIV] THEN
    simp[]
  ; pass
  ] THEN
  qed[RING_POW_1]
);;
```

### Informal statement
For any ring `r` and any power series `p` over `r` indexed by variables of type `V`, if `p` is a ring powerseries, then the 1st power of `p` according to the ring power series exponentiation operation, `poly_pow r p 1`, equals `p`.

### Informal sketch
The proof proceeds as follows:
- Introduce the ring `r` and the power series `p`.
- Rewrite the goal using the definition of `poly_pow`.
- Show that `p` is an element of the carrier of the power series ring `powser_ring r (:V)`.
  - Simplify using theorems about `POWSER_RING`, `IN_ELIM_THM`, and `SUBSET_UNIV` to complete the proof that `p` is in the ring power series.
- Apply the theorem `RING_POW_1` to complete the proof.

### Mathematical insight
This theorem states that raising a power series to the power of 1 (in the sense of ring powerseries exponentiation) results in the original power series. This is a basic property of exponentiation in any ring and specialized here for power series rings.

### Dependencies
- Definitions: `poly_pow`, `ring_powerseries`, `powser_ring`
- Theorems: `RING_POW_1`, `POWSER_RING`, `IN_ELIM_THM`, `SUBSET_UNIV`

### Porting notes (optional)
The `poly_pow` function is crucial as well as understanding how rings and ring powerseries are represented. Ensure that the target proof assistant has suitable definitions and theorems for handling rings, power series, and exponentiation. The automation steps (`rw`, `simp`) rely on the algebraic simplification capabilities of HOL Light, so you may need to provide explicit rewrite rules or lemmas in other proof assistants.


---

## poly_1_pow

### Name of formal statement
poly_1_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_1_pow = prove(`
  !(r:R ring) n.
  poly_pow r (poly_1 r) n = poly_1 r:(V->num)->R
`,
  once_rw[poly_pow] THEN
  qed[POWSER_RING;RING_POW_ONE]
);;
```
### Informal statement
For any ring `R`, element `r` in `R`, and natural number `n`, the `poly_pow` (polynomial power) of `poly_1` (the polynomial representing the constant 1) raised to the power of `n` is equal to `poly_1`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `poly_pow`.
- Then, discharge the goal using properties of rings (`POWSER_RING`), and the fact that 1 raised to any power is 1 in a ring (`RING_POW_ONE`).

### Mathematical insight
This theorem states that the polynomial which is constantly 1, raised to any power, is still the polynomial which is constantly 1. This is an important property that simplifies reasoning about polynomials and their powers, and is used to establish various algebraic identities.

### Dependencies
- Definitions: `poly_pow`, `poly_1`
- Theorems: `POWSER_RING`, `RING_POW_ONE`


---

## poly_pow_add

### Name of formal statement
poly_pow_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_add = prove(`
  !(r:R ring) (p:(V->num)->R) m n.
  ring_powerseries r p ==>
  poly_pow r p (m+n) = poly_mul r (poly_pow r p m) (poly_pow r p n)
`,
  once_rw[poly_pow] THEN
  intro THEN
  have `(p:(V->num)->R) IN ring_carrier(powser_ring r (:V))` [series_in_full_ring] THEN
  simp[RING_POW_ADD] THEN
  qed[POWSER_RING]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), any formal power series `p` (of type `(V->num)->R`) over `r`, and any natural numbers `m` and `n`, if `p` is a ring power series, then the `(m+n)`-th power of `p` is equal to the formal power series multiplication of the `m`-th power of `p` and the `n`-th power of `p`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `poly_pow`.
- Introduce the variables `r`, `p`, `m`, and `n`.
- Show that `p` is in the carrier of the ring of power series `powser_ring r (:V)`.
- Simplify using the theorem `RING_POW_ADD`, which states that `(a ^ m) * (a ^ n) = a ^ (m + n)` in any ring carrier.
- Finally, the proof is completed by appealing to the theorem `POWSER_RING`.

### Mathematical insight
This theorem establishes a fundamental property of powering formal power series over a ring: the exponentiation of formal power series behaves as expected with respect to addition of exponents, mirroring the behavior of exponentiation in any ring. The `poly_pow` function is defined such that `poly_pow r p n` represents `p` raised to the power `n` within the formal power series ring structure defined by ring `r`. Specifically, it shows that the formal power series analogue of `p^(m+n) = p^m * p^n` holds true, where `*` represents formal power series multiplication, thus aligning with standard algebraic properties of rings.

### Dependencies
- `poly_pow`
- `ring_powerseries`
- `RING_POW_ADD`
- `POWSER_RING`


---

## x_pow_pow

### Name of formal statement
x_pow_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_pow = prove(`
  !(r:R ring) m n.
  poly_pow r (x_pow r m) n
  = x_pow r (m*n)
`,
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0;x_pow_0;ARITH_RULE `m * 0 = 0`]
  ;
    rw[ARITH_RULE `SUC n = n+1`;ARITH_RULE `m*(n+1) = m*n+m`] THEN
    simp[poly_pow_add;poly_pow_1;x_pow_series] THEN
    qed[x_pow_add]
  ]
);;
```

### Informal statement
For any ring `r`, and for all natural numbers `m` and `n`, the polynomial power of `x_pow r m` to the power of `n` is equal to `x_pow r (m*n)`.
Here `x_pow r m` is the formal power series X raised to the m-th power interpreted in the ring `r`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. We need to prove `poly_pow r (x_pow r m) 0 = x_pow r (m*0)`. We simplify `poly_pow r (x_pow r m) 0` to `poly_ring_1 r` which then simplifies to `x_pow r 0`. Finally m*0 = 0.
- Inductive step: Assume `poly_pow r (x_pow r m) n = x_pow r (m*n)`. We aim to prove `poly_pow r (x_pow r m) (SUC n) = x_pow r (m*(SUC n))`.  We rewrite `SUC n` to `n+1` and `m*(n+1)` to `m*n+m`. Then the goal becomes: `poly_pow r (x_pow r m) (n+1) = x_pow r (m*n+m)`. We rewrite `poly_pow r (x_pow r m) (n+1)` to `poly_pow r (x_pow r m) n * x_pow r m`. By the induction hypothesis, `poly_pow r (x_pow r m) n = x_pow r (m*n)`, so we have `x_pow r (m*n) * x_pow r m`. Finally, `x_pow r (m*n) * x_pow r m = x_pow r (m*n+m)` by `x_pow_add`.

### Mathematical insight
This theorem expresses a fundamental property of exponentiation: (x^m)^n = x^(m*n), where x is the formal power series `X`. Formal power series are a canonical structure which enable this style of algebraic manipulation.

### Dependencies
- `poly_pow_0`
- `x_pow_0`
- `x_pow_add`
- `poly_pow_add`
- `poly_pow_1`
- `x_pow_series`


---

## poly_pow_mul

### Name of formal statement
poly_pow_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_mul = prove(`
  !(r:R ring) (p:(V->num)->R) m n.
  ring_powerseries r p ==>
  poly_pow r (poly_pow r p m) n
  = poly_pow r p (m*n)
`,
  once_rw[poly_pow] THEN
  intro THEN
  have `(p:(V->num)->R) IN ring_carrier(powser_ring r (:V))` [series_in_full_ring] THEN
  simp[RING_POW_MUL]
);;
```

### Informal statement
For any ring `r` and any formal power series `p` over `r` (where `p` maps variables of type `V` to natural numbers, and then maps these to ring elements), and for any natural numbers `m` and `n`, if `p` is a ring power series, then raising `p` to the power `m` and then raising the result to the power `n` is equal to raising `p` to the power `m*n`.

### Informal sketch
The theorem is proved as follows:

- Expand the outermost `poly_pow` using its definition (`once_rw[poly_pow]`).
- Introduce the variables `r`, `p`, `m`, and `n` into the assumptions (`intro`).
- Establish that `p` belongs to the carrier of the ring of power series over `r` (`have \`(p:(V->num)->R) IN ring_carrier(powser_ring r (:V))\``) given it is a series in the full ring (`series_in_full_ring`).
- Apply the theorem `RING_POW_MUL` to simplify the expression.

### Mathematical insight
This theorem establishes the property that exponentiation of formal power series satisfies the power of a power rule inherited from the underlying ring theory. This is a fundamental property for reasoning about powers and polynomials in rings.

### Dependencies
- Definitions: `poly_pow`
- Theorems: `RING_POW_MUL`


---

## poly_mul_pow

### Name of formal statement
poly_mul_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_pow = prove(`
  !(r:R ring) (p:(V->num)->R) q n.
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  poly_pow r (poly_mul r p q) n
  = poly_mul r (poly_pow r p n) (poly_pow r q n)
`,
  once_rw[poly_pow] THEN
  intro THEN
  have `(p:(V->num)->R) IN ring_carrier(powser_ring r (:V))` [series_in_full_ring] THEN
  have `(q:(V->num)->R) IN ring_carrier(powser_ring r (:V))` [series_in_full_ring] THEN
  have `poly_mul(r:R ring) = ring_mul(powser_ring r (:V))` [POWSER_RING] THEN
  simp[RING_MUL_POW]
);;
```

### Informal statement
For any ring `r` and polynomials `p` and `q` over the ring `r`, if `p` and `q` are ring power series, then the `n`-th power of `poly_mul r p q` equals `poly_mul r (poly_pow r p n) (poly_pow r q n)`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definition of `poly_pow`.
- Introduce the assumption that the polynomials `p` and `q` are in `ring_carrier(powser_ring r (:V))`.
- Show that `poly_mul(r:R ring) = ring_mul(powser_ring r (:V))` using `POWSER_RING`.
- Simplify using `RING_MUL_POW`.

### Mathematical insight
This theorem states that the polynomial power of the product of two polynomials is equal to the product of the polynomial powers of individual polynomials. This is a useful result when working with polynomials, as it allows us to distribute the power over multiplication. It relies on the fact that polynomials are ring power series and on the properties of multiplication and exponentiation in rings.

### Dependencies
- Definitions: `poly_pow`, `poly_mul`
- Theorems: `POWSER_RING`, `RING_MUL_POW`


---

## poly_deg_pow_le

### Name of formal statement
poly_deg_pow_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_deg_pow_le = prove(`
  !(r:R ring) (p:(V->num)->R) n.
  ring_polynomial r p ==>
  poly_deg r (poly_pow r p n) <= n * poly_deg r p
`,
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0] THEN
    rw[POLY_DEG_1] THEN
    ARITH_TAC
  ;
    intro THEN
    have `ring_polynomial r (poly_pow r (p:(V->num)->R) n)` [poly_pow_poly] THEN
    rw[poly_pow] THEN
    rw[ring_pow] THEN
    rw[GSYM poly_pow;POWSER_RING] THEN
    have `poly_deg r (poly_mul r (p:(V->num)->R) (poly_pow r p n)) <= poly_deg r p + poly_deg r (poly_pow r p n)` [POLY_DEG_MUL_LE] THEN
    have `poly_deg r (poly_pow r (p:(V->num)->R) n) <= n * poly_deg r p` [] THEN
    ASM_ARITH_TAC
  ]
);;
```

### Informal statement
For any ring `r` and any polynomial `p` over `r` (where `p` is a function from variable assignments to ring elements), and any natural number `n`, if `p` is a ring polynomial, then the degree of `p` raised to the power of `n` is less than or equal to `n` times the degree of `p`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. The polynomial `p` to the power of 0 is 1. The degree of 1 is 0. Thus, the degree of `p` to the power of 0, which is 0, is less than or equal to 0 times the degree of `p`, which is also 0.
- Inductive step: Assume the statement holds for `n`. We want to show that it holds for `n+1`.  We rewrite `poly_pow r p (SUC n)` as `ring_mul r p (poly_pow r p n)`. We have that `ring_polynomial r (poly_pow r (p:(V->num)->R) n)` holds by assumption. Then we can use the theorem `POLY_DEG_MUL_LE` which states that the degree of `p * q` is less than or equal to degree of `p` plus the degree of `q`. Thus, `poly_deg r (poly_mul r (p:(V->num)->R) (poly_pow r p n)) <= poly_deg r p + poly_deg r (poly_pow r p n)`. By the inductive hypothesis, we have `poly_deg r (poly_pow r (p:(V->num)->R) n) <= n * poly_deg r p`. Therefore, `poly_deg r (poly_pow r p (SUC n)) <= poly_deg r p + n * poly_deg r p`, and therefore `poly_deg r (poly_pow r p (SUC n)) <= (SUC n) * poly_deg r p`.

### Mathematical insight
This theorem provides an upper bound on the degree of a polynomial raised to a power. The degree of `p^n` is at most `n` times the degree of `p`. Equality holds when the ring is an integral domain (i.e., there are no zero divisors).

### Dependencies
- `ring_polynomial`
- `poly_pow_0`
- `POLY_DEG_1`
- `poly_pow`
- `ring_pow`
- `POWSER_RING`
- `POLY_DEG_MUL_LE`


---

## coeff_pow_infinite_geometric_series

### Name of formal statement
coeff_pow_infinite_geometric_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_pow_infinite_geometric_series = prove(`
  !(r:R ring) c e n.
  c IN ring_carrier r ==>
  coeff n (poly_pow r (infinite_geometric_series r c) (e+1))
  = ring_mul r
      (ring_of_num r (binom(n+e,e)))
      (ring_pow r c n)
`,
  rw[x_series_use_pow] THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby num_WF THEN
  intro THEN
  case `e = 0` THENL [
    simp[ARITH_RULE `0 + 1 = 1`;RING_POW_1;infinite_geometric_series_x_series] THEN
    simp[binom;RING_OF_NUM_1;RING_MUL_LID;RING_POW] THEN
    qed[coeff_infinite_geometric_series]
  ; pass
  ] THEN
  rw[ARITH_RULE `e+1 = SUC e`;ring_pow] THEN
  rw[GSYM x_series_use;coeff_poly_mul_oneindex] THEN
  rw[coeff_infinite_geometric_series] THEN
  subgoal `ring_sum(r:R ring) (0..n) (\a. ring_mul r (ring_pow r c a) (coeff (n - a) (ring_pow (x_series r) (infinite_geometric_series r c) e))) = ring_sum r (0..n) (\a. ring_mul r (ring_pow r c a) (ring_mul r (ring_of_num r (binom((n-a)+(e-1),(e-1)))) (ring_pow r c (n-a))))` THENL [
    sufficesby RING_SUM_EQ THEN
    intro THEN
    num_linear_fact `~(e = 0) ==> (e-1) < e` THEN
    have `coeff (n-a) (ring_pow (x_series(r:R ring)) (infinite_geometric_series r c) ((e-1) + 1)) = ring_mul r (ring_of_num r (binom ((n-a) + (e-1),e-1))) (ring_pow r c (n-a))` [] THEN
    num_linear_fact `~(e = 0) ==> (e-1)+1 = e` THEN
    have `coeff (n-a) (ring_pow (x_series(r:R ring)) (infinite_geometric_series r c) e) = ring_mul r (ring_of_num r (binom ((n-a) + (e-1),e-1))) (ring_pow r c (n-a))` [] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_sum(r:R ring) (0..n) (\a. ring_mul r (ring_pow r c a) (ring_mul r (ring_of_num r (binom((n-a)+(e-1),(e-1)))) (ring_pow r c (n-a)))) = ring_sum r (0..n) (\a. ring_mul r (ring_of_num r (binom((n-a)+(e-1),(e-1)))) (ring_pow r c n))` THENL [
    sufficesby RING_SUM_EQ THEN
    intro THEN
    have `a <= n:num` [IN_NUMSEG_0] THEN
    num_linear_fact `a <= n:num ==> a + (n-a) = n` THEN
    have `ring_mul(r:R ring) (ring_pow r c a) (ring_pow r c (n-a)) = ring_pow r c n` [RING_POW_ADD] THEN
    qed[RING_RULE `ring_mul(r:R ring) A M = N ==> ring_mul r A (ring_mul r B M) = ring_mul r B N`;RING_POW;RING_OF_NUM]
  ; pass
  ] THEN
  subgoal `ring_sum(r:R ring) (0..n) (\a. ring_mul r (ring_of_num r (binom (n - a + e - 1,e - 1))) (ring_pow r c n)) = ring_mul r (ring_sum r (0..n) (\a. ring_of_num r (binom (n - a + e - 1,e - 1)))) (ring_pow r c n)` THENL [
    sufficesby RING_SUM_RMUL THEN
    qed[RING_POW;FINITE_NUMSEG;RING_OF_NUM]
  ; pass
  ] THEN
  subgoal `ring_sum(r:R ring) (0..n) (\a. ring_of_num r (binom (n - a + e - 1,e - 1))) = ring_of_num r (binom (n + e,e))` THENL [
    specialize[`e:num`;`n:num`]binom_reverse_stair_sum THEN
    have `FINITE (0..n)` [FINITE_NUMSEG] THEN
    specialize[`r:R ring`;`\a. binom(n-a+e-1,e-1)`;`0..n`]ring_sum_num THEN
    qed[]
  ; pass
  ] THEN
  simp[]
);;
```
### Informal statement
For any ring `r`, any element `c` in the carrier of `r`, and any natural numbers `e` and `n`, the `n`-th coefficient of the polynomial power `(infinite_geometric_series r c)^(e+1)` is equal to `ring_mul r (ring_of_num r (binom(n+e,e))) (ring_pow r c n)`.

### Informal sketch
The proof proceeds by induction on `e`.
- Base Case: `e = 0`. Simplify both sides of the equation using properties of `binom`, `RING_OF_NUM_1`, `RING_MUL_LID`, `RING_POW` and `coeff_infinite_geometric_series`.
- Inductive Step: Assume the theorem holds for `e`. Rewrite `e+1` as the successor of `e` and use `ring_pow` to split the polynomial power. Apply `coeff_poly_mul_oneindex` along with `coeff_infinite_geometric_series.`
  - The goal is now to prove that a certain `ring_sum` is equal to `ring_sum r (0..n) (\a. ring_mul r (ring_of_num r (binom((n-a)+(e-1),(e-1)))) (ring_pow r c n))`. This is achieved by showing each term in both sums are equal and using the `RING_SUM_EQ` tactic.
  - The preceding sum is then transformed into `ring_mul r (ring_sum r (0..n) (\a. ring_of_num r (binom (n - a + e - 1,e - 1)))) (ring_pow r c n)` by using `RING_SUM_RMUL`.
  - The `ring_sum` part is simplified to `ring_of_num r (binom (n + e,e))` by using `binom_reverse_stair_sum` and `ring_sum_num`.

### Mathematical insight
The theorem provides a formula for calculating the coefficients of powers of the infinite geometric series in a ring. This is useful in various algebraic manipulations and power series expansions.

### Dependencies
- `x_series_use_pow`
- `x_series_use`
- `coeff_poly_mul_oneindex`
- `coeff_infinite_geometric_series`
- `ARITH_RULE`
- `binom`
- `RING_OF_NUM_1`
- `RING_MUL_LID`
- `RING_POW`
- `RING_POW_1`
- `RING_POW_ADD`
- `RING_SUM_EQ`
- `RING_SUM_RMUL`
- `FINITE_NUMSEG`
- `ring_sum_num`
- `binom_reverse_stair_sum`
- `IN_NUMSEG_0`

### Porting notes (optional)
This theorem relies heavily on the `ring` theory and arithmetic simplification in HOL Light. When porting, ensure that the target prover has similar capabilities for rewriting with ring axioms and simplifying arithmetic expressions. The handling of dependent types (as seen in `ring(r:R ring)`) might require adjustments depending on the target system.


---

## pow_infinite_geometric_series

### Name of formal statement
pow_infinite_geometric_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_infinite_geometric_series = prove(`
  !(r:R ring) c e.
  c IN ring_carrier r ==>
  poly_pow r (infinite_geometric_series r c) (e+1)
  = series_from_coeffs (\n.
      ring_mul r
        (ring_of_num r (binom(n+e,e)))
        (ring_pow r c n))
`,
  qed[coeff_pow_infinite_geometric_series;eq_coeff;coeff_series_from_coeffs]
);;
```
### Informal statement
For any ring `r`, and for all `c` and `e`, if `c` is an element of the carrier of the ring `r`, then the `(e+1)`-th power of the infinite geometric series with common ratio `c` in the ring `r` is equal to the series constructed from the coefficients given by the function that maps `n` to the ring product of `ring_of_num r (binom(n+e,e))` and `ring_pow r c n`.

### Informal sketch
The proof establishes that the power of an infinite geometric series is another series whose coefficients can be explicitly computed in terms of binomial coefficients and powers of the common ratio. The proof proceeds as follows:
- First, use `coeff_pow_infinite_geometric_series` to express the coefficient of `poly_pow r (infinite_geometric_series r c) (e+1)` in terms of binomial coefficients. Specifically, this gives the coefficient of `X^n` in `(infinite_geometric_series r c)^(e+1)` as `ring_of_num r (binom(n+e,e)) * ring_pow r c n`.
- Then, the goal is to show the equality between the computed coefficient and the coefficient of general series represented by `series_from_coeffs`.
- Next, use `eq_coeff` to reduce the goal to an equality between coefficients of the two series.
- After that, use `coeff_series_from_coeffs` to simplify the coefficient of a general series, and obtain the desired result.

### Mathematical insight
This theorem provides a closed-form expression for the power of an infinite geometric series. It expresses how raising the geometric series to an integer power transforms its coefficients which are all initially constant to a series where coefficients are a product of binomial coefficients and powers of the constant ratio. It generalizes the original geometric series. This kind of result is used in power series manipulations and combinatorial arguments.

### Dependencies
- `coeff_pow_infinite_geometric_series`
- `eq_coeff`
- `coeff_series_from_coeffs`


---

## pow_infinite_geometric_series_inverse_lemma

### Name of formal statement
pow_infinite_geometric_series_inverse_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_infinite_geometric_series_inverse_lemma = prove(`
  !(r:R ring) c e.
  c IN ring_carrier r ==>
  poly_mul r
    (poly_pow r (one_minus_constx r c) (e+1))
    (poly_pow r (infinite_geometric_series r c) (e+1))
  = poly_1 r
`,
  intro THEN
  have `ring_powerseries(r:R ring) (one_minus_constx r c)` [one_minus_constx_series] THEN
  have `ring_powerseries(r:R ring) (infinite_geometric_series r c)` [infinite_geometric_series_powerseries] THEN
  simp[GSYM poly_mul_pow] THEN
  simp[infinite_geometric_series_inverse] THEN
  qed[poly_1_pow]
);;
```

### Informal statement
For any ring `r`, given that `c` is an element of the carrier of the ring `r`, it holds that the polynomial multiplication of `poly_pow r (one_minus_constx r c) (e+1)` and `poly_pow r (infinite_geometric_series r c) (e+1)` is equal to `poly_1 r`. In other words, (1-cx)^(e+1) * (1 + cx + (cx)^2 + ... )^(e+1) = 1.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions.
- Show that the ring power series `one_minus_constx r c` is a ring power series using `one_minus_constx_series`.
- Show that the ring power series `infinite_geometric_series r c` is a ring power series using `infinite_geometric_series_powerseries`.
- Simplify using `GSYM poly_mul_pow`.
- Simplify using `infinite_geometric_series_inverse`.
- Apply `poly_1_pow` to conclude the proof.

### Mathematical insight
This theorem states that the formal power series representation of `1/(1-cx)` (truncated to the power `e+1`) is the multiplicative inverse of `(1-cx)` (truncated to the power `e+1`) within the ring of polynomials. It's a formal analogue of the geometric series identity a/(1-r). It demonstrates the inverse relationship between the polynomial `one_minus_constx r c` and the `infinite_geometric_series r c` within the context of polynomial rings.

### Dependencies
- Definitions: `ring_carrier`, `poly_mul`, `poly_pow`, `one_minus_constx`, `infinite_geometric_series`, `poly_1`
- Theorems: `one_minus_constx_series`, `infinite_geometric_series_powerseries`, `infinite_geometric_series_inverse`, `poly_1_pow`


---

## pow_infinite_geometric_series_inverse

### Name of formal statement
pow_infinite_geometric_series_inverse

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_infinite_geometric_series_inverse = prove(`
  !(r:R ring) c e.
  c IN ring_carrier r ==>
  poly_mul r
    (poly_pow r (one_minus_constx r c) (e+1))
    (series_from_coeffs (\n.
      ring_mul r
        (ring_of_num r (binom(n+e,e)))
        (ring_pow r c n)))
  = poly_1 r
`,
  intro THEN
  qed[pow_infinite_geometric_series_inverse_lemma;pow_infinite_geometric_series]
);;
```
### Informal statement
For all `r` of type ring, and for all `c` and `e`, if `c` is an element of the carrier of the ring `r`, then the polynomial multiplication of `poly_pow r (one_minus_constx r c) (e+1)` and the series constructed from coefficients given by the lambda expression `\n. ring_mul r (ring_of_num r (binom(n+e,e))) (ring_pow r c n)` is equal to the polynomial one `poly_1 r`.

### Informal sketch
The theorem states that $(1-cx)^{e+1} \sum_{n=0}^{\infty} \binom{n+e}{e} c^n x^n = 1$.
The proof proceeds as follows:
- Introduce the assumptions.
- Apply the lemma `pow_infinite_geometric_series_inverse_lemma` to connect the geometric series to the binomial coefficients.
- Apply `pow_infinite_geometric_series` lemma, which presumably deals with the expansion of the geometric series.
- Conclude the proof.

### Mathematical insight
This theorem expresses an identity relating powers of a binomial $(1-cx)$ and an infinite series with coefficients involving binomial coefficients and powers of $c$. This is a generalization of the standard geometric series formula and is a key result used in complex analysis and combinatorics when manipulating power series.

### Dependencies
- Theorem: `pow_infinite_geometric_series_inverse_lemma`
- Theorem: `pow_infinite_geometric_series`


---

## poly_pow_o_permutes

### Name of formal statement
poly_pow_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_o_permutes = prove(`
  !(r:R ring) p:(V->num)->R S f n m.
  f permutes S ==>
  ring_powerseries r p ==>
  poly_pow r p n (m o f) =
  poly_pow r (\m. p (m o f)) n m
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0] THEN
    qed[poly_1_o_permutes]
  ;
    rw[ARITH_RULE `SUC n = 1 + n`] THEN
    intro THEN
    have `ring_powerseries(r:R ring) (\m:V->num. p(m o (f:V->V)))` [powerseries_o_permutes] THEN
    simp[poly_pow_1;poly_pow_add] THEN
    specialize[
      `r:R ring`;
      `p:(V->num)->R`;
      `poly_pow r p n:(V->num)->R`;
      `S:V->bool`;
      `f:V->V`
    ]poly_mul_o_permutes THEN
    subgoal `poly_pow(r:R ring) (\m. p(m o f)) n = \m. poly_pow r p n (m o (f:V->V))` THENL [
      rw[FUN_EQ_THM] THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any function `p` from a type `V` to the natural numbers, any set `S:V->bool`, any permutation `f:V->V` over `S`, and any natural numbers `n` and `m`, if `f` permutes `S` and `p` is a ring powerseries with respect to `r`, then `poly_pow r p n (m o f)` is equal to `poly_pow r (\m. p (m o f)) n m`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. Using the definition of `poly_pow_0`, the goal reduces to proving `poly_1_o_permutes`.
- Inductive step: Assume the theorem holds for `n`. We want to prove it for `SUC n`. The proof uses the inductive hypothesis, the fact that `ring_powerseries(r:R ring) (\m:V->num. p(m o (f:V->V)))` which is `powerseries_o_permutes`, simplifies using `poly_pow_1` and `poly_pow_add`, and then specializes `poly_mul_o_permutes`. Finally, it proves the lemma `poly_pow(r:R ring) (\m. p(m o f)) n = \m. poly_pow r p n (m o (f:V->V))` using `FUN_EQ_THM` (functional equality).

### Mathematical insight
This theorem states that composing the input of `poly_pow` with a permutation is equivalent to applying the permutation within the power series itself. This is useful for reasoning about symmetry and invariance properties of polynomial powers.

### Dependencies
- `poly_pow_0`
- `poly_1_o_permutes`
- `ARITH_RULE`
- `powerseries_o_permutes`
- `poly_pow_1`
- `poly_pow_add`
- `poly_mul_o_permutes`
- `FUN_EQ_THM`


---

## eval_poly_pow_multi

### Name of formal statement
eval_poly_pow_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_poly_pow_multi = prove(`
  !(r:R ring) (p:(V->num)->R) c U n.
  p IN ring_carrier(poly_ring r U) ==>
  (!v. v IN U ==> c v IN ring_carrier r) ==>
  poly_evaluate r (poly_pow r p n) c
  = ring_pow r (poly_evaluate r p c) n
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0;RING_POW_0;POLY_EVALUATE_1]
  ;
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    intro THEN
    have `ring_polynomial r (p:(V->num)->R)` [POLY_RING;IN_ELIM_THM] THEN
    have `ring_powerseries r (p:(V->num)->R)` [ring_polynomial] THEN
    simp[poly_pow_add;poly_pow_1;RING_POW_ADD;RING_POW_1;POLY_EVALUATE] THEN
    have `ring_polynomial r (poly_pow r (p:(V->num)->R) n)` [poly_pow_poly] THEN
    subgoal `!v:V. v IN poly_vars(r:R ring) p UNION poly_vars r (poly_pow r p n) ==> c v IN ring_carrier r` THENL [
      rw[IN_UNION] THEN
      subgoal `poly_vars r (p:(V->num)->R) SUBSET U` THENL [
        have `(p:(V->num)->R) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET U}` [POLY_RING] THEN
        set_fact `(p:(V->num)->R) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET U} ==> poly_vars r p SUBSET U` THEN
        qed[]
      ; pass
      ] THEN
      subgoal `poly_vars r (poly_pow r (p:(V->num)->R) n) SUBSET U` THENL [
        have `poly_pow r (p:(V->num)->R) n IN {q | ring_polynomial r q /\ poly_vars r q SUBSET U}` [poly_pow_in_poly_ring;POLY_RING] THEN
        set_fact `poly_pow r (p:(V->num)->R) n IN {q | ring_polynomial r q /\ poly_vars r q SUBSET U} ==> poly_vars r (poly_pow r p n) SUBSET U` THEN
        qed[]
      ; pass
      ] THEN
      intro THEN
      have `v:V IN U` [SUBSET] THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `r:R ring`;
      `p:(V->num)->R`;
      `poly_pow r p n:(V->num)->R`;
      `c:V->R`
    ]POLY_EVALUATE_MUL THEN
    rw[know `poly_evaluate(r:R ring) (poly_mul r p (poly_pow r p n)) (c:V->R) = ring_mul r (poly_evaluate r p c) (poly_evaluate r (poly_pow r p n) c)`] THEN
    qed[]
  ]
);;
```

### Informal statement
Let `r` be a ring. Let `p` be a polynomial from `V->num` to `R` that is an element of the carrier of polynomials over the ring `r` with variables from `U`. Let `c` be a function from `V` to `R` such that for all `v` in `U`, `c v` is in the ring carrier of `r`. Then the polynomial `p` raised to the power `n`, evaluated at `c`, is equal to the ring element that results from raising the evaluation of `p` at `c` to the power `n` in the ring `r`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. The theorem reduces to evaluating the constant polynomial 1, which is 1, and raising anything to the power of 0 in a ring leads to 1.
- Inductive step: Assume the result holds for `n`. Prove it for `SUC n = 1+n`.
    - Use the inductive hypothesis and rewrite `poly_pow (p, SUC n)` as `poly_mul p (poly_pow p n)`.
    - Apply the evaluation of a product of polynomials `POLY_EVALUATE_MUL` to transform `poly_evaluate (poly_mul p (poly_pow p n)) c` into `ring_mul (poly_evaluate p c) (poly_evaluate (poly_pow p n) c)`.
    - Verify that the variables on which `c` must be defined is contained in U.
    - Thus, we have `ring_mul (poly_evaluate p c) (ring_pow (poly_evaluate p c) n)` by the induction hypothesis.
    - Finally, rewrite `ring_mul (poly_evaluate p c) (ring_pow (poly_evaluate p c) n)` into `ring_pow (poly_evaluate p c) (1+n)` using ring properties.

### Mathematical insight
This theorem shows that evaluating the power of a polynomial at a point is the same as taking the power of the evaluation of the polynomial at that point. This is a fundamental property connecting polynomial algebra and ring algebra, allowing simplification of calculations.

### Dependencies
- `poly_pow_0`
- `RING_POW_0`
- `POLY_EVALUATE_1`
- `ARITH_RULE `SUC n = 1+n``
- `POLY_RING`
- `IN_ELIM_THM`
- `ring_polynomial`
- `poly_pow_add`
- `poly_pow_1`
- `RING_POW_ADD`
- `RING_POW_1`
- `POLY_EVALUATE`
- `poly_pow_poly`
- `IN_UNION`
- `SUBSET`
- `poly_pow_in_poly_ring`
- `POLY_EVALUATE_MUL`

### Porting notes (optional)
- The theorem relies heavily on rewriting and simplification rules for polynomials and rings.
- Ensure that similar lemmas are available in the target proof assistant.
- Pay close attention to the handling of variables and carrier sets for rings and polynomials.


---

## poly_const_pow

### Name of formal statement
poly_const_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_pow = prove(`
  !(r:R ring) c n.
  c IN ring_carrier r ==>
  poly_const r (ring_pow r c n)
  = poly_pow r (poly_const r c) n:(V->num)->R
`,
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[RING_POW_0;poly_pow_0;poly_1]
  ;
    rw[ring_pow] THEN
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    intro THEN
    have `ring_powerseries r (poly_const r c:(V->num)->R)` [RING_POWERSERIES_CONST] THEN
    simp[poly_pow_add;poly_pow_1] THEN
    simp[POLY_CONST_MUL;RING_POW]
  ]
);;
```
### Informal statement
For any ring `r`, any element `c` in the carrier of `r`, and any natural number `n`, the polynomial constant function that maps every variable to the ring power `c^n` (in ring `r`) is equal to the `n`-th power of the polynomial constant function that maps every variable to `c` (in ring `r`). Note that `n` is a function from a variable to a natural number.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: When `n = 0`, we need to show that `poly_const r (ring_pow r c 0) = poly_pow r (poly_const r c) 0`. This follows directly from the definitions of `RING_POW_0`, `poly_pow_0` and `poly_1`.
- Inductive step: Assume the statement holds for `n`. We need to show it holds for `SUC n` (i.e., `1+n`). We start with `poly_const r (ring_pow r c (SUC n))` and rewrite `SUC n` as `1+n` using `ARITH_RULE`. By the inductive hypothesis and definition of ring powers (`ring_pow`) we have `ring_pow r c (1+n) = ring_mul r c (ring_pow r c n)`. Then we rewrite based on `ring_powerseries r (poly_const r c:(V->num)->R)` and `POLY_CONST_MUL`. We use the definitions of `poly_pow_add`, `poly_pow_1` and `RING_POW` to complete the proof.

### Mathematical insight
This theorem establishes a relationship between constant polynomials and the ring power operation. It states that raising a constant polynomial to a power is equivalent to creating a constant polynomial with the ring element raised to that same power. This is a fundamental property when dealing with polynomials over rings.

### Dependencies
- `RING_POW_0`
- `poly_pow_0`
- `poly_1`
- `ring_pow`
- `ARITH_RULE`
- `RING_POWERSERIES_CONST`
- `poly_pow_add`
- `poly_pow_1`
- `POLY_CONST_MUL`
- `RING_POW`


---

## x_monomial_shift

### Name of formal statement
- x_monomial_shift

### Type of the formal statement
- new_definition

### Formal Content
```ocaml
let x_monomial_shift = new_definition `
  x_monomial_shift (m:1->num)
  = (\v. m v + 1)
`;;
```
### Informal statement
- The function `x_monomial_shift` applied to a function `m` from a type `:1` to the natural numbers is defined as a function that, when given a value `v` of type `:1`, returns the natural number that is the result of applying `m` to `v` and then adding 1 to the result.

### Informal sketch
- The definition introduces `x_monomial_shift` as a function transformer.
- The definition directly specifies the behavior of the transformed function, namely the mapping `v` to `m v + 1`.

### Mathematical insight
- This definition represents a shift in the exponent of a monomial. If `m v` represents the exponent of `x` in a monomial indexed by `v`, then `x_monomial_shift m` represents the monomial where the exponent associated with `v` is increased by 1. This is a fundamental operation when dealing with polynomials and related algebraic structures.

### Dependencies
- None


---

## x_monomial_shift_eq_x_monomial

### Name of formal statement
x_monomial_shift_eq_x_monomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_shift_eq_x_monomial = prove(`
  !m d.
  x_monomial_shift m = x_monomial d
  <=>
  (?c. d = c + 1 /\ m = x_monomial c)
`,
  rw[x_monomial_shift;x_monomial;FUN_EQ_THM] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    witness `m one:num` THEN
    qed[ETA_ONE;one]
  ;
    intro THEN
    qed[]
  ]
);;
```

### Informal statement
For all `m` and `d`, `x_monomial_shift m` is equal to `x_monomial d` if and only if there exists a `c` such that `d` is equal to `c + 1` and `m` is equal to `x_monomial c`.

### Informal sketch
- The proof proceeds by rewriting with the definitions of `x_monomial_shift` and `x_monomial`, as well as the extensionality theorem for functions (`FUN_EQ_THM`).
- Then, the equivalence is split into two implications.
  - For the forward implication, assume `x_monomial_shift m = x_monomial d`. We need to show that there exists a `c` such that `d = c + 1` and `m = x_monomial c`. The proof uses a witness of `m one:num` and further simplification with `ETA_ONE` and the definition of `one`.
  - For the reverse implication, assume that there exists a `c` such that `d = c + 1` and `m = x_monomial c`. We need to show that `x_monomial_shift m = x_monomial d`. This is proved directly by assumption and rewriting earlier definitions.

### Mathematical insight
The theorem characterises when the shifted monomial of some `m` is equal to the monomial of some `d`. Essentially, it says that for `x_monomial_shift m` to be equal to `x_monomial d`, `d` must be one more than some `c`, and `m` has to be the monomial of that `c`.

### Dependencies
- `x_monomial_shift`
- `x_monomial`
- `FUN_EQ_THM`
- `ETA_ONE`
- `one`


---

## x_monomial_shift_is_not_monomial_1

### Name of formal statement
x_monomial_shift_is_not_monomial_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_shift_is_not_monomial_1 = prove(`
  !m.
  ~(x_monomial_shift m = monomial_1)
`,
  rw[x_monomial_shift;monomial_1;FUN_EQ_THM] THEN
  ARITH_TAC
);;
```
### Informal statement
For all natural numbers `m`, it is not the case that `x_monomial_shift m` is equal to `monomial_1`.

### Informal sketch
- The proof proceeds by rewriting using the definitions of `x_monomial_shift` and `monomial_1`.
- `x_monomial_shift m` is defined such that it maps 0 to `m + 1` and shifts other values, whereas `monomial_1` is defined to map 0 to 1 and shifts other values.
- The step `FUN_EQ_THM` unfolds the equality of functions into the statement that they evaluate to the same value at all arguments.
- The goal is then reduced to showing that `!(f:num->num). (!n. f n = if n = 0 then 1 else f(n - 1)) ==> ~(?m. (!n. f n = if n = 0 then m + 1 else f (n - 1)))`.
- The goal can be proved by `ARITH_TAC`

### Mathematical insight
This theorem states that applying the `x_monomial_shift` operation to any monomial `m` will never result in the `monomial_1`. `x_monomial_shift` increases the value at 0, so it will always be different than `monomial_1` that is a function that maps 0 to 1.

### Dependencies
- Definitions:
  - `x_monomial_shift`
  - `monomial_1`
- Theorems:
  - `FUN_EQ_THM`


---

## x_monomial_shift_mul

### Name of formal statement
x_monomial_shift_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_shift_mul = prove(`
  !m n.
  monomial_mul (x_monomial_shift m) n
  = x_monomial_shift (monomial_mul m n)
`,
  rw[FUN_EQ_THM] THEN
  rw[monomial_mul;x_monomial_shift] THEN
  ARITH_TAC
);;
```
### Informal statement
For all `m` and `n`, `monomial_mul` applied to `x_monomial_shift m` and `n` is equal to `x_monomial_shift` applied to `monomial_mul m` and `n`.

### Informal sketch
The proof proceeds as follows:
- Apply the extensionality rule `FUN_EQ_THM`.
- Rewrite using the definitions of `monomial_mul` and `x_monomial_shift`.
- Use arithmetic simplification `ARITH_TAC` to complete the proof.

### Mathematical insight
This theorem demonstrates a compatibility property between the `x_monomial_shift` operation and monomial multiplication `monomial_mul`. Specifically, shifting a monomial before or after multiplication yields the same result.

### Dependencies
- Definitions: `monomial_mul`, `x_monomial_shift`
- Theorems: `FUN_EQ_THM`


---

## x_monomial_mul_shift

### Name of formal statement
x_monomial_mul_shift

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_mul_shift = prove(`
  !m n.
  monomial_mul m (x_monomial_shift n)
  = x_monomial_shift (monomial_mul m n)
`,
  rw[FUN_EQ_THM] THEN
  rw[monomial_mul;x_monomial_shift] THEN
  ARITH_TAC
);;
```
### Informal statement
For all monomials `m` and `n`, multiplying the monomial `m` by the result of shifting the monomial `n` by `x` is equal to shifting the product of the monomials `m` and `n` by `x`.

### Informal sketch
The proof proceeds as follows:
- First, apply `FUN_EQ_THM` to rewrite the equation to a point-free form.
- Then, expand the definitions of `monomial_mul` and `x_monomial_shift`.
- Finally, use arithmetic simplification (`ARITH_TAC`) to complete the proof.

### Mathematical insight
This theorem demonstrates how monomial multiplication interacts with the `x_monomial_shift` which represents the monomial `x`. Multiplying by `x` after multiplying by `m` is the same as multiplying `m` by `x`.

### Dependencies
- Definitions: `monomial_mul`, `x_monomial_shift`
- Theorems: `FUN_EQ_THM`


---

## x_monomial_shift_injective

### Name of formal statement
x_monomial_shift_injective

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_monomial_shift_injective = prove(`
  !m n.
  x_monomial_shift m = x_monomial_shift n ==>
  m = n
`,
  rw[x_monomial_shift;FUN_EQ_THM] THEN
  qed[ARITH_RULE `m + 1 = n + 1 ==> m = n`]
);;
```
### Informal statement
For all natural numbers `m` and `n`, if `x_monomial_shift m` is equal to `x_monomial_shift n`, then `m` is equal to `n`.

### Informal sketch
- The proof starts by rewriting `x_monomial_shift` using its definition.
- After the rewriting, `FUN_EQ_THM` proves `!x. f x = g x ==> f = g`, which transforms the goal into `!n m. lambda x. x pow m * x = lambda x. x pow n * x ==> m = n`. This is equivalent to `!m n. x pow m * x = x pow n * x ==> m = n`
- Finally, an arithmetic rule, `ARITH_RULE`, discharges the equality `m + 1 = n + 1 ==> m = n`, relying on the fact that addition of natural numbers is injective, ultimately proving the injectivity of `x_monomial_shift`.

### Mathematical insight
The theorem states that the function `x_monomial_shift`, which maps a natural number `n` to the function `x |-> x^n * x`, is injective. This is a fundamental property when working with polynomials and their representations, meaning that different exponents result in different monomial functions, which is important for uniquely identifying terms in polynomial expressions.

### Dependencies
- Definitions:
  - `x_monomial_shift`

- Theorems:
  - `FUN_EQ_THM`

- Rules:
  - `ARITH_RULE`


---

## x_derivative

### Name of formal statement
- x_derivative

### Type of the formal statement
- new_definition

### Formal Content
- The full HOL Light statement will be inserted here **after generation**.
```ocaml
let x_derivative = new_definition `
  x_derivative (r:R ring) (p:(1->num)->R)
  = (\m. ring_mul r
          (ring_of_num r (m one + 1))
          (p (x_monomial_shift m)))
`;;
```
### Informal statement
- Given a ring `r` and a function `p` from `(1 -> num) -> R` to `R`, the `x_derivative` of `p` with respect to `r`  is a function that maps `m` to the ring multiplication of `r` with the ring of numbers of `r` applied to `(m*1 + 1)` and `p` applied to `(x_monomial_shift m)`.

### Informal sketch
- The definition introduces the concept of a formal derivative for functions of the type `(1 -> num) -> R` where `R` forms ring. The function `p` can be thought of as a polynomial (represented as a function from monomials to coefficients), and the derivative is defined formally using ring operations.
- The derivative at `m` is obtained multiplying `(m*1 + 1)` by the result of evaluating `p` shifted by `x_monomial_shift m)` using the ring operations defined by `r`.

### Mathematical insight
- This definition formalizes the derivative of a polynomial in a ring-theoretic setting. The function `x_monomial_shift` likely shifts the monomial basis, enabling the definition of differentiation. The definition aligns with the standard power rule for differentiation. It's a formal construction that abstracts the usual calculus derivative to an algebraic setting.

### Dependencies
- `ring_mul`
- `ring_of_num`
- `x_monomial_shift`
- `one`


---

## x_derivative_series

### Name of formal statement
x_derivative_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) p.
  ring_powerseries r p ==>
  ring_powerseries r (x_derivative r p)
```

### Informal statement
For all rings `r` and power series `p`, if `p` is a ring power series over `r`, then the formal derivative of `p` with respect to `x` is also a ring power series over `r`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definitions of `ring_powerseries` and `x_derivative`.
- Then use a pre-proved result `RING_OF_NUM`, `RING_MUL`, `FINITE_MONOMIAL_VARS_1` and `INFINITE` to complete the proof.

### Mathematical insight
This theorem states that the formal derivative of a power series preserves the ring power series property. This is a fundamental result in the theory of formal power series, which ensures that differentiation, a basic operation in calculus, remains within the framework of ring power series.

### Dependencies
- Definitions: `ring_powerseries`, `x_derivative`
- Theorems: `RING_OF_NUM`, `RING_MUL`, `FINITE_MONOMIAL_VARS_1`, `INFINITE`


---

## x_derivative_polynomial

### Name of formal statement
x_derivative_polynomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_polynomial = prove(`
  !(r:R ring) p.
  ring_polynomial r p ==>
  ring_polynomial r (x_derivative r p)
`,
  rw[ring_polynomial] THEN
  intro THENL [
    qed[x_derivative_series]
  ;
    rw[x_derivative] THEN
    have `!m. ~(ring_mul(r:R ring) (ring_of_num r (m one + 1)) (p (x_monomial_shift m)) = ring_0 r) ==> ~(p (x_monomial_shift m) = ring_0 r)` [RING_MUL_RZERO;RING_OF_NUM] THEN
    set_fact `(!m. ~(ring_mul(r:R ring) (ring_of_num r (m one + 1)) (p (x_monomial_shift m)) = ring_0 r) ==> ~(p (x_monomial_shift m) = ring_0 r)) ==> {m | ~(ring_mul(r:R ring) (ring_of_num r (m one + 1)) (p (x_monomial_shift m)) = ring_0 r)} SUBSET {m | ~(p (x_monomial_shift m) = ring_0 r)}` THEN
    have `{m | ~(ring_mul(r:R ring) (ring_of_num r (m one + 1)) (p (x_monomial_shift m)) = ring_0 r)} SUBSET {m | ~(p (x_monomial_shift m) = ring_0 r)}` [] THEN
    specialize_assuming[`x_monomial_shift`;`{m:1->num | ~(p m = ring_0(r:R ring))}`]FINITE_IMAGE_INJ THEN
    have `FINITE {m | x_monomial_shift m IN {m | ~(p m = ring_0(r:R ring))}}` [x_monomial_shift_injective] THEN
    set_fact `{m | x_monomial_shift m IN {m | ~(p m = ring_0(r:R ring))}} = {m | ~(p (x_monomial_shift m) = ring_0(r:R ring))}` THEN
    have `FINITE {m | ~(p (x_monomial_shift m) = ring_0(r:R ring))}` [] THEN
    qed[FINITE_SUBSET]
  ]
);;
```
### Informal statement
For any ring `r` and any polynomial `p` over `r`, if `p` is a ring polynomial, then the formal derivative of `p` (denoted `x_derivative r p`) is also a ring polynomial.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a `ring_polynomial`.
- We need to show `x_derivative r p` is also a `ring_polynomial`. This means showing the set of `m` such that `ring_mul r (ring_of_num r (m one + 1)) (p (x_monomial_shift m))` is not equal to `ring_0 r` is finite.
- The following lemma is proved: `!m. ~(ring_mul(r:R ring) (ring_of_num r (m one + 1)) (p (x_monomial_shift m)) = ring_0 r) ==> ~(p (x_monomial_shift m) = ring_0 r)`.
- Conclude that the set `{m | ~(ring_mul(r:R ring) (ring_of_num r (m one + 1)) (p (x_monomial_shift m)) = ring_0 r)}` is a subset of `{m | ~(p (x_monomial_shift m) = ring_0 r)}`.
- Show that the set `{m | x_monomial_shift m IN {m | ~(p m = ring_0(r:R ring))}}` is finite using the fact that `x_monomial_shift` is injective and `FINITE_IMAGE_INJ`
- The set `{m | x_monomial_shift m IN {m | ~(p m = ring_0(r:R ring))}}` it is equal to `{m | ~(p (x_monomial_shift m) = ring_0(r:R ring))}`.
- Finally, we conclude the set `{m | ~(p (x_monomial_shift m) = ring_0(r:R ring))}` is finite because it is a subset of a finite set. We use `FINITE_SUBSET` to discharge this.

### Mathematical insight
The theorem states that the formal derivative of a polynomial is also a polynomial. This is a fundamental property in algebra. The proof relies on the fact that a polynomial has a finite number of non-zero coefficients. The derivative operation, while formally involving a potentially infinite series, when applied to a polynomial results in another polynomial, maintaining the finiteness property of non-zero coefficients.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `x_derivative`

- Theorems:
  - `x_derivative_series`
  - `RING_MUL_RZERO`
  - `RING_OF_NUM`
  - `x_monomial_shift_injective`
  - `FINITE_IMAGE_INJ`
  - `FINITE_SUBSET`

### Porting notes (optional)
- The proof relies heavily on set theory and manipulations of finiteness properties. Other proof assistants may have different approaches for formalizing finiteness or different levels of automation for set-theoretic reasoning.
- The definition of `x_derivative` and `ring_polynomial` will likely need to be ported first.


---

## coeff_x_derivative

### Name of formal statement
coeff_x_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_derivative = prove(`
  !(r:R ring) p d.
  coeff d (x_derivative r p)
  = ring_mul r (ring_of_num r (d+1)) (coeff (d+1) p)
`,
  intro THEN
  rw[x_derivative;coeff] THEN
  have `x_monomial_shift (x_monomial d) = x_monomial (d+1)` [x_monomial_shift_eq_x_monomial] THEN
  simp[] THEN
  rw[x_monomial]
);;
```
### Informal statement
For any ring `r`, polynomial `p` over `r`, and natural number `d`, the coefficient of `x` to the power of `d` in the derivative of `p` is equal to the ring multiplication of `r` with the ring of numbers `(d+1)` in `r`, and the coefficient of `x` to the power of `(d+1)` in `p`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions `r:R ring`, `p`, and `d`.
- Rewrite using the definitions of `x_derivative` and `coeff`.
- Establish that `x_monomial_shift (x_monomial d) = x_monomial (d+1)`.
- Simplify using standard simplifications.
- Rewrite using the definition of `x_monomial`.

### Mathematical insight
This theorem relates the coefficients of a polynomial and its derivative. It formalizes the standard calculus rule that the derivative of `x^(n+1)` is `(n+1) * x^n`. This is a fundamental result used for manipulating and reasoning about polynomials in a formal setting.

### Dependencies
- Definitions: `x_derivative`, `coeff`, `x_monomial`
- Theorems: `x_monomial_shift_eq_x_monomial`


---

## x_derivative_add_series

### Name of formal statement
x_derivative_add_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_add_series = prove(`
  !(r:R ring) p q.
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  x_derivative r (poly_add r p q)
  = poly_add r (x_derivative r p) (x_derivative r q)
`,
  intro THEN
  have `!m:1->num. p m IN ring_carrier(r:R ring)` [ring_powerseries] THEN
  have `!m:1->num. q m IN ring_carrier(r:R ring)` [ring_powerseries] THEN
  rw[x_derivative;poly_add] THEN
  once_rw[FUN_EQ_THM] THEN
  simp[RING_ADD_LDISTRIB;RING_OF_NUM]
);;
```
### Informal statement
For any ring `r` and any power series `p` and `q` over `r`, if `p` and `q` are ring power series, then the formal derivative of the power series `p + q` is equal to the power series `(dp) + (dq)`, where `dp` is the derivative of `p` and `dq` is the derivative of `q`.

### Informal sketch
The proof proceeds as follows:
- Assume `ring_powerseries r p` and `ring_powerseries r q`.
- Show `!m:1->num. p m IN ring_carrier(r:R ring)` using the hypothesis `ring_powerseries`.
- Show `!m:1->num. q m IN ring_carrier(r:R ring)` using the hypothesis `ring_powerseries`.
- Expand the definitions of `x_derivative` and `poly_add`.
- Rewrite using `FUN_EQ_THM`, which states that two functions are equal if their values are equal for all arguments.
- Simplify using the distributive property of addition over multiplication (`RING_ADD_LDISTRIB`) and the ring structure on natural numbers (`RING_OF_NUM`).

### Mathematical insight
This theorem establishes that the formal derivative operator is linear with respect to addition of power series. This is a fundamental property used in calculus and analysis, as it allows for the differentiation of sums by differentiating term by term. Linearity is vital for manipulating and simplifying expressions involving formal derivatives.

### Dependencies
- Definitions: `x_derivative`, `poly_add`, `ring_powerseries`
- Theorems: `FUN_EQ_THM`, `RING_ADD_LDISTRIB`, `RING_OF_NUM`


---

## x_derivative_neg_series

### Name of formal statement
x_derivative_neg_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_neg_series = prove(`
  !(r:R ring) p.
  ring_powerseries r p ==>
  x_derivative r (poly_neg r p)
  = poly_neg r (x_derivative r p)
`,
  intro THEN
  have `!m:1->num. p m IN ring_carrier(r:R ring)` [ring_powerseries] THEN
  rw[x_derivative;poly_neg] THEN
  once_rw[FUN_EQ_THM] THEN
  simp[RING_MUL_RNEG;RING_OF_NUM]
);;
```
### Informal statement
For any ring `r` and any power series `p` over `r`, if `p` is a ring power series, then the formal derivative of the negation of `p` is equal to the negation of the formal derivative of `p`.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is a ring power series.
- Expand `x_derivative` and `poly_neg` using their definitions.
- Apply the extensionality theorem `FUN_EQ_THM` to reduce the equality of two functions to pointwise equality.
- Simplify using the ring properties `RING_MUL_RNEG` (multiplication by the ring negation) and the definition `RING_OF_NUM` (ring of numbers represented as coefficient sequence).

### Mathematical insight
This theorem states that the derivative of the negation of a formal power series is the negation of the derivative of the formal power series. This is a basic property of derivatives that also holds for formal derivatives of power series. It demonstrates a useful algebraic property that allows simplification and manipulation of formal power series within the formal system

### Dependencies
- Definitions:
    - `x_derivative`
    - `poly_neg`
    - `ring_powerseries`
- Theorems:
    - `FUN_EQ_THM`
    - `RING_MUL_RNEG`
    - `RING_OF_NUM`


---

## x_derivative_sub_series

### Name of formal statement
x_derivative_sub_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_sub_series = prove(`
  !(r:R ring) p q.
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  x_derivative r (poly_sub r p q)
  = poly_sub r (x_derivative r p) (x_derivative r q)
`,
  rw[POLY_SUB] THEN
  qed[RING_POWERSERIES_NEG;x_derivative_add_series;x_derivative_neg_series]
);;
```
### Informal statement
For any ring `r` and power series `p` and `q` over `r`, if `p` and `q` are ring power series, then the formal derivative with respect to `x` of the power series `p - q` is equal to the power series obtained by subtracting the formal derivative with respect to `x` of `q` from the formal derivative with respect to `x` of `p`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `POLY_SUB` to express subtraction in terms of addition and negation.
- Then, apply the theorems: `RING_POWERSERIES_NEG`, `x_derivative_add_series` and `x_derivative_neg_series`.
- Finally, the goal is discharged.

### Mathematical insight
This theorem shows that the formal derivative operator distributes over subtraction of power series. This is a fundamental property needed for reasoning about derivatives of power series, and it's crucial for applications like solving differential equations or analyzing the behavior of analytic functions.

### Dependencies
- Definitions: `POLY_SUB`
- Theorems: `RING_POWERSERIES_NEG`, `x_derivative_add_series`, `x_derivative_neg_series`


---

## x_derivative_poly_const

### Name of formal statement
x_derivative_poly_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_poly_const = prove(`
  !(r:R ring) c.
  x_derivative r (poly_const r c) = poly_0 r
`,
  rw[x_derivative;poly_0;poly_const;x_monomial_shift_is_not_monomial_1;COND_ID] THEN
  once_rw[FUN_EQ_THM] THEN
  qed[FUN_EQ_THM;RING_OF_NUM;RING_MUL_RZERO]
);;
```
### Informal statement
For any ring `R` and any ring element `c` in `R`, the formal derivative `x_derivative` of the constant polynomial `poly_const r c` is the zero polynomial `poly_0 r`.

### Informal sketch
The proof proceeds as follows:
- Expand the definitions of `x_derivative`, `poly_0`, and `poly_const`.
- Apply `x_monomial_shift_is_not_monomial_1` to simplify the derivative of the constant polynomial, showing it to be zero.
- Use `COND_ID` to handle conditional simplification.
- Use `FUN_EQ_THM` to show the functions are equal.
- Apply `RING_OF_NUM` and `RING_MUL_RZERO` which are theorems related to ring properties and multiplication by zero to ultimately prove the equivalence.

### Mathematical insight
This theorem formalizes the basic calculus result that the derivative of a constant function is zero, within the context of formal polynomials. It is a special case of the derivative of a polynomial and is essential for reasoning about polynomial derivatives in general.

### Dependencies
- Definitions: `x_derivative`, `poly_0`, `poly_const`
- Theorems: `x_monomial_shift_is_not_monomial_1`, `FUN_EQ_THM`, `RING_OF_NUM`, `RING_MUL_RZERO`
- Tactics: `COND_ID`


---

## x_derivative_poly_0

### Name of formal statement
x_derivative_poly_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_poly_0 = prove(`
  !(r:R ring).
  x_derivative r (poly_0 r) = poly_0 r
`,
  qed[poly_0;x_derivative_poly_const]
);;
```
### Informal statement
For any ring `r`, the formal derivative of the zero polynomial `poly_0 r` is the zero polynomial `poly_0 r`.

### Informal sketch
The proof proceeds by using the fact that the derivative of a constant polynomial (`x_derivative_poly_const`) is zero and that the zero polynomial `poly_0` is a constant polynomial. The proof consists of discharging the ring assumption and applying rewrite rules based on definitions and previously proven theorems. Specifically it uses the theorem `x_derivative_poly_const` and the definition of `poly_0`.

### Mathematical insight
This theorem establishes a fundamental property of the formal derivative operator applied to polynomials. It states that the zero polynomial, which represents the constant function zero, indeed has a zero derivative. This is consistent with the behavior of derivatives in calculus.

### Dependencies
- Definitions: `poly_0`
- Theorems: `x_derivative_poly_const`


---

## x_derivative_poly_1

### Name of formal statement
x_derivative_poly_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_poly_1 = prove(`
  !(r:R ring).
  x_derivative r (poly_1 r) = poly_0 r
`,
  qed[poly_1;x_derivative_poly_const]
);;
```
### Informal statement
For all real numbers `r` (considered as elements of a ring `R`), the derivative of the polynomial `poly_1 r` with respect to `x` is equal to the polynomial `poly_0 r`.

### Informal sketch
The proof proceeds by showing that the derivative of the polynomial `poly_1 r`, which is `r * X^1`, is the constant polynomial `poly_0 r`, where `r` is a real number. This relies on:
- The definition of `poly_1`, which represents a polynomial of the form `r * X^1`.
- The theorem `x_derivative_poly_const`, which states that the derivative of a constant polynomial (with respect to x) is zero i.e. equal to `poly_0`.

### Mathematical insight
This theorem shows a basic instance of polynomial differentiation, in particular that the derivative of a first-order monomial is a constant and, in this specific case can be simplified to `poly_0`. It serves as a building block for more complex differentiation rules for polynomials.

### Dependencies
- Definitions: `poly_1`, `poly_0`
- Theorems: `x_derivative_poly_const`


---

## x_derivative_poly_const_mul_series

### Name of formal statement
x_derivative_poly_const_mul_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_poly_const_mul_series = prove(`
  !(r:R ring) c p.
  c IN ring_carrier r ==>
  ring_powerseries r p ==>
  x_derivative r (poly_mul r (poly_const r c) p)
  = poly_mul r (poly_const r c) (x_derivative r p)
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_x_derivative] THEN
  have `ring_powerseries(r:R ring) (x_derivative r p)` [x_derivative_series] THEN
  simp[coeff_poly_const_times] THEN
  rw[coeff_x_derivative] THEN
  have `coeff (d+1) p IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  have `ring_of_num r (d+1) IN ring_carrier(r:R ring)` [RING_OF_NUM] THEN
  RING_TAC
);;
```
### Informal statement
For any ring `r` and any constant `c` and any power series `p` over the ring `r`, if `c` is in the carrier of the ring `r` and `p` is a power series over the ring `r`, then the formal derivative of the power series obtained by multiplying `p` by the constant `c`, is equal to the power series obtained by multiplying the formal derivative of `p` by the constant `c`.

### Informal sketch
The proof proceeds as follows:
- Introduce the universally quantified variables `r`, `c`, and `p`.
- Reduce the goal to showing the equality of coefficients by `eq_coeff`.
- Introduce the index `d` as natural number.
- Rewrite the goal using `coeff_x_derivative` to express the coefficient of the formal derivative.
- Show that `x_derivative r p` is a power series.
- Simplify the goal using `coeff_poly_const_times`.
- Rewrite the simplified goal using `coeff_x_derivative` again.
- Establish that `coeff (d+1) p` is in the ring carrier using `coeff_series_in_ring`.
- Show that `ring_of_num r (d+1)` is in ring carrier using `RING_OF_NUM`.
- Use ring tactics to prove the equality.

### Mathematical insight
This theorem expresses the linearity of the formal derivative operator with respect to constant multiplication for formal power series. It's a basic property of differentiation that's essential for manipulating and reasoning about power series.

### Dependencies
- `coeff_x_derivative`
- `x_derivative_series`
- `coeff_poly_const_times`
- `coeff_series_in_ring`
- `RING_OF_NUM`


---

## x_derivative_const_x_pow

### Name of formal statement
x_derivative_const_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_const_x_pow = prove(`
  !(r:R ring) e.
  c IN ring_carrier r ==>
  x_derivative r (const_x_pow r c e)
  = const_x_pow r (ring_mul r (ring_of_num r e) c) (e-1)
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_x_derivative] THEN
  rw[coeff_const_x_pow] THEN
  case `d+1 = e:num` THENL [
    num_linear_fact `d+1 = e:num ==> d = e-1` THEN
    qed[]
  ;
    have `ring_of_num(r:R ring) (d+1) IN ring_carrier r` [RING_OF_NUM] THEN
    case `e = 0` THENL [
      have `ring_of_num(r:R ring) e = ring_0 r` [RING_OF_NUM_0] THEN
      qed[RING_MUL_RZERO;RING_MUL_LZERO]
    ;
      num_linear_fact `~(d+1 = e:num) /\ ~(e = 0) ==> ~(d = e-1)` THEN
      qed[RING_MUL_RZERO]
    ]
  ]
);;
```

### Informal statement
For any ring `r` and elements `c` in the carrier of `r` and any natural number `e`, the derivative with respect to `x` in ring `r` of the polynomial `c * x^e` is equal to the polynomial `(e * c) * x^(e-1)` in ring `r`.

### Informal sketch
The proof proceeds by mathematical induction and rewriting with existing definitions and theorems.

- Introduction and focus on equality of coefficients of polynomials. This is achieved by using `eq_coeff`
- Rewrite using the definitions of `coeff_x_derivative` and `coeff_const_x_pow`.
- Distinguish via cases of the form `d+1 = e:num`, where `d` is the index of an arbitrary monomial. Two possibilities arise from this case split:
  - Case 1: `d+1 = e`. In this case we prove that `d = e-1`.
  - Case 2: `not d+1 = e`. In this case, another case distinction is applied, this time according to whether `e = 0`.
     - Case 2a: `e = 0`, in which case we rewrite using `RING_OF_NUM_0` and use properties of zero, e.g. `RING_MUL_RZERO;RING_MUL_LZERO`.
     - Case 2b: `not e = 0`, in which case `not d = e-1`, and we can prove the result for `RING_MUL_RZERO`

### Mathematical insight
This theorem expresses the standard power rule of differentiation for polynomials in the context of a ring `r`. It establishes that the derivative of a polynomial term of the form `c * x^e` is obtained by multiplying the coefficient `c` by the exponent `e` and reducing the exponent by 1. This result is fundamental in calculus and essential for manipulating and reasoning about derivatives of polynomial functions within HOL Light.

### Dependencies
- `ring_carrier`
- `x_derivative`
- `const_x_pow`
- `ring_mul`
- `ring_of_num`
- `coeff_x_derivative`
- `coeff_const_x_pow`
- `RING_OF_NUM`
- `RING_OF_NUM_0`
- `RING_MUL_RZERO`
- `RING_MUL_LZERO`
- `eq_coeff`

### Porting notes (optional)
- The theorem assumes the concepts of rings and polynomials have already been defined. Ensure these are available in the target proof assistant.
- The proof relies on rewriting and equational reasoning. Ensure that the target proof assistant has similar automation capabilities.
- The use of tactics `num_linear_fact` suggests some arithmetic facts about natural numbers. Ensure these are either available or proven in the target setting.


---

## x_derivative_x_pow

### Name of formal statement
x_derivative_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_x_pow = prove(`
  !(r:R ring) e.
  x_derivative r (x_pow r e)
  = const_x_pow r (ring_of_num r e) (e-1)
`,
  intro THEN
  rw[x_pow] THEN
  have `ring_1(r:R ring) IN ring_carrier r` [RING_1] THEN
  qed[x_derivative_const_x_pow;RING_MUL_RID;RING_OF_NUM]
);;
```
### Informal statement
For any ring `r` and any ring element `e` in `r`, the derivative of `x_pow r e` with respect to `r` is equal to `const_x_pow r (ring_of_num r e) (e-1)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the variables `r` and `e`.
- Rewrite using the definition of `x_pow`.
- Establish that `ring_1 r` belongs to `ring_carrier r`, using the theorem `RING_1`.
- Conclude by applying `x_derivative_const_x_pow`, `RING_MUL_RID`, and `RING_OF_NUM`.

### Mathematical insight
This theorem states the derivative of `x^e` with respect to `x` equals `e*x^(e-1)` in the setting of a ring `r`. The function `x_pow` represents exponentiation in the ring, while `const_x_pow` effectively calculates the product `e*x^(e-1)` where `e` is first coerced to a representation inside the ring, accounting for the ring's specific arithmetic structure.

### Dependencies
- Theorems: `x_derivative_const_x_pow`, `RING_MUL_RID`, `RING_OF_NUM`, `RING_1`
- Definitions: `x_pow`


---

## coeff_x_derivative_poly_mul

### Name of formal statement
coeff_x_derivative_poly_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_derivative_poly_mul = prove(`
  !(r:R ring) p q d.
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  coeff d (x_derivative r (poly_mul r p q))
  = ring_add r
      (coeff d (poly_mul r (x_derivative r p) q))
      (coeff d (poly_mul r p (x_derivative r q)))
`,
  rw[coeff_x_derivative;coeff_poly_mul_oneindex] THEN
  intro THEN
  have `!i. coeff i p IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  have `!i. coeff i q IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  have `ring_0(r:R ring) = ring_mul r (ring_mul r (ring_of_num r 0) (coeff 0 p)) (coeff ((d + 1) - 0) q)` [RING_OF_NUM_0;RING_MUL_LZERO] THEN
  specialize[`r:R ring`;`\a. ring_mul(r:R ring) (ring_mul r (ring_of_num r a) (coeff a p)) (coeff ((d+1)-a) q)`;`d:num`](GSYM ring_sum_shift1) THEN
  specialize[`0`;`d+1`]FINITE_NUMSEG THEN
  have `ring_of_num(r:R ring) (d+1) IN ring_carrier r` [RING_OF_NUM] THEN
  have `!a. a IN (0..d+1) ==> ring_mul r (coeff a p) (coeff ((d + 1) - a) q) IN ring_carrier(r:R ring)` [RING_MUL] THEN
  set_fact_using `!a:num. a IN (0..d) ==> a <= d` [NUMSEG_LE] THEN
  num_linear_fact `!a:num. a <= d ==> d - a = (d+1)-(a+1)` THEN
  have `!a:num. a IN (0..d) ==> d - a = (d+1)-(a+1)` [] THEN
  specialize[`r:R ring`;`\a. ring_mul (r:R ring) (coeff a p) (coeff ((d+1)-a) q)`;`ring_of_num(r:R ring) (d+1)`;`0..d+1`](GSYM RING_SUM_LMUL) THEN
  num_linear_fact `!a:num. a <= d ==> d-a+1 = (d+1)-a` THEN
  have `!a:num. a IN (0..d) ==> d-a+1 = (d+1)-a` [] THEN
  have `ring_of_num r ((d+1)-(d+1)) = ring_0(r:R ring)` [RING_OF_NUM_0;ARITH_RULE `(d+1)-(d+1)=0`] THEN
  have `ring_0(r:R ring) = ring_mul r (coeff (d+1) p) (ring_mul r (ring_of_num r ((d+1)-(d+1))) (coeff ((d+1)-(d+1)) q))` [RING_OF_NUM;RING_MUL_LZERO;RING_MUL_RZERO] THEN
  specialize[`r:R ring`;`\a. ring_mul(r:R ring) (coeff a p) (ring_mul r (ring_of_num r ((d+1)-a)) (coeff ((d+1)-a) q))`;`d:num`](GSYM ring_sum_insert_top) THEN
  simp[] THEN
  have `!a. ring_mul r (ring_mul r (ring_of_num r a) (coeff a p)) (coeff ((d + 1) - a) q) IN ring_carrier(r:R ring)` [RING_OF_NUM;RING_MUL] THEN
  have `!a. ring_mul r (coeff a p) (ring_mul r (ring_of_num r ((d + 1) - a)) (coeff ((d + 1) - a) q)) IN ring_carrier(r:R ring)` [RING_OF_NUM;RING_MUL] THEN
  simp[GSYM RING_SUM_ADD] THEN
  have `!a. ring_add(r:R ring) (ring_mul r (ring_mul r (ring_of_num r a) (coeff a p)) (coeff ((d+1)-a) q)) (ring_mul r (coeff a p) (ring_mul r (ring_of_num r ((d+1)-a)) (coeff ((d+1)-a) q))) = ring_mul r (ring_add r (ring_of_num r a) (ring_of_num r ((d+1)-a))) (ring_mul r (coeff a p) (coeff ((d+1)-a) q))` [RING_RULE `ring_add(r:R ring) (ring_mul r (ring_mul r (ring_of_num r a) (coeff a p)) (coeff ((d+1)-a) q)) (ring_mul r (coeff a p) (ring_mul r (ring_of_num r ((d+1)-a)) (coeff ((d+1)-a) q))) = ring_mul r (ring_add r (ring_of_num r a) (ring_of_num r ((d+1)-a))) (ring_mul r (coeff a p) (coeff ((d+1)-a) q))`] THEN
  simp[GSYM RING_OF_NUM_ADD] THEN
  num_linear_fact `!a. a <= d + 1 ==> a + (d+1) - a = d+1` THEN
  set_fact_using `!a. a IN (0..d+1) ==> a <= d+1` [NUMSEG_LE] THEN
  have `!a. a IN (0..d+1) ==> a+(d+1)-a = d+1` [NUMSEG_LE] THEN
  simp[]
);;
```
### Informal statement
For any ring `r`, and power series `p` and `q` over `r`, and any natural number `d`, if `p` and `q` are ring power series over `r`, then the coefficient of `x^d` in the derivative of the product `p * q` equals the sum of the coefficient of `x^d` in the product of derivative of `p` and `q` with the coefficient of `x^d` in the product of `p` and the derivative of `q`.

### Informal sketch
The proof proceeds as follows:

- Rewrite the left-hand side using `coeff_x_derivative` to express the coefficient of the derivative in terms of a sum involving coefficients of `p` and `q`. Also rewrite the right hand side of the equal sign using `coeff_poly_mul_oneindex`.
- Introduce the assumption that `p` and `q` are ring power series over `r`.
- Show that `coeff i p` and `coeff i q` are elements of the ring carrier of `r` for any `i`.
- Simplify the expression obtained earlier using arithmetic and ring properties, shifting indices of summation, inserting and extracting terms from summations, and applying the ring distributivity law.

### Mathematical insight
This theorem expresses the Leibniz rule for the derivative of a product of power series, specifically relating the coefficients of the power series representing the derivatives and products. It essentially states that the derivative of the product of two power series can be computed in a way analogous to the product rule in differential calculus by considering corresponding coefficients.

### Dependencies
- `coeff_x_derivative`
- `coeff_poly_mul_oneindex`
- `RING_OF_NUM_0`
- `RING_MUL_LZERO`
- `ring_sum_shift1`
- `FINITE_NUMSEG`
- `RING_OF_NUM`
- `RING_MUL`
- `NUMSEG_LE`
- `RING_SUM_LMUL`
- `RING_OF_NUM_0`
- `RING_MUL_RZERO`
- `ring_sum_insert_top`
- `RING_SUM_ADD`
- `RING_OF_NUM_ADD`


---

## x_derivative_mul

### Name of formal statement
x_derivative_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_mul = prove(`
  !(r:R ring) p q.
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  x_derivative r (poly_mul r p q)
  = poly_add r
      (poly_mul r (x_derivative r p) q)
      (poly_mul r p (x_derivative r q))
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  simp[coeff_x_derivative_poly_mul] THEN
  rw[coeff_poly_add]
);;
```
### Informal statement
For any ring `r` and any power series `p` and `q` over `r`, if `p` and `q` are ring power series, then the formal derivative of the product `p * q` is equal to the sum of the products `(p' * q) + (p * q')`, where `p'` and `q'` are the formal derivatives of `p` and `q` respectively, and where all operations (`poly_mul`, `poly_add`, `x_derivative`) are interpreted in the ring `r`.

### Informal sketch
The proof proceeds by:
- Introduction of assumptions.
- Suffices by showing equality of coefficients.
- Introduction of assumptions.
- Simplifying using the definition of `coeff_x_derivative_poly_mul`. This likely expands the coefficient of the derivative of the product in terms of the coefficients of the original power series.
- Rewriting using the definition of `coeff_poly_add`. This likely expands the coefficient of the sum of power series in terms of the coefficients of the individual power series.

The proof establishes the product rule for formal power series by demonstrating the equality of coefficients.

### Mathematical insight
This theorem expresses the familiar product rule from calculus in the context of formal power series. In particular, the derivative of a product of two power series is the sum of the derivative of each power series multiplied by the other. This is a fundamental result for manipulating and reasoning about power series.

### Dependencies
- Definitions: `ring_powerseries`, `poly_mul`, `x_derivative`, `poly_add`
- Theorems: `coeff_x_derivative_poly_mul`, `coeff_poly_add`


---

## x_derivative_mul_const

### Name of formal statement
x_derivative_mul_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_mul_const = prove(`
  !(r:R ring) c q.
  c IN ring_carrier r ==>
  ring_powerseries r q ==>
  x_derivative r (poly_mul r (poly_const r c) q)
  = poly_mul r (poly_const r c) (x_derivative r q)
`,
  intro THEN
  have `ring_powerseries(r:R ring) ((poly_const r c):(1->num)->R)` [RING_POWERSERIES_CONST] THEN
  have `ring_powerseries(r:R ring) (x_derivative r q)` [x_derivative_series] THEN
  have `ring_powerseries(r:R ring) (poly_mul r (poly_const r c) (x_derivative r q))` [RING_POWERSERIES_MUL] THEN
  simp[x_derivative_mul] THEN
  simp[x_derivative_poly_const] THEN
  simp[POLY_MUL_0;RING_MUL_LZERO] THEN
  simp[POWSER_MUL_0] THEN
  qed[POLY_ADD_LZERO]
);;
```

### Informal statement
For all rings `r` of type `R ring`, for all `c` and `q`, if `c` is an element of the carrier of the ring `r` and `q` is a ring power series over `r`, then the formal derivative with respect to `x` of the polynomial multiplication of the constant polynomial `c` by `q` in the ring `r` is equal to the polynomial multiplication of the constant polynomial `c` by the formal derivative with respect to `x` of `q` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions that `r` is a ring, `c` is an element of the ring carrier of `r`, and `q` is a ring power series over `r`.
- Show that `poly_const r c` is a ring power series using `RING_POWERSERIES_CONST`.
- Show that `x_derivative r q` is a ring power series using `x_derivative_series`.
- Show that `poly_mul r (poly_const r c) (x_derivative r q)` is a ring power series using `RING_POWERSERIES_MUL`.
- Simplify the expression `x_derivative r (poly_mul r (poly_const r c) q)` using the derivative of a product rule `x_derivative_mul`.
- Simplify the resulting expression, using the derivative of a constant polynomial `x_derivative_poly_const`.
- Simplify further, employing `POLY_MUL_0` and `RING_MUL_LZERO` (meaning that `0` is a left zero for ring multiplication).
- Then apply `POWSER_MUL_0` (power series multiplication by zero).
- Finally, complete the proof using `POLY_ADD_LZERO` (meaning that `0` is a left zero for polynomial addition).

### Mathematical insight
This theorem states that the derivative of a constant multiple of a power series is the constant multiple of the derivative of the power series. This is a basic property of differentiation and is crucial for manipulating power series.

### Dependencies
- `RING_POWERSERIES_CONST`
- `x_derivative_series`
- `RING_POWERSERIES_MUL`
- `x_derivative_mul`
- `x_derivative_poly_const`
- `POLY_MUL_0`
- `RING_MUL_LZERO`
- `POWSER_MUL_0`
- `POLY_ADD_LZERO`


---

## x_derivative_x_minus_const

### Name of formal statement
x_derivative_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_x_minus_const = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  x_derivative r (x_minus_const r c) = poly_1 r
`,
  intro THEN
  rw[x_minus_const] THEN
  have `ring_powerseries(r:R ring) (x_pow r 1)` [x_pow_series] THEN
  have `ring_powerseries(r:R ring) ((poly_const r c):(1->num)->R)` [RING_POWERSERIES_CONST] THEN
  simp[x_derivative_sub_series] THEN
  simp[x_derivative_x_pow] THEN
  simp[x_derivative_poly_const] THEN
  rw[RING_OF_NUM_1] THEN
  rw[ARITH_RULE `1-1 = 0:num`] THEN
  rw[const_x_pow_0;poly_1] THEN
  qed[poly_sub_0;POLY_CONST;RING_1;RING_POWERSERIES_CONST]
);;
```
### Informal statement
For any ring `r` and any `c` in the carrier of `r`, the derivative of the powerseries representing `x - c` is the powerseries representing the constant 1.

### Informal sketch
The proof unfolds as follows:
- Introduce the assumptions, namely that `r` is a ring and `c` is an element of its carrier.
- Rewrite `x_minus_const r c` using its definition.
- Establish that `x_pow r 1` is a ring powerseries, denoted by the hypothesis `x_pow_series`.
- Establish that `poly_const r c` is a ring powerseries, denoted by `RING_POWERSERIES_CONST`.
- Apply the theorem `x_derivative_sub_series` to compute the derivative of the difference of two power series.
- Apply `x_derivative_x_pow` to compute the derivative of `x_pow r 1` which results in `(&1) * x_pow r (1-1)`.
- Apply `x_derivative_poly_const` to compute the derivative of the constant power series `poly_const r c`, which is 0.
- Simplify `(&1)` to `RING_OF_NUM_1`.
- Simplify `1-1` to 0 in the exponent using `ARITH_RULE`.
- Rewrite `(&1) * x_pow r 0` to `poly_1 r`.
- Reduce `poly_sub_0` to remove the subtraction of 0.
- Finally the other theorems which are used are `POLY_CONST`, `RING_1`, `RING_POWERSERIES_CONST`.

### Mathematical insight
This theorem expresses a fundamental relationship in calculus, namely, that the derivative of the function `x - c` is the constant function `1`. The result is formalized in the context of rings and power series within HOL Light. The derivative of a linear function represented as a power series is proven to be a constant function.

### Dependencies
- `x_minus_const`
- `x_pow_series`
- `RING_POWERSERIES_CONST`
- `x_derivative_sub_series`
- `x_derivative_x_pow`
- `x_derivative_poly_const`
- `RING_OF_NUM_1`
- `ARITH_RULE`
- `const_x_pow_0`
- `poly_1`
- `poly_sub_0`
- `POLY_CONST`
- `RING_1`


---

## x_derivative_one_minus_constx

### Name of formal statement
x_derivative_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_one_minus_constx = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  x_derivative r (one_minus_constx r c) = poly_const r (ring_neg r c)
`,
  intro THEN
  rw[one_minus_constx] THEN
  have `ring_powerseries(r:R ring) (x_pow r 0)` [x_pow_series] THEN
  have `ring_powerseries(r:R ring) (const_x_pow r c 1)` [const_x_pow_series] THEN
  simp[x_derivative_sub_series] THEN
  simp[x_derivative_x_pow] THEN
  simp[x_derivative_const_x_pow] THEN
  rw[ARITH_RULE `0-1 = 0:num`] THEN
  rw[ARITH_RULE `1-1 = 0:num`] THEN
  rw[RING_OF_NUM_0] THEN
  rw[RING_OF_NUM_1] THEN
  rw[const_x_pow_0] THEN
  simp[RING_MUL_LID] THEN
  rw[GSYM poly_0] THEN
  have `ring_powerseries(r:R ring) ((poly_const r c):(1->num)->R)` [RING_POWERSERIES_CONST] THEN
  qed[poly_0_sub;POLY_CONST_NEG]
);;
```
### Informal statement
For any ring `r` and any element `c` in the carrier of `r`, the formal derivative of the power series `one_minus_constx r c` (which represents 1 - cx) is equal to the power series `poly_const r (ring_neg r c)` (which represents the constant -c).

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions that `r` is a ring and `c` is in the carrier of `r`.
- Expand the definition of `one_minus_constx r c`.
- Show that `x_pow r 0` and `const_x_pow r c 1` are ring power series.
- Use `x_derivative_sub_series` to differentiate the difference of series.
- Apply `x_derivative_x_pow` and `x_derivative_const_x_pow` to differentiate `x_pow r 0` and `const_x_pow r c 1` respectively.
- Simplify arithmetic expressions (e.g., `0 - 1 = 0`, `1 - 1 = 0`).
- Simplify using ring properties `RING_OF_NUM_0` and `RING_OF_NUM_1`.
- Use `const_x_pow_0` to simplify `const_x_pow r c 0`.
- Simplify using the left identity of ring multiplication (`RING_MUL_LID`).
- Rewrite with `poly_0` (which states that zero is the empty polynomial).
- Show that `poly_const r c` is a ring powerseries
- Use `poly_0_sub` and `POLY_CONST_NEG` to complete the proof.

### Mathematical insight
This theorem states that the formal derivative of the power series representation of `1 - cx` is equal to `-c`. This aligns with the usual derivative from calculus. It is a key step in showing that formal differentiation in HOL Light aligns with the mathematical concept.

### Dependencies
- `one_minus_constx`
- `x_pow_series`
- `const_x_pow_series`
- `x_derivative_sub_series`
- `x_derivative_x_pow`
- `x_derivative_const_x_pow`
- `RING_OF_NUM_0`
- `RING_OF_NUM_1`
- `const_x_pow_0`
- `RING_MUL_LID`
- `poly_0`
- `RING_POWERSERIES_CONST`
- `poly_0_sub`
- `POLY_CONST_NEG`
- `RING_CARRIER`
- `RING_NEG`
- `ARITH_RULE`

### Porting notes (optional)
- Pay attention to the representations of rings and power series in the target proof assistant.
- Ensure that the definitions of `x_derivative`, `x_pow`, `const_x_pow`, and `poly_const` are compatible.
- The proof relies on simplification and rewriting rules, so the target proof assistant will need equivalent automation.


---

## x_derivative_subring

### Name of formal statement
x_derivative_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_subring = prove(`
  !(r:R ring) G p.
  x_derivative (subring_generated r G) p
  = x_derivative r p
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_x_derivative] THEN
  rw[SUBRING_GENERATED] THEN
  rw[RING_OF_NUM_SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `G`, and any element `p`, the `x_derivative` of the subring generated by `r` and `G` at `p` is equal to the `x_derivative` of `r` at `p`.

### Informal sketch
The proof proceeds as follows:
- First, introduce the assumptions `r`, `G`, and `p`.
- It suffices to prove that the coefficients are equal (`eq_coeff`).
- Introduce the variable.
- Rewrite using the definition of `coeff_x_derivative`.
- Rewrite using the definition of `SUBRING_GENERATED`.
- Rewrite using the definition of `RING_OF_NUM_SUBRING_GENERATED`.

### Mathematical insight
This theorem states that the `x_derivative` of a subring generated by a ring `r` and a set `G` is the same as the `x_derivative` of the original ring `r`. This essentially means that adjoining additional elements (given by `G`) to the ring does not change its `x_derivative`. This is important for understanding how derivatives behave with respect to ring extensions and subrings.

### Dependencies
- `coeff_x_derivative`
- `SUBRING_GENERATED`
- `RING_OF_NUM_SUBRING_GENERATED`


---

## x_derivative_ratio_scaling

### Name of formal statement
x_derivative_ratio_scaling

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_ratio_scaling = prove(`
  !(r:R ring) p q s.
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  ring_powerseries r s ==>
  poly_sub r (
    poly_mul r (
      x_derivative r (poly_mul r s p)
    ) (
      poly_mul r s q
    )
  ) (
    poly_mul r (
      poly_mul r s p
    ) (
      x_derivative r (poly_mul r s q)
    )
  )
  =
  poly_mul r (
    poly_pow r s 2
  ) (
    poly_sub r (
      poly_mul r (x_derivative r p) (q)
    ) (
      poly_mul r (p) (x_derivative r q)
    )
  )
`,
  intro THEN
  simp[x_derivative_mul] THEN
  simp[x_series_use;x_series_sub_use;x_series_use_pow] THEN
  specialize_assuming[`x_series(r:R ring)`
    ;`x_derivative(r:R ring) p`
    ;`x_derivative(r:R ring) q`
    ;`x_derivative(r:R ring) s`
    ;`p:(1->num)->R`
    ;`q:(1->num)->R`
    ;`s:(1->num)->R`
  ](GENL[
    `r:R ring`;`P:R`;`Q:R`;`S:R`;`p:R`;`q:R`;`s:R`
  ](RING_RULE
    `ring_sub(r:R ring) (ring_mul r (ring_add r (ring_mul r (S) p) (ring_mul r s (P))) (ring_mul r s q)) (ring_mul r (ring_mul r s p) (ring_add r (ring_mul r (S) q) (ring_mul r s (Q)))) = ring_mul r (ring_pow r s 2) (ring_sub r (ring_mul r (P) q) (ring_mul r p (Q)))`
  )) THEN
  qed[x_derivative_series;x_series_use]
);;
```
### Informal statement
For all rings `r` (satisfying `ring`), and for all ring power series `p`, `q`, and `s` over `r`, the following equality holds:
```
(x_derivative r (poly_mul r s p) `*` poly_mul r s q) - (poly_mul r s p `*` x_derivative r (poly_mul r s q)) 
= 
(poly_pow r s 2) `*` ((x_derivative r p `*` q) - (p `*` x_derivative r q))
```
where `x_derivative r p` denotes the formal derivative of the power series `p` with respect to `x` in ring `r`, `poly_mul r p q` denotes the multiplication of power series `p` and `q` in ring `r`, `poly_sub r p q` denotes subtraction of power series `p` and `q` in ring `r`, and `poly_pow r s 2` denotes the square of the powerseries `s` under the ring operations in `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Simplify using the definition of the derivative of a product, specifically `x_derivative_mul`.
- Simplify using expansion lemmas for `x_series`, `x_series_sub_use`, and `x_series_use_pow`.
- Specialize the assumptions about `x_series(r:R ring)`, `x_derivative(r:R ring) p`, `x_derivative(r:R ring) q`, `x_derivative(r:R ring) s`, `p:(1->num)->R`, `q:(1->num)->R`, and `s:(1->num)->R` to rewrite the theorem into a ring equality.
- Apply a general ring tactic `RING_RULE` to prove that the left-hand side equals the right-hand side from the ring equality obtained after the specializations.
- Use `x_derivative_series` and `x_series_use` to complete the proof.

Essentially, the proof relies on algebraic manipulation of power series and uses the ring properties to show the equality.

### Mathematical insight
The theorem states that the derivative of a ratio of two power series (scaled by another power series) can be expressed in terms of the derivatives of the original power series and the scaling power series. In other words, it shows that calculating `d/dx (s*p / s*q)` is the same as `(s^2)*(p'q - pq')`. This result simplifies the calculation of derivatives of ratios, making it a valuable tool for manipulating power series.

### Dependencies
- `x_derivative_mul`
- `x_series_use`
- `x_series_sub_use`
- `x_series_use_pow`
- `x_derivative_series`

### Porting notes (optional)
- Porting to other systems will mainly focus on ensuring the `RING_RULE` is appropriately replaced by something that closes the algebraic gaps.
- Ensure the target system equivalents of `x_series_use`, `x_series_sub_use`, `x_series_use_pow` are available to automatically perform the necessary expansions.


---

## poly_sum

### Name of formal statement
poly_sum

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let poly_sum = new_definition `
  poly_sum (r:R ring) (S:X->bool) (p:X->(1->num)->R)
  = ring_sum(x_series r) S p
`;;
```
### Informal statement
For a ring `r` (of type `R ring`), a set `S` of elements of type `X` (i.e., `S: X->bool`), and a function `p` that maps an element of type `X` and a function from natural numbers to `R` (i.e. `(1->num)->R`) to an element of `R`, the polynomial sum `poly_sum r S p` is defined to be the ring sum of the `x_series r` over the set `S` with respect to the function `p`.

### Informal sketch
*   The definition introduces `poly_sum` as a specialized version of `ring_sum`, applied specifically to power series.
*   `poly_sum r S p` calculates the ring sum of power series evaluated for each `x` in `S`. Specifically, `x_series r` likely represents the formal power series ring with coefficients from the ring `r`, and `p` specifies, for each `x` in `S`, the power series to be summed.

### Mathematical insight
The `poly_sum` definition provides a way to sum power series over a specified set, which is a fundamental operation in analysis and algebra, particularly in topics such as generating functions and formal language theory. This definition simplifies the expression of sums of power series, leveraging the existing `ring_sum` definition.

### Dependencies
- Definition: `ring_sum`
- Definition: `x_series`


---

## poly_sum_empty

### Name of formal statement
poly_sum_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_empty = prove(`
  !(r:R ring) p:X->(1->num)->R.
  poly_sum r {} p = poly_0 r
`,
  rw[poly_sum] THEN
  rw[RING_SUM_CLAUSES] THEN
  qed[x_series_use]
);;
```
### Informal statement
For any ring `R` (with ring operations denoted by `r`), any type `X`, and any function `p` from `X` to functions from `(1->num)` to `R`, the sum of `p` over the empty set (indexed by `(1->num)`) is equal to the zero polynomial `poly_0 r` in the ring `R`.

### Informal sketch
- The proof starts by unfolding the definition of `poly_sum` using the rule `rw[poly_sum]`. This reveals that the `poly_sum` over a set is defined as the ring sum `RING_SUM` of the function `p` over that set.
- Then, the definition of `RING_SUM` applied to the empty set is unfolded using the rule `rw[RING_SUM_CLAUSES]`. This simplifies the `RING_SUM` over the empty set to the zero element of the ring, which is represented by `poly_0 r`.
- Finally, the goal is proven using `qed[x_series_use]`.

### Mathematical insight
This theorem states that summing any function over an empty set results in the zero element (here, the zero polynomial) of the ring. This is a fundamental property of summation (and more generally, aggregation) and is crucial for establishing the correctness of various algebraic manipulations involving polynomials. Namely, zero polynomials serve as a base case for induction.

### Dependencies
- Definitions: `poly_sum`, `poly_0`, `RING_SUM_CLAUSES`


---

## poly_sum_insert

### Name of formal statement
poly_sum_insert

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_insert = prove(`
  !(r:R ring) p:X->(1->num)->R S t.
  FINITE S ==>
  poly_sum r (t INSERT S) p =
  (if ring_powerseries r (p t) ==> t IN S
   then poly_sum r S p
   else poly_add r (p t) (poly_sum r S p))
`,
  rw[poly_sum] THEN
  rw[x_series_use] THEN
  qed[RING_SUM_CLAUSES]
);;
```

### Informal statement
For any ring `r`, any function `p` from `X` to functions from the unit type `1` to `r`, and any finite set `S` and element `t` in `X`, if `S` is finite, then the polynomial sum of `p` over `t INSERT S` (the set `S` with `t` inserted) is equal to the following: If `p t` can be represented as a ring powerseries of `r`, which is equivalent to `t` being already in `S`, then it is equal to the polynomial sum of `p` over `S`. Otherwise, it is equal to the ring addition of `p t` to the polynomial sum of `p` over `S`.

### Informal sketch
- The proof starts by rewriting the left-hand side using the definition of `poly_sum`.
- Next, the rule for `x_series_use` unfolds the sum over the inserted set `t INSERT S`.
- Finally, the `RING_SUM_CLAUSES` tactic likely applies distributivity and other simplifications from the underlying ring structure to complete the argument.

### Mathematical insight
The theorem expresses how the polynomial sum changes when inserting a new element into the set over which the sum is taken. If the function `p` applied to the element `t` could be represented as a ring power series (`ring_powerseries r (p t)`), then the element `t` must already belong to the set `S`. If the function `p` applied to an element `t` cannot be represented as a ring power series (`ring_powerseries r (p t)`), then the sum over the set `t INSERT S` is equal to adding `p t` to the sum over the original set `S`. This result is fundamental for manipulating and reasoning about polynomial sums.

### Dependencies
- `poly_sum`
- `x_series_use`
- `RING_SUM_CLAUSES`


---

## poly_sum_delete2

### Name of formal statement
poly_sum_delete2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_delete2 = prove(`
  !(r:R ring) S p:X->(1->num)->R t.
  FINITE S ==>
  t IN S ==>
  ring_powerseries r (p t) ==>
  poly_sum r S p
  = poly_add r (p t) (poly_sum r (S DELETE t) p)
`,
  intro THEN
  rw[poly_sum;x_series_use] THEN
  have `p(t:X) IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
  qed[ring_sum_delete2]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any finite set `S` of type `X`, any function `p` from `X` to functions from `1` to `num` to `R`, and any element `t` of type `X`, if `S` is finite, `t` is in `S`, and for all `t`, `p t` is a ring power series, then `poly_sum r S p` is equal to `poly_add r (p t) (poly_sum r (S DELETE t) p)`.

### Informal sketch
The proof proceeds by induction on the finite set `S`.

- The base case is handled by `rw[poly_sum;x_series_use]`.
- We assume `p(t:X)` is a ring power series using `x_series_use`.
- The inductive step uses `ring_sum_delete2`.

### Mathematical insight
This theorem describes a recursive relationship for the `poly_sum` over a finite set `S`. It states that the sum of polynomials `p t` over the set `S` can be computed by taking the polynomial at a particular element `t` in `S` (`p t`) and adding it to the polynomial sum over the set `S` with `t` removed (`S DELETE t`). This is a standard way to decompose a summation.

### Dependencies
- Definitions: `poly_sum`, `ring_powerseries`, `poly_add`
- Theorems: `ring_sum_delete2`


---

## poly_sum_series

### Name of formal statement
poly_sum_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) p:X->(1->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  ring_powerseries r (poly_sum r S p)
```

### Informal statement
For any ring `r` (of type `R`), for any function `p` from a set `X` to power series over `r` (i.e., `p` takes an element of `X` and returns a function from natural numbers to `R`), and for any set `S` of type `X`, if `S` is finite, and if for all `s` in `S`, the power series `p s` is a ring power series over `r`, then the power series `poly_sum r S p` is a ring power series over `r`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: `S` is empty. Then `poly_sum r S p` is zero, and zero is a ring power series. This follows by rewriting with `poly_sum_empty` and then applying `RING_POWERSERIES_0`.
- Inductive step: Assume the theorem holds for all sets `S'` such that `S'` is finite, and we have to show the theorem for `INSERT x S` for an arbitrary `x` in `X`. Assume also that every element `s` in `INSERT x S` the power series `p s` is a ring power series with ring `r`, which we will denote as `ring_powerseries r (p s)`. We rewrite `poly_sum r (INSERT x S) p` to `p x + poly_sum r S p` using lemma `poly_sum_insert`. By assumption, `ring_powerseries r (p x)` holds and by induction hypothesis, `ring_powerseries r (poly_sum r S p)` also holds. The required result `ring_powerseries r (p x + poly_sum r S p)` follows by `RING_POWERSERIES_ADD`.

### Mathematical insight
The theorem states that the `poly_sum` operation preserves the "ring power series" property, that is, if we sum a finite collection of ring power series, indexed by a set `S`, the result is also a ring power series. This is an important property, as it allows one to construct more complex ring power series from simpler ones.

### Dependencies
- `FINITE`
- `ring_powerseries`
- `poly_sum`
- `poly_sum_empty`
- `poly_sum_insert`
- `RING_POWERSERIES_0`
- `RING_POWERSERIES_ADD`


---

## series_sum_series_multi

### Name of formal statement
series_sum_series_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) p:X->(V->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  ring_powerseries r (ring_sum(powser_ring r (:V)) S p)
```

### Informal statement
For any ring `r` (of type `R ring`), any set `S` (of type `X`), and any function `p` mapping elements of `S` to power series over `r` (specifically, functions from `V` to numbers in `R`), if `S` is finite and for every `s` in `S`, the power series `p s` is a ring power series over `r`, then the ring sum of the power series `p s` over the set `S` in the powerseries ring `powser_ring r (:V)` is also a ring power series over `r`.

### Informal sketch
The proof proceeds by induction on the finite set `S`.

- Base case: When `S` is empty, the ring sum is the zero element of the powerseries ring `powser_ring r (:V)`, which is a ring power series over `r` by `RING_POWERSERIES_0`.
- Inductive step: Assume the result holds for `S`. We want to show it holds for `INSERT x S`. We are given that `S` is finite and that all `s IN S` satisfy `ring_powerseries r (p s)`. Also given that ring `ring_powerseries r (p x)`. The ring sum over `INSERT x S` is the sum of `p x` and the ring sum over `S`. Since both `p x` and the ring sum over `S` are ring power series over `r`, their sum is also a ring power series over `r` by `RING_POWERSERIES_ADD`.

### Mathematical insight
The theorem states that summing a finite collection of ring power series results in another ring power series. This is a closure property that is important in formal reasoning about power series.

### Dependencies
- `FINITE`
- `RING_SUM_CLAUSES`
- `POWSER_RING`
- `RING_POWERSERIES_0`
- `RING_POWERSERIES_ADD`

### Porting notes (optional)
The main challenge in porting this theorem might be in recreating the setup and definitions for ring power series and the ring sum operation, since this is a domain specific concept. The finiteness condition on the set `S` is crucial for the inductive proof, and should be carefully considered when porting to other systems.


---

## poly_sum_ring_sum_x_poly

### Name of formal statement
poly_sum_ring_sum_x_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_ring_sum_x_poly = prove(`
  !(r:R ring) p:X->(1->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  poly_sum r S p = ring_sum(x_poly r) S p
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_sum_empty;RING_SUM_CLAUSES] THEN
    qed[x_poly_use]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    have `(p(x:X):(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_use] THEN
    simp[poly_sum_insert;RING_SUM_CLAUSES] THEN
    rw[x_poly_use]
  ]
);;
```

### Informal statement
For any ring `r` with carrier type `R`, any function `p` from a type `X` to functions from `1->num` to `R`, and any finite set `S` of type `X`, if for all `s` in `S`, `p s` is a ring polynomial with respect to the ring `r`, then the polynomial sum of `p` over `S` with respect to `r` is equal to the ring sum of `x_poly r` over `S` with respect to `p`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is the empty set, then both `poly_sum r S p` and `ring_sum(x_poly r) S p` are zero, using `poly_sum_empty` and `RING_SUM_CLAUSES`. The equality follows directly using `x_poly_use`.
- Inductive step: Assuming the theorem holds for all sets `S'` such that `FINITE S'`, we need to show it holds for `x INSERT S`, where `x` is an element of type `X` and `S` is a set of elements of type `X`. The assumption is that `FINITE S ==> (!s. s IN S ==> ring_polynomial r (p s)) ==> poly_sum r S p = ring_sum(x_poly r) S p` holds and need to show `FINITE(x INSERT S) ==> (!s. s IN x INSERT S ==> ring_polynomial r (p s)) ==> poly_sum r (x INSERT S) p = ring_sum (x_poly r) (x INSERT S) p`
  - Assuming `FINITE (x INSERT S)` and `!s. s IN x INSERT S ==> ring_polynomial r (p s)`, we apply `poly_sum_insert` to expand `poly_sum r (x INSERT S) p` to `poly_sum r S p + p x` and apply `RING_SUM_CLAUSES` to expand `ring_sum (x_poly r) (x INSERT S) p` to `ring_sum (x_poly r) S p + x_poly r (p x)`.
  - We apply `x_poly_use` to show that `x_poly r (p x) = p x`.
  - By the induction hypothesis, `poly_sum r S p = ring_sum (x_poly r) S p`. From both sides we have `poly_sum r S p + p x = ring_sum (x_poly r) S p + p x`, hence `poly_sum r (x INSERT S) p = ring_sum (x_poly r) (x INSERT S) p`

### Mathematical insight
This theorem relates the `poly_sum` function, used when dealing with ring polynomials, to the more general `ring_sum` function, showing their equivalence when summing over a set of ring polynomials. The function `x_poly r` lifts a function from `1->num` to `R` to a ring polynomial with respect to ring `r`. The significance lies in establishing a connection between polynomial summation and generic ring summation, simplifying reasoning about polynomial structures.

### Dependencies
- `poly_sum_empty`
- `RING_SUM_CLAUSES`
- `x_poly_use`
- `poly_sum_insert`

### Porting notes (optional)
When porting to other proof assistants:
- Ensure the `FINITE` predicate and set operations (e.g., `INSERT`) are appropriately defined in the target system.
- The handling of ring structures (i.e. `R ring`) will need to align with the type class or module system of the target proof assistant.
- Be mindful of the specific syntax for defining and manipulating polynomials (i.e. `ring_polynomial`).


---

## poly_sum_poly

### Name of formal statement
poly_sum_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_poly = prove(`
  !(r:R ring) p:X->(1->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  ring_polynomial r (poly_sum r S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_sum_empty] THEN
    qed[RING_POLYNOMIAL_0]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    simp[poly_sum_insert] THEN
    qed[RING_POLYNOMIAL_ADD]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `p` from a type `X` to functions from `1->num` to `R`, and any set `S` of type `X`, if `S` is a finite set and for all `s` in `S`, `ring_polynomial r (p s)` holds, then `ring_polynomial r (poly_sum r S p)` holds.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty.  Then `poly_sum r S p` is `0`, and `ring_polynomial r 0` holds.
- Inductive step: Assume the property holds for all subsets of `S`. Let `x` be an element in `S`. We need to show that if `ring_polynomial r (p x)` and `ring_polynomial r (poly_sum r S p)` hold, then `ring_polynomial r (poly_sum r (INSERT x S) p)` holds. This follows from the definition of `poly_sum` on insertions (`poly_sum_insert`), which gives `poly_sum r (INSERT x S) p = p x + poly_sum r S p`, and the fact that `ring_polynomial` is closed under addition (`RING_POLYNOMIAL_ADD`).

### Mathematical insight
The theorem states that if we sum a finite set of ring polynomials, the result is also a ring polynomial. This is a fundamental property that ensures closure under summation within to the ring polynomial construction. This theorem is essential for manipulating sums of polynomials.

### Dependencies
- Definitions: `ring_polynomial`, `poly_sum`, `FINITE`
- Theorems: `poly_sum_empty`, `poly_sum_insert`, `RING_POLYNOMIAL_0`, `RING_POLYNOMIAL_ADD`


---

## poly_sum_eq

### Name of formal statement
poly_sum_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_eq = prove(`
  !(r:R ring) S:X->bool p:X->(1->num)->R q:X->(1->num)->R.
  (!s. s IN S ==> p s = q s) ==>
  poly_sum r S p = poly_sum r S q
`,
  qed[poly_sum;RING_SUM_EQ]
);;
```
### Informal statement
For any ring `r`, set `S` of type `X`->bool, and functions `p` and `q` from `X` to functions from `1` to `nums` to elements of `r`, if for all `s` in `S`, `p s` is equal to `q s`, then the polynomial sum of `p` over `S` with respect to `r` is equal to the polynomial sum of `q` over `S` with respect to `r`.

### Informal sketch
The proof relies on the theorem `RING_SUM_EQ`, which states that if two functions are equal on a set, then their sums over that set are equal. The hypothesis `!s. s IN S ==> p s = q s` indicates that `p` and `q` are equivalent when applied to elements of `S`.
The theorem `poly_sum_eq` demonstrates that if two functions are pointwise equal on a set, then their polynomial sums over that set are equal. This follows directly from `RING_SUM_EQ` applied to the functions `p` and `q` when they are restricted to the set `S`.

### Mathematical insight
This theorem states a basic substitution property for polynomial sums: if two functions agree on the set over which the sum is taken, then the sums are equal. This is a generalization of the usual substitution property and highlights the functional nature of summation within HOL Light.

### Dependencies
- Definitions: `poly_sum`
- Theorems: `RING_SUM_EQ`


---

## coeff_poly_sum

### Name of formal statement
coeff_poly_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_sum = prove(`
  !(r:R ring) p:X->(1->num)->R d:num S:X->bool.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  coeff d (poly_sum r S p) =
  ring_sum r S (\s. coeff d (p s))
`,
  rw[poly_sum] THEN
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;GSYM x_series_use;coeff_poly_0]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    have `(p(x:X):(1->num)->R) IN ring_carrier(x_series r)` [x_series_use] THEN
    have `coeff d (p(x:X)) IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
    simp[RING_SUM_CLAUSES] THEN
    rw[coeff_series_add] THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r` (with carrier type `R`), any function `p` from some type `X` to power series over `r` (i.e., functions from `1->num` to `R`), any natural number `d`, and any finite set `S` of type `X`, such that for all `s` in `S`, `p s` is a ring power series over `r`, the `d`-th coefficient of the power series `poly_sum r S p` (the sum of the power series `p s` over all `s` in `S`) is equal to the sum over `S` of the `d`-th coefficients of the power series `p s`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: `S` is empty. The theorem reduces to showing that the `d`-th coefficient of `poly_sum r & {} p` is equal to `ring_sum r &{} (\s. coeff d (p s))`. But `poly_sum r &{} p` equals the zero power series `x_series r ring_zero` and the `ring_sum` over the empty set is `ring_zero r`, therefore reducing the conclusion to `coeff d (x_series r ring_zero)` equals `ring_zero r` which is `coeff_poly_0`.
- Inductive step: Assume that the theorem holds for all subsets of `S`. We want to prove that the theorem holds for `INSERT x S`, where `x` is an element of type `X`.
    - We assume `FINITE (INSERT x S)`.
    - We have `ring_powerseries r (p x)`.
    - We need to show that `coeff d (poly_sum r (INSERT x S) p) = ring_sum r (INSERT x S) (\s. coeff d (p s))`.
    - By the definition of `poly_sum`, `poly_sum r (INSERT x S) p = p x + poly_sum r S p`.
    - By the definition of `ring_sum`, `ring_sum r (INSERT x S) (\s. coeff d (p s)) = ring_plus r (coeff d (p x)) (ring_sum r S (\s. coeff d (p s)))`.
    - Therefore, we need to show that `coeff d (p x + poly_sum r S p) = ring_plus r (coeff d (p x)) (ring_sum r S (\s. coeff d (p s)))`.
    - By `coeff_series_add`, `coeff d (p x + poly_sum r S p) = ring_plus r (coeff d (p x)) (coeff d (poly_sum r S p))`.
    - By the inductive hypothesis, `coeff d (poly_sum r S p) = ring_sum r S (\s. coeff d (p s))`.
    - This completes the inductive step.

### Mathematical insight
This theorem states that the coefficients of the sum of power series are equal to the sum of their corresponding coefficients. This is a fundamental property used for manipulating power series and performing calculations with them. The theorem generalizes the linearity of coefficients over a finite sum operation.

### Dependencies
- `FINITE`
- `ring_powerseries`
- `poly_sum`
- `coeff`
- `ring_sum`
- `RING_SUM_CLAUSES`
- `x_series_use`
- `coeff_poly_0`
- `INSERT`
- `coeff_series_in_ring`
- `coeff_series_add`
- `RING_SUM_CLAUSES`
- `ring_carrier`
- `ring_zero`
- `HOL_SUM_def`


---

## x_derivative_sum

### Name of formal statement
x_derivative_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_sum = prove(`
  !(r:R ring) p (S:X->bool).
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  x_derivative r (poly_sum r S p)
  = poly_sum r S (\s. x_derivative r (p s))
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (x_derivative r (p s))` [x_derivative_series] THEN
  simp[coeff_poly_sum] THEN
  rw[coeff_x_derivative] THEN
  simp[coeff_poly_sum] THEN
  have `ring_of_num(r:R ring) (d+1) IN ring_carrier r` [RING_OF_NUM] THEN
  have `!s:X. s IN S ==> coeff (d+1) (p s) IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  simp[RING_SUM_LMUL]
);;
```
### Informal statement
For any ring `r` and any function `p` mapping from a type `X` to the type of formal power series over `r`, if `S` is a finite set of type `X` such that for all `s` in `S`, `p s` is a ring power series over `r`, then the derivative of the sum of the power series `p s` over the set `S` is equal to the sum of the derivatives of the power series `p s` over the set `S`.

### Informal sketch
The proof proceeds by showing that the coefficients of the power series on both sides of the equation are equal.
- The proof starts by introducing assumptions and reducing the goal to showing the equality of coefficients of the power series on both sides (`eq_coeff`).
- It is shown that if each `p s` is a ring power series, then the derivative of each `p s` is also a ring power series (`x_derivative_series`).
- The coefficient of the derivative of the sum is simplified using `coeff_poly_sum` and `coeff_x_derivative`.
- Further simplification using `coeff_poly_sum` is applied to the right-hand side.
- It is shown that the natural number `d+1` is an element of the carrier of the ring `r` (`RING_OF_NUM`).
- It is shown that the coefficient of `p s` at `d+1` is an element of the carrier of the ring `r` (`coeff_series_in_ring`).
- Finally, `RING_SUM_LMUL` is used to complete the proof.

### Mathematical insight
This theorem demonstrates the linearity of the formal derivative operator with respect to finite sums of formal power series. This is a fundamental property used extensively in calculus and analysis. The theorem extends the analogous property of derivatives of ordinary functions to the setting of formal power series.

### Dependencies
- `ring_powerseries`
- `FINITE`
- `x_derivative`
- `poly_sum`
- `coeff_poly_sum`
- `coeff_x_derivative`
- `RING_OF_NUM`
- `coeff_series_in_ring`
- `RING_SUM_LMUL`

### Porting notes (optional)
- The theorem relies on the definition of formal power series and their derivatives. A port to another proof assistant requires defining these concepts accordingly.
- The HOL Light library `RING` contains a substantial number of results about rings and sums. Care must be taken to ensure that all necessary properties of rings and finite sums are available in the target system.
- Tactics such as `sufficesby` are specific to HOL Light but can be emulated by similar proof structuring tactics in other systems.


---

## poly_deg_sum_le

### Name of formal statement
poly_deg_sum_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_deg_sum_le = prove(`
  !(r:R ring) (p:X->(1->num)->R) n S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> poly_deg r (p s) <= n) ==>
  poly_deg r (poly_sum r S p) <= n
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_sum_empty;POLY_DEG_0;ARITH_RULE `0 <= n`]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    simp[poly_sum_insert] THEN
    have `ring_polynomial(r:R ring) (poly_sum r (S:X->bool) p)` [poly_sum_poly] THEN
    qed[POLY_DEG_ADD_LE;ARITH_RULE `d <= n /\ e <= n /\ c <= MAX d e ==> c <= n:num`]
  ]
);;
```

### Informal statement
For any ring `r`, any function `p` from a type `X` to polynomials over `r` (represented as functions from `(1->num)` to `R`), any natural number `n`, and any finite set `S` of type `X`, if every element `s` in `S` has `p s` as a ring polynomial over `r`, and the degree of `p s` is less than or equal to `n` for all `s` in `S`, then the degree of the polynomial sum of `p s` over `S` with respect to `r` is less than or equal to `n`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.

- Base case: If `S` is empty, the polynomial sum over `S` is 0. The degree of 0 is 0, which is less than or equal to `n`.
- Inductive step: Assume that the theorem holds for all subsets of size less than the size of `S`. Let `x` be an element in `S`.
    - We can write the polynomial sum over `S` as the polynomial sum over `x INSERT S`, which is equal to the summand at `x` plus the polynomial sum over `S \ {x}`.
    - By the inductive hypothesis, the degree of the polynomial sum over `S \ {x}` is less than or equal to `n`.
    - We also have `poly_deg r (p x) <= n` from the assumptions.
    - Now we can use `POLY_DEG_ADD_LE` and `ARITH_RULE` with `d <= n /\ e <= n /\ c <= MAX d e ==> c <= n` to show that the degree of the polynomial sum over `S` is less than or equal to `n`.

### Mathematical insight
This theorem states that if we sum a finite number of polynomials, each of which has degree less than or equal to `n`, then the resulting polynomial will also have a degree less than or equal to `n`. This is a fundamental property of the degree of polynomials.

### Dependencies

- Definitions:
  - `ring_polynomial`
  - `poly_deg`
  - `poly_sum`
- Theorems:
  - `POLY_DEG_0`
  - `poly_sum_empty`
  - `poly_sum_insert`
  - `poly_sum_poly`
  - `POLY_DEG_ADD_LE`
- Tactics:
  - `FINITE_INDUCT_STRONG`

### Porting notes (optional)
- The most important part to porting this is having the `FINITE_INDUCT_STRONG` induction principle. Many proof assistants have libraries containing similar principles, or it could be derived from other theories.
- The `ARITH_RULE` tactic in HOL Light automatically proves arithmetic facts. A similar automation or manual proof may be needed in other proof assistants.


---

## poly_sum_lmul

### Name of formal statement
poly_sum_lmul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_lmul = prove(`
  !(r:R ring) (p:X->(1->num)->R) c S.
  ring_powerseries r c ==>
  FINITE S ==>
  (!s:X. s IN S ==> ring_powerseries r (p s)) ==>
  poly_sum r S (\s. poly_mul r c (p s))
  = poly_mul r c (poly_sum r S p)
`,
  intro THEN
  rw[poly_sum;x_series_use] THEN
  have `c IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
  have `!s:X. s IN S ==> p s IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
  specialize[`x_series(r:R ring)`;`p:X->(1->num)->R`;`c:(1->num)->R`;`S:X->bool`]RING_SUM_LMUL THEN
  qed[]
);;
```
### Informal statement
For any ring `r` (with carrier `R`), any function `p` from a type `X` to powerseries over `r` (i.e., functions of type `(1->num)->R`), any element `c` that is a powerseries over `r` (i.e., of type `(1->num)->R`), and any set `S` of type `X`, if `c` is a ring powerseries over `r`, `S` is a finite set, and for all `s` in `S`, `p s` is a ring powerseries over `r`, then the powerseries sum of `poly_mul r c (p s)` over `S` is equal to `poly_mul r c` with the powerseries sum of `p s` over `S`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Rewrite using the definition of `poly_sum` and `x_series_use`.
- Show that `c` and `p s` are in the ring carrier of `x_series(r:R ring)`.
- Specialize the theorem `RING_SUM_LMUL` with appropriate instantiations.
- Conclude the proof.

### Mathematical insight
The theorem `poly_sum_lmul` states that multiplication by a constant distributes over a finite sum of powerseries within a ring `r`. This is an important property for manipulating and simplifying expressions involving powerseries. It essentially lifts the ring property of distributivity to the level of power series.

### Dependencies
- Definitions: `poly_sum`, `x_series_use`
- Theorems: `RING_SUM_LMUL`


---

## poly_sum_const

### Name of formal statement
poly_sum_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_const = prove(`
  !(r:R ring) (p:(1->num)->R) S.
  ring_powerseries r p ==>
  FINITE S ==>
  poly_sum r S (\s:X. p)
  = poly_mul r (poly_const r (ring_of_num r (CARD S))) p
`,
  intro THEN
  rw[poly_sum] THEN
  have `p IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
  simp[ring_sum_const;GSYM x_series_use] THEN
  qed[ring_of_num_x_series]
);;
```
### Informal statement
For any ring `r` with ring operations and type `R`, any function `p` from `(1->num)` to `R` (i.e., a series `p` where the argument is a function from 1 to natural numbers), and any set `S`: if `p` is a ring power series with respect to `r` and `S` is finite, then the polynomial sum of `p` over `S` is equal to polynomial multiplication of `p` with a constant polynomial whose value is the ring representation of the cardinality of `S`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions: `r` is a ring, `p` is a power series over `r` and `S` is finite.
- Rewrite using the definition of `poly_sum`.
- Show that `p` is an element of the carrier of power series over ring `r` using introduction rule for `x_series`.
- Simplify using `ring_sum_const` and `x_series_use`.
- Apply `ring_of_num_x_series` to conclude the proof.

### Mathematical insight
This theorem states that summing a power series `p` over a finite set `S` is equivalent to multiplying `p` by the constant polynomial representing the size of `S`. This is a fundamental property when dealing with finite sums in a ring-theoretic context, especially when working with power series. It allows one to replace a summation with a multiplication by a constant factor, which can simplify calculations.

### Dependencies
- Definitions: `poly_sum`, `ring_powerseries`, `poly_mul`, `poly_const`, `ring_of_num`, `ring_carrier`
- Theorems: `ring_sum_const`, `ring_of_num_x_series`


---

## poly_sum_poly_multi

### Name of formal statement
poly_sum_poly_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_poly_multi = prove(`
  !(r:R ring) p:X->(V->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  ring_polynomial r (ring_sum(poly_ring r (:V)) S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES] THEN
    simp[GSYM poly_use] THEN
    qed[RING_POLYNOMIAL_0]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(r:R ring) (p(x:X):(V->num)->R)` [] THEN
    simp[RING_SUM_CLAUSES] THEN
    simp[GSYM poly_use] THEN
    qed[RING_POLYNOMIAL_ADD]
  ]
);;
```

### Informal statement
For any ring `r`, any function `p` from a type `X` to functions from a type `V` to the ring `r`, and any set `S` of type `X`, if `S` is finite and for all `s` in `S`, `p s` is a ring polynomial, then the ring sum of `p s` over `S` with respect to the polynomial ring over `r` and `V` is also a ring polynomial.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- In the base case, when `S` is empty, the ring sum is zero, which is a ring polynomial.
- In the inductive step, we assume that the theorem holds for all subsets of `x INSERT S`. We need to show that it holds for `x INSERT S` itself, assuming that for all `s` in `x INSERT S`, `p s` is a ring polynomial. Then, the ring sum over `x INSERT S` can be expressed as the sum of `p x` and the ring sum over `S`. Since both `p x` and the ring sum over `S` are ring polynomials (by assumption and the inductive hypothesis, respectively), their sum is also a ring polynomial.

The rewriting with `RING_SUM_CLAUSES` simplifies the ring sum over `INSERT` into the sum of the element and the ring sum over the rest of the set. The `RING_POLYNOMIAL_0` and `RING_POLYNOMIAL_ADD` theorems are used to show that zero and the sum of two ring polynomials are ring polynomials, respectively. The use of `poly_use` is to unfold the definition of `ring_polynomial`.

### Mathematical insight
This theorem establishes that the sum of a finite collection of ring polynomials is itself a ring polynomial. This is a fundamental property of ring polynomials and is crucial for constructing more complex polynomial expressions and proving properties about them.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `RING_SUM_CLAUSES`
- `RING_POLYNOMIAL_0`
- `RING_POLYNOMIAL_ADD`
- `poly_use`
- `ring_polynomial`
- `ring_sum`

### Porting notes (optional)
The main challenge in porting this theorem is likely to be the handling of finiteness and the automation concerning ring polynomials. Other proof assistants may require explicit proofs of finiteness or may have different ways of representing and manipulating polynomials. The tactics `GEN_TAC` and `SIMP` may need adaptation depending on the automation capabilities of other provers.


---

## poly_sum_subring_multi

### Name of formal statement
poly_sum_subring_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_subring_multi = prove(`
  !(r:R ring) G (p:X->(V->num)->R) S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial(subring_generated r G) (p s)) ==>
  ring_sum(poly_ring(subring_generated r G) (:V)) S p
  = ring_sum(poly_ring r (:V)) S p
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES] THEN
    rw[POLY_RING] THEN
    rw[poly_0;poly_const;SUBRING_GENERATED]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(subring_generated r G) (p(x:X):(V->num)->R)` [] THEN
    have `ring_polynomial r (p(x:X):(V->num)->R)` [ring_polynomial_if_subring] THEN
    have `!s:X. s IN S ==> ring_polynomial(subring_generated(r:R ring) G) (p s:(V->num)->R)` [] THEN
    simp[RING_SUM_CLAUSES;GSYM poly_use] THEN
    have `ring_polynomial (subring_generated r G) (ring_sum(poly_ring r (:V)) S (p:X->(V->num)->R))` [poly_sum_poly_multi] THEN
    qed[poly_add_subring;ring_polynomial]
  ]
);;
```
### Informal statement
For any ring `r` with carrier type `R`, any type `X`, any function `p` from `X` to functions from `V` to `num` to `R`, and any finite set `S` of type `X`, if for all `s` in `S`, `p s` is a ring polynomial over the subring generated by `r` and `G` with respect to variables of type `V`, then the ring sum of `p` over `S` with respect to the polynomial ring over the subring generated by `r` and `G` with respect to variables of type `V`, equals the ring sum of `p` over `S` with respect to the polynomial ring over `r` with respect to variables of type `V`.

### Informal sketch
The proof proceeds by strong induction on the cardinality of the finite set `S`. The base case, where `S` is empty, follows directly from the definition of `ring_sum`. For the inductive step, assuming the result holds for all subsets of `S` with smaller cardinality, we consider an arbitrary element `x` in `S`. We show that if each `p s` is a polynomial over the ring generated by `r` w.r.t. `V`, then the ring sum over the subring is equal to the ring sum over `r` w.r.t. `V`. This involves several steps:
- First, we establish the hypothesis regarding `ring_polynomial` for `p x`.
- We prove that each `p s` where `s` is any element of `S` is a ring polynomial over the subring generated by `r` w.r.t. `V`.
- After simplifying using `RING_SUM_CLAUSES` and `poly_use` to expand the sums, we need to prove that the ring polynomial over the subring generated can be derived by summing the polynomial with the ring w.r.t. `V`.
- Finally, we infer that the ring polynomial over the subring is constructed and shown to be equal to the ring using `poly_add_subring`, and by applying `ring_polynomial`.

### Mathematical insight
This theorem states that when summing polynomials, if each polynomial in the sum is a polynomial over a subring, then the sum can be computed either in the polynomial ring over the original ring or in the polynomial ring over the subring, yielding the same result. This is a useful result for simplifying calculations and reasoning about polynomials over subrings.

### Dependencies
- `RING_SUM_CLAUSES`
- `POLY_RING`
- `poly_0`
- `poly_const`
- `SUBRING_GENERATED`
- `ring_polynomial_if_subring`
- `GSYM poly_use`
- `poly_sum_poly_multi`
- `poly_add_subring`
- `ring_polynomial`


---

## ring_polynomial_subring_sum

### Name of formal statement
ring_polynomial_subring_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_polynomial_subring_sum = prove(`
  !(r:R ring) G p:X->(V->num)->R S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial(subring_generated r G) (p s)) ==>
  ring_polynomial(subring_generated r G) (ring_sum(poly_ring r (:V)) S p)
`,
  simp[GSYM poly_sum_subring_multi] THEN
  qed[RING_SUM;poly_in_full_ring]
);;
```
### Informal statement
Given a ring `r` with carrier type `R`, a set `G` of generators of a subring, a type `X`, and a function `p` mapping elements of `X` to polynomials over the ring `r` with formal variables of type `V`, and a set `S` of type `X`.  If `S` is finite, and for all `s` in `S`, the polynomial `p s` is a polynomial over the subring of `r` generated by `G`, then the sum (over `S`) of `p s` (considered as a polynomial over the ring `r` with variables in `V`) is also a polynomial over the subring of `r` generated by `G`.  Here the sum is taken in the polynomial ring over `r` with variables of type `V`.

### Informal sketch
The proof proceeds as follows:
- Apply `GSYM poly_sum_subring_multi` to rewrite the goal. This likely expands the `ring_sum` which constructs the summation over the finite set. The goal is now in a form such that `RING_SUM` and `poly_in_full_ring` apply.
- Apply the tactic `RING_SUM`, which probably appeals to closure of the ring sum operation in `ring_polynomial`.
- Apply `poly_in_full_ring` which likely shows that a polynomial that has coefficients in a subring is also a polynomial in the full ring.
- Apply `qed` to complete the proof.

### Mathematical insight
This theorem states that if we have a finite sum of polynomials, where each polynomial has coefficients in a subring generated by some set `G`, then the resulting sum also has coefficients in the same subring. The key idea is that subrings are closed under addition, thus the summation preserves the property of coefficients lying within the subring. This is a standard result useful when reasoning about polynomial rings and their subrings.

### Dependencies
- `GSYM`
- `poly_sum_subring_multi`
- `RING_SUM`
- `poly_in_full_ring`


---

## poly_sum_restrict_subset

### Name of formal statement
poly_sum_restrict_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_sum_restrict_subset = prove(`
  !(r:R ring) S:X->bool U p.
  S SUBSET U ==>
  poly_sum r U (\s. if s IN S then p s else poly_0 r)
  = poly_sum r S p
`,
  rw[poly_sum;x_series_use] THEN
  intro THEN
  specialize[
    `S:X->bool`;
    `x_series(r:R ring)`;
    `U:X->bool`;
    `p:X->(1->num)->R`
  ]RING_SUM_RESTRICT_SET THEN
  set_fact `S SUBSET U:X->bool ==> {x | x IN U /\ S x} = S` THEN
  rw[IN] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and sets `S` and `U` of type `X->bool`, and any function `p` from `X` to a ring, if `S` is a subset of `U`, then the summation of `p(s)` over `U` with the restriction that if `s` is in `S`, then `p(s)` otherwise zero element of the ring is equal to the summation of `p(s)` over `S`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `poly_sum` and rewrite with `x_series_use`.
- Introduce the assumptions and quantifiers.
- Specialize the theorem `RING_SUM_RESTRICT_SET` with `S`, `x_series(r:R ring)`, `U` and `p:X->(1->num)->R`.
- Set the fact that  `S SUBSET U:X->bool ==> {x | x IN U /\ S x} = S`.
- Rewrite using the definition of `IN`.
- Conclude the proof.

### Mathematical insight
This theorem states that when computing a sum over a larger set `U`, where the terms outside a smaller set `S` are set to zero, the result is the same as computing the sum directly over the smaller set `S`. This is a fundamental property of summations and is often used to simplify calculations.

### Dependencies
- Definitions: `poly_sum`, `x_series_use`, `IN`
- Theorems: `RING_SUM_RESTRICT_SET`


---

## poly_const_sum

### Name of formal statement
poly_const_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_sum = prove(`
  !(r:R ring) f:X->R S.
  FINITE S ==>
  (!s. s IN S ==> f s IN ring_carrier r) ==>
  poly_const r (ring_sum r S f) =
  poly_sum r S (\s. poly_const r (f s))
`,
  GEN_TAC THEN
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;poly_sum_empty] THEN
    rw[POLY_CONST_0]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    have `ring_powerseries r (poly_const r (f(x:X)):(1->num)->R)` [RING_POWERSERIES_CONST] THEN
    simp[RING_SUM_CLAUSES;poly_sum_insert] THEN
    qed[POLY_CONST_ADD;RING_SUM]
  ]
);;
```

### Informal statement
For any ring `r` (with carrier `ring_carrier r`), any set `S` of type `X`, and any function `f` from type `X` to the carrier of `r`, if `S` is finite, and if for every `s` in `S`, `f s` is in the carrier of `r`, then the polynomial constant of the ring sum of `f s` over `S` is equal to the ring sum of the polynomial constant of `f s` over `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: When `S` is empty, both sides of the equation reduce to the polynomial constant of the ring's zero element, using `RING_SUM_CLAUSES`, `poly_sum_empty`, and `POLY_CONST_0`.
- Inductive step: Assuming the property holds for any subset of `S`, we want to show that it holds for `x INSERT S`.
  - We introduce the assumption that `s IN S ==> s IN x INSERT S` and `(x:X) IN x INSERT S`.
  - We establish the property that `ring_powerseries r (poly_const r (f(x:X)):(1->num)->R)` using `RING_POWERSERIES_CONST`.
  - Simplify using `RING_SUM_CLAUSES` and `poly_sum_insert`.
  - Finally, apply the induction hypothesis and manipulate the expressions using `POLY_CONST_ADD` and `RING_SUM` to complete the proof.

### Mathematical insight
This theorem states that forming a constant polynomial from the sum of elements is equivalent to summing the constant polynomials of those elements. This is a fundamental property when dealing with polynomials and ring homomorphisms. The theorem connects ring sums and polynomial constructions, providing a way to move between algebraic structures via constant polynomial embeddings.

### Dependencies
- `RING_SUM_CLAUSES`
- `poly_sum_empty`
- `POLY_CONST_0`
- `RING_POWERSERIES_CONST`
- `poly_sum_insert`
- `POLY_CONST_ADD`
- `RING_SUM`


---

## poly_product

### Name of formal statement
poly_product

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let poly_product = new_definition `
  poly_product (r:R ring) (S:X->bool) (p:X->(1->num)->R)
  = ring_product(x_series r) S p
`;;
```
### Informal statement
For any ring `r` and any set `S` of type `X->bool` and any `p` of type `X->(1->num)->R`, the polynomial product `poly_product r S p` is equal to `ring_product(x_series r) S p`.

### Informal sketch
This definition introduces `poly_product` as a specialization of the more general `ring_product` operating on formal power series (`x_series`). It essentially defines the product of a family of power series indexed by a set `S`. The family of series is given by `p`, which for each index `x` in `S` provides a power series, i.e., a function from natural numbers to ring elements.
The `ring_product` function takes the ring structure (in this instance, power series) and constructs the product.

*   The `x_series r` represents the ring of formal power series over the ring `r`.
*   The `S` represents the index set over which the product is taken.
*   The `p` represents the family of power series to be multiplied, indexed by `S`.

### Mathematical insight
This definition provides a way to define products of power series in a formal manner. The power series are indexed by an arbitrary type `X`, and the product is taken over a subset `S` of `X`. This is a common construction in algebra. It provides a way to define more complex power series operations using a general-purpose higher-order function `ring_product`.

### Dependencies
*   Definitions: `ring_product`, `x_series`


---

## poly_product_empty

### Name of formal statement
poly_product_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_empty = prove(`
  !(r:R ring) p:X->(1->num)->R.
  poly_product r {} p = poly_1 r
`,
  rw[poly_product] THEN
  rw[RING_PRODUCT_CLAUSES] THEN
  qed[x_series_use]
);;
```
### Informal statement
For any ring `r` (with type `R ring`), and any function `p` from a type `X` to functions from `(1 -> num)` to `R`, the polynomial product `poly_product r {} p` over the empty set {} equals `poly_1 r`.

### Informal sketch
The proof proceeds as follows:
- First, apply the definition of `poly_product`.
- Then, simplify using the clauses for `RING_PRODUCT_CLAUSES`, which likely specifies how products over empty sets are handled in rings.
- Finally, apply `qed[x_series_use]` to complete the proof, probably using a theorem about power series.

### Mathematical insight
This theorem states that the product of polynomials over an empty set is the multiplicative identity for polynomials, `poly_1 r`. This is a standard convention in mathematics, analogous to the product of no numbers being 1 or the sum of no numbers being 0.

### Dependencies
- Definition: `poly_product`
- Theorem: `RING_PRODUCT_CLAUSES`
- Theorem: `x_series_use` (likely related to power series and used in the concluding step)


---

## poly_product_insert

### Name of formal statement
poly_product_insert

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_insert = prove(`
  !(r:R ring) p:X->(1->num)->R S t.
  FINITE S ==>
  poly_product r (t INSERT S) p =
  (if ring_powerseries r (p t) ==> t IN S
   then poly_product r S p
   else poly_mul r (p t) (poly_product r S p))
`,
  rw[poly_product] THEN
  rw[x_series_use] THEN
  qed[RING_PRODUCT_CLAUSES]
);;
```

### Informal statement
For any ring `r`, any function `p` from a type `X` to power series over the ring `R`, any finite set `S` of type `X`, and any element `t` of type `X`, if `S` is finite, then the product of power series `p x` for `x` in `t INSERT S` equals `poly_product r S p` if `p t` is a power series implies `t` belongs to `S`; otherwise, it equals `poly_mul r (p t) (poly_product r S p)`.

### Informal sketch
The proof proceeds by:
- Rewriting `poly_product r (t INSERT S) p` using the definition of `poly_product`.
- Then rewriting using `x_series_use`, which is applied to expand `poly_series` in the definition of `poly_product`.
- Discharging the goal using `RING_PRODUCT_CLAUSES`

### Mathematical insight
This theorem provides a recursive way to compute the product of a finite set of power series. It shows how adding an element `t` to the set `S` affects the product. If the power series `p t` is already in the product (because `p t` being a ring power series implies `t` is already in `S`), then adding `t` doesn't change the overall product. Otherwise, we multiply the existing product by `p t`. This is a fundamental result for manipulating and calculating with products of power series indexed by elements of a finite set.

### Dependencies
- `poly_product`
- `x_series_use`
- `RING_PRODUCT_CLAUSES`


---

## poly_product_1

### Name of formal statement
poly_product_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_1 = prove(`
  !(r:R ring) S.
  poly_product r S (\s:X. poly_1 r)
  = poly_1 r
`,
  rw[poly_product] THEN
  rw[x_series_use] THEN
  rw[RING_PRODUCT_1]
);;
```
### Informal statement
For any ring `r` and any set `S`, the polynomial product of the set `S` of polynomials, where each polynomial in `S` is the polynomial that is constantly 1 (denoted `poly_1 r`), is equal to the polynomial that is constantly 1 in the ring `r`.

### Informal sketch
The proof proceeds by:
- Rewriting with the definition of `poly_product`. The definition expands the product of a set of polynomials into a single polynomial using `x_series_use`.
- Rewriting with `x_series_use`. This replaces the polynomial product with the constant polynomial of the ring product of 1.
- Rewriting with `RING_PRODUCT_1`. This simplifies the ring product of a set of elements all equal to 1, which is 1 itself. This shows the polynomial is a constant polynomial equal to 1, completing the proof.

### Mathematical insight
The theorem states a fundamental property about polynomial products. When multiplying a set of polynomials that are all equal to the constant polynomial 1, the result is the constant polynomial 1. This is analogous to the identity property in multiplication, extended to polynomials.

### Dependencies
- Definitions: `poly_product`, `poly_1`
- Theorems: `x_series_use`, `RING_PRODUCT_1`


---

## poly_product_eq

### Name of formal statement
poly_product_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_eq = prove(`
  !(r:R ring) p:X->(1->num)->R q S.
  (!s. s IN S ==> p s = q s) ==>
  poly_product r S p = poly_product r S q
`,
  rw[poly_product] THEN
  qed[RING_PRODUCT_EQ]
);;
```
### Informal statement
For any ring `r`, any type `X`, any function `p` from `X` to functions from `1 -> num` to `R`, any function `q` from `X` to functions from `1 -> num` to `R`, and any set `S`, if for all `s` in `S`, `p s` equals `q s`, then the polynomial product of `p` over `S` with respect to `r` equals the polynomial product of `q` over `S` with respect to `r`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `poly_product` using the rewrite tactic.
- Apply the theorem `RING_PRODUCT_EQ` to conclude the proof. The theorem `RING_PRODUCT_EQ` states that if two functions are equal on a set, then their products over that set are equal.

### Mathematical insight
The theorem states that if two functions `p` and `q` are pointwise equal on a set `S`, then their polynomial products over `S` are equal. This is a natural and expected property of products: if we are only concerned with the product of a function over a set, then the values of the function outside of the set do not matter. This theorem is useful for simplifying expressions involving polynomial products by replacing a function with another that is equal on the domain of interest.

### Dependencies
- Definition: `poly_product`
- Theorem: `RING_PRODUCT_EQ`


---

## poly_product_series_multi

### Name of formal statement
poly_product_series_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_series_multi = prove(`
  !(r:R ring) p:X->(V->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  ring_powerseries r (ring_product(powser_ring r (:V)) S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;POWSER_RING] THEN
    qed[RING_POWERSERIES_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(r:R ring) (p(x:X):(V->num)->R)` [] THEN
    simp[RING_PRODUCT_CLAUSES;POWSER_RING] THEN
    qed[RING_POWERSERIES_MUL]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `p` from a type `X` to functions from `V` to natural numbers to `R`, and any set `S` of type `X`, if `S` is finite and for all `s` in `S`, `ring_powerseries r (p s)` holds then `ring_powerseries r (ring_product(powser_ring r (:V)) S p)` holds.

### Informal sketch
The theorem is proved by strong induction on the finiteness of the set `S`.
- Base case: `S` is empty. In this case, we show that `ring_powerseries r (ring_product(powser_ring r (:V)) EMPTY p)` and the result follows from `RING_POWERSERIES_1` (which states powerseries property holds for 1).
- Inductive step: Assume that the theorem holds for all proper subsets of `x INSERT S`. Given the hypothesis that `ring_powerseries r (p x)` and for every `s` in `S`, `ring_powerseries r (p s)`, we aim to prove `ring_powerseries r (ring_product(powser_ring r (:V)) (x INSERT S) p)`. We achieve this by using rewriting rules for `ring_product` and `POWSER_RING`, and relying on `RING_POWERSERIES_MUL`.

### Mathematical insight
This theorem extends the result that the product of two power series is a power series to the product of a finite set of power series. The inductive step uses the fact that the product over `x INSERT S` can be expressed as the product of `p x` with the product over `S`, thus reducing the problem to showing that the product of two power series is a power series, as captured in `RING_POWERSERIES_MUL`.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `RING_PRODUCT_CLAUSES`
- `POWSER_RING`
- `RING_POWERSERIES_1`
- `RING_POWERSERIES_MUL`

### Porting notes (optional)
The main difficulty might come from the way finiteness is handled. In HOL Light, finiteness is expressed using a predicate. The theorem relies on induction over finite sets, so a port to another system should make sure such induction principle is in place. Also, the rewriting rules for `ring_product` are crucial for the proof to go through.


---

## poly_product_poly_multi

### Name of formal statement
poly_product_poly_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_poly_multi = prove(`
  !(r:R ring) p:X->(V->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  ring_polynomial r (ring_product(poly_ring r (:V)) S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES] THEN
    simp[GSYM poly_use] THEN
    qed[RING_POLYNOMIAL_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(r:R ring) (p(x:X):(V->num)->R)` [] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    simp[GSYM poly_use] THEN
    qed[RING_POLYNOMIAL_MUL]
  ]
);;
```
### Informal statement
For every ring `r` of type `R ring`, every function `p` from `X` to functions from `V` to numbers to `R`, and every set `S`, if `S` is finite and for every `s` in `S`, `p s` is a ring polynomial over `r`, then `ring_product(poly_ring r (:V)) S p` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.
- Base case: When `S` is empty, `ring_product` is 1, and `1`(`RING_POLYNOMIAL_1`) is a ring polynomial.
- Inductive step: Assume the theorem holds for all subsets of `S`. Then, let `x` be an element in `S`. It is necessary to prove that the given statement holds for `INSERT x S`.  By assumption, `p x` is a ring polynomial. From inductive hypothesis, `ring_product` over S is a ring polynomial. So `p x` multiplied by `ring_product S p` is a ring polynomial via `RING_POLYNOMIAL_MUL`.

### Mathematical insight
This theorem asserts that the product of ring polynomials over a finite set is also a ring polynomial. This is a fundamental closure property for ring polynomials and is essential for constructing larger polynomials from smaller ones, preserving the ring polynomial structure.

### Dependencies
- Definitions: `ring_polynomial`, `ring_product`, `poly_ring`
- Theorems: `RING_POLYNOMIAL_1`, `RING_POLYNOMIAL_MUL`, `RING_PRODUCT_CLAUSES`


---

## poly_product_series

### Name of formal statement
poly_product_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_series = prove(`
  !(r:R ring) p:X->(1->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  ring_powerseries r (poly_product r S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty] THEN
    qed[RING_POWERSERIES_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    simp[poly_product_insert] THEN
    qed[RING_POWERSERIES_MUL]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `p` from a type `X` to a function from `(1->num)` to `R`, and any set `S` of type `X`, if `S` is finite, and for all `s` in `S`, `ring_powerseries r (p s)` holds, then `ring_powerseries r (poly_product r S p)` holds.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty. Then `poly_product r {} p` is 1, and `ring_powerseries r 1` holds by `RING_POWERSERIES_1`.
- Inductive step: Assume the theorem holds for all subsets of `S`. Let `x` be an element in `S`. We want to prove that the theorem holds for `INSERT x S`. We have `poly_product r (INSERT x S) p = p x * poly_product r S p`. By the assumption, `ring_powerseries r (p s)` holds for all `s` in `S`, so `ring_powerseries r (poly_product r S p)` holds by the inductive hypothesis. We also know that `ring_powerseries r (p x)` holds because `x` is in `INSERT x S`. Then, since both `ring_powerseries r (p x)` and `ring_powerseries r (poly_product r S p)` hold, their product satisfies `ring_powerseries` as well due to `RING_POWERSERIES_MUL`.

### Mathematical insight
The theorem states that if a collection of power series (indexed by elements of a finite set) are all ring power series, then their product is also a ring power series. This is important because it allows us to construct new ring power series by multiplying existing smaller ones.

### Dependencies
- `FINITE`
- `ring_powerseries`
- `poly_product`
- `RING_POWERSERIES_1`
- `RING_POWERSERIES_MUL`
- `INSERT`


---

## poly_product_poly

### Name of formal statement
poly_product_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_poly = prove(`
  !(r:R ring) p:X->(1->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  ring_polynomial r (poly_product r S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty] THEN
    qed[RING_POLYNOMIAL_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    simp[poly_product_insert] THEN
    qed[RING_POLYNOMIAL_MUL]
  ]
);;
```

### Informal statement
For any ring `r` and any function `p` from a type `X` to polynomials over `r` (where the polynomials are represented as functions from `(1->num)` to `R`), and any finite set `S` of type `X`, if for all `s` in `S`, `p s` is a ring polynomial, then the product of the polynomials `p s` for all `s` in `S` (denoted by `poly_product r S p`) is also a ring polynomial.

### Informal sketch
The proof proceeds by strong induction on the size of the finite set `S`.

- Base case: If `S` is empty, then `poly_product r S p` is equal to 1, which is a ring polynomial by `RING_POLYNOMIAL_1`.
- Inductive step: Assume that for any set `S'` with cardinality less than the cardinality of `S`, if for all `s` in `S'`, `p s` is a ring polynomial, then `poly_product r S' p` is also a ring polynomial.
  - Let `x` be an element of `S`. Then `S` can be written as `x INSERT S'`, where `S'` does not contain `x`. We know that `x IN x INSERT S`, and for all `s` in `S'`, `s IN S`.
  - By the inductive hypothesis, `poly_product r S' p` is a ring polynomial. Also, `p x` is a ring polynomial.
  - By the definition of `poly_product` for non-empty sets, `poly_product r (x INSERT S') p = poly_product r (INSERT x S') p = p x * poly_product r S' p`.
  - Since `p x` and `poly_product r S' p` are ring polynomials, their product `p x * poly_product r S' p` is also a ring polynomial by `RING_POLYNOMIAL_MUL`.
  - Therefore, `poly_product r (x INSERT S') p` is a ring polynomial.

The proof uses `FINITE_INDUCT_STRONG` to perform strong induction on the finiteness of set `S`.

### Mathematical insight
This theorem is a fundamental result about ring polynomials. It states that the product of a finite collection of ring polynomials is also a ring polynomial. This property is crucial for many manipulations and reasoning steps involving ring polynomials.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_product_empty`
- `RING_POLYNOMIAL_1`
- `poly_product_insert`
- `RING_POLYNOMIAL_MUL`
- `FINITE`
- `IN`
- `INSERT`
- `ring_polynomial`

### Porting notes (optional)
- The theorem relies on the definition of `poly_product`, which likely needs to be defined first.
- Pay attention to how finiteness is represented in the target proof assistant, and ensure that the induction is performed correctly over finite sets.
- The `RING_POLYNOMIAL_*` theorems will likely need to be ported first. In some proof assistants like Lean, these could follow from defining the `is_ring` typeclass and proving distributivity of `*` over `+`.


---

## poly_product_ring_product_x_poly

### Name of formal statement
poly_product_ring_product_x_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_ring_product_x_poly = prove(`
  !(r:R ring) p:X->(1->num)->R S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  poly_product r S p
  = ring_product(x_poly r) S p
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;RING_PRODUCT_CLAUSES] THEN
    qed[x_poly;POLY_RING]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    have `(p(x:X):(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_use] THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    simp[poly_product_insert;RING_PRODUCT_CLAUSES] THEN
    qed[x_poly;POLY_RING]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any function `p` from a type `X` to functions from `(1->num)` to `R`, and any finite set `S` of type `X`, if for all `s` in `S`, `p s` is a ring polynomial over `r`, then the polynomial product over `r` of `S` with respect to `p` is equal to the ring product with respect to `x_poly r` of `S` with respect to `p`.

### Informal sketch
The theorem states the equivalence between the polynomial product and the ring product (using `x_poly`) under specific conditions. The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty. We show that `poly_product r S p` reduces to the identity element, and `ring_product (x_poly r) S p` also reduces to the identity element. This uses `poly_product_empty` and `RING_PRODUCT_CLAUSES`
- Inductive step: We assume the theorem holds for all subsets of `S`. Let `x` be an element of `X`. We show the theorem holds for `INSERT x S`, given it holds for `S`.
  - We require that `p x` is a ring polynomial over `r` from the assumptions provided. This ensures that `p x` is an element of the carrier of the ring `x_poly r`.
  - Rewrite `poly_product r (INSERT x S) p` and `ring_product (x_poly r) (INSERT x S) p`, applying the inductive hypothesis, and simplifications using `poly_product_insert` and `RING_PRODUCT_CLAUSES`.

### Mathematical insight
This theorem links the concept of polynomial products with ring products when dealing with polynomials represented as functions from `(1->num)` to `R`. It essentially shows that the standard polynomial product can be expressed using a more general ring product framework when considering the ring of polynomials. The `x_poly` ring structure is crucial for this equivalence.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_product_empty`
- `RING_PRODUCT_CLAUSES`
- `x_poly`
- `POLY_RING`
- `ring_polynomial`
- `ring_powerseries`
- `poly_product_insert`

### Porting notes (optional)
- The inductive proof relies heavily on properties of `FINITE` sets and `INSERT`. Ensure these concepts are available in the target proof assistant.
- The definition and properties of `x_poly` (polynomial ring) must be available. Pay close attention to differences in how polynomial rings are represented.
- The tactics `sufficesby` are specific to HOL Light; in other proof assistants, it might be necessary to manually decompose the goal into smaller lemmas.


---

## poly_product_pow

### Name of formal statement
poly_product_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_pow = prove(`
  !(r:R ring) S (p:X->(1->num)->R) n.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  poly_pow r (poly_product r S p) n
  = poly_product r S (\s:X. poly_pow r (p s) n)
`,
  intro THEN
  have `!s:X. s IN S ==> p s IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
  have `!s:X. s IN S ==> p s IN ring_carrier(powser_ring (r:R ring) (:1))` [x_series] THEN
  rw[poly_pow;poly_product;x_series] THEN
  specialize[`powser_ring(r:R ring) (:1)`;`p:X->(1->num)->R`;`n:num`;`S:X->bool`]ring_pow_product THEN
  qed[]
);;
```
### Informal statement
For any ring `r` over a type `R`, any set `S` of type `X`, any function `p` from `X` to formal power series over `r` (i.e., `(1->num)->R`), and any natural number `n`, if `S` is finite and for all `s` in `S`, `p s` is a formal power series over `r`, then the `n`-th power of the product of the power series `p s` over `S` is equal to the product over `S` of the `n`-th powers of the power series `p s`.

### Informal sketch
The proof proceeds as follows:
- Assume `FINITE S` and `!s. s IN S ==> ring_powerseries r (p s)`.
- Establish that for all `s` in `S`, `p s` is in the carrier of the ring of formal power series over `r` by using `x_series_use`.
- Establish that for all `s` in `S`, `p s` is in the carrier of the ring of formal power series over `r` by using `x_series`.
- Rewrite the goal using the definitions of `poly_pow`, `poly_product`, and `x_series`.
- Specialize the theorem `ring_pow_product` with `powser_ring(r:R ring) (:1)`, `p:X->(1->num)->R`, `n:num` and `S:X->bool`.
- Conclude the proof.

### Mathematical insight
This theorem states that raising a product of power series to a power `n` is equivalent to taking the product of each power series raised to the power `n`. This reflects the distributivity property of exponentiation over multiplication, generalized to formal power series. This is a fundamental property used in manipulating and simplifying expressions involving formal power series.

### Dependencies
- `FINITE`
- `ring_powerseries`
- `poly_pow`
- `poly_product`
- `x_series`
- `ring_pow_product`


---

## poly_mul_sum_mul_delete

### Name of formal statement
poly_mul_sum_mul_delete

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_sum_mul_delete = prove(`
  !(r:R ring) S:X->bool f:X->(1->num)->R g:X->(1->num)->R x.
  ~(x IN S) ==>
  FINITE S ==>
  ring_powerseries r (g x) ==>
  (!s. s IN S ==> ring_powerseries r (g s)) ==>
  (!s. s IN S ==> ring_powerseries r (f s)) ==>
  poly_mul r
    (g x)
    (poly_sum r S (\s. poly_mul r (f s) (poly_product r (S DELETE s) g)))
  =  poly_sum r S (\s. poly_mul r (f s) (poly_product r ((x INSERT S) DELETE s) g))
`,
  rw[x_series_use] THEN
  rw[poly_sum] THEN
  rw[poly_product] THEN
  GEN_TAC THEN
  specialize_assuming[`x_series(r:R ring)`]ring_mul_sum_mul_delete THEN
  qed[]
);;
```

### Informal statement
Let `r` be a ring. Let `S` be a set of type `X` that is a subset of some larger domain. Let `f` be a function from `X` to functions mapping `1->num` to elements of the ring `R`. Let `g` be a function from `X` to functions mapping `1->num` to elements of the ring `R`. Let `x` be an element of type `X`.
If `x` is not in `S`, and `S` is finite, and `ring_powerseries r (g x)` holds, and for all `s` in `S`, `ring_powerseries r (g s)` holds, and for all `s` in `S`, `ring_powerseries r (f s)` holds, then 
`poly_mul r (g x) (poly_sum r S (\s. poly_mul r (f s) (poly_product r (S DELETE s) g)))` 
is equal to 
`poly_sum r S (\s. poly_mul r (f s) (poly_product r ((x INSERT S) DELETE s) g))`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `x_series_use`.
- Then, rewrite both sides using the definition of `poly_sum`.
- Then, rewrite both sides using the definition of `poly_product`.
- Apply `GEN_TAC` to discharge the assumptions related to generailzed sum and product operators.
- Specialize `ring_mul_sum_mul_delete`, instantiating with `x_series(r:R ring)`.
- Finally, discharge all remaining goals by equational reasoning.

### Mathematical insight
This theorem relates the product of a power series at a point `x` with a sum of products, to a modified sum of products, where `x` is inserted into the index set of the sum and product. The condition `x IN S` is important as it determines how the terms in the sum and product operators are re-arranged.

### Dependencies
- `x_series_use`
- `poly_sum`
- `poly_product`
- `ring_mul_sum_mul_delete`


---

## x_derivative_product

### Name of formal statement
x_derivative_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_product = prove(`
  !(r:R ring) p (S:X->bool).
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  x_derivative r (poly_product r S p)
  = poly_sum r S
      (\s. poly_mul r
             (x_derivative r (p s))
             (poly_product r (S DELETE s) p))
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;poly_sum_empty] THEN
    rw[x_derivative_poly_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `~(x IN S) ==> ((x:X) INSERT S) DELETE x = S` THEN
    have `((x:X) INSERT S) DELETE x = S` [] THEN
    have `ring_powerseries(r:R ring) (x_derivative r (p(x:X)))` [x_derivative_series] THEN
    have `ring_powerseries(r:R ring) (poly_product r (S:X->bool) p)` [poly_product_series] THEN
    have `ring_powerseries(r:R ring) (poly_mul r (x_derivative r (p(x:X))) (poly_product r (S:X->bool) p))` [RING_POWERSERIES_MUL] THEN
    simp[poly_product_insert;poly_sum_insert] THEN
    simp[x_derivative_mul] THEN
    set_fact `!s:X. s IN S ==> ~(x IN S) ==> (x INSERT S) DELETE s = x INSERT (S DELETE s)` THEN
    have `!s:X. s IN S ==> ring_powerseries (r:R ring) ((p:X->(1->num)->R) s)` [IN_INSERT] THEN
    have `!s:X. FINITE(S DELETE s)` [FINITE_DELETE] THEN
    have `!s:X. s IN S ==> ring_powerseries(r:R ring) ((\s. x_derivative r (p s)) s)` [x_derivative_series] THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    specialize_assuming[`r:R ring`;`S:X->bool`;`\s:X. x_derivative(r:R ring) (p s)`;`p:X->(1->num)->R`;`x:X`]poly_mul_sum_mul_delete THEN
    qed[]
  ]
);;
```
### Informal statement
Given a ring `r`, consider a finite set `S` of elements of type `X`, and a function `p` from `X` to power series over `r`, such that for every `s` in `S`, `p s` is a ring power series over `r`. Then the `x_derivative` of the product of the power series `p s` for `s` in `S` is equal to the sum over `S` of the product of the `x_derivative` of `p s` with the product of `p s'` for `s'` in `S` excluding `s`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.
- Base case: `S` is empty. The product and sum are both 1, and the derivative is 0.
- Inductive step: Assume the theorem holds for all finite sets smaller than `x INSERT S`. We aim to prove it for `x INSERT S`.
    - Rewrite the product and sum using `poly_product_insert` and `poly_sum_insert`.
    - Apply the derivative product rule `x_derivative_mul`.
    - Relate `(x INSERT S) DELETE s` to `x INSERT (S DELETE s)` when `s IN S` and `~(x IN S)`.
    - Apply the induction hypothesis on `S DELETE s`, using `FINITE_DELETE` to establish that `S DELETE s` is finite.
    - Apply `poly_mul_sum_mul_delete`.

### Mathematical insight
This theorem generalizes the product rule of differentiation to a finite product of power series. It expresses the derivative of a product of power series as a sum of terms, each involving the derivative of one factor and the product of the remaining factors.

### Dependencies
- `FINITE`
- `ring_powerseries`
- `x_derivative`
- `poly_product`
- `poly_sum`
- `poly_mul`
- `poly_product_empty`
- `poly_sum_empty`
- `x_derivative_poly_1`
- `poly_product_insert`
- `poly_sum_insert`
- `x_derivative_mul`
- `FINITE_DELETE`
- `poly_mul_sum_mul_delete`
- `RING_POWERSERIES_MUL`
- `IN_INSERT`

### Porting notes (optional)
Note that theorems involving sets in HOL Light might need a specific library to deal with finiteness in another proof assistant. The overall structure of induction on a finite set should be relatively straightforward to translate.


---

## poly_product_const

### Name of formal statement
poly_product_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_const = prove(`
  !(r:R ring) (p:(1->num)->R) S.
  ring_powerseries r p ==>
  FINITE S ==>
  poly_product r S (\s:X. p) = poly_pow r p (CARD S)
`,
  intro THEN
  rw[poly_pow;poly_product] THEN
  have `p IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
  qed[ring_product_const;x_series]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), any polynomial `p` (of type `(1->num)->R`) which is a ring powerseries in the ring `r`, and any finite set `S`, the polynomial product (with respect to `r`) over the set `S` where each term is the polynomial `p` is equal to the `CARD S`-th power of the polynomial `p` (with respect to `r`).

### Informal sketch
The proof proceeds as follows:
- Introduce the universally quantified variables `r`, `p`, and `S`.
- Rewrite the goal using the definitions of `poly_pow` and `poly_product`.
- Show that `p` is in `ring_carrier(x_series(r))`. This uses the hypothesis that `p` is a ring powerseries (`ring_powerseries r p`).
- Apply the theorem `ring_product_const` to conclude the proof, using `x_series(r)` as the ring.

### Mathematical insight
This theorem states a basic but important property of polynomial products. When taking the product of a constant polynomial `p` over a finite set `S`, the result is equivalent to raising the polynomial `p` to the power of the cardinality of `S`. This result simplifies calculations and provides a connection between polynomial products and polynomial exponentiation.

### Dependencies
- Definitions: `poly_pow`, `poly_product`
- Theorems: `ring_product_const`
- Theorems: `x_series`, `x_series_use`


---

## poly_pow_is_product

### Name of formal statement
poly_pow_is_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) (p:(1->num)->R) n.
  ring_powerseries r p ==>
  poly_pow r p n = poly_product r (1..n) (\i. p)
```

### Informal statement
For all rings `r` (with carrier type `R`), for all power series `p` over `r` (where `p` is a function from `(1->num)` to `R`), and for all natural numbers `n`, if `p` is a ring power series over the ring `r`, then the `n`-th power of `p` (denoted `poly_pow r p n`) is equal to the product of `n` copies of `p` (denoted `poly_product r (1..n) (\i. p)`), where the product ranges from 1 to `n`.

### Informal sketch
- The proof starts by introducing all variables.
- The definitions of `poly_pow` and `poly_product` are expanded using rewriting.
- It's shown that `p` belongs to the carrier of the ring of power series `x_series(r)` (where `x_series` constructs the ring of power series over the ring `r`). This follows from the assumption that `p` is a ring power series.
- Finally, use `ring_pow_is_product;x_series` to conclude. Essentially, this utilizes the already-proven theorem `ring_pow_is_product` and the construction of `x_series`.

### Mathematical insight
This theorem states a fundamental property of power series, connecting exponentiation (raising a power series to a power) with repeated multiplication (forming a product of identical power series). It essentially says that raising a power series to the *n*-th power is the same as multiplying *n* copies of the power series together. This is a crucial result when manipulating and reasoning about power series in a formal setting.

### Dependencies
 ring:
 - `ring_powerseries`
 - `ring_carrier`

x_series:
 - `x_series`

Theorems:
 - `ring_pow_is_product`


---

## x_derivative_pow

### Name of formal statement
x_derivative_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_pow = prove(`
  !(r:R ring) p n.
  ring_powerseries r p ==>
  x_derivative r (poly_pow r p n)
  =
  poly_mul r (
    poly_const r (ring_of_num r n)
  ) (
    poly_mul r (
      x_derivative r p
    ) (
      poly_pow r p (n-1)
    )
  )
`,
  intro THEN
  case `n = 0` THENL [
    simp[poly_pow_0;RING_OF_NUM_0] THEN
    rw[poly_1;x_derivative_poly_const] THEN
    rw[GSYM poly_0] THEN
    qed[POWSER_MUL_0;x_derivative_series;poly_pow_series;RING_POWERSERIES_MUL]
  ; pass
  ] THEN
  simp[poly_pow_is_product] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  have `!i. i IN 1..n ==> ring_powerseries r (p:(1->num)->R)` [] THEN
  specialize[`r:R ring`;`\i:num. p:(1->num)->R`;`1..n`]x_derivative_product THEN
  subgoal `poly_sum(r:R ring) (1..n) (\s. poly_mul r (x_derivative r p) (poly_product r ((1..n) DELETE s) (\i. p))) = poly_sum r (1..n) (\s. poly_mul r (x_derivative r p) (poly_pow r p (n-1)))` THENL [
    sufficesby poly_sum_eq THEN
    intro THEN
    rw[BETA_THM] THEN
    have `CARD(1..n) = n` [CARD_NUMSEG_1] THEN
    have `CARD((1..n) DELETE s) = CARD(1..n) - 1` [CARD_DELETE] THEN
    have `CARD((1..n) DELETE s) = n - 1` [] THEN
    have `FINITE((1..n) DELETE s)` [FINITE_DELETE] THEN
    simp[poly_product_const]
  ; pass
  ] THEN
  simp[poly_product_const;FINITE_NUMSEG;CARD_NUMSEG_1] THEN
  have `ring_powerseries(r:R ring) (poly_mul r (x_derivative r p) (poly_pow r p (n - 1)))` [RING_POWERSERIES_MUL;x_derivative_series;poly_pow_series] THEN
  specialize[`r:R ring`;`poly_mul(r:R ring) (x_derivative r p) (poly_pow r p (n - 1))`;`1..n`]poly_sum_const THEN
  have `CARD(1..n) = n` [CARD_NUMSEG_1] THEN
  qed[]
);;
```
### Informal statement
For any `r` that is a ring, and any formal power series `p` over `r`, and any natural number `n`, if `p` is a ring power series, then the derivative of `p` to the power of `n` equals the product of `n` (represented as a constant power series) with the product of the derivative of `p` and `p` to the power of `n-1`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. The left-hand side is the derivative of 1 (since `p` to the power of 0 is 1), which is 0. The right-hand side is also 0 because it contains a factor of `n`, which is 0 in this case.
- Inductive step: Assume the statement holds for `n`. We want to prove it for `n+1`. The main step is to use the fact that `p^(n+1) = p * p^n`. We apply the derivative-of-a-product rule. Then, we simplify using the inductive hypothesis. After some algebraic manipulations involving the properties of power series, we arrive at the desired conclusion.
  - The proof uses `x_derivative_product` to go from a derivative of a product to a sum of derivatives.
  - The proof uses `poly_sum_eq` to rewrite the sum on the right-hand side.
  - The proof uses `poly_sum_const` to move the constant term `(x_derivative r p) (poly_pow r p (n - 1))` out of the summation.
  - The cardinality of `1..n` is equal to `n` is used to correctly reconstruct the factors.

### Mathematical insight
The theorem gives the derivative of a power of a formal power series. It is a standard result and often useful when manipulating or solving equations involving formal power series.

### Dependencies
- `poly_pow_0`
- `RING_OF_NUM_0`
- `poly_1`
- `x_derivative_poly_const`
- `poly_0`
- `POWSER_MUL_0`
- `x_derivative_series`
- `poly_pow_series`
- `RING_POWERSERIES_MUL`
- `poly_pow_is_product`
- `FINITE_NUMSEG`
- `x_derivative_product`
- `poly_sum_eq`
- `BETA_THM`
- `CARD_NUMSEG_1`
- `CARD_DELETE`
- `FINITE_DELETE`
- `poly_product_const`
- `poly_sum_const`
- `x_derivative_series`
- `poly_pow_series`

### Porting notes (optional)
The theorem relies on the ring structure and the properties of formal power series. Ensure that the target proof assistant has similar libraries for ring theory and formal power series. The handling of natural numbers and finite sets might differ across proof assistants. Be mindful of the different notations for these concepts.


---

## eval_poly_product

### Name of formal statement
eval_poly_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_poly_product = prove(`
  !(r:R ring) p:(X->(1->num)->R) z S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  z IN ring_carrier r ==>
  poly_eval r (poly_product r S p) z
  = ring_product r S (\s. poly_eval r (p s) z)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;RING_PRODUCT_CLAUSES] THEN
    qed[POLY_EVAL_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial r ((p:(X->(1->num)->R)) x)` [] THEN
    have `ring_powerseries r ((p:(X->(1->num)->R)) x)` [ring_polynomial] THEN
    have `poly_eval r ((p:(X->(1->num)->R)) x) z IN ring_carrier r` [POLY_EVAL] THEN
    simp[poly_product_insert;RING_PRODUCT_CLAUSES] THEN
    have `ring_polynomial r (poly_product r S (p:(X->(1->num)->R)))` [poly_product_poly] THEN
    simp[POLY_EVAL_MUL]
  ]
);;
```
### Informal statement
For any ring `r` with carrier `ring_carrier r`, any function `p` mapping elements of a type `X` to polynomials over `r` (i.e. functions from `(1->num)` to `R`), any `z` in `ring_carrier r`, and any finite set `S` of type `X`, if for every `s` in `S`, `p s` is a ring polynomial, then the evaluation of the product of the polynomials `p s` for `s` in `S` at `z` is equal to the product of the evaluations of `p s` at `z` for `s` in `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: If `S` is empty, then the product of polynomials over `S` is `1` (from `poly_product_empty` and `RING_PRODUCT_CLAUSES`).  The evaluation of `1` at `z` is `1` (from `POLY_EVAL_1`).  The product of the evaluations is also `1` since `S` is empty (from `RING_PRODUCT_CLAUSES`).
- Inductive step: Assume that the result holds for all subsets of `S`.  Consider an arbitrary element `x` in `X` and the set `x INSERT S`.  We have that `ring_polynomial r (p x)` (by the assumption that `p s` are ring polynomials). Also, `poly_eval r (p x) z IN ring_carrier r` by `POLY_EVAL`.  The product of the polynomials over `x INSERT S` is `p x * poly_product r S p` (by `poly_product_insert`).  The evaluation of this product at `z` is `poly_eval r (p x) z * poly_eval r (poly_product r S p) z` (by `POLY_EVAL_MUL`). By the inductive hypothesis (and `poly_product_poly` which states that the product of ring polynomials is also a ring polynomial), `poly_eval r (poly_product r S p) z = ring_product r S (\s. poly_eval r (p s) z)`. Thus, `poly_eval r (poly_product r (x INSERT S) p) z = poly_eval r (p x) z * ring_product r S (\s. poly_eval r (p s) z) = ring_product r (x INSERT S) (\s. poly_eval r (p s) z)` (by `RING_PRODUCT_CLAUSES`).

### Mathematical insight
This theorem states that evaluating a product of polynomials is the same as taking the product of the evaluations of each polynomial. This result is fundamental in polynomial algebra and is used extensively when dealing with polynomial rings and their homomorphisms.

### Dependencies
- `FINITE_INDUCT_STRONG` (induction scheme for finite sets)
- `poly_product_empty`
- `RING_PRODUCT_CLAUSES` (identities about `ring_product`)
- `POLY_EVAL_1` (evaluation of the polynomial `1`)
- `POLY_EVAL` (evaluation of polynomial is in ring carrier)
- `poly_product_insert`
- `poly_product_poly` (a product of ring polynomials is a ring polynomial)
- `POLY_EVAL_MUL` (evaluation of a product of polynomials)


---

## poly_product_subring_multi

### Name of formal statement
poly_product_subring_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_subring_multi = prove(`
  !(r:R ring) G (p:X->(V->num)->R) S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial(subring_generated r G) (p s)) ==>
  ring_product(poly_ring(subring_generated r G) (:V)) S p
  = ring_product(poly_ring r (:V)) S p
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES] THEN
    rw[POLY_RING] THEN
    rw[poly_1;poly_const;SUBRING_GENERATED]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(subring_generated r G) (p(x:X):(V->num)->R)` [] THEN
    have `ring_polynomial r (p(x:X):(V->num)->R)` [ring_polynomial_if_subring] THEN
    have `!s:X. s IN S ==> ring_polynomial(subring_generated(r:R ring) G) (p s:(V->num)->R)` [] THEN
    simp[RING_PRODUCT_CLAUSES;GSYM poly_use] THEN
    have `ring_polynomial (subring_generated r G) (ring_product(poly_ring r (:V)) S (p:X->(V->num)->R))` [poly_product_poly_multi] THEN
    qed[poly_mul_subring;ring_polynomial]
  ]
);;
```

### Informal statement
Let `r` be a ring, `G` be a generator set, `p` be a function that takes an element `s` of type `X` and a function from `V` to the carrier of `r` to the carrier of `r`, and `S` be a finite set of type `X`. If `S` is finite and for all `s` in `S`, the polynomial `p s` is a ring polynomial over the subring generated by `G` within `r`, then the ring product over `S` of the polynomials `p s` computed with respect to the polynomial ring over the subring generated by `G` within `r` is equal to the ring product over `S` of the polynomials `p s` computed with respect to the polynomial ring over `r`.

### Informal sketch
The proof proceeds by strong induction over the size of the finite set `S`.

- Base case: When `S` is empty, both ring products are 1 in the respective polynomial rings. This is established by rewriting with `RING_PRODUCT_CLAUSES`, `POLY_RING`, `poly_1`, `poly_const`, and `SUBRING_GENERATED`.
- Inductive step: Assume that the theorem holds for all subsets of the set `x INSERT S`, where `x` is an element of type `X` and `S` is also a set of the same type `X`. It is also assumed that `x` is an element of `x INSERT S` and for all `s` in `S`, `s` is in `x INSERT S`.
    - Show that `p x` satisfies the ring polynomial property over both `subring_generated r G` and `r`. We are provided with the facts that the ring polynomial `p x` over `subring_generated r G` holds and that `p x` over `r` holds by `ring_polynomial_if_subring`.
    - Rewrite using `RING_PRODUCT_CLAUSES` and `GSYM poly_use` to separate the product into `p x` multiplied by the product over `S`.
    - Apply the inductive hypothesis on `S`.
    - Show that the polynomial `ring_product` over `S` is a ring polynomial over its subring by using `poly_product_poly_multi`.
    - The proof concludes by induction, utilizing `poly_mul_subring` and the fact that `ring_polynomial` is closed over multiplication.

### Mathematical insight
The theorem states that if all polynomials in a product are polynomials over a subring, then taking the product within the polynomial ring of that subring is the same as taking the product within the larger polynomial ring. This essentially says that the subring structure is preserved under ring products of polynomials, provided the individual polynomials have coefficients within the subring. When calculating the ring product, we can restrict ourselves to the subring.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POLY_RING`
- `poly_1`
- `poly_const`
- `SUBRING_GENERATED`
- `ring_polynomial_if_subring`
- `GSYM poly_use`
- `poly_product_poly_multi`
- `poly_mul_subring`
- `ring_polynomial`


---

## poly_product_subring

### Name of formal statement
poly_product_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_subring = prove(`
  !(r:R ring) G (p:X->(1->num)->R) S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_powerseries(subring_generated r G) (p s)) ==>
  poly_product (subring_generated r G) S p
  = poly_product r S p
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty] THEN
    rw[poly_1;poly_const;SUBRING_GENERATED]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(subring_generated r G) (p(x:X):(1->num)->R)` [] THEN
    have `ring_powerseries r (p(x:X):(1->num)->R)` [ring_powerseries_subring] THEN
    have `!s:X. s IN S ==> ring_powerseries(subring_generated(r:R ring) G) (p s:(1->num)->R)` [] THEN
    simp[poly_product_insert] THEN
    have `ring_powerseries (subring_generated r G) (poly_product r S (p:X->(1->num)->R))` [poly_product_series] THEN
    qed[poly_mul_subring]
  ]
);;
```

### Informal statement
Given a ring `r` of type `R ring`, a set `G` of elements, a type `X`, a finite set `S` of elements of type `X`, and a function `p` from `X` to functions from `(1->num)` to `R`, if for all `s` in `S`, `ring_powerseries(subring_generated r G) (p s)` holds, then the `poly_product` of `S` with respect to `p` over the subring generated by `G` from `r` equals the `poly_product` of `S` with respect to `p` over the ring `r`.

### Informal sketch
The proof proceeds by strong induction on the cardinality of the finite set `S`.

- Base Case: If `S` is empty, then both `poly_product (subring_generated r G) S p` and `poly_product r S p` are equal to 1 (using `poly_product_empty` and the definition of `poly_1`, `poly_const`, and `SUBRING_GENERATED`).

- Inductive Step: Assume the theorem holds for all sets smaller than `x INSERT S`. We assume that `ring_powerseries(subring_generated r G) (p x)` and `!s:X. s IN S ==> ring_powerseries(subring_generated(r:R ring) G) (p s:(1->num)->R)` hold, and we want to prove that `poly_product (subring_generated r G) (x INSERT S) p = poly_product r (x INSERT S) p`.

  - Using `poly_product_insert`, the goal becomes `poly_mul (p x) (poly_product (subring_generated r G) S p) = poly_mul (p x) (poly_product r S p)`.

  - By the inductive hypothesis and `poly_product_series`, we know that `ring_powerseries (subring_generated r G) (poly_product r S p)` holds.

  - By `poly_mul_subring`, we can conclude the inductive step.

### Mathematical insight
This theorem states that if each individual element in a product has a power series representation within a subring generated by `G`, then the product calculated within that subring will coincide with the product calculated within the original ring. This is a crucial result for reasoning about subrings and their associated power series.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_product_empty`
- `poly_1`
- `poly_const`
- `SUBRING_GENERATED`
- `poly_product_insert`
- `poly_product_series`
- `poly_mul_subring`
- `ring_powerseries_subring`


---

## ring_polynomial_subring_product

### Name of formal statement
ring_polynomial_subring_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_polynomial_subring_product = prove(`
  !(r:R ring) G p:X->(V->num)->R S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial(subring_generated r G) (p s)) ==>
  ring_polynomial(subring_generated r G) (ring_product(poly_ring r (:V)) S p)
`,
  simp[GSYM poly_product_subring_multi] THEN
  qed[RING_PRODUCT;poly_in_full_ring]
);;
```
### Informal statement
Given a ring `r` and a subring generator `G` for `r`, let `p` be a function that maps elements `s` from a finite set `S` of type `X` to ring polynomials `p s` (of type `V->num->R`) over `r`. If all `p s` belong to the ring of polynomials with coefficients in the subring generated by `G`, then the product of these polynomials, `ring_product(poly_ring r (:V)) S p`, also belongs to the ring of polynomials with coefficients in the subring generated by `G`.

### Informal sketch
*   The proof starts with the assumption that `S` is a finite set and that for all `s` in `S`, the ring polynomials `p s` belong to the ring of polynomials over the subring generated by `G`.
*   Apply the simplification rule `GSYM poly_product_subring_multi` which likely rewrites the goal in terms of `ring_product`.
*   Apply the theorem `RING_PRODUCT` which likely establishes that `ring_product` preserves subrings.
*   Apply the theorem `poly_in_full_ring` which probably states that if the coefficients of a polynomial belong to a subring, then the polynomial, viewed as an element of the full ring of polynomials, remains in the subring generated by `G`.
*   Conclude that the product `ring_product(poly_ring r (:V)) S p` is a ring polynomial over the subring generated by `G`.

### Mathematical insight
The theorem states that if we take a finite number of polynomials, each having coefficients in a subring generated by `G`, then their product will also have coefficients in that same subring. This result shows that the subring structure is preserved under finite products of polynomials, which is crucial for many algebraic constructions and proofs involving polynomials.

### Dependencies
- `GSYM poly_product_subring_multi`
- `RING_PRODUCT`
- `poly_in_full_ring`


---

## poly_product_image

### Name of formal statement
poly_product_image

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_image = prove(`
  !(r:R ring) S (f:X->Y) (g:Y->(1->num)->R).
  (!x y. x IN S ==> y IN S ==> f x = f y ==> x = y) ==>
  poly_product r (IMAGE f S) g = poly_product r S (g o f)
`,
  rw[poly_product] THEN
  intro THEN
  specialize[`x_series(r:R ring)`;`f:X->Y`;`g:Y->(1->num)->R`;`S:X->bool`]RING_PRODUCT_IMAGE THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, any sets `S` of type `X`, any function `f` from `X` to `Y`, and any function `g` from `Y` to functions from `(1->num)` to `R`, if `f` is injective on `S` (i.e., for all `x` and `y` in `S`, if `f(x) = f(y)` then `x = y`), then the polynomial product of `g` over the image of `S` under `f` is equal to the polynomial product of `g o f` over `S`.

### Informal sketch
The proof proceeds by:
- Rewriting the left-hand side using the definition of `poly_product`.
- Introducing the universally quantified variables.
- Applying the theorem `RING_PRODUCT_IMAGE`, after specializing it with the concrete variables `x_series(r:R ring)`, `f:X->Y`, `g:Y->(1->num)->R`, `S:X->bool`.
- Closing the proof.

Essentially, the proof leverages the pre-existing theorem `RING_PRODUCT_IMAGE` which likely generalizes to a range of `RING` types, and then applies it to the case of polynomials by specialization.

### Mathematical insight
The theorem states that computing a polynomial product over the image of a set under an injective function is equivalent to computing the polynomial product over the original set, composed with the injective function. This is useful because it allows us to transform the domain over which the polynomial product is calculated, potentially simplifying the calculation or making it more amenable to induction.

### Dependencies
- `poly_product`
- `RING_PRODUCT_IMAGE`


---

## poly_deg_product_le

### Name of formal statement
- poly_deg_product_le

### Type of the formal statement
- theorem

### Formal Content
- The full HOL Light statement will be inserted here **after generation**.
```ocaml
let poly_deg_product_le = prove(`
  !(r:R ring) (p:X->(1->num)->R) n S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> poly_deg r (p s) <= n s) ==>
  poly_deg r (poly_product r S p) <= nsum S n
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;NSUM_CLAUSES;POLY_DEG_1] THEN
    ARITH_TAC
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial r (p(x:X):(1->num)->R)` [] THEN
    have `ring_powerseries r (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    simp[poly_product_insert;NSUM_CLAUSES] THEN
    simp[CARD_CLAUSES] THEN
    have `ring_polynomial(r:R ring) (poly_product r (S:X->bool) p)` [poly_product_poly] THEN
    have `poly_deg(r:R ring) (poly_product r (S:X->bool) p) <= nsum S n` [poly_product_poly] THEN
    qed[POLY_DEG_MUL_LE;ARITH_RULE `d <= dx + ds ==> dx <= nx ==> ds <= ns ==> d <= nx + ns:num`]
  ]
);;
```
### Informal statement
- For any ring `r`, if `S` is a finite set, and `p` is a function mapping elements of `S` to polynomials over `r` such that each `p s` is a ring polynomial, and the degree of each `p s` is less than or equal to `n s`, then the degree of the product of the polynomials `p s` for `s` in `S` is less than or equal to the sum of `n s` for `s` in `S`.

### Informal sketch
- The proof proceeds by induction on the finite set `S`.
- Base Case: When `S` is empty, the product `poly_product r S p` is 1, and the sum `nsum S n` is 0. Since the degree of 1 is 0, the inequality holds via `POLY_DEG_1` and `NSUM_CLAUSES`.
- Inductive Step: Assume the theorem holds for `S`. We need to prove it for `INSERT x S`.
  - Rewrite `poly_product r (INSERT x S) p` as `poly_product r (INSERT x S) p = poly_mul r (p x) (poly_product r S p)`.
  - Rewrite `nsum (INSERT x S) n` as `nsum (INSERT x S) n = n x + nsum S n`.
  - We have `poly_deg r (poly_product r S p) <= nsum S n` by the inductive hypothesis.
  - We also have `poly_deg r (p x) <= n x` by the assumption `!s:X. s IN S ==> poly_deg r (p s) <= n s`, instantiated with `x` after proving `x IN (x INSERT S)`.
  - Apply `POLY_DEG_MUL_LE` to deduce `poly_deg r (poly_mul r (p x) (poly_product r S p)) <= poly_deg r (p x) + poly_deg r (poly_product r S p)`.
  - Combine with the inductive hypothesis using arithmetic (`ARITH_RULE`) to reach the conclusion: `poly_deg r (poly_mul r (p x) (poly_product r S p)) <= n x + nsum S n`.

### Mathematical insight
- This theorem provides an upper bound on the degree of a product of polynomials. The degree of the product of polynomials is at most the sum of their individual degrees. This is used in reasoning about the complexity of polynomial arithmetic.

### Dependencies
- ring_polynomial
- poly_deg
- poly_product
- finite
- nsum
- POLY_DEG_1
- POLY_DEG_MUL_LE
- NSUM_CLAUSES
- CARD_CLAUSES
- poly_product_empty
- poly_product_insert
- ARITH_RULE
- ring_powerseries
- poly_product_poly


---

## poly_deg_product_each_le

### Name of formal statement
poly_deg_product_each_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_deg_product_each_le = prove(`
  !(r:R ring) (p:X->(1->num)->R) n S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> poly_deg r (p s) <= n) ==>
  poly_deg r (poly_product r S p) <= (CARD S) * n
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;POLY_DEG_1] THEN
    ARITH_TAC
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial r (p(x:X):(1->num)->R)` [] THEN
    have `ring_powerseries r (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    simp[poly_product_insert] THEN
    simp[CARD_CLAUSES] THEN
    have `ring_polynomial(r:R ring) (poly_product r (S:X->bool) p)` [poly_product_poly] THEN
    have `poly_deg(r:R ring) (poly_product r (S:X->bool) p) <= CARD S * n` [poly_product_poly] THEN
    qed[POLY_DEG_MUL_LE;ARITH_RULE `a <= b + c ==> b <= n ==> c <= S * n ==> a <= SUC(S) * n`]
  ]
);;
```

### Informal statement
For any ring `r`, any function `p` from a type `X` to polynomials over `r`, any natural number `n`, and any finite set `S` of type `X`, if `p s` is a polynomial for all `s` in `S`, and if the degree of `p s` is less than or equal to `n` for all `s` in `S`, then the degree of the product of the polynomials `p s` for `s` in `S` is less than or equal to the cardinality of `S` times `n`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then the product of polynomials over `S` is 1, and the degree of 1 is 0. Since `(CARD S) * n = 0 * n = 0`, the theorem holds.
- Inductive step: Assume the theorem holds for all subsets of `S`. Let `x` be an element of `S`. Then `S` can be written as `x INSERT S'`, where `S'` is a subset of `S`.
    - We know `p x` is a polynomial and `poly_deg r (p x) <= n`
    - Also `poly_product r (x INSERT S') p = (p x) * (poly_product r S' p)`.
    - By the induction hypothesis, `poly_deg r (poly_product r S' p) <= (CARD S') * n`
    - By `POLY_DEG_MUL_LE`, `poly_deg r ((p x) * (poly_product r S' p)) <= poly_deg r (p x) + poly_deg r (poly_product r S' p)`. Then, combining the inequalities, using ARITH we conclude `poly_deg r (poly_product r (x INSERT S') p) <= SUC (CARD S') * n`, and since `SUC (CARD S') = CARD(x INSERT S')`, we have the desired result.

### Mathematical insight
This theorem provides an upper bound for the degree of a product of polynomials, in terms of the number of polynomials being multiplied and an upper bound on the degree of each individual polynomial. It generalizes the basic facts about the degree of a product of two polynomials.

### Dependencies
- `FINITE`
- `ring_polynomial`
- `poly_deg`
- `poly_product`
- `CARD`
- `poly_product_empty`
- `POLY_DEG_1`
- `poly_product_insert`
- `CARD_CLAUSES`
- `poly_product_poly`
- `POLY_DEG_MUL_LE`

### Porting notes (optional)
The proof uses `FINITE_INDUCT_STRONG`. Recreating this step may be non-trivial in proof assistants that do not have such an induction principle built-in. One may have to define a corresponding induction principle from the well-foundedness of `<` on natural numbers. The arithmetic reasoning may need to be made explicit, depending on the automation available. Also, some proof assistants may require explicit handling of ring properties.


---

## poly_product_delete

### Name of formal statement
poly_product_delete

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) S t f:X->((1->num)->R).
  FINITE S ==>
  t IN S ==>
  ring_powerseries r (f t) ==>
  poly_product r S f = poly_mul r (f t) (poly_product r (S DELETE t) f)
```

### Informal statement
For any ring `r` of type `R ring`, any finite set `S`, any element `t` such that `t` is in `S`, and any function `f` from `X` to `(1->num)->R` such that `ring_powerseries r (f t)` holds, then `poly_product r S f` is equal to `poly_mul r (f t) (poly_product r (S DELETE t) f)`.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent: `FINITE S`, `t IN S`, and `ring_powerseries r (f t)`.
- Show that `f t` is an element of the ring carrier of `x_series r`.
- Show that `f t` is an element of the ring carrier of `powser_ring r (:1)`.
- Rewrite using the definition of `poly_product` and `x_series` to obtain the desired equality using `ring_product_delete`.

### Mathematical insight
This theorem states that when computing the `poly_product` of a finite set `S` of formal power series, if we pick an element `t` from `S`, then we can extract `f t` from the product: the product over `S` equals the product of `f t` with the product over `S DELETE t`. Intuitively, this is like saying that the product of a collection of numbers is the same as taking one element out and multiplying it by the product of the remaining numbers. The novelty here concerns the context of formal power series, and the formal setup including the ring `r`.

### Dependencies
- Definitions: `poly_product`, `poly_mul`, `ring_powerseries`, `x_series`, `DELETE`
- Theorems: `ring_product_delete`
- Type Definition: `R ring`

### Porting notes (optional)
The main difficulty will be correctly setting up the types to match the HOL Light types. `R ring` will need to be translated carefully. The theorem `ring_product_delete` will need to be present in the target system, so porting may depend on a substantial library of ring theory. The rewriting steps depend on the specifics of how definitions are unfolded in HOL Light, so the corresponding steps in other proof assistants may differ significantly.


---

## poly_pow_subring

### Name of formal statement
poly_pow_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_subring = prove(`
  !(r:R ring) G (p:(V->num)->R) n.
  ring_powerseries(subring_generated r G) p ==>
  poly_pow (subring_generated r G) p n
  = poly_pow r p n
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0;poly_1;poly_const] THEN
    simp[SUBRING_GENERATED]
  ;
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    intro THEN
    specialize[`r:R ring`;`G:R->bool`;`p:(V->num)->R`]ring_powerseries_subring THEN
    simp[poly_pow_add;poly_pow_1] THEN
    qed[poly_mul_subring;poly_pow_series]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `G` of type `R -> bool`, any power series `p` of type `(V -> num) -> R`, and any natural number `n`, if `p` is a ring powerseries over the subring generated by `r` and `G`, then `poly_pow` of the subring generated by `r` and `G` with `p` and `n` equals `poly_pow` of `r` with `p` and `n`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: Show that `poly_pow (subring_generated r G) p 0 = poly_pow r p 0`. This follows from rewriting with `poly_pow_0`, `poly_1`, `poly_const` and simplifying using `SUBRING_GENERATED`.
- Inductive step: Assume `poly_pow (subring_generated r G) p n = poly_pow r p n`. We must show that `poly_pow (subring_generated r G) p (SUC n) = poly_pow r p (SUC n)`. We rewrite `SUC n` with `1+n` and use the assumption that `p` is a ring powerseries over `subring_generated r G`. Simplify using `poly_pow_add` and `poly_pow_1`. Finally, discharge using `poly_mul_subring` and `poly_pow_series`.

### Mathematical insight
This theorem states that computing the power of a power series `p` within a subring generated by some set `G` of a ring `r` yields the same result as computing the power of `p` directly within the ring `r`, given that `p` is a ring powerseries over the subring generated by `G`. This allows us to compute powers of power series in a larger ring when we already know the power series belongs to a subring.

### Dependencies
- `ring_powerseries`
- `subring_generated`
- `poly_pow_0`
- `poly_1`
- `poly_const`
- `SUBRING_GENERATED`
- `poly_pow_add`
- `poly_pow_1`
- `ring_powerseries_subring`
- `poly_mul_subring`
- `poly_pow_series`


---

## poly_product_botcoeff1

### Name of formal statement
poly_product_botcoeff1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_botcoeff1 = prove(`
  !(r:R ring) (p:X->(1->num)->R) S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> coeff 0 (p s) = ring_1 r) ==>
  coeff 0 (poly_product r S p) = ring_1 r
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;coeff_poly_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial r (p(x:X):(1->num)->R)` [] THEN
    have `ring_powerseries r (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    simp[poly_product_insert] THEN
    rw[coeff_poly_mul_oneindex] THEN
    simp[RING_SUM_CLAUSES_NUMSEG;ARITH_RULE `0-0=0`;RING_1;RING_MUL;RING_MUL_LID]
  ]
);;
```
### Informal statement
For any ring `r` (with carrier type `R`), any type `X`, any function `p` from `X` to polynomials over `r` (formally, from `X` to `(1->num)->R`), and any finite set `S` of elements of type `X`, if for all `s` in `S`, `p s` is a ring polynomial over `r`, and for all `s` in `S`, the coefficient of `(p s)` at index 0 is equal to the ring unit `ring_1 r`, then the coefficient of the polynomial `poly_product r S p` at index 0 is equal to the ring unit `ring_1 r`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then `poly_product r S p` is `poly_1`, whose coefficient at 0 is `ring_1 r` by `coeff_poly_1`.
- Inductive step: Assume the statement holds for all finite subsets of `S`. Let `S` be `INSERT x S'` where `x` is an element and `S'` is a finite set. Assume that for all `s` in `INSERT x S'`, `p s` is a ring polynomial and `coeff 0 (p s) = ring_1 r`.
  - Instantiate the assumption for the inductive step to show that `ring_polynomial r (p x)` holds.
  - Deduce that `ring_powerseries r (p x)` holds since every ring polynomial ring is a ring powerseries.
  - By rewriting `poly_product r (INSERT x S' ) p` to `poly_product r S' p * p x` according to `poly_product_insert`, the problem reduces to showing `coeff 0 (poly_product r S' p * p x) = ring_1 r`.
  - Applying `coeff_poly_mul_oneindex` allows expansion of the coefficient of index 0 of the product of two polynomials into an expression which is then simplified using the assumptions and properties of rings. This simplification make use of `RING_SUM_CLAUSES_NUMSEG`, `ARITH_RULE 0-0=0`, the definitions of `RING_1`, `RING_MUL`, and `RING_MUL_LID`.

### Mathematical insight
The theorem states that if a finite product of polynomials each has a constant term of 1, then the product also has a constant term of 1. This is a basic but important property in ring theory, especially in the context of polynomials and formal power series.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_product_empty`
- `coeff_poly_1`
- `poly_product_insert`
- `coeff_poly_mul_oneindex`
- `RING_SUM_CLAUSES_NUMSEG`
- `ARITH_RULE 0-0=0`
- `RING_1`
- `RING_MUL`
- `RING_MUL_LID`
- `ring_polynomial`
- `ring_powerseries`


---

## poly_product_in_poly_ring

### Name of formal statement
poly_product_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_in_poly_ring = prove(`
  !(r:R ring) (p:X->(V->num)->R) E S.
  FINITE S ==>
  (!s:X. s IN S ==> p s IN ring_carrier(poly_ring r E)) ==>
  ring_product(poly_ring r (:V)) S p IN ring_carrier(poly_ring r E)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES] THEN
    qed[RING_1;POLY_RING]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `(p(x:X):(V->num)->R) IN ring_carrier(poly_ring r E)` [] THEN
    have `(p(x:X):(V->num)->R) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET E}` [POLY_RING] THEN
    set_fact `(p(x:X):(V->num)->R) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET E} ==> ring_polynomial r (p x)` THEN
    have `(p(x:X):(V->num)->R) IN ring_carrier(poly_ring r (:V))` [RING_POLYNOMIAL] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `ring_product (poly_ring(r:R ring) (:V)) (S:X->bool) p IN ring_carrier (poly_ring r E)` [] THEN
    rw[CONJUNCT2 POLY_RING] THEN
    qed[poly_mul_in_poly_ring]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any type `X`, any function `p` from `X` to functions from `V` to numbers to `R`, and any set `E` of type `X->bool`, if `S` is a finite set of type `X->bool` such that for all `s` in `S`, `p s` is in the carrier of the polynomial ring over `r` with variable type `V` and variables in the set `E`, then the ring product of `p` over `S` in the polynomial ring over `r` with variable type `V` is in the carrier of the polynomial ring over `r` with variables in `E`.

### Informal sketch
The theorem states that a finite product of polynomials in a polynomial ring, where the polynomials have variables in a restricted set E, remains in the polynomial ring with variables in E. The proof follows by strong induction on the finiteness of `S`.

- Base case: `S` is empty. In this case, the product is the ring's multiplicative identity `RING_1`, which is in the polynomial ring `POLY_RING`.
- Inductive step: Assume the theorem holds for all subsets of `x INSERT S`.  Show that if all `p s` for `s` in `x INSERT S` are in the carrier of the polynomial ring then the product over `x INSERT S` is in the carrier of the polynomial ring.  
    - Use `RING_PRODUCT_CLAUSES` to rewrite the product over `x INSERT S` as `ring_product(poly_ring r (:V)) (INSERT x S) p = ring_op (poly_ring r (:V)) (p x) (ring_product (poly_ring r (:V)) S p)`.
    - We know `p x` is in the carrier of `poly_ring r E` by assumption, and by the inductive hypothesis, `ring_product (poly_ring r (:V)) S p` is in the carrier of `poly_ring r E`.
    - Apply `poly_mul_in_poly_ring`.

### Mathematical insight
This theorem is important because it demonstrates closure under multiplication within the polynomial ring structure. Specifically, if we start with polynomials whose variables belong to a set `E`, multiplying them together will not introduce any new variables. This result is vital for maintaining the desired structure when working with polynomial rings.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `RING_1`
- `POLY_RING`
- `RING_POLYNOMIAL`
- `CONJUNCT2`
- `poly_mul_in_poly_ring`


---

## powser_product_o_permutes

### Name of formal statement
powser_product_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powser_product_o_permutes = prove(`
  !(r:R ring) p:X->(V->num)->R U f S.
  FINITE S ==>
  !m.
  f permutes U ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  ring_product(powser_ring r (:V)) S p (m o f) =
  ring_product(powser_ring r (:V)) S (\s m. (p s) (m o f)) m
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES] THEN
    rw[POWSER_RING] THEN
    qed[poly_1_o_permutes]
  ;
    intro THEN
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `ring_powerseries(r:R ring) (p(x:X):(V->num)->R)` [] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `f:V->V`;
      `U:V->bool`
    ]powerseries_o_permutes THEN
    have `p(x:X) IN ring_carrier(powser_ring(r:R ring) (:V))` [powser_use] THEN
    have `(\m:V->num. p(x:X) (m o (f:V->V))) IN ring_carrier(powser_ring(r:R ring) (:V))` [powser_use] THEN
    simp[] THEN
    rw[POWSER_RING] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `ring_product (powser_ring(r:R ring) (:V)) (S:X->bool) p`;
      `U:V->bool`;
      `f:V->V`;
      `m:V->num`
    ]poly_mul_o_permutes THEN
    simp[] THEN
    subgoal `(\m:V->num. ring_product (powser_ring(r:R ring) (:V)) S (\s:X n:V->num. p s (n o (f:V->V))) m) = ring_product (powser_ring r (:V)) S (\s n. p s (n o f))` THENL [
      rw[FUN_EQ_THM]
    ; pass
    ] THEN
    simp[]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `p` from `X` to functions from `V->num` to `R`, any boolean predicate `U` on `V`, any function `f` from `V` to `V`, and any boolean predicate `S` on `X`, if `S` is finite, and `f` permutes `U`, and for all `s` in `S`, `p s` is a ring powerseries with ring `r`, then the ring product (defined with respect to ring `r` and variable type `V`) of the family `p` indexed by `S`, evaluated at `m o f`, is equal to the ring product of the family `\s m. (p s) (m o f)` indexed by `S`, evaluated at `m`.
Here, `m` is a function from `V` to `num`.

### Informal sketch
The proof proceeds by induction on the finite set `S` with a strong induction hypothesis. Base case: `S` is empty. The theorem follows from the definition of `ring_product` in this case and `poly_1_o_permutes`.
Inductive step: Assume the property holds for `S`. We need to show it for `INSERT x S`. After rewriting using the definition of `ring_product`, we need to show `(p x) (m o f) * (ring_product S (\s m. p s (m o f)) m) = ring_product (INSERT x S) (\s m. p s (m o f)) m` where `*` denotes multiplication in `powser_ring r`. `powerseries_o_permutes` is used to rewrite `(p x) (m o f)` such that we can call `poly_mul_o_permutes` on the product. Then, we are left with showing that  `(\m. ring_product S (\s n. p s (n o f)) m) = ring_product S (\s n. p s (n o f))`. This is proven by appealing to `FUN_EQ_THM`.

- Base Case: `FINITE EMPTY`
- Inductive Step: For an arbitrary `x`, assume `!(S:X->bool). FINITE S ==> (!m. f permutes U ==> (!s. s IN S ==> ring_powerseries r (p s)) ==> ring_product(powser_ring r (:V)) S p (m o f) = ring_product(powser_ring r (:V)) S (\s m. (p s) (m o f)) m)`
  prove `!m. f permutes U ==> (!s. s IN (INSERT x S) ==> ring_powerseries r (p s)) ==> ring_product(powser_ring r (:V)) (INSERT x S) p (m o f) = ring_product(powser_ring r (:V)) (INSERT x S) (\s m. (p s) (m o f)) m` by using `powerseries_o_permutes` and `poly_mul_o_permutes`

### Mathematical insight
The theorem states that the product of powerseries, when composed with a permutation, is the same as the product where each individual powerseries is composed with the permutation. This theorem is useful for simplifying expressions involving products of power series and permutations and shows that the ring product interacts nicely with function composition.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POWSER_RING`
- `poly_1_o_permutes`
- `powerseries_o_permutes`
- `poly_mul_o_permutes`
- `FUN_EQ_THM`

### Porting notes (optional)
The main challenge in porting this theorem might lie in the correct instantiation and application of `powerseries_o_permutes` and `poly_mul_o_permutes`. Also, the handling of function composition and the `powser_ring` definition have to be considered carefully. Make sure that the porting target has appropriate definitions of `FINITE`, `ring_product`, `ring_powerseries` and other ring theory concepts.


---

## poly_product_o_permutes

### Name of formal statement
poly_product_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_o_permutes = prove(`
  !(r:R ring) p:X->(V->num)->R U f S.
  FINITE S ==>
  !m.
  f permutes U ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  ring_product(poly_ring r (:V)) S p (m o f) =
  ring_product(poly_ring r (:V)) S (\s m. (p s) (m o f)) m
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES] THEN
    rw[POLY_RING] THEN
    qed[poly_1_o_permutes]
  ;
    intro THEN
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `ring_polynomial(r:R ring) (p(x:X):(V->num)->R)` [] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `f:V->V`;
      `U:V->bool`
    ]polynomial_o_permutes THEN
    have `p(x:X) IN ring_carrier(poly_ring(r:R ring) (:V))` [poly_use] THEN
    have `(\m:V->num. p(x:X) (m o (f:V->V))) IN ring_carrier(poly_ring(r:R ring) (:V))` [poly_use] THEN
    simp[] THEN
    rw[POLY_RING] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `ring_product (poly_ring(r:R ring) (:V)) (S:X->bool) p`;
      `U:V->bool`;
      `f:V->V`;
      `m:V->num`
    ]poly_mul_o_permutes THEN
    simp[] THEN
    subgoal `(\m:V->num. ring_product (poly_ring(r:R ring) (:V)) S (\s:X n:V->num. p s (n o (f:V->V))) m) = ring_product (poly_ring r (:V)) S (\s n. p s (n o f))` THENL [
      rw[FUN_EQ_THM]
    ; pass
    ] THEN
    simp[]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any type `X`, any type `V`, any function `p` from `X` to functions from `V` to the numbers to `R`, any set `U` of elements of type `V`, any function `f` from `V` to `V`, and any set `S` of elements of type `X`, given that `S` is finite, if `f` permutes `U`, and if for all `s` in `S`, `p s` is a ring polynomial over `r`, then the ring product over `S` of `p s` composed with `f` (that is, `ring_product(poly_ring r (:V)) S p (m o f)`) is equal to the ring product over `S` of `p s` composed with `f` as applied pointwise, (that is, `ring_product(poly_ring r (:V)) S (\s m. (p s) (m o f)) m`).

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.
- **Base Case:** If `S` is empty, then the ring product is 1, and `poly_1_o_permutes` is used.
- **Inductive Step:**
  - Assume the result holds for all subsets of `S`. Let `x` be an element of type `X`. We want to show that the result holds for `x INSERT S`.
  - Simplify using the clauses for `RING_PRODUCT_CLAUSES`.
  - The hypothesis `ring_polynomial r (p s)` and `polynomial_o_permutes` is specialized by instantiating its variables.
  - `poly_mul_o_permutes` is specialized.
  - Prove the subgoal using `FUN_EQ_THM`.

### Mathematical insight
The theorem states that composing with a permutation before taking a ring product is equivalent to first taking the ring product and then composing with the permutation. This is a useful property when dealing with symmetric polynomials or other situations where permutations are involved.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POLY_RING`
- `poly_1_o_permutes`
- `polynomial_o_permutes`
- `poly_mul_o_permutes`
- `FUN_EQ_THM`


---

## eval_poly_product_multi

### Name of formal statement
eval_poly_product_multi

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_poly_product_multi = prove(`
  !(r:R ring) (p:X->(V->num)->R) c U S.
  FINITE S ==>
  (!s:X. s IN S ==> p s IN ring_carrier(poly_ring r U)) ==>
  (!v. v IN U ==> c v IN ring_carrier r) ==>
  poly_evaluate r (ring_product(poly_ring r (:V)) S p) c
  = ring_product r S (\s. poly_evaluate r (p s) c)
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;POLY_RING;POLY_EVALUATE_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    specialize[`r:R ring`;`U:V->bool`](CONJUNCT1 POLY_RING) THEN
    have `p(x:X):(V->num)->R IN {q | ring_polynomial(r:R ring) q /\ poly_vars r q SUBSET U}` [] THEN
    set_fact `p(x:X):(V->num)->R IN {q | ring_polynomial(r:R ring) q /\ poly_vars r q SUBSET U} ==> ring_polynomial r (p x)` THEN
    have `p(x:X) IN ring_carrier(poly_ring(r:R ring) (:V))` [poly_use] THEN
    simp[RING_PRODUCT_CLAUSES;POLY_EVALUATE;POLY_RING] THEN
    have `ring_polynomial(r:R ring) (ring_product (poly_ring r (:V)) (S:X->bool) p)` [RING_PRODUCT;poly_use] THEN
    subgoal `!i. i IN poly_vars(r:R ring) (p(x:X)) UNION poly_vars r (ring_product (poly_ring r (:V)) S p) ==> c i IN ring_carrier r` THENL [
      rw[IN_UNION] THEN
      set_fact `p(x:X):(V->num)->R IN {q | ring_polynomial(r:R ring) q /\ poly_vars r q SUBSET U} ==> poly_vars r (p x) SUBSET U` THEN
      subgoal `ring_product (poly_ring(r:R ring) (:V)) (S:X->bool) p IN ring_carrier(poly_ring r U)` THENL [
        have `!s:X. s IN S ==> p s:(V->num)->R IN ring_carrier (poly_ring r U)` [] THEN
        specialize[
          `r:R ring`;
          `p:X->(V->num)->R`;
          `U:V->bool`;
          `S:X->bool`
        ]poly_product_in_poly_ring THEN
        qed[]
      ; pass
      ] THEN
      have `ring_product (poly_ring r (:V)) (S:X->bool) p IN {q | ring_polynomial(r:R ring) q /\ poly_vars r q SUBSET U}` [] THEN
      set_fact `ring_product (poly_ring r (:V)) (S:X->bool) p IN {q | ring_polynomial(r:R ring) q /\ poly_vars r q SUBSET U} ==> poly_vars r (ring_product (poly_ring r (:V)) S p) SUBSET U` THEN
      GEN_TAC THEN DISCH_TAC THEN
      have `i:V IN U` [SUBSET] THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `ring_product (poly_ring(r:R ring) (:V)) (S:X->bool) p`;
      `c:V->R`
    ]POLY_EVALUATE_MUL THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r` over type `R`, any set of variables `U` of type `V`, any finite set `S` of type `X`, any mapping `p` from `X` to polynomials over `r` with variables in `U`, and any variable assignment `c` from `V` to the carrier of `r`, if every element `s` in `S` maps to a polynomial `p s` over `r` with variables in `U`, and every variable `v` in `U` is assigned a value `c v` in the carrier of `r`, then the evaluation of the product of the polynomials `p s` for all `s` in `S` under the variable assignment `c` is equal to the product of the evaluations of the individual polynomials `p s` under the variable assignment `c` for all `s` in `S`.

### Informal sketch
*   The proof proceeds by strong induction on the finiteness of the set `S`.
*   **Base Case:** When `S` is empty, both sides of the equation reduce to the multiplicative identity of the ring `r` due to `RING_PRODUCT_CLAUSES` and `POLY_EVALUATE_1`.
*   **Inductive Step:** Assume the theorem holds for all sets `S'` such that `FINITE S'`. We want to prove it for `INSERT x S`, where `x` is an element of type `X`.
*   The left-hand side is `poly_evaluate r (ring_product (poly_ring r (:V)) (INSERT x S) p) c`. This is expanded using `RING_PRODUCT_CLAUSES` to `poly_evaluate r ((p x) * (ring_product (poly_ring r (:V)) S p)) c`.
*   The right-hand side is `ring_product r (INSERT x S) (\s. poly_evaluate r (p s) c)`. This is expanded using `RING_PRODUCT_CLAUSES` to `(poly_evaluate r (p x) c) * (ring_product r S (\s. poly_evaluate r (p s) c))`.
*   We require that each `p x` is a polynomial over `r` with variables in `U` to ensure correct evaluation.
*   We apply the inductive hypothesis and use the theorem `POLY_EVALUATE_MUL` to split the evaluation of the product on the left-hand side, transforming it into the product of individual evaluations.
*   Finally, we show that all variables in `poly_vars(r:R ring) (p(x:X))` and `poly_vars r (ring_product (poly_ring r (:V)) S p)` get values within `ring_carrier r`, thus permitting evaluation.

### Mathematical insight
This theorem states that the evaluation of a product of polynomials is the product of the evaluations of those polynomials. This is a fundamental property used in algebraic manipulation and simplifies computation in many contexts. The condition `(!s:X. s IN S ==> p s IN ring_carrier(poly_ring r U))` ensures that we are indeed multiplying polynomials and the product remains a well-defined polynomial.

### Dependencies
* `RING_PRODUCT_CLAUSES`
* `POLY_RING`
* `POLY_EVALUATE_1`
* `POLY_EVALUATE`
* `RING_PRODUCT`
* `IN_UNION`
* `SUBSET`
* `POLY_EVALUATE_MUL`
* `poly_product_in_poly_ring`

### Porting notes (optional)
*   Ensure that the target proof assistant has a notion of rings, polynomials, and variable assignments.
*   The finiteness condition on `S` might need to be expressed differently depending on the target system.
*   The `POLY_EVALUATE_MUL` theorem is crucial for bridging the gap between the product of polynomials and the product of their evaluations. Make sure an equivalent exists or can be proven.
*   The handling of dependent types (specifically, the type of polynomials depending on the ring `r`) might require careful attention.


---

## poly_product_restrict_subset

### Name of formal statement
poly_product_restrict_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_product_restrict_subset = prove(`
  !(r:R ring) S:X->bool U p.
  S SUBSET U ==>
  poly_product r U (\s. if s IN S then p s else poly_1 r)
  = poly_product r S p
`,
  rw[poly_product;x_series_use] THEN
  intro THEN
  specialize[
    `S:X->bool`;
    `x_series(r:R ring)`;
    `U:X->bool`;
    `p:X->(1->num)->R`
  ]RING_PRODUCT_RESTRICT_SET THEN
  set_fact `S SUBSET U:X->bool ==> {x | x IN U /\ S x} = S` THEN
  rw[IN] THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, any sets `S` and `U` (represented as boolean valued functions over a type `X`), and any function `p` from `X` to functions from natural numbers to the ring `r`, if `S` is a subset of `U`, then the product of `p(s)` for all `s` in `U`, where `p(s)` is replaced by the multiplicative identity `poly_1 r` if `s` is not in `S`, is equal to the product of `p(s)` for all `s` in `S`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `poly_product` using `rw[poly_product;x_series_use]`.
- Introduce the assumptions using `intro`.
- Specialize the theorem `RING_PRODUCT_RESTRICT_SET` with the given parameters `S`, `x_series(r:R ring)`, `U`, and `p`. This theorem likely states a general property about products over sets with a restriction.
- Establish the fact `S SUBSET U:X->bool ==> {x | x IN U /\ S x} = S` given the subset relation using `set_fact`.
- Rewrite using the definition of `IN` (set membership) by `rw[IN]`.
- Conclude the proof using `qed[]`.

### Mathematical insight
This theorem captures the intuition that if we are taking a product over a set `U`, and we replace the terms corresponding to elements not in a subset `S` of `U` with the multiplicative identity, then the result is the same as taking the product only over the subset `S`. This is a crucial property for manipulating products and sums in algebraic settings, as it allows us to restrict the domain of the product to a relevant subset without changing the result.

### Dependencies
- `poly_product`
- `x_series_use`
- `RING_PRODUCT_RESTRICT_SET`
- `IN`


---

## poly_const_product

### Name of formal statement
poly_const_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_product = prove(`
  !(r:R ring) f:X->R S.
  FINITE S ==>
  (!t. t IN S ==> f t IN ring_carrier r) ==>
  poly_const r (ring_product r S f) =
  poly_product r S (\t. poly_const r (f t))
`,
  GEN_TAC THEN
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;poly_product_empty] THEN
    rw[POLY_CONST_1]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    have `ring_powerseries r (poly_const r (f(x:X)):(1->num)->R)` [RING_POWERSERIES_CONST] THEN
    simp[RING_PRODUCT_CLAUSES;poly_product_insert] THEN
    qed[POLY_CONST_MUL;RING_PRODUCT]
  ]
);;
```

### Informal statement
For any ring `r` (with carrier `ring_carrier r` and ring product operation `ring_product r`), any function `f` from a type `X` to the ring `r`, and any finite set `S` of type `X`, such that for every `t` in `S`, `f t` belongs to the carrier of ring `r`, the polynomial constant of the ring `r` applied to the ring product of `r` over `S` with respect to `f` is equal to the ring product of `r` over `S` with respect to the function that maps each `t` to the polynomial constant of `r` applied to `f t`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case (`S` is empty): Reduce both sides using the clauses for `RING_PRODUCT` in the empty set to 1, and use the fact that the polynomial constant of 1 is 1 (`POLY_CONST_1`).
- Inductive step (`S` is `x INSERT S`): Assume the theorem holds for all subsets of `S`. Show that `s IN S ==> s IN x INSERT S` and `x IN x INSERT S`. Rewrite both sides using the clauses for `RING_PRODUCT` over an insertion. Apply `POLY_CONST_MUL` to the left side and `RING_PRODUCT` to finish the proof. Utilize pre-existing knowledge about constant polynomials (`RING_POWERSERIES_CONST`).

### Mathematical insight
This theorem essentially states that the polynomial constant of a ring product is the ring product of polynomial constants, provided the ring product is applied to elements within the ring. This is a useful result for manipulating expressions involving polynomials and ring products.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `poly_product_empty`
- `POLY_CONST_1`
- `POLY_CONST_MUL`
- `RING_PRODUCT`
- `RING_POWERSERIES_CONST`

### Porting notes (optional)
This theorem relies on the definition and properties of ring products over finite sets and polynomial constants. Special attention should be paid to the encoding of finiteness and how ring products are handled in the target proof assistant. In systems like Coq or Lean, one might need to explicitly prove the equivalence between different encodings of finiteness. The use of clauses to define `RING_PRODUCT` assists with rewriting.


---

## monic_vanishing_at

### Name of formal statement
monic_vanishing_at

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let monic_vanishing_at = new_definition `
  monic_vanishing_at (r:R ring) (S:X->bool) (c:X->R)
  = poly_product r S (\s. x_minus_const r (c s))
`;;
```
### Informal statement
For a ring `R`, a subset `S` of a type `X`, and a function `c` from `X` to `R`, `monic_vanishing_at r S c` is defined as the product of the polynomials `x_minus_const r (c s)` for all `s` in `S`.

### Informal sketch
- The definition constructs a polynomial by taking a product of linear factors.
- Each linear factor is of the form `x - c s`, where `c s` is a constant in the ring `R` determined by the function `c` applied to an element `s` from the set `S`.
- The `poly_product` function computes the product of these polynomials over the set `S`. The ring `r` is an argument to `poly_product` and signifies the ring in which the polynomial coefficients lie.
- The resulting polynomial `monic_vanishing_at r S c` will vanish at each of the values `c s` for `s` in `S`. It will be monic provide that `S` is finite.

### Mathematical insight
The definition constructs a polynomial that has roots at specific values determined by the function `c` on the set `S`. This is a standard technique to construct polynomials with prescribed roots.

### Dependencies
- `poly_product`
- `x_minus_const`


---

## monic_vanishing_at_empty

### Name of formal statement
monic_vanishing_at_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_empty = prove(`
  !(r:R ring) c:X->R.
  monic_vanishing_at r {} c = poly_1 r
`,
  qed[monic_vanishing_at;poly_product_empty]
);;
```
### Informal statement
For any ring `r` and any function `c` from a type `X` to `r`, `monic_vanishing_at r {} c` is equal to `poly_1 r`.

### Informal sketch
The proof proceeds by induction using `monic_vanishing_at` definition and appealing to `poly_product_empty`.
- The definition of `monic_vanishing_at r s c` is reduced to `poly_1 r` when `s` is empty.
- `poly_product_empty` simplifies the product of polynomials over an empty set to `poly_1 r`.

### Mathematical insight
This theorem states that if we have an empty set of roots, the corresponding monic polynomial is just 1. It captures a fundamental aspect of polynomial construction related to vanishing at roots: with no roots, we have the multiplicative identity polynomial.

### Dependencies
- Definitions: `monic_vanishing_at`
- Theorems: `poly_product_empty`


---

## monic_vanishing_at_insert

### Name of formal statement
monic_vanishing_at_insert

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_insert = prove(`
  !(r:R ring) S:X->bool c t.
  (c t) IN ring_carrier r ==>
  FINITE S ==>
  monic_vanishing_at r (t INSERT S) c
  = if t IN S
    then monic_vanishing_at r S c
    else poly_mul r (x_minus_const r (c t)) (monic_vanishing_at r S c)
`,
  rw[monic_vanishing_at] THEN
  intro THEN
  have `ring_powerseries(r:R ring) (x_minus_const r (c(t:X)))` [x_minus_const_series] THEN
  simp[poly_product_insert]
);;
```

### Informal statement
For any ring `r` with carrier set `ring_carrier r`, any set `S` of type `X`, any function `c` from `X` to the carrier of `r`, and any element `t` of type `X`, if `c t` is an element of the carrier of `r` and `S` is finite, then `monic_vanishing_at r (t INSERT S) c` is equal to `monic_vanishing_at r S c` if `t` is in `S`; otherwise, it is equal to the polynomial product of `x_minus_const r (c t)` and `monic_vanishing_at r S c`.

### Informal sketch
- The proof starts by rewriting `monic_vanishing_at` to expose its definition.
- Then, we introduce the assumptions.
- Next, proving that `ring_powerseries(r:R ring) (x_minus_const r (c(t:X)))` holds using `x_minus_const_series`.
- Finally, we simplify the expression using `poly_product_insert`.

### Mathematical insight
This theorem describes how the `monic_vanishing_at` polynomial changes when an element `t` is inserted into the set `S`. If `t` is already in `S`, the polynomial remains the same. Otherwise, the polynomial is multiplied by `x - c(t)`, ensuring that the polynomial vanishes at the value `c(t)` corresponding to `t`. The function `monic_vanishing_at` constructs a monic polynomial that vanishes at all elements of a finite set `S`. This theorem is important because it provides a recursive way to construct the polynomial by adding elements to the set one by one.

### Dependencies
- `monic_vanishing_at`
- `ring_carrier`
- `FINITE`
- `poly_mul`
- `x_minus_const`
- `poly_product_insert`
- `x_minus_const_series`


---

## monic_vanishing_at_plus1

### Name of formal statement
monic_vanishing_at_plus1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_plus1 = prove(`
  !(r:R ring) c n.
  (c n) IN ring_carrier r ==>
  monic_vanishing_at r {i:num | i < n+1} c
  = poly_mul r (x_minus_const r (c n)) (monic_vanishing_at r {i:num | i < n} c)
`,
  intro THEN
  have `FINITE {i:num | i < n}` [FINITE_NUMSEG_LT] THEN
  subgoal `{i:num | i < n+1} = n INSERT {i:num | i < n}` THENL [
    rw[EXTENSION;IN_INSERT;IN_ELIM_THM] THEN
    qed[ARITH_RULE `i < n+1 <=> i = n \/ i < n`]
  ;
    num_linear_fact `~(n < n:num)` THEN
    set_fact `~(n < n) ==> ~(n IN {i:num | i < n})` THEN
    specialize[`r:R ring`;`{i:num | i < n}`;`c:num->R`;`n:num`]monic_vanishing_at_insert THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r` (with carrier `ring_carrier r`) and any function `c` from natural numbers to the ring `r`, if `c n` is an element of the carrier of the ring `r` for all natural numbers `n`, then the polynomial `monic_vanishing_at r {i:num | i < n+1} c` is equal to the polynomial `poly_mul r (x_minus_const r (c n)) (monic_vanishing_at r {i:num | i < n} c)`.

### Informal sketch
The proof proceeds by induction. The critical step involves rewriting `{i:num | i < n+1}` as `n INSERT {i:num | i < n}`. This decomposition allows us to apply the theorem `monic_vanishing_at_insert`.
- Verify the set equality mentioned above: `{i:num | i < n+1} = n INSERT {i:num | i < n}` using standard set theory and arithmetic (`EXTENSION; IN_INSERT; IN_ELIM_THM`, `ARITH_RULE`).
- Then, use `num_linear_fact` to prove `~(n < n:num)` which implies `~(n IN {i:num | i < n})`.
- Finally, specialize and apply `monic_vanishing_at_insert`.

### Mathematical insight
This theorem provides a recursive way to construct the monic polynomial `monic_vanishing_at r s c` which vanishes at the points `c i` for each `i` in the set `s`.  The theorem expresses how increasing the index set `s` by one impacts the resultant polynomial. This is fundamental for constructing polynomials that vanish at specific points within a given ring.

### Dependencies
- `ring_carrier`
- `monic_vanishing_at`
- `poly_mul`
- `x_minus_const`
- `FINITE_NUMSEG_LT`
- `EXTENSION`
- `IN_INSERT`
- `IN_ELIM_THM`
- `ARITH_RULE`
- `num_linear_fact`
- `monic_vanishing_at_insert`

### Porting notes (optional)
The main challenge in porting this theorem might lie in ensuring that the set theory and arithmetic rules (`ARITH_RULE`) used in HOL Light are adequately represented and automated in the target proof assistant. The dependencies, especially `monic_vanishing_at_insert` and `monic_vanishing_at` need to be ported first.


---

## monic_vanishing_at_eq

### Name of formal statement
monic_vanishing_at_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_eq = prove(`
  !(r:R ring) S:X->bool c d.
  (!s:X. s IN S ==> c s = d s) ==>
  monic_vanishing_at r S c = monic_vanishing_at r S d
`,
  rw[monic_vanishing_at] THEN
  qed[poly_product_eq]
);;
```
### Informal statement
For any ring `R`, any set `S` of type `X`, and any functions `c` and `d` from `X` to `R`, if `c s = d s` for all `s` in `S`, then `monic_vanishing_at r S c` is equal to `monic_vanishing_at r S d`.

### Informal sketch
- The proof proceeds by rewriting the definition of `monic_vanishing_at`.
- The goal then follows by `poly_product_eq`.
    - `poly_product_eq` states that if two coefficient functions are equal on a set, then the monic polynomials vanishing on that set are equal.

### Mathematical insight
This theorem states that the `monic_vanishing_at` function, which constructs a monic polynomial that vanishes on a set `S`, produces the same polynomial if we replace a coefficient function with another function that agrees with it on the set `S`. This reflects the idea that the polynomial is determined by its values on the set `S`.

### Dependencies
- Definitions: `monic_vanishing_at`
- Theorems: `poly_product_eq`


---

## monic_vanishing_at_poly

### Name of formal statement
monic_vanishing_at_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_poly = prove(`
  !(r:R ring) S c:X->R.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_polynomial r (monic_vanishing_at r S c)
`,
  intro THEN
  have `(!s. s IN S ==> ring_polynomial(r:R ring) (x_minus_const r (c(s:X))))` [x_minus_const_poly] THEN
  rw[monic_vanishing_at] THEN
  qed[poly_product_poly]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any finite set `S` of type `X`, and any function `c` from `X` to `R`, if for all `s`, `s` in `S` implies `c s` is in the carrier of the ring `r`, then the polynomial `monic_vanishing_at r S c` is a polynomial over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- We introduce the assumptions: a ring `r`, a finite set `S`, and a function `c`. We also assume that for every element `s` in `S`, `c s` is an element of the ring carrier of `r`.
- We show that for all `s`, if `s` is in `S`, then `x_minus_const r (c s)` is a polynomial over the ring `r`. This relies on `x_minus_const_poly`.
- We rewrite the goal with `monic_vanishing_at`, which presumably expands the definition of `monic_vanishing_at r S c`.
- We complete the proof using `poly_product_poly`, which likely states that a product of polynomials (over a ring) is also a polynomial (over that ring), and that the `monic_vanishing_at` is defined as a product of polynomials.

### Mathematical insight
The theorem establishes that the polynomial `monic_vanishing_at r S c` is indeed a polynomial over the ring `r`, assuming that the function `c` maps elements of the set `S` into the ring carrier of `r`. The polynomial `monic_vanishing_at r S c` is defined as a product of linear factors of the form `x - c s` for `s` in `S`. This theorem is important because it ensures that the constructed polynomial has the correct type, i.e., it is a polynomial over the ring `r`.

### Dependencies
- `FINITE`
- `ring_carrier`
- `ring_polynomial`
- `monic_vanishing_at`
- `x_minus_const_poly`
- `poly_product_poly`


---

## monic_vanishing_at_series

### Name of formal statement
monic_vanishing_at_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_series = prove(`
  !(r:R ring) S c:X->R.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_powerseries r (monic_vanishing_at r S c)
`,
  qed[monic_vanishing_at_poly;ring_polynomial]
);;
```
### Informal statement
For any ring `r`, any finite set `S` of elements of type `X`, and any function `c` from `X` to the carrier of the ring `r`, such that for all `s` in `S`, `c s` is in the carrier of `r`, then `monic_vanishing_at r S c` is a power series over the ring `r`.

### Informal sketch
* The theorem asserts that `monic_vanishing_at r S c` (which represents a formal power series constructed to vanish at certain points) is indeed a power series.
* The proof utilizes the earlier theorem `monic_vanishing_at_poly` showing that `monic_vanishing_at r S c` is a polynomial. The theorem `ring_polynomial` then shows that polynomials over a ring are powerseries over that ring.

### Mathematical insight
The theorem confirms that a construction intended to produce a power series (specifically, one vanishing at the specified elements `s` in `S` with corresponding ring elements `c s` being viewed as the value of the evaluation at `s`) indeed results in a valid power series. This is a crucial step in establishing the algebraic properties of such vanishing constructions. It shows that if the evaluation points are ring elements and the set of evaluation points is finite, then the vanishing "function" is a formal power series.

### Dependencies
- Theorems: `monic_vanishing_at_poly`, `ring_polynomial`


---

## x_derivative_monic_vanishing_at

### Name of formal statement
x_derivative_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_monic_vanishing_at = prove(`
  !(r:R ring) S c:X->R.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  x_derivative r (monic_vanishing_at r S c)
  = poly_sum r S
      (\s. (monic_vanishing_at r (S DELETE s) c))
`,
  intro THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (x_minus_const r (c s))` [x_minus_const_series] THEN
  specialize[`r:R ring`;`\s:X. x_minus_const(r:R ring) (c s)`;`S:X->bool`]x_derivative_product THEN
  rw[monic_vanishing_at] THEN
  simp[] THEN
  sufficesby poly_sum_eq THEN
  intro THEN
  simp[x_derivative_x_minus_const] THEN
  have `FINITE(S DELETE s:X)` [FINITE_DELETE] THEN
  set_fact `!t:X. t IN S DELETE s ==> t IN S` THEN
  have `!t:X. t IN S DELETE s ==> ring_powerseries(r:R ring) (x_minus_const r (c t))` [] THEN
  specialize[`r:R ring`;`\s:X. x_minus_const(r:R ring) (c s)`;`(S:X->bool) DELETE s`]poly_product_series THEN
  qed[POLY_MUL_LID]
);;
```
### Informal statement
For any ring `r` and any finite set `S` of elements of type `X`, and any function `c` from `X` to the carrier of `r` such that for all `s` in `S`, `c s` is in the carrier of `r`, the formal derivative of the polynomial `monic_vanishing_at r S c` is equal to the sum, for `s` in `S`, of the polynomials `monic_vanishing_at r (S DELETE s) c`.

### Informal sketch
The proof proceeds by induction on the size of the finite set `S`.
- First, we introduce the assumptions.
- We then specialize the theorem `x_derivative_product` to create a specific result about the derivatives of products of ring power series.
- Next, we rewrite using the definition of `monic_vanishing_at`.
- Then, we simplify.
- After that, we reduce the problem to proving an equality about `poly_sum`.
- Then we introduce assumptions, simplify the `x_derivative_x_minus_const` term.
- Then, we establish finiteness of the `S DELETE s` using `FINITE_DELETE`.
- Next, show that `t IN S DELETE s` implies `t IN S`.
- Specialize `poly_product_series` and discharge the proof using `POLY_MUL_LID`.

### Mathematical insight
The theorem states that the derivative of a monic polynomial that vanishes at the points `c s` for `s` in `S` is equal to the sum of monic polynomials, each vanishing at all `c s` except for one particular `s`. This reflects the product rule of differentiation, focusing on the behavior of polynomial roots.

### Dependencies
- `FINITE`
- `x_derivative`
- `monic_vanishing_at`
- `poly_sum`
- `x_minus_const`
- `x_derivative_product`
- `poly_sum_eq`
- `x_derivative_x_minus_const`
- `FINITE_DELETE`
- `poly_product_series`
- `POLY_MUL_LID`


---

## eval_monic_vanishing_at

### Name of formal statement
eval_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_monic_vanishing_at = prove(`
  !(r:R ring) S (c:X->R) z.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  z IN ring_carrier r ==>
  poly_eval r (monic_vanishing_at r S c) z
  = ring_product r S (\s. ring_sub r z (c s))
`,
  intro THEN
  rw[monic_vanishing_at] THEN
  have `!s:X. s IN S ==> ring_polynomial(r:R ring) (x_minus_const r (c s))` [x_minus_const_poly] THEN
  simp[eval_poly_product] THEN
  sufficesby RING_PRODUCT_EQ THEN
  qed[eval_x_minus_const]
);;
```
### Informal statement
For any ring `r` (with carrier denoted as `ring_carrier r`), any finite set `S`, any function `c` from elements of type `X` to the carrier of the ring `r`, and any element `z` in the carrier of the ring `r`, if every element `s` in `S` maps via `c` to an element `c s` in the carrier of `r`, then the evaluation of the polynomial `monic_vanishing_at r S c` at `z` is equal to the product, in the ring `r`, of the set `S` where each element `s` is mapped to `ring_sub r z (c s)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions and rewrite using the definition of `monic_vanishing_at`.
- Show that for every `s` in `S`, `x_minus_const r (c s)` is a polynomial.
- Simplify the left-hand side by evaluating the product using `eval_poly_product`.
- Apply `RING_PRODUCT_EQ` to show that evaluation of the polynomial product equals the ring product of evaluations of the constituent polynomials `x_minus_const`, which are `eval_x_minus_const r (c s) z = ring_sub r z (c s)`.

### Mathematical insight
This theorem essentially states that evaluating the polynomial which vanishes on the set `S` (where the vanishing is achieved by choosing appropriate constants `c s` to subtract from `x`), when evaluated at a point `z`, gives the product of the differences between `z` and the constants `c s` associated with the elements of `S`. The `monic_vanishing_at` polynomial is constructed to have roots at the values `c s` for `s` in the set `S`.

### Dependencies
- `FINITE`
- `ring_carrier`
- `monic_vanishing_at`
- `ring_product`
- `ring_sub`
- `eval_poly_product`
- `x_minus_const`
- `ring_polynomial`
- `eval_x_minus_const`


---

## ring_product_eq_0

### Name of formal statement
ring_product_eq_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_eq_0 = prove(`
  !(r:R ring) S (f:X->R).
  FINITE S /\
  (!s. s IN S ==> f s IN ring_carrier r) /\
  (?t. t IN S /\ f t = ring_0 r) ==>
  ring_product r S f = ring_0 r
`,
  intro THEN
  set_fact `t:X IN S ==> S = t INSERT (S DELETE t)` THEN
  set_fact `~(t:X IN (S DELETE t))` THEN
  have `FINITE (S DELETE (t:X))` [FINITE_DELETE] THEN
  have `ring_product(r:R ring) (t INSERT (S DELETE (t:X))) f = ring_mul r (f t) (ring_product r (S DELETE t) f)` [RING_PRODUCT_CLAUSES] THEN
  have `ring_product(r:R ring) S f = ring_mul r (f t) (ring_product r (S DELETE(t:X)) f)` [] THEN
  qed[RING_MUL_LZERO;RING_PRODUCT]
);;
```

### Informal statement
For any ring `r` of type `R ring`, and for any set `S` of type `X`, and for any function `f` from `X` to `R`, if `S` is finite and for all `s`, if `s` is in `S` then `f s` is in the carrier of the ring `r`, and there exists a `t` such that `t` is in `S` and `f t` is equal to the zero of the ring `r`, then the ring product of `f` over `S` with respect to ring `r` is equal to the zero of the ring `r`.

### Informal sketch
The proof proceeds by induction on the size of the finite set `S`.
- Assume that the condition `?t. t IN S /\ f t = ring_0 r` holds. Choose such a `t`.
- Rewrite `S` as `t INSERT (S DELETE t)`.
- Then `ring_product r S f` can be rewritten (using `RING_PRODUCT_CLAUSES`) as `ring_mul r (f t) (ring_product r (S DELETE t) f)`.
- Since `f t = ring_0 r`, the expression `ring_mul r (f t) (ring_product r (S DELETE t) f)` simplifies to `ring_mul r (ring_0 r) (ring_product r (S DELETE t) f)`.
- Finally, `ring_mul r (ring_0 r) (ring_product r (S DELETE t) f)` simplifies to `ring_0 r` using `RING_MUL_LZERO`.

### Mathematical insight
This theorem states that if any element in the set `S` maps to the ring zero under the function `f`, then the product of `f` over `S` is zero in the given ring. This is a fundamental property of rings.

### Dependencies
- `FINITE_DELETE`
- `RING_PRODUCT_CLAUSES`
- `RING_MUL_LZERO`
- `RING_PRODUCT`

### Porting notes (optional)
The main challenge in porting this theorem lies in ensuring that the finiteness conditions are handled correctly in the target proof assistant. Additionally, the inductive definition of `ring_product` should be ported faithfully. Theorem `RING_PRODUCT_CLAUSES` may need to be re-established depending on how the inductive definition is ported. The tactics `intro` and `set_fact` are common tactics, however, `qed[RING_MUL_LZERO;RING_PRODUCT]` will likely require different automation in another proof assistant.


---

## eval_monic_vanishing_at_refl

### Name of formal statement
eval_monic_vanishing_at_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_monic_vanishing_at_refl = prove(`
  !(r:R ring) S (c:X->R) t.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  t IN S ==>
  poly_eval r (monic_vanishing_at r S c) (c t)
  = ring_0 r
`,
  intro THEN
  have `c(t:X) IN ring_carrier(r:R ring)` [] THEN
  simp[eval_monic_vanishing_at] THEN
  sufficesby ring_product_eq_0 THEN
  qed[RING_SUB_REFL;RING_SUB]
);;
```
### Informal statement
Given a ring `r` with carrier `ring_carrier r`, a set `S` of type `X`, and a function `c` from `X` to the carrier of `r`, if `S` is finite and for all `s` in `S`, `c s` is in `ring_carrier r`, then for any `t` in `S`, the polynomial evaluation of `monic_vanishing_at r S c` at `c t` using the ring `r` is equal to the zero element `ring_0 r` of the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: finiteness of `S`, membership of `c s` in `ring_carrier r` for all `s` in `S`, and `t` is in `S`.
- Establish that `c t` belongs to `ring_carrier r`.
- Simplify the evaluation `poly_eval r (monic_vanishing_at r S c) (c t)` to a ring product, which involves terms of the form `ring_sub r (c t) (c s)` for `s` in `S`.
- It suffices to prove that this ring product is zero. This hinges on showing that one of the factors `ring_sub r (c t) (c s)` is zero when `s = t`.
- Apply `RING_SUB_REFL` and `RING_SUB` to demonstrate that `ring_sub r (c t) (c t) = ring_0 r`.
- Apply `ring_product_eq_0` and conclude that the entire expression equals `ring_0 r`.

### Mathematical insight
The theorem states a fundamental property relating to polynomials which vanish on a given set. The polynomial `monic_vanishing_at r S c` is constructed to be monic and to have roots at the values `c s` for all `s` in `S`. The theorem simply confirms that evaluating this polynomial at any of those roots indeed yields zero in the corresponding ring. This is a key result in the theory of polynomial rings.

### Dependencies
- `eval_monic_vanishing_at`
- `ring_product_eq_0`
- `RING_SUB_REFL`
- `RING_SUB`


---

## monic_vanishing_at_image

### Name of formal statement
monic_vanishing_at_image

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_image = prove(`
  !(r:R ring) S (f:X->Y) (g:Y->R).
  (!x y. x IN S ==> y IN S ==> f x = f y ==> x = y) ==>
  monic_vanishing_at r (IMAGE f S) g = monic_vanishing_at r S (g o f)
`,
  rw[monic_vanishing_at] THEN
  intro THEN
  specialize[`r:R ring`;`S:X->bool`;`f:X->Y`;`\s:Y. x_minus_const(r:R ring) (g s)`]poly_product_image THEN
  simp[] THEN
  sufficesby poly_product_eq THEN
  qed[FUN_EQ_THM;o_THM]
);;
```
### Informal statement
For any ring `r` with carrier type `R`, any sets `S` of type `X` and functions `f:X -> Y` and `g:Y -> R`, if `f` is injective on `S` (i.e., for all `x` and `y` in `S`, if `f x = f y` then `x = y`), then the polynomial `monic_vanishing_at r` of the image of `S` under `f` applied to `g` equals the polynomial `monic_vanishing_at r` of `S` applied to the composition of `g` and `f`.

### Informal sketch
The proof proceeds as follows:
- Expand `monic_vanishing_at` on both sides of the equation using its definition.
- Introduce the assumptions of the theorem, particularly the injectivity condition.
- Specialize the theorem `poly_product_image` with `r`, `S`, `f` and `g` replaced by a function that subtracts a constant value from its input (`x_minus_const (g s)`).
- Simplify the resulting expression.
- It suffices to show that two polynomial products are equal to prove the theorem, so the proof reduces to demonstrating that `poly_product_eq` holds
- The equality is established by using the theorems `FUN_EQ_THM` and `o_THM`.

### Mathematical insight

The key idea is that if `f` is injective on `S`, then the set of roots of the polynomial `monic_vanishing_at r` on the image `IMAGE f S` when composed with `g` is essentially the same as considering the set `S` and composing `g` with `f`. This allows algebraic manipulations based on polynomial roots over the image of `f(S)` to be translated back to the original set `S`.

### Dependencies
Polynomials:
- `monic_vanishing_at`
- `poly_product_image`
- `poly_product_eq`
Theorems:
- `FUN_EQ_THM`
- `o_THM`



---

## monic

### Name of formal statement
monic

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let monic = new_definition `
  monic (r:R ring) (p:(1->num)->R)
  <=> coeff (poly_deg r p) p = ring_1 r
`;;
```
### Informal statement
Given a ring `r` and a polynomial `p` with coefficients in `r`, we say that `p` is monic if and only if the coefficient of `p` at its degree (as given by `poly_deg r p`) is equal to the multiplicative identity `ring_1 r` of the ring `r`.

### Informal sketch
The definition of `monic` is straightforward: it checks if the leading coefficient (the coefficient corresponding to the highest power with a non-zero coefficient) of the polynomial is the multiplicative identity of the ring.
There is no proof sketch, as it is a definition.

### Mathematical insight
The definition of a monic polynomial is standard and important in algebra. Monic polynomials have several nice properties, particularly in the context of polynomial rings over fields. For example, if $R$ is a unique factorization domain, then any polynomial in $R[x]$ divides a monic polynomial.

### Dependencies
- Definition: `poly_deg`
- Definition: `coeff`
- Definition: `ring_1`
- Type: `R ring`


---

## monic_zero_ring

### Name of formal statement
monic_zero_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_zero_ring = prove(`
  !(r:R ring) p.
  ring_1 r = ring_0 r ==>
  ring_powerseries r p ==>
  monic r p
`,
  intro THEN
  have `trivial_ring(r:R ring)` [TRIVIAL_RING_10] THEN
  have `coeff (poly_deg r p) p IN ring_carrier(r:R ring)` [coeff_series_in_ring] THEN
  have `coeff (poly_deg r p) p IN {ring_0(r:R ring)}` [trivial_ring] THEN
  set_fact `!x. x IN {ring_0(r:R ring)} ==> x = ring_0 r` THEN
  qed[monic]
);;
```
### Informal statement
For any ring `r` and any power series `p` over `r`, if the multiplicative identity `ring_1` of `r` is equal to the additive identity `ring_0` of `r`, and `p` is a power series over ring `r`, then `p` is monic over `r`.

### Informal sketch
The proof proceeds as follows:

- Assume `ring_1 r = ring_0 r` and that `p` is a power series over `r`.
- Derive that `r` is a trivial ring using the theorem `TRIVIAL_RING_10`. This means that all elements in the ring are equal to the zero element `ring_0 r`.
- State that the coefficient of  `p` at its degree `poly_deg r p` is an element of ring `r`. This is proven by the theorem `coeff_series_in_ring`.
- State that the coefficient of `p` at its degree `poly_deg r p` is an element of `{ring_0(r:R ring)}` due to `r` being a trivial ring.
- Use the definition that any element which is a member of `{ring_0(r:R ring)}` is equal to `ring_0 r`.
- Conclude that `p` is monic over `r`.

### Mathematical insight
The theorem states that if a ring is trivial (i.e., its multiplicative identity equals its additive identity), then any power series over that ring is monic. In a trivial ring, there's only one element, which is both the zero and one. Therefore, the leading coefficient of any power series must be this unique element, which makes the power series monic.

### Dependencies
- `ring_1`
- `ring_0`
- `ring_powerseries`
- `monic`
- `TRIVIAL_RING_10`
- `coeff_series_in_ring`
- `poly_deg`
- `coeff`
- `ring_carrier`
- `trivial_ring`


---

## monic_poly_0

### Name of formal statement
monic_poly_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_poly_0 = prove(`
  !(r:R ring).
  monic r (poly_0 r) <=> ring_1 r = ring_0 r
`,
  rw[monic;POLY_DEG_0;coeff_poly_0] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R ring`, `poly_0 r` is monic if and only if the multiplicative identity `ring_1 r` equals the additive identity `ring_0 r`.

### Informal sketch
The proof proceeds by:
- Rewriting using definition of `monic`.
- Then rewriting using the definition of `POLY_DEG_0` which gives that the degree of a `poly_0` is less than 0.
- Then using the definition `coeff_poly_0` which says that the coefficient of `poly_0` at 0 is `ring_0`.
- Combining these rewrite rules and using basic logical reasoning, the result is proved.

### Mathematical insight
This theorem states a fundamental property: the zero polynomial is monic if and only if the ring is trivial. This is because for a polynomial to be monic, its leading coefficient must be 1. The degree of `poly_0` is less than 0, so its leading coefficient is the coefficient at index 0, which is `ring_0`. Therefore, `poly_0` is monic iff `ring_0 = ring_1`.

### Dependencies
- Definitions: `monic`, `POLY_DEG_0`, `coeff_poly_0`


---

## monic_poly_1

### Name of formal statement
monic_poly_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_poly_1 = prove(`
  !(r:R ring).
  monic r (poly_1 r)
`,
  rw[monic;POLY_DEG_1;coeff_poly_1]
);;
```
### Informal statement
For any ring `R` and any element `r` of `R`, the polynomial `poly_1 r` is monic.

### Informal sketch
The proof proceeds by rewriting the goal using the definitions of `monic`, `POLY_DEG_1`, and `coeff_poly_1`.

- The definition of `monic` states that a polynomial is monic if its leading coefficient equals 1.
- `POLY_DEG_1` defines the degree of the polynomial `poly_1 r` as 1.
- `coeff_poly_1 r 1` gives the coefficient of x^1 in `poly_1 r`, which will be shown to be 1.

### Mathematical insight
The theorem states that linear polynomials of the form `x + r` are monic. A polynomial is monic if its leading coefficient (the coefficient of the highest power of the variable) is 1. This is a fundamental property when considering polynomial rings and their factorizations.

### Dependencies
- Definitions: `monic`, `POLY_DEG_1`, `coeff_poly_1`


---

## poly_1_if_monic_deg_0

### Name of formal statement
poly_1_if_monic_deg_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_1_if_monic_deg_0 = prove(`
  !(r:R ring) p.
  ring_polynomial r p ==>
  poly_deg r p = 0 ==>
  monic r p ==>
  p = poly_1 r
`,
  intro THEN
  choose `c:R` `c IN ring_carrier r /\ p = poly_const r c:(1->num)->R` [POLY_DEG_EQ_0] THEN
  have `coeff 0 p = c:R` [coeff_poly_const] THEN
  have `coeff 0 p = ring_1(r:R ring)` [monic] THEN
  qed[poly_1]
);;
```
### Informal statement
For any ring `r` and polynomial `p` over `r`, if `p` is a ring polynomial, the degree of `p` is 0, and `p` is monic, then `p` is equal to `poly_1 r`.

### Informal sketch
*   We start with the assumptions that `p` is a ring polynomial over the ring `r`, the degree of `p` is 0, and `p` is monic.
*   We choose a ring element `c` such that `c` belongs to the carrier of `r` and `p` is the constant polynomial `poly_const r c`. This step uses the theorem `POLY_DEG_EQ_0`.
*   We show that the coefficient of `p` at index 0 is equal to `c`. This uses the theorem `coeff_poly_const`.
*   We show that the coefficient of `p` at index 0 is equal to `ring_1 r` since `p` is monic. The theorem used is `monic`.
*   Then we deduce that `p` is equal to `poly_1 r`. This uses the theorem `poly_1`.

### Mathematical insight
This theorem states that if a polynomial has degree 0 and is monic, then it must be the polynomial `poly_1`, which represents the multiplicative identity in the ring of polynomials. This is an important result when characterizing polynomials of low degree.

### Dependencies
*   Theorems: `POLY_DEG_EQ_0`, `coeff_poly_const`, `monic`, `poly_1`


---

## monic_x_pow

### Name of formal statement
monic_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_x_pow = prove(`
  !(r:R ring) n.
  monic r (x_pow r n)
`,
  intro THEN
  case `ring_1 r = ring_0(r:R ring)` THENL [
    qed[x_pow_series;monic_zero_ring]
  ;
    have `poly_deg(r:R ring) (x_pow r n) = n` [deg_x_pow] THEN
    simp[monic;coeff_x_pow]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any natural number `n`, the polynomial `x_pow r n` is monic.

### Informal sketch
The proof proceeds by induction on the ring `r`.

- Case 1: `ring_1 r = ring_0(r:R ring)`. In this case, the result follows directly from `x_pow_series` and `monic_zero_ring`.
- Case 2: We have `poly_deg(r:R ring) (x_pow r n) = n` from `deg_x_pow`. Then, using the definitions of `monic` and `coeff_x_pow`, the result is obtained by simplification.

### Mathematical insight
This theorem establishes that the polynomial `x^n` is monic, meaning its highest degree coefficient is equal to the multiplicative identity of the ring. This is a basic but important property used in polynomial algebra.

### Dependencies
- Definitions: `monic`, `coeff_x_pow`
- Theorems: `x_pow_series`, `monic_zero_ring`, `deg_x_pow`


---

## monic_x_minus_const

### Name of formal statement
monic_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_x_minus_const = prove(`
  !(r:R ring) c.
  c IN ring_carrier r ==>
  monic r (x_minus_const r c)
`,
  intro THEN
  case `ring_1 r = ring_0(r:R ring)` THENL [
    qed[x_minus_const_series;monic_zero_ring]
  ;
    have `poly_deg(r:R ring) (x_minus_const r c) = 1` [deg_x_minus_const] THEN
    simp[monic;coeff_x_minus_const]
  ]
);;
```
### Informal statement
For any ring `r` and any element `c` in the carrier of the ring `r`, the polynomial `x_minus_const r c` is monic in the ring `r`.

### Informal sketch
The proof proceeds by case distinction on whether the multiplicative identity `ring_1 r` equals the additive identity `ring_0 r` in the ring `r`.

- If `ring_1 r = ring_0 r`, then the result follows from `x_minus_const_series` and `monic_zero_ring`.
- Otherwise, we have that the degree of the polynomial `x_minus_const r c` is 1, proved using `deg_x_minus_const`.
- Using `coeff_x_minus_const`, we then check that the leading coefficient (the coefficient of `x^1`) is the multiplicative identity `ring_1 r` which implies that `x_minus_const r c` is monic by definition `monic`.

### Mathematical insight
This theorem establishes a basic property of polynomials of the form `x - c` over a ring `r`. These polynomials play a crucial role in polynomial factorization and root finding. A polynomial being monic simplifies many arguments related to polynomial division and ideal theory.

### Dependencies
- Definitions: `monic`, `x_minus_const`, `ring_carrier`
- Theorems: `monic_zero_ring`, `deg_x_minus_const`, `coeff_x_minus_const`, `x_minus_const_series`


---

## topcoeff_monic_poly_mul

### Name of formal statement
topcoeff_monic_poly_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let topcoeff_monic_poly_mul = prove(`
  !(r:R ring) p q.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  monic r p ==>
  monic r q ==>
  coeff (poly_deg r p + poly_deg r q) (poly_mul r p q)
  = ring_1 r
`,
  rw[monic] THEN
  intro THEN
  rw[coeff_poly_mul_oneindex] THEN
  subgoal `ring_sum(r:R ring) (0..poly_deg r p + poly_deg r q) (\a. ring_mul r (coeff a p) (coeff ((poly_deg r p + poly_deg r q) - a) q)) = ring_sum r (0..poly_deg r p + poly_deg r q) (\a. if a = poly_deg r p then ring_mul r (coeff a p) (coeff ((poly_deg r p + poly_deg r q) - a) q) else ring_0 r)` THENL [
    sufficesby RING_SUM_EQ THEN
    intro THEN
    simp[] THEN
    case `a = poly_deg r (p:(1->num)->R)` THENL [
      simp[]
    ; pass
    ] THEN
    simp[] THEN
    case `a < poly_deg r (p:(1->num)->R)` THENL [
      num_linear_fact `a < poly_deg r (p:(1->num)->R) ==> ~((poly_deg r p + poly_deg r (q:(1->num)->R)) - a <= poly_deg r q)` THEN
      num_linear_fact `poly_deg r (q:(1->num)->R) <= poly_deg r q` THEN
      have `coeff ((poly_deg r (p:(1->num)->R) + poly_deg r (q:(1->num)->R)) - a) q = ring_0 r` [coeff_deg_le] THEN
      qed[RING_MUL_RZERO;coeff_poly_in_ring]
    ;
      num_linear_fact `~(a = poly_deg r (p:(1->num)->R)) /\ ~(a < poly_deg r p) ==> ~(a <= poly_deg r p)` THEN
      num_linear_fact `poly_deg r (p:(1->num)->R) <= poly_deg r p` THEN
      have `coeff a (p:(1->num)->R) = ring_0 r` [coeff_deg_le] THEN
      qed[RING_MUL_LZERO;coeff_poly_in_ring]
    ]
  ; pass
  ] THEN
  have `poly_deg r (p:(1->num)->R) IN 0..poly_deg r p + poly_deg r (q:(1->num)->R)` [IN_NUMSEG_0;ARITH_RULE `poly_deg r (p:(1->num)->R) <= poly_deg r p + poly_deg r (q:(1->num)->R)`] THEN
  simp[RING_SUM_DELTA;RING_MUL_LID;RING_1;RING_MUL;coeff_poly_in_ring;ARITH_RULE `(poly_deg r (p:(1->num)->R) + poly_deg r (q:(1->num)->R)) - poly_deg r p = poly_deg r q`]
);;
```

### Informal statement
For all rings `r` and polynomials `p` and `q` over `r`, if `p` and `q` are ring polynomials, and `p` and `q` are monic, then the coefficient of the term with degree `poly_deg r p + poly_deg r q` in the polynomial `poly_mul r p q` is equal to `ring_1 r`.

### Informal sketch
The proof proceeds by:
- Rewriting with the definition of `monic`.
- Introducing the assumptions.
- Rewriting the coefficient of the product of two polynomials using `coeff_poly_mul_oneindex`, expressing it as a ring sum.
- Showing that the ring sum is equivalent to the case where `a = poly_deg r p`.
  - Accomplished by showing that when `a` is not equal to `poly_deg r p`, then the term in the sum becomes `ring_0 r` because if `a < poly_deg r p` then `coeff ((poly_deg r p + poly_deg r q) - a) q = ring_0 r`, and if `a > poly_deg r p` implies `coeff a p = ring_0 r`.
- Simplifying the sum using `RING_SUM_DELTA` to isolate the term where `a = poly_deg r p`, and then applying properties of `ring_1` and `RING_MUL` to obtain `ring_1 r`.

### Mathematical insight
This theorem states that the leading coefficient of the product of two monic polynomials is 1 (the multiplicative identity of the ring). This reflects the algebraic property that when multiplying polynomials, the leading terms multiply to give the leading term of the resulting polynomial, and in the case of monic polynomials, the leading coefficients are both 1.

### Dependencies
- `monic`
- `coeff_poly_mul_oneindex`
- `RING_SUM_EQ`
- `RING_MUL_RZERO`
- `coeff_poly_in_ring`
- `RING_MUL_LZERO`
- `IN_NUMSEG_0`
- `RING_SUM_DELTA`
- `RING_MUL_LID`
- `RING_1`
- `RING_MUL`
- `ARITH_RULE`


---

## deg_monic_poly_mul

### Name of formal statement
deg_monic_poly_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_monic_poly_mul = prove(`
  !(r:R ring) p q.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  monic r p ==>
  monic r q ==>
  poly_deg r (poly_mul r p q) = poly_deg r p + poly_deg r q
`,
  intro THEN
  case `ring_1(r:R ring) = ring_0 r` THENL [
    have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
    have `ring_powerseries r (q:(1->num)->R)` [ring_polynomial] THEN
    have `ring_powerseries r (poly_mul r (p:(1->num)->R) (q:(1->num)->R))` [RING_POWERSERIES_MUL] THEN
    simp[deg_zero_ring] THEN
    qed[ARITH_RULE `0+0 = 0`]
  ; pass
  ] THEN
  have `ring_polynomial r (poly_mul r (p:(1->num)->R) (q:(1->num)->R))` [RING_POLYNOMIAL_MUL] THEN
  have `poly_deg r (poly_mul r p q) <= poly_deg r (p:(1->num)->R) + poly_deg r (q:(1->num)->R)` [POLY_DEG_MUL_LE] THEN
  have `coeff (poly_deg r (p:(1->num)->R) + poly_deg r (q:(1->num)->R)) (poly_mul r p q) = ring_1 r` [topcoeff_monic_poly_mul] THEN
  have `~(coeff (poly_deg r (p:(1->num)->R) + poly_deg r (q:(1->num)->R)) (poly_mul r p q) = ring_0 r)` [] THEN
  qed[deg_coeff_from_le]
);;
```
### Informal statement
For any ring `r`, and any polynomials `p` and `q` over `r`, if `p` and `q` are ring polynomials, and both `p` and `q` are monic, then the degree of the polynomial `p * q` is equal to the sum of the degrees of `p` and `q`.

### Informal sketch
The proof proceeds as follows:
- The base case is handled where `ring_1 r = ring_0 r`. In this case, it is shown that the degree of both `p` and `q` must be zero. Then, using the properties of `ring_powerseries` and `RING_POWERSERIES_MUL`, and simplifying with `deg_zero_ring` and arithmetic reasoning, the result holds.
- Otherwise, it is assumed that `ring_1 r` is not equal to `ring_0 r`, allowing us to proceed with the general proof.
- It is first shown that `poly_mul r p q` is a ring polynomial using `RING_POLYNOMIAL_MUL`.
- Then it is shown that the degree of `poly_mul r p q` is less than or equal to the sum of the degree of `p` and the degree of `q`, by `POLY_DEG_MUL_LE`.
- Next, it uses `topcoeff_monic_poly_mul` to show that the coefficient of `poly_mul r p q` at the index equal to the sum of the degrees of `p` and `q` is equal to `ring_1 r`.
- Since this coefficient isn't `ring_0 r`, it uses `deg_coeff_from_le` to prove that the degree of `poly_mul r p q` is equal to the sum of the degrees of `p` and `q`.

### Mathematical insight
This theorem states a fundamental property of polynomial degrees: the degree of the product of two monic polynomials is the sum of their individual degrees. The "monic" condition is crucial because it ensures that the leading coefficients multiply to give the leading coefficient of the product, making the simple addition of degrees valid. The separate handling of the degenerate case where `ring_1 r = ring_0 r` is characteristic of how HOL Light often deals with corner cases in algebraic definitions where the standard axioms may lead to unexpected behaviour.

### Dependencies
- `RING_POWERSERIES_MUL`
- `deg_zero_ring`
- `RING_POLYNOMIAL_MUL`
- `POLY_DEG_MUL_LE`
- `topcoeff_monic_poly_mul`
- `deg_coeff_from_le`


---

## monic_poly_mul

### Name of formal statement
monic_poly_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_poly_mul = prove(`
  !(r:R ring) p q.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  monic r p ==>
  monic r q ==>
  monic r (poly_mul r p q)
`,
  intro THEN
  have `poly_deg r (poly_mul r (p:(1->num)->R) (q:(1->num)->R)) = poly_deg r p + poly_deg r q` [deg_monic_poly_mul] THEN
  simp[monic] THEN
  qed[topcoeff_monic_poly_mul]
);;
```
### Informal statement
For any ring `r`, and for any polynomials `p` and `q` over `r`, if `p` and `q` are ring polynomials, and `p` and `q` are monic, then the polynomial product `poly_mul r p q` is monic.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions: `r` is a ring, `p` and `q` are ring polynomials, `p` is monic, and `q` is monic.
- Use the theorem `deg_monic_poly_mul` to establish that `poly_deg r (poly_mul r p q) = poly_deg r p + poly_deg r q`.
- Simplify using the definition of `monic`. The tactic `topcoeff_monic_poly_mul` implicitly unfolds the definition of `monic` and uses the fact that the top coefficient of the product of two monic polynomials is the product of their top coefficients, which is 1 if both polynomials are monic.

### Mathematical insight
This theorem states that the product of two monic polynomials over a ring is also a monic polynomial. This result is important in polynomial algebra and is frequently used when working with factorization and divisibility of polynomials. A monic polynomial of degree $n$ is a polynomial whose leading coefficient (the coefficient of $x^n$) is 1.

### Dependencies
- Definitions: `ring_polynomial`, `monic`, `poly_mul`
- Theorems: `deg_monic_poly_mul`, `topcoeff_monic_poly_mul`

### Porting notes (optional)
- In proof assistants like Coq or Lean, ensure that the ring type `R` is properly defined with the ring axioms. The definitions of `ring_polynomial`, `monic`, and `poly_mul` should be ported carefully, paying attention to how polynomials are represented (e.g., as lists of coefficients or functions from indices to coefficients). The theorem concerning the degree of a product of monic polynomials is crucial and must have an equivalent available. The statement `topcoeff_monic_poly_mul` might require a separate proof or be directly provable depending on the representation of polynomial coefficients so ensure you check the assumptions made during it's proof in HOL Light.


---

## monic_poly_product

### Name of formal statement
monic_poly_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_poly_product = prove(`
  !(r:R ring) p (S:X->bool).
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  (!s. s IN S ==> monic r (p s)) ==>
  monic r (poly_product r S p)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty] THEN
    qed[monic_poly_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `!s:X. s IN S ==> ring_polynomial r (p(s:X):(1->num)->R)` [] THEN
    have `ring_powerseries r (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    have `ring_polynomial r (p(x:X):(1->num)->R)` [] THEN
    have `ring_polynomial (r:R ring) (poly_product r (S:X->bool) p)` [poly_product_poly] THEN
    have `monic (r:R ring) (poly_product r (S:X->bool) p)` [] THEN
    have `monic r (p(x:X):(1->num)->R)` [] THEN
    simp[poly_product_insert] THEN
    qed[monic_poly_mul]
  ]
);;
```
### Informal statement
For any ring `r`, polynomial family `p` indexed by type `X`, and set `S` of type `X`, if `S` is finite, and for all `s` in `S`, `p s` is a ring polynomial over `r`, and for all `s` in `S`, `p s` is monic over `r`, then the product of the polynomials `p s` over `S` is monic over `r`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then the product `poly_product r S p` is 1. The theorem `monic_poly_1` states that the constant polynomial 1 is monic.
- Inductive step: Assume the theorem holds all subsets of `x INSERT S`. We assume that `S` is finite, all `p s` are ring polynomials, and all `p s` are monic. Given `x INSERT S`, it needs to be shown that `poly_product r (x INSERT S) p` is monic.
  - Using the definition of `poly_product_insert`, `poly_product r (x INSERT S) p = poly_product r S p * p x`.
  - By the inductive hypothesis, `poly_product r S p` is monic. By assumption, `p x` is monic.
  - Applying `monic_poly_mul`, the product of two monic polynomials is monic which yields the desired result.

### Mathematical insight
The theorem states that the product of monic polynomials is monic. This is a fundamental property in polynomial algebra. The fact that the polynomials are ring polynomials over a ring insures closure and that we can multiply said polynomials.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_product_empty`
- `monic_poly_1`
- `poly_product_insert`
- `monic_poly_mul`
- `poly_product_poly`
- `ring_polynomial`
- `ring_powerseries`
- `monic`


---

## monic_vanishing_at_monic

### Name of formal statement
monic_vanishing_at_monic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_monic = prove(`
  !(r:R ring) S:X->bool c.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  monic r (monic_vanishing_at r S c)
`,
  rw[monic_vanishing_at] THEN
  intro THEN
  have `!s:X. s IN S ==> ring_polynomial(r:R ring) (x_minus_const r (c s))` [x_minus_const_poly] THEN
  have `!s:X. s IN S ==> monic(r:R ring) (x_minus_const r (c s))` [monic_x_minus_const] THEN
  simp[monic_poly_product]
);;
```
### Informal statement
For any ring `r` and any finite set `S` of type `X`, and any function `c` from `X` to the carrier of the ring `r` such that for every `s` in `S`, `c s` is an element of the carrier of `r`, then `monic_vanishing_at r S c` is a monic polynomial in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `monic_vanishing_at r S c`.
- Introduce the assumptions.
- Show that for any `s` in `S`, `x_minus_const r (c s)` is a ring polynomial, using `x_minus_const_poly`.
- Show that for any `s` in `S`, `x_minus_const r (c s)` is a monic polynomial, using `monic_x_minus_const`.
- Use `monic_poly_product` to conclude that the product of these monic polynomials (which is `monic_vanishing_at r S c`) is monic.

### Mathematical insight
The theorem states that if we construct a polynomial by taking the product of `(x - c s)` for `s` in a *finite* set `S`, where the `c s` are ring elements, then the resulting polynomial is monic. This is an important property when working with factorizations of polynomials, and it ensures that we can construct monic polynomials with specific roots.

### Dependencies
- Definitions:
  - `monic_vanishing_at`
- Theorems:
  - `monic_x_minus_const`
  - `monic_poly_product`
  - `x_minus_const_poly`


---

## monic_subring

### Name of formal statement
monic_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_subring = prove(`
  !(r:R ring) G p.
  monic (subring_generated r G) p
  <=> monic r p
`,
  rw[monic;SUBRING_GENERATED;POLY_DEG_SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` and any set `G` of polynomials, a polynomial `p` is monic in the subring generated by `G` over `r` if and only if `p` is monic in `r`.

### Informal sketch
The proof proceeds as follows:
- The main tactic `rw` rewrites the goal using the definitions of `monic` and `SUBRING_GENERATED`, and the theorem `POLY_DEG_SUBRING_GENERATED`.
- `monic p` is defined as `poly_degree p = leading_coeff p`.
- `SUBRING_GENERATED r G` represents the subring generated by `G` over `r`. The subring generated contains the elements of `r` along with the set `G` and is closed under addition, subtraction, and multiplication.
- `POLY_DEG_SUBRING_GENERATED` shows that the polynomials in the subring generated by `G` have the same degrees as in the original ring `r`

### Mathematical insight
This theorem states a property of monic polynomials and subrings. A polynomial is monic if its leading coefficient is 1. The subring generated by a set of polynomials along with the base ring will contain only polynomials whose leading coefficients and degree are the same as when considered as polynomials in the original ring. Therefore, checking if a polynomial is monic can be done in the original ring.

### Dependencies
- Definitions: `monic`, `SUBRING_GENERATED`
- Theorems: `POLY_DEG_SUBRING_GENERATED`


---

## PID_x_poly_field

### Name of formal statement
`PID_x_poly_field`

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PID_x_poly_field = prove(`
  !r:R ring.
  field r ==> PID(x_poly r)
`,
  qed[PID_POLY_RING;x_poly]
);;
```
### Informal statement
For any ring `r` in the type `R ring`, if `r` is a field, then the polynomial ring `x_poly r` is a principal ideal domain (PID).

### Informal sketch
The proof demonstrates that if `r` is a field, then `x_poly r` is a principal ideal domain. The tactic `PID_POLY_RING` is employed, likely a pre-proven theorem or tactic that establishes that the polynomial ring over a field is a Euclidean domain, and thus a PID. The tactic `x_poly` expands or introduces the polynomial ring. The overall structure suggests reducing the problem to a previously established result about polynomial rings over fields.

### Mathematical insight
This theorem establishes a fundamental connection between field theory and polynomial rings. It states that polynomial rings over fields inherit the property of being a principal ideal domain. This is significant because PIDs have unique factorization, simplifying many algebraic arguments. This fact is important in algebraic number theory, commutative algebra, and cryptography.

### Dependencies
- Definitions:
  - `ring`
  - `field`
  - `x_poly`
  - `PID`
- Theorems:
  - `PID_POLY_RING`


---

## UFD_x_poly_field

### Name of formal statement
UFD_x_poly_field

### Type of the formal statement
theorem

### Formal Content
```ocaml
let UFD_x_poly_field = prove(`
  !r:R ring.
  field r ==> UFD(x_poly r)
`,
  qed[PID_x_poly_field;PID_IMP_UFD]
);;
```
### Informal statement
For any ring `r` that is a field, the polynomial ring `x_poly r` is a unique factorization domain (UFD).

### Informal sketch
The proof proceeds as follows:
- First, establish that if `r` is a field, then `x_poly r` is a principal ideal domain (PID). This is achieved using `PID_x_poly_field`, which states that if `r` is a field then `x_poly r` is a PID.
- Then, use the theorem `PID_IMP_UFD`, which states that every PID is a UFD.
- Applying `PID_IMP_UFD` to the result of `PID_x_poly_field` then proves that `x_poly r` is a UFD.

### Mathematical insight
This theorem is a fundamental result in abstract algebra. It connects the concepts of fields, polynomial rings, principal ideal domains, and unique factorization domains. Knowing that polynomial rings over fields are UFDs is essential for studying polynomial factorization and algebraic extensions of fields.

### Dependencies
- Theorems: `PID_x_poly_field`, `PID_IMP_UFD`


---

## integral_domain_x_poly_field

### Name of formal statement
integral_domain_x_poly_field

### Type of the formal statement
theorem

### Formal Content
```ocaml
let integral_domain_x_poly_field = prove(`
  !r:R ring.
  field r ==> integral_domain(x_poly r)
`,
  qed[PID_x_poly_field;PID_IMP_INTEGRAL_DOMAIN]
);;
```
### Informal statement
For any ring `r` of type `R`, if `r` is a field, then the polynomial ring `x_poly r` is an integral domain.

### Informal sketch
The proof shows that if a ring `r` is a field, then the polynomial ring `x_poly r` satisfies the definition of an integral domain.

- First, we use `PID_x_poly_field`, which likely proves that the polynomial ring over a field is a principal ideal domain (PID).
- Then, we use `PID_IMP_INTEGRAL_DOMAIN`, which probably states that every principal ideal domain is an integral domain. Thus, we derive the result that if `r` is a field, then `x_poly r` is an integral domain.

### Mathematical insight
This theorem states a fundamental algebraic property: polynomials over a field form an integral domain. It is important because integral domains have properties like unique factorization (in some cases) and are the natural structure for defining divisibility. This result is essential for the theory of polynomial rings and field extensions.

### Dependencies
- Theorems: `PID_x_poly_field`, `PID_IMP_INTEGRAL_DOMAIN`


---

## prime_iff_irreducible_over_field

### Name of formal statement
prime_iff_irreducible_over_field

### Type of the formal statement
theorem

### Formal Content
```ocaml
let prime_iff_irreducible_over_field = prove(`
  !(r:R ring) p.
  field r ==>
  (ring_irreducible(x_poly r) p <=> ring_prime(x_poly r) p)
`,
  qed[PID_x_poly_field;PID_IRREDUCIBLE_EQ_PRIME]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any polynomial `p`, if `r` is a field, then `p` is irreducible over `x_poly r` if and only if `p` is prime over `x_poly r`.

### Informal sketch
The proof demonstrates the equivalence between irreducibility and primality for polynomials over a field.

- The proof starts by assuming that `r` is a field.
- Then, the proof demonstrates that `ring_irreducible(x_poly r) p` is equivalent to `ring_prime(x_poly r) p`.
- The proof utilizes theorems `PID_x_poly_field` and `PID_IRREDUCIBLE_EQ_PRIME`. The first one `PID_x_poly_field` establishes that the polynomials over any field form a principal ideal domain, and `PID_IRREDUCIBLE_EQ_PRIME`, applicable to general principal ideal domains, shows equivalence between primality and irreducibility of elements.

### Mathematical insight
This theorem establishes a fundamental connection between two important concepts in ring theory, irreducibility and primality, specifically in the context of polynomials over a field. In general, a prime element in a ring is always irreducible. However, the converse (an irreducible element is prime) does not hold in all rings. This theorem shows that in the ring of polynomials over a field (which is a principal ideal domain), an irreducible polynomial is indeed always prime. This is a crucial property used in many algebraic arguments.

### Dependencies
- Theorems: `PID_x_poly_field`, `PID_IRREDUCIBLE_EQ_PRIME`


---

## squarefree_if_irreducible_over_field

### Name of formal statement
squarefree_if_irreducible_over_field

### Type of the formal statement
theorem

### Formal Content
```ocaml
let squarefree_if_irreducible_over_field = prove(`
  !(r:R ring) p.
  field r ==>
  ring_irreducible(x_poly r) p ==>
  ring_squarefree(x_poly r) p
`,
  qed[prime_iff_irreducible_over_field;ring_squarefree_if_prime]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any polynomial `p`, if `r` is a field and `p` is irreducible over `r` in the sense of `x_poly r`, then `p` is squarefree over `r` in the sense of `x_poly r`.

### Informal sketch
The proof proceeds as follows:
- First, apply `prime_iff_irreducible_over_field` to reduce the goal to showing that if `r` is a field and `p` is irreducible over `r` then `p` is prime over `r`.
- Second, apply `ring_squarefree_if_prime`

### Mathematical insight
This theorem states a fundamental property: over a field, an irreducible polynomial is always squarefree. The contrapositive is also useful: if a polynomial has repeated factors (i.e., not squarefree), it must either be reducible or over a non-field.

### Dependencies
- Theorems: `prime_iff_irreducible_over_field`, `ring_squarefree_if_prime`


---

## x_poly_field_monic_associate

### Name of formal statement
x_poly_field_monic_associate

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_field_monic_associate = prove(`
  !(r:R ring) (p:(1->num)->R).
  field r ==>
  ring_polynomial r p ==>
  ~(p = poly_0 r) ==>
  ?q. (ring_polynomial r q /\
       monic r q /\
       ring_associates(x_poly r) p q)
`,
  intro THEN
  def `n:num` `poly_deg r (p:(1->num)->R)` THEN
  def `pn:R` `coeff n (p:(1->num)->R)` THEN
  have `pn IN ring_carrier(r:R ring)` [coeff_poly_in_ring] THEN
  have `~(pn = ring_0(r:R ring))` [topcoeff_nonzero] THEN
  have `ring_unit(r:R ring) pn` [FIELD_UNIT] THEN
  have `ring_inv(r:R ring) pn IN ring_carrier r` [RING_INV] THEN
  have `ring_mul(r:R ring) pn (ring_inv r pn) = ring_1 r` [ring_div_refl;ring_div] THEN
  have `ring_mul(r:R ring) (ring_inv r pn) pn = ring_1 r` [RING_MUL_SYM] THEN
  def `q:(1->num)->R` `poly_mul r (p:(1->num)->R) (poly_const r (ring_inv r pn))` THEN
  have `poly_deg r (q:(1->num)->R) = poly_deg r (p:(1->num)->R)` [deg_mul_const_const_1] THEN
  witness `q:(1->num)->R` THEN
  rw[monic] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `ring_polynomial r (q:(1->num)->R)` [RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_CONST] THEN
  have `ring_powerseries r (q:(1->num)->R)` [ring_polynomial] THEN
  specialize[`r:R ring`;`ring_inv(r:R ring) pn`;`p:(1->num)->R`;`poly_deg r (p:(1->num)->R)`]coeff_times_poly_const THEN
  have `coeff (poly_deg r (p:(1->num)->R)) (q:(1->num)->R) = ring_1 r` [coeff_times_poly_const] THEN
  have `coeff (poly_deg r (q:(1->num)->R)) (q:(1->num)->R) = ring_1 r` [] THEN
  rw[x_poly] THEN
  have `ring_unit(r:R ring) (ring_inv r pn)` [RING_UNIT_INV] THEN
  qed[associates_if_mul_unit_const;x_poly]
);;
```
### Informal statement
Given a ring `r` which is a field, and a polynomial `p` over `r` that is a ring polynomial and not equal to the zero polynomial `poly_0 r`, there exists a polynomial `q` over `r` such that `q` is a ring polynomial, `q` is monic, and `p` and `q` are associates with respect to the `x_poly r` relation.

### Informal sketch
The proof proceeds as follows:
- Assume `r` is a field and `p` is a non-zero ring polynomial over `r`.
- Define `n` as the degree of the polynomial `p` using `poly_deg r p`.
- Define `pn` as the coefficient of `x^n` in `p` using `coeff n p`.
- Show that `pn` is in the carrier of the ring `r`.
- Show that `pn` is not the zero element `ring_0 r` of the ring `r`.
- Since `r` is a field, `pn` is a unit in `r`.
- Show that the ring inverse of `pn`, i.e., `ring_inv r pn`, is in the carrier of `r`.
- Show that `pn * (ring_inv r pn) = ring_1 r` and `(ring_inv r pn) * pn = ring_1 r`.
- Define `q` as the polynomial obtained by multiplying `p` by the constant polynomial `ring_inv r pn` using `poly_mul r p (poly_const r (ring_inv r pn))`.
- Show that the degree of `q` is equal to the degree of `p`.
- Witness the existence of such a polynomial `q`.
- To prove that `q` is monic, we need to show that the coefficient of the highest degree term is `ring_1 r`.
- Knowing `p` is ring polynomial, then `p` is trivially a ring powerseries
- Show that `q` is a ring polynomial using the fact that `p` is a ring polynomial and that constant polynomials are ring polynomials and `ring_polynomial` are closed under multiplication.
- Knowing `q` is ring polynomial, then `q` is trivially a ring powerseries
- Using `coeff_times_poly_const` states that the coefficient of the term with degree equal to `poly_deg r p` (the degree of `p`) in `q` is `ring_1 r`.
- Since `poly_deg r q = poly_deg r p` the coefficient of the term with degree `poly_deg r q` is also `ring_1 r`, thus `q` is monic
- Finally, showing that they are associates is trivially resolved by `associates_if_mul_unit_const`.

### Mathematical insight
The theorem states that in a field, any non-zero polynomial has a monic associate. A monic polynomial is a polynomial whose leading coefficient is 1. This theorem demonstrates a way to normalize any non-zero polynomial in a field by multiplying it by the inverse of its leading coefficient. This is important because monic polynomials have several nice properties and are often easier to work with.

### Dependencies
- `ring_polynomial`
- `poly_0`
- `monic`
- `ring_associates`
- `x_poly`
- `poly_deg`
- `coeff`
- `ring_carrier`
- `ring_0`
- `FIELD_UNIT`
- `RING_INV`
- `ring_mul`
- `ring_inv`
- `ring_1`
- `RING_MUL_SYM`
- `poly_mul`
- `poly_const`
- `RING_POLYNOMIAL_MUL`
- `RING_POLYNOMIAL_CONST`
- `RING_UNIT_INV`

**Theorems and definitions**:
- `intro`
- `def`
- `coeff_poly_in_ring`
- `topcoeff_nonzero`
- `ring_div_refl`
- `ring_div`
- `deg_mul_const_const_1`
- `RING_POLYNOMIAL`
- `coeff_times_poly_const`
- `associates_if_mul_unit_const`

### Porting notes (optional)
- The tactics used in the HOL Light proof script, such as `intro`, `def`, `have`, and `rw`, represent common proof strategies. The specific names (e.g., `FIELD_UNIT`, `RING_INV`) refer to named theorems or definitions that establish properties of rings and fields.
- When porting to another system, first ensure compatible definitions of rings, fields, polynomials, and monic polynomials are present.
- The proof relies on the fact that in a field, every non-zero element is a unit and has an inverse. Recreate that reasoning path.
- The handling of polynomials (representation, coefficients, degrees) will need adjustment based on the target system's polynomial library.


---

## mul_unit_const_if_associates

### Name of formal statement
mul_unit_const_if_associates

### Type of the formal statement
theorem

### Formal Content
```ocaml
let mul_unit_const_if_associates = prove(`
  !(r:R ring) (p:(V->num)->R) q.
  field r ==>
  ring_associates(poly_ring r (:V)) p q ==>
  ?c. ring_unit r c /\ q = poly_mul r p (poly_const r c)
`,
  intro THEN
  have `integral_domain(r:R ring)` [FIELD_IMP_INTEGRAL_DOMAIN] THEN
  have `integral_domain(poly_ring (r:R ring) (:V))` [INTEGRAL_DOMAIN_POLY_RING] THEN
  choose `u:(V->num)->R` `ring_unit(poly_ring (r:R ring) (:V)) u /\ ring_mul(poly_ring (r:R ring) (:V)) p u = q` [INTEGRAL_DOMAIN_ASSOCIATES] THEN
  choose `c:R` `ring_unit(r:R ring) c /\ u = poly_const r c:(V->num)->R` [RING_UNIT_POLY_DOMAIN] THEN
  witness `c:R` THEN
  qed[POLY_RING_CLAUSES]
);;
```
### Informal statement
For any ring `r` of type `R ring`, polynomials `p` and `q` of type `(V->num)->R`, if `r` is a field and `p` and `q` are associates in the polynomial ring over `r` with variables of type `V`, then there exists a constant `c` of type `R` such that `c` is a unit in `r` and `q` is the product of `p` and the constant polynomial `c`.

### Informal sketch
The proof proceeds as follows:
- Assume the field property for the ring `r` and that polynomials `p` and `q` are associates.
- Use the fact that a field is an integral domain (`FIELD_IMP_INTEGRAL_DOMAIN`).
- Deduce that the polynomial ring over an integral domain is also an integral domain (`INTEGRAL_DOMAIN_POLY_RING`).
- Since `p` and `q` are associates in an integral domain, there exists a unit `u` such that `p * u = q` (`INTEGRAL_DOMAIN_ASSOCIATES`). The `choose` tactic is used to obtain such a `u`.
- Use the property that `u` is a unit in the polynomial ring, so there exists a constant `c` such that `u` is equal to the constant polynomial `c` (`RING_UNIT_POLY_DOMAIN`). The `choose` tactic is used to obtain such a `c`.
- Witness the existence of `c` and conclude that `q` is equal to the product of `p` and the constant polynomial `c` (`POLY_RING_CLAUSES`).

### Mathematical insight
This theorem states that if two polynomials `p` and `q` are associates over a field, then `q` can be obtained by multiplying `p` by a constant unit. This is a fundamental property used in polynomial ring theory, particularly when dealing with factorization and divisibility. It simplifies the notion of associates in polynomial rings over fields.

### Dependencies
- `FIELD_IMP_INTEGRAL_DOMAIN`
- `INTEGRAL_DOMAIN_POLY_RING`
- `INTEGRAL_DOMAIN_ASSOCIATES`
- `RING_UNIT_POLY_DOMAIN`
- `POLY_RING_CLAUSES`


---

## monic_associates

### Name of formal statement
monic_associates

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_associates = prove(`
  !(r:R ring) p q.
  field r ==>
  monic r p ==>
  monic r q ==>
  ring_associates(x_poly r) p q ==>
  p = q
`,
  intro THEN
  choose `c:R` `ring_unit(r:R ring) c /\ q = poly_mul r p (poly_const r c:(1->num)->R)` [mul_unit_const_if_associates;x_poly] THEN
  have `integral_domain(x_poly(r:R ring))` [integral_domain_x_poly_field] THEN
  have `p IN ring_carrier(x_poly(r:R ring))` [INTEGRAL_DOMAIN_ASSOCIATES] THEN
  have `q IN ring_carrier(x_poly(r:R ring))` [INTEGRAL_DOMAIN_ASSOCIATES] THEN
  have `ring_polynomial r (p:(1->num)->R)` [x_poly_use] THEN
  have `ring_polynomial r (q:(1->num)->R)` [x_poly_use] THEN
  have `ring_unit(r:R ring) c` [] THEN
  specialize[`r:R ring`;`p:(1->num)->R`;`c:R`]deg_mul_unit_const THEN
  have `poly_deg r (q:(1->num)->R) = poly_deg r (p:(1->num)->R)` [deg_mul_unit_const;x_poly_use] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `c IN ring_carrier(r:R ring)` [ring_unit] THEN
  specialize[`r:R ring`;`c:R`;`p:(1->num)->R`;`poly_deg r (p:(1->num)->R)`]coeff_times_poly_const THEN
  have `coeff (poly_deg r (p:(1->num)->R)) p = ring_1 r` [monic] THEN
  have `coeff (poly_deg r (p:(1->num)->R)) q = ring_1 r` [monic] THEN
  have `ring_1 r = ring_mul r c (ring_1(r:R ring))` [] THEN
  have `c = ring_1(r:R ring)` [RING_MUL_RID] THEN
  have `poly_const r c = ring_1 (x_poly(r:R ring))` [poly_1;x_poly_use] THEN
  qed[RING_MUL_RID;x_poly_use]
);;
```
### Informal statement
For any ring `r` and polynomials `p` and `q` over `r`, if `r` is a field, `p` is monic, `q` is monic, and `p` and `q` are associates in the polynomial ring over `r` (denoted `x_poly r`), then `p` equals `q`.

### Informal sketch
The proof proceeds as follows:
- Assume that `r` is a field, `p` and `q` are monic polynomials over `r`, and `p` and `q` are associates in the polynomial ring `x_poly r`.
- Choose `c` such that `c` is a unit in `r` and `q` is `p` multiplied by the constant polynomial `c`.
- Show that `x_poly r` is an integral domain since `r` is a field.
- Show that `p` and `q` are in the carrier of `x_poly r`.
- Deduce that `p` and `q` are ring polynomials.
- Show `c` is a unit in ring `r`.
- Specialize the theorem `deg_mul_unit_const` to show that the degrees of `p` and `q` are equal.
- State that `p` is a ring power series because it is polynomial.
- Show that `c` is in the carrier of ring `r`.
- Specialize the theorem `coeff_times_poly_const`.
- Deduce that the leading coefficients of `p` and `q` are both the ring identity `1` using the fact that they are monic.
- Show that `ring_1 r = ring_mul r c (ring_1(r:R ring))`.
- Deduce that `c` is equal to the multiplicative identity `1` of the ring `r`.
- Obtain `poly_const r c = ring_1 (x_poly(r:R ring))`.
- Finally deduce that `p = q`.

### Mathematical insight
This theorem states that monic associates in a polynomial ring over a field are equal. This is a standard result in abstract algebra. Being associates means that they differ by a unit factor. Because the polynomials are monic, the unit factor must be 1.

### Dependencies
- `field`
- `monic`
- `ring_associates`
- `x_poly`
- `mul_unit_const_if_associates`
- `integral_domain_x_poly_field`
- `integral_domain`
- `INTEGRAL_DOMAIN_ASSOCIATES`
- `ring_polynomial`
- `x_poly_use`
- `ring_unit`
- `deg_mul_unit_const`
- `ring_powerseries`
- `coeff_times_poly_const`
- `RING_MUL_RID`
- `poly_1`


---

## no_square_divisor_if_coprime_derivative_lemma1

### Name of formal statement
no_square_divisor_if_coprime_derivative_lemma1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let no_square_divisor_if_coprime_derivative_lemma1 = prove(`
  !(r:R ring) q (u:(V->num)->R).
  ring_polynomial r q ==>
  ring_polynomial r u ==>
  poly_mul r (poly_mul r q q) u
  = poly_mul r q (poly_mul r q u)
`,
  intro THEN
  have `ring_powerseries(r:R ring) (q:(V->num)->R)` [ring_polynomial] THEN
  have `ring_powerseries(r:R ring) (u:(V->num)->R)` [ring_polynomial] THEN
  qed[POLY_MUL_ASSOC]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any polynomials `q` and `u` over `r`, if `q` is a ring polynomial and `u` is a ring polynomial, then the polynomial `(q * q) * u` is equal to the polynomial `q * (q * u)`.

### Informal sketch
The proof consists of the following steps:
- Assume `ring_polynomial r q` and `ring_polynomial r u`.
- Apply the associativity of polynomial multiplication `POLY_MUL_ASSOC` to conclude `poly_mul r (poly_mul r q q) u = poly_mul r q (poly_mul r q u)`.

### Mathematical insight
This theorem demonstrates that polynomial multiplication is associative. This is a fundamental property of polynomial rings.

### Dependencies
- `ring_polynomial`
- `POLY_MUL_ASSOC`

### Porting notes (optional)
The main challenge for porting this theorem to other proof assistants is finding appropriate algebraic structures and their corresponding polynomial operations. In many proof assistants, modules for polynomial rings are available with built-in support for associativity. However, it is important to verify that the definitions of polynomial multiplication and what exactly consitutes a "ring polynomial" match the HOL Light definitions. Also, make sure that the `ring_polynomial` predicate is encoded correctly in the target proof assistant.


---

## no_square_divisor_if_coprime_derivative_lemma2

### Name of formal statement
no_square_divisor_if_coprime_derivative_lemma2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let no_square_divisor_if_coprime_derivative_lemma2 = prove(`
  !(r:R ring) q u.
  ring_polynomial r q ==>
  ring_polynomial r u ==>
     poly_add r
     (poly_mul r
      (poly_add r (poly_mul r (x_derivative r q) q)
      (poly_mul r q (x_derivative r q)))
     u)
     (poly_mul r (poly_mul r q q) (x_derivative r u)) =
     poly_mul r q
     (poly_add r
      (poly_mul r (poly_add r (x_derivative r q) (x_derivative r q)) u)
     (poly_mul r q (x_derivative r u)))
`,
  intro THEN
  have `ring_polynomial(r:R ring) (x_derivative r q)` [x_derivative_polynomial] THEN
  have `ring_polynomial(r:R ring) (x_derivative r u)` [x_derivative_polynomial] THEN
  have `q IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `u IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `x_derivative r q IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `x_derivative r u IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  rw[x_poly_use] THEN
  specialize[
    `x_poly(r:R ring)`;`q:(1->num)->R`
    ;`x_derivative r q:(1->num)->R`
    ;`u:(1->num)->R`
    ;`x_derivative r u:(1->num)->R`]
  (GENL[`r:R ring`;`q:R`;`Q:R`;`u:R`;`U:R`](
    RING_RULE `ring_add(r:R ring) (ring_mul r (ring_add r (ring_mul r Q q) (ring_mul r q Q)) u) (ring_mul r (ring_mul r q q) U) = ring_mul r q (ring_add r (ring_mul r (ring_add r Q Q) u) (ring_mul r q U))`
  )) THEN
  qed[]
);;
```
### Informal statement
For all rings `r` (of type `R ring`), and for all polynomials `q` and `u` over `r`, if `q` and `u` are ring polynomials over `r`, then the following equality holds:
`poly_add r (poly_mul r (poly_add r (poly_mul r (x_derivative r q) q) (poly_mul r q (x_derivative r q))) u) (poly_mul r (poly_mul r q q) (x_derivative r u)) = poly_mul r q (poly_add r (poly_mul r (poly_add r (x_derivative r q) (x_derivative r q)) u) (poly_mul r q (x_derivative r u)))`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions that `r` is a ring, and that `q` and `u` are both ring polynomials over `r`.
- Use `x_derivative_polynomial` to prove that both `x_derivative r q` and `x_derivative r u` are ring polynomials over `r`.
- Use `x_poly_use` to rewrite the goal in terms of carrier sets.
- Specialize a ring rule with appropriate instantiations for `r`, `q`, `x_derivative r q`, `u`, and `x_derivative r u`.
- Apply the specialized ring rule to complete the proof.

### Mathematical insight
This lemma demonstrates a polynomial identity within a ring structure. The identity simplifies an expression involving polynomial addition, multiplication, and the derivative of polynomials. This type of algebraic manipulation is crucial in polynomial algebra and related fields. The identity likely arises in contexts such as factorization or root-finding algorithms.

### Dependencies
- `ring_polynomial`
- `x_derivative_polynomial`
- `x_poly_use`

### Porting notes (optional)
The proof relies heavily on the underlying ring axioms. Translation into other proof assistants will require similar algebraic reasoning capabilities. The user needs to ensure the presence of `ring_polynomial` and `x_derivative_polynomial`, since the rule `x_poly_use` uses them. Ensure correct typing for ring elements and polynomials and `x_derivative`.


---

## no_square_divisor_if_coprime_derivative

### Name of formal statement
no_square_divisor_if_coprime_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let no_square_divisor_if_coprime_derivative = prove(`
  !(r:R ring) p q.
  field r ==>
  ring_polynomial r q ==>
  ring_coprime(x_poly r) (p,x_derivative r p) ==>
  ring_divides(x_poly r) (poly_mul r q q) p ==>
  ring_unit(x_poly r) q
`,
  intro THEN
  choose `u:(1->num)->R` `u IN ring_carrier(x_poly r) /\ p:(1->num)->R = ring_mul(x_poly r) (poly_mul r q q) u` [ring_divides] THEN
  have `p:(1->num)->R = poly_mul r (poly_mul r q q) u` [x_poly_use] THEN
  have `(p:(1->num)->R) IN ring_carrier(x_poly r)` [ring_coprime] THEN
  have `ring_polynomial r (p:(1->num)->R)` [x_poly_use] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `ring_powerseries r (q:(1->num)->R)` [ring_polynomial] THEN
  specialize[`r:R ring`;`q:(1->num)->R`;`q:(1->num)->R`]x_derivative_mul THEN
  have `ring_polynomial r (u:(1->num)->R)` [x_poly_use] THEN
  have `ring_powerseries r (u:(1->num)->R)` [ring_polynomial] THEN
  have `ring_powerseries r (poly_mul r q (q:(1->num)->R))` [RING_POWERSERIES_MUL] THEN
  specialize[`r:R ring`;`poly_mul r q (q:(1->num)->R)`;`u:(1->num)->R`]x_derivative_mul THEN
  have `x_derivative(r:R ring) p = poly_add r (poly_mul r (poly_add r (poly_mul r (x_derivative r q) q) (poly_mul r q (x_derivative r q))) u) (poly_mul r (poly_mul r q q) (x_derivative r u))` [] THEN
  have `x_derivative(r:R ring) p = poly_mul r q (poly_add r (poly_mul r (poly_add r (x_derivative r q) (x_derivative r q)) u) (poly_mul r q (x_derivative r u)))` [no_square_divisor_if_coprime_derivative_lemma2] THEN
  have `ring_polynomial r (x_derivative r (p:(1->num)->R))` [x_derivative_polynomial] THEN
  have `ring_polynomial r (x_derivative r (q:(1->num)->R))` [x_derivative_polynomial] THEN
  have `ring_polynomial r (x_derivative r (u:(1->num)->R))` [x_derivative_polynomial] THEN
  have `ring_polynomial r (poly_add r (x_derivative r (q:(1->num)->R)) (x_derivative r q))` [RING_POLYNOMIAL_ADD] THEN
  have `ring_polynomial r (poly_mul r (poly_add r (x_derivative r (q:(1->num)->R)) (x_derivative r q)) u)` [RING_POLYNOMIAL_MUL] THEN
  have `ring_polynomial r (poly_mul r (q:(1->num)->R) (x_derivative r u))` [RING_POLYNOMIAL_MUL] THEN
  have `ring_polynomial r (poly_add r (poly_mul r (poly_add r (x_derivative r (q:(1->num)->R)) (x_derivative r q)) u) (poly_mul r q (x_derivative r u)))` [RING_POLYNOMIAL_ADD] THEN
  have `poly_add r (poly_mul r (poly_add r (x_derivative r (q:(1->num)->R)) (x_derivative r q)) u) (poly_mul r q (x_derivative r u)) IN ring_carrier(x_poly r)` [x_poly_use] THEN
  have `(q:(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_use] THEN
  have `(p:(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_use] THEN
  have `x_derivative r (p:(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_use] THEN
  subgoal `ring_divides(x_poly(r:R ring)) q (x_derivative r p)` THENL [
    rw[ring_divides] THEN
    intro THENL [qed[]; qed[]; pass] THEN
    witness `poly_add r (poly_mul r (poly_add r (x_derivative r (q:(1->num)->R)) (x_derivative r q)) u) (poly_mul r q (x_derivative r u))` THEN
    intro THENL [
      qed[]
    ;
      rw[GSYM x_poly_use] THEN
      qed[]
    ]
  ; pass
  ] THEN
  subgoal `ring_divides(x_poly(r:R ring)) q p` THENL [
    rw[ring_divides] THEN
    intro THENL [qed[]; qed[]; pass] THEN
    witness `poly_mul r q u:(1->num)->R` THEN
    have `ring_polynomial r (poly_mul r q u:(1->num)->R)` [RING_POLYNOMIAL_MUL] THEN
    have `(poly_mul r q u:(1->num)->R) IN ring_carrier(x_poly r)` [x_poly_use] THEN
    have `p:(1->num)->R = poly_mul r q (poly_mul r q u)` [no_square_divisor_if_coprime_derivative_lemma1] THEN
    qed[x_poly_use]
  ; pass
  ] THEN
  qed[ring_coprime]
);;
```
### Informal statement
For any ring `r` that is also a field, and any polynomials `p` and `q` over `r`, if `x_poly r` is coprime with the derivative of `p` with respect to `r`, and `x_poly r` divides `p` multiplied by `q` squared, then `q` is a unit in the ring of polynomials over `r`.

### Informal sketch
The proof proceeds by assuming that `x_poly r` divides `p = q^2 * u` for some polynomial `u`. The goal is to show that `q` is a unit in the polynomial ring.
- Choose a polynomial `u` such that `p = q^2 * u`.
- Compute the derivative of `p` to get `x_derivative(r) p = q * (2 * x_derivative(r) q * u + q * x_derivative(r) u)`.
- Use the assumption that `ring_coprime(x_poly r) (p, x_derivative r p)` to conclude that `x_poly r` divides both `p` and `x_derivative r p`.
- Show that `q` divides `p` and `x_derivative r p`. From `p = q^2 * u`, clearly `q` divides `p`. The tactic `ring_divides` is rewritten.
- Show that `q` divides `x_derivative r p`.
- By the assumption of coprimality `ring_coprime(x_poly r) (p, x_derivative r p)` it should be the case that `q` is a unit.

### Mathematical insight
This theorem states that If `x_poly r` divides `p` but `not q`, it must divide square part of `p`. This theorem is likely related to the concept of square-free polynomials and their derivatives. A square-free polynomial is one that is not divisible by the square of any non-constant polynomial. The condition that `x_poly r` and `x_derivative r p` are coprime is a key condition for `p` to be square-free.

### Dependencies
- `ring_divides`
- `x_poly_use`
- `ring_coprime`
- `ring_polynomial`
- `ring_powerseries`
- `x_derivative_mul`
- `RING_POWERSERIES_MUL`
- `no_square_divisor_if_coprime_derivative_lemma2`
- `x_derivative_polynomial`
- `RING_POLYNOMIAL_ADD`
- `RING_POLYNOMIAL_MUL`
- `no_square_divisor_if_coprime_derivative_lemma1`

### Porting notes (optional)
The proof relies heavily on rewriting using the definitions of `ring_divides`, `x_poly_use`, and properties of polynomial arithmetic provided by the `RING_POLYNOMIAL` and `RING_POWERSERIES` theories. The main challenge in porting is likely to be reproducing the equational reasoning steps in another proof assistant.


---

## nonzero_if_coprime_derivative

### Name of formal statement
nonzero_if_coprime_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_if_coprime_derivative = prove(`
  !(r:R ring) p.
  field r ==>
  ring_coprime(x_poly r) (p,x_derivative r p) ==>
  ~(p = poly_0 r)
`,
  intro THEN
  have `PID (x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `ring_0(x_poly r):(1->num)->R = poly_0 r` [x_poly_use] THEN
  have `p IN ring_carrier(x_poly(r:R ring))` [ring_coprime] THEN
  have `x_derivative r p = ring_0(x_poly r):(1->num)->R` [x_derivative_poly_0] THEN
  have `ring_gcd(x_poly r) (p,x_derivative r p) = ring_0(x_poly r):(1->num)->R` [RING_GCD_00] THEN
  have `x_derivative r p IN ring_carrier(x_poly(r:R ring))` [ring_coprime] THEN
  specialize[`x_poly(r:R ring)`;`p:(1->num)->R`;`x_derivative (r:R ring) p`]RING_GCD_EQ_1 THEN
  have `ring_gcd(x_poly r) (p,x_derivative r p) = ring_1(x_poly r):(1->num)->R` [RING_GCD_EQ_1] THEN
  qed[PID_IMP_INTEGRAL_DOMAIN;integral_domain]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any polynomial `p`, if `r` is a field, and the polynomials `p` and the derivative of `p` with respect to the indeterminate `x_poly r` are coprime, then `p` is not the zero polynomial.

### Informal sketch
The theorem states that if a polynomial and its derivative are coprime in a field, then the polynomial is non-zero. The proof proceeds as follows:
- Assume that `r` is a field, and `p` and its derivative with respect to `x_poly r` are coprime.
- Use `PID_x_poly_field` to assert that the polynomial ring `x_poly r` is a PID.
- Instantiate `RING_GCD_EQ_1` with the polynomials `p` and `x_derivative r p`. This justifies a step concluding that `ring_gcd (x_poly r) (p,x_derivative r p) = ring_1(x_poly r):(1->num)->R` .
- Derive contradictory facts using `x_derivative_poly_0`, `RING_GCD_00`, `PID_IMP_INTEGRAL_DOMAIN` and `integral_domain`, and ultimately conclude that `p` cannot be the zero polynomial `poly_0 r`.

### Mathematical insight
This theorem establishes a connection between the coprimality of a polynomial and its derivative, and the non-zeroness of the polynomial in the context of a field. The underlying intuition is that if a polynomial and its derivative are coprime, then the polynomial cannot be identically zero, because if it were, its derivative would also be zero, contradicting the coprimality assumption, and that in a field then ring GCD is well behaved. This property is important in algebraic geometry and field theory, particularly when analyzing the roots and irreducibility of polynomials.

### Dependencies
- `field`
- `ring_coprime`
- `x_poly`
- `x_derivative`
- `PID_x_poly_field`
- `x_poly_use`
- `ring_coprime`
- `x_derivative_poly_0`
- `RING_GCD_00`
- `ring_coprime`
- `RING_GCD_EQ_1`
- `PID_IMP_INTEGRAL_DOMAIN`
- `integral_domain`


---

## squarefree_if_coprime_derivative

### Name of formal statement
squarefree_if_coprime_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let squarefree_if_coprime_derivative = prove(`
  !(r:R ring) p.
  field r ==>
  ring_coprime(x_poly r) (p,x_derivative r p) ==>
  ring_squarefree(x_poly r) p
`,
  intro THEN
  have `p IN ring_carrier(x_poly(r:R ring))` [ring_coprime] THEN
  have `~(p = ring_0(x_poly(r:R ring)))` [nonzero_if_coprime_derivative;x_poly_use] THEN
  proven_if `ring_unit(x_poly(r:R ring)) p` [ring_squarefree_if_unit] THEN
  have `PID (x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `UFD (x_poly(r:R ring))` [PID_IMP_UFD] THEN
  ASSUME_TAC(UNDISCH_ALL (ISPECL[`p:(1->num)->R`] (CONJUNCT2 (UNDISCH_ALL (fst (EQ_IMP_RULE (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL [`x_poly(r:R ring)`]UFD_EQ_PRIMEFACT_NONUNIT))))))))) THEN
  choose2 `n:num` `q:num->(1->num)->R` `1 <= n /\ (!i. 1 <= i /\ i <= n ==> ring_prime(x_poly(r:R ring)) (q i)) /\ ring_product(x_poly r) (1..n) q = p` [] THEN
  subgoal `!i j. 1 <= i /\ i <= n /\ 1 <= j /\ j <= n /\ ring_divides(x_poly(r:R ring)) (q i) (q j) /\ ~(i = j) ==> F` THENL [
    intro THEN
    have `FINITE (1..n)` [FINITE_NUMSEG] THEN
    have `!i:num. i IN (1..n) ==> q i IN ring_carrier(x_poly(r:R ring))` [ring_prime;IN_NUMSEG] THEN
    have `i IN (1..n)` [IN_NUMSEG] THEN
    have `j IN (1..n)` [IN_NUMSEG] THEN
    specialize[`x_poly(r:R ring)`;`1..n`;`q:num->(1->num)->R`;`i:num`;`j:num`]square_divides_product_if_factor_divides_factor THEN
    have `ring_divides(x_poly(r:R ring)) (poly_mul r (q(i:num)) (q(i))) p` [x_poly_use] THEN
    have `ring_polynomial r (q(i:num):(1->num)->R)` [ring_prime;x_poly_use] THEN
    specialize[`r:R ring`;`p:(1->num)->R`;`q(i:num):(1->num)->R`]no_square_divisor_if_coprime_derivative THEN
    qed[ring_prime]
  ; pass
  ] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  have `!i. i IN 1..n ==> ring_prime(x_poly(r:R ring)) (q i)` [IN_NUMSEG] THEN
  have `!i. i IN 1..n ==> q i IN ring_carrier(x_poly(r:R ring))` [ring_prime] THEN
  have `!i j. i IN 1..n ==> j IN 1..n ==> ring_divides(x_poly(r:R ring)) (q i) (q j) ==> i = j` [IN_NUMSEG] THEN
  specialize[`x_poly(r:R ring)`;`1..n`;`q:num->(1->num)->R`]ring_squarefree_if_product_coprime_primes_indexed THEN
  qed[]
);;
```

### Informal statement
For any ring `r` that is a field, and any polynomial `p` over the ring `x_poly r`, if `p` is coprime with its formal derivative `x_derivative r p` in the ring `x_poly r`, then `p` is squarefree in the ring `x_poly r`.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is in the carrier of the ring `x_poly r` (which is implied by the assumption that `p` and its derivative are coprime).
- Show that if `p` is not zero in the ring `x_poly r` (which follows from `p` and its derivative begin coprime), then either `p` is a unit, in which case it is squarefree, or it is not a unit.
- Assume that `p` is not a unit.
- Use the fact that `x_poly r` is a PID because `r` is a field (`PID_x_poly_field`) and therefore a UFD (`PID_IMP_UFD`). Thus, `p`, being a non-unit, has a prime factorization: there exist `n` and `q` such that `1 <= n`, each `q i` (for `1 <= i <= n`) is prime, and their product is `p`.
- Show that the `q i` are pairwise coprime. This is done by contradiction: if `ring_divides(x_poly(r:R ring)) (q i) (q j)` for some `i != j`, then it can be shown by `no_square_divisor_if_coprime_derivative` that `poly_mul r (q i) (q i)` divides `p`, and therefore `p` and its derivative cannot be coprime, which is a contradiction.
- Finally, using `ring_squarefree_if_product_coprime_primes_indexed`, conclude that `p` is squarefree.

### Mathematical insight
This theorem provides a practical criterion to check if a polynomial is squarefree, which is to check if the polynomial and its derivative are coprime. The result relies on the fact that formal derivative can detect repeated factors. This is essential for many computations in polynomial algebra, e.g. root finding or partial fraction decomposition.

### Dependencies
- `ring_coprime`
- `nonzero_if_coprime_derivative`
- `x_poly_use`
- `ring_squarefree_if_unit`
- `PID_x_poly_field`
- `PID_IMP_UFD`
- `UFD_EQ_PRIMEFACT_NONUNIT`
- `FINITE_NUMSEG`
- `ring_prime`
- `IN_NUMSEG`
- `square_divides_product_if_factor_divides_factor`
- `no_square_divisor_if_coprime_derivative`
- `ring_polynomial`
- `ring_squarefree_if_product_coprime_primes_indexed`


---

## deg_x_derivative_lemma

### Name of formal statement
deg_x_derivative_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_derivative_lemma = prove(`
  !(r:R ring) p d.
  ring_polynomial r p ==>
  ~(coeff d (x_derivative r p) = ring_0(r:R ring)) ==>
  d <= poly_deg r p - 1
`,
  rw[coeff_x_derivative] THEN
  intro THEN
  have `~(coeff (d+1) p = ring_0(r:R ring))` [RING_MUL_RZERO;RING_OF_NUM] THEN
  have `d+1 <= poly_deg r (p:(1->num)->R)` [coeff_le_deg] THEN
  num_linear_fact `d+1 <= poly_deg r (p:(1->num)->R) ==> d <= poly_deg r p - 1` THEN
  qed[]
);;
```

### Informal statement
For any ring `r`, polynomial `p` over `r`, and natural number `d`, if `p` is a ring polynomial over `r` and the coefficient of `x^d` in the derivative of `p` with respect to `x` is not equal to the ring zero of `r`, then `d` is less than or equal to the degree of `p` minus 1.

### Informal sketch
The proof proceeds as follows:

- Start by rewriting the coefficient of the derivative of `p` using `coeff_x_derivative`, which relates the coefficients of the derivative to the coefficients of the original polynomial. Specifically, `coeff d (x_derivative r p) = ring_of_num r (d + 1) * coeff (d + 1) p`.
- Introduce assumptions using `intro`.
- Show that `coeff (d+1) p` is not `ring_0(r:R ring)` based on the assumption that `coeff d (x_derivative r p)` is not zero. If `coeff (d+1) p` were zero, then the product `ring_of_num r (d + 1) * coeff (d + 1) p` would also be zero since zero multiplied by anything is zero in a ring (using `RING_MUL_RZERO`, and `RING_OF_NUM` to handle the injected natural number as a ring element).
- Apply `coeff_le_deg` to deduce that `d+1` is less than or equal to the degree of `p`. `coeff_le_deg` states that if the `(d+1)`-th coefficient of `p` is nonzero, then `d+1` must be less than or equal to the degree of `p`.
- Apply the arithmetic fact `d+1 <= poly_deg r (p:(1->num)->R) ==> d <= poly_deg r p - 1` to complete the proof, rearranging the inequality.

### Mathematical insight
This theorem relates the degree of a polynomial to the degree of its derivative. It states that if the `d`-th coefficient of the derivative is nonzero, then the degree of the original polynomial must be at least `d+1`. This makes intuitive sense because taking the derivative reduces the degree of a polynomial by one, and if the `d`-th coefficient of the derivative is non-zero, that means there was an `x^(d+1)` term in the original polynomial.

### Dependencies
- `coeff_x_derivative`
- `coeff_le_deg`
- `RING_MUL_RZERO`
- `RING_OF_NUM`


---

## deg_x_derivative_le

### Name of formal statement
deg_x_derivative_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_derivative_le = prove(`
  !(r:R ring) p.
  ring_polynomial r p ==>
  poly_deg r (x_derivative r p) <= poly_deg r p - 1
`,
  intro THEN
  have `!d. ~(coeff d (x_derivative r p) = ring_0(r:R ring)) ==> d <= poly_deg r p - 1` [deg_x_derivative_lemma] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `ring_polynomial r (x_derivative r (p:(1->num)->R))` [x_derivative_polynomial] THEN
  qed[deg_le_coeff;ring_polynomial]
);;
```
### Informal statement
For any ring `r` and polynomial `p` over `r`, if `p` is a ring polynomial, then the degree of the derivative of `p` with respect to `x` is less than or equal to the degree of `p` minus 1.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions that the ring `r` exists and that `p` is a ring polynomial over `r`.
- Proving the intermediate lemma that if the coefficient of `d` in the derivative of `p` with respect to `x` is not zero, then `d` is less than or equal to the degree of `p` minus 1. This step relies on the theorem `deg_x_derivative_lemma`.
- Showing that `p` is a ring powerseries using the fact it is a ring polynomial per `ring_polynomial`.
- Showing that the derivative of `p` with respect to `x` is a ring polynomial by applying `x_derivative_polynomial`.
- Finally, proving the main result about the degree of the derivative of `p` being less than or equal to the degree of `p` minus 1, using `deg_le_coeff` and the fact that `p` is a `ring_polynomial`..

### Mathematical insight
This theorem states a fundamental property regarding the degree of the derivative of a polynomial. Specifically, it asserts that the degree of the derivative of a polynomial is at most one less than the degree of the original polynomial. This property is crucial for reasoning about the behavior of polynomials and their derivatives, and it plays a fundamental role in various areas of mathematics, including calculus, algebra, and numerical analysis.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `poly_deg`
  - `x_derivative`
  - `ring_0`
  - `ring_powerseries`
- Theorems:
  - `deg_x_derivative_lemma`
  - `deg_le_coeff`
  - `x_derivative_polynomial`


---

## deg_x_derivative

### Name of formal statement
deg_x_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_derivative = prove(`
  !(r:R ring) p.
  integral_domain r ==>
  ring_char r = 0 ==>
  ring_polynomial r p ==>
  poly_deg r (x_derivative r p) = poly_deg r p - 1
`,
  intro THEN
  have `!d. ~(coeff d (x_derivative r p) = ring_0(r:R ring)) ==> d <= poly_deg r p - 1` [deg_x_derivative_lemma] THEN
  case `poly_deg r (p:(1->num)->R) = 0` THENL [
    choose `c:R` `c IN ring_carrier r /\ (p:(1->num)->R) = poly_const r c` [POLY_DEG_EQ_0] THEN
    have `x_derivative r (p:(1->num)->R) = poly_0 r` [x_derivative_poly_const] THEN
    qed[POLY_DEG_0;ARITH_RULE `0 - 1 = 0`]
  ; pass
  ] THEN
  subgoal `~(coeff (poly_deg r p - 1) (x_derivative r p) = ring_0(r:R ring))` THENL [
    have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
    rw[coeff_x_derivative] THEN
    num_linear_fact `~(poly_deg r (p:(1->num)->R) - 1 + 1 = 0)` THEN
    have `~(ring_of_num r (poly_deg r (p:(1->num)->R) - 1 + 1) = ring_0 r)` [RING_CHAR_EQ_0] THEN
    num_linear_fact `~(poly_deg r (p:(1->num)->R) = 0) ==> poly_deg r p - 1 + 1 = poly_deg r p` THEN
    have `~((p:(1->num)->R) = poly_0 r)` [POLY_DEG_0;x_poly_use] THEN
    have `~(coeff (poly_deg r p - 1 + 1) (p:(1->num)->R) = ring_0 r)` [topcoeff_nonzero] THEN
    qed[integral_domain;RING_OF_NUM;coeff_poly_in_ring]
  ; pass
  ] THEN
  have `ring_polynomial r (x_derivative r (p:(1->num)->R))` [x_derivative_polynomial] THEN
  qed[deg_coeff;ring_polynomial]
);;
```

### Informal statement
Given a ring `r` that is an integral domain with characteristic 0, and `p` is a polynomial over `r`, the degree of the derivative of `p` is equal to the degree of `p` minus 1.

### Informal sketch
The proof proceeds by induction on the degree of the polynomial `p`.
- Base case: If the degree of `p` is 0, then `p` is a constant polynomial, so its derivative is 0, and the degree of the derivative is also 0. Since 0 - 1 = 0 is false, we can conclude the statement.
- Inductive step: Assume the degree of `p` is not 0. We need to show that the coefficient of `x` raised to the power of `poly_deg r p - 1` in the derivative of `p` is not zero in the ring `r`.
    - We use the lemma `coeff_x_derivative` to express the coefficient of the derivative.
    - We need to show that `(poly_deg r p) * (coeff (poly_deg r p) p)` is not zero in `r`.  Since `r` is an integral domain, it suffices to show that neither `poly_deg r p` nor `(coeff (poly_deg r p) p)` is zero in `r`.
        - `poly_deg r p` is not zero because we assumed the degree is not zero.
        - `(coeff (poly_deg r p) p)` is not zero because it is the leading coefficient of a polynomial.
- Finally, it is shown that the derivative of a ring polynomial is also a ring polynomial.
- Combine above results with lemma `deg_x_derivative_lemma`, the conclusion holds.

### Mathematical insight
This theorem expresses a fundamental property of polynomial derivatives: differentiating a polynomial reduces its degree by one. The condition that the ring has characteristic 0 is necessary to ensure that the leading coefficient of the derivative is non-zero; otherwise, multiplying by the degree could result in zero, even if the original coefficient was non-zero.

### Dependencies
- `integral_domain`
- `ring_char`
- `ring_polynomial`
- `poly_deg`
- `x_derivative`
- `deg_x_derivative_lemma`
- `POLY_DEG_EQ_0`
- `x_derivative_poly_const`
- `POLY_DEG_0`
- `coeff_x_derivative`
- `ring_of_num`
- `RING_CHAR_EQ_0`
- `x_poly_use`
- `topcoeff_nonzero`
- `integral_domain`
- `RING_OF_NUM`
- `coeff_poly_in_ring`
- `x_derivative_polynomial`
- `deg_coeff`
- `ring_polynomial`

### Porting notes (optional)
- The proof relies on the ring having characteristic 0. This is a condition that might need explicit handling in other provers if their ring theories do not automatically include this assumption.
- Tactics involving arithmetic reasoning (`ARITH_RULE`, `num_linear_fact`) may require adaptation to the specific arithmetic capabilities of the target proof assistant.


---

## x_derivative_nonzero

### Name of formal statement
x_derivative_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_derivative_nonzero = prove(`
  !(r:R ring) p.
  integral_domain r ==>
  ring_char r = 0 ==>
  ring_polynomial r p ==>
  ~(poly_deg r p = 0) ==>
  ~(x_derivative r p = poly_0 r)
`,
  intro THEN
  num_linear_fact `~(poly_deg r (p:(1->num)->R) = 0) ==> poly_deg r p - 1 + 1 = poly_deg r p` THEN
  subgoal `~(coeff (poly_deg r p - 1) (x_derivative r p) = ring_0(r:R ring))` THENL [
    have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
    rw[coeff_x_derivative] THEN
    num_linear_fact `~(poly_deg r (p:(1->num)->R) - 1 + 1 = 0)` THEN
    have `~(ring_of_num r (poly_deg r (p:(1->num)->R) - 1 + 1) = ring_0 r)` [RING_CHAR_EQ_0] THEN
    have `~((p:(1->num)->R) = poly_0 r)` [POLY_DEG_0;x_poly_use] THEN
    have `~(coeff (poly_deg r p - 1 + 1) (p:(1->num)->R) = ring_0 r)` [topcoeff_nonzero] THEN
    qed[integral_domain;RING_OF_NUM;coeff_poly_in_ring]
  ; pass
  ] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `coeff (poly_deg r (p:(1->num)->R) - 1) (x_derivative r p) = ring_mul r (ring_of_num r (poly_deg r p - 1 + 1)) (coeff (poly_deg r p - 1 + 1) p)` [coeff_x_derivative] THEN
  have `coeff (poly_deg r (p:(1->num)->R) - 1) (x_derivative r p) = ring_mul r (ring_of_num r (poly_deg r p)) (coeff (poly_deg r p) p)` [coeff_x_derivative] THEN
  have `~((p:(1->num)->R) = poly_0 r)` [POLY_DEG_0;x_poly_use] THEN
  have `~(coeff (poly_deg r p) (p:(1->num)->R) = ring_0 r)` [topcoeff_nonzero] THEN
  have `~(ring_of_num r (poly_deg r (p:(1->num)->R)) = ring_0 r)` [RING_CHAR_EQ_0] THEN
  have `~(coeff (poly_deg r (p:(1->num)->R) - 1) (x_derivative r p) = ring_0 r)` [integral_domain;RING_OF_NUM;coeff_poly_in_ring] THEN
  qed[coeff_poly_0]
);;
```

### Informal statement
For any ring `r` of type `R ring` such that `r` is an integral domain, the characteristic of `r` is 0, and `p` is a polynomial over `r` of type `ring_polynomial r p`, if the degree of `p` is not 0, then the formal derivative `x_derivative r p` of `p` is not the zero polynomial `poly_0 r`.

### Informal sketch
The proof proceeds by contradiction; assuming that the polynomial degree of `p` is not zero, we aim to show that the `x_derivative` of `p` is not the zero polynomial `poly_0 r`.
- The proof starts by introducing assumptions. Then it focuses on showing that the coefficient of `x^(deg(p)-1)` in `x_derivative r p` is not zero. This is done by considering `coeff (poly_deg r p - 1) (x_derivative r p)`.
- By the theorem `coeff_x_derivative`, this coefficient is equal to `ring_mul r (ring_of_num r (poly_deg r p)) (coeff (poly_deg r p) p)`.
- Because the degree of `p` is not 0, and `r` is an integral domain with characteristic 0, it follows that `ring_of_num r (poly_deg r p)` and `coeff (poly_deg r p) p` are both non-zero since `p` is not the zero polynomial via `topcoeff_nonzero`.
- Since `r` is an integral domain `ring_mul r (ring_of_num r (poly_deg r p)) (coeff (poly_deg r p) p)` is non-zero via `integral_domain` property.
- Therefore, `coeff (poly_deg r p - 1) (x_derivative r p)` is non-zero so `x_derivative r p` can't be `poly_0 r` which concludes the proof.

### Mathematical insight
This theorem states that the formal derivative of a non-constant polynomial over an integral domain with characteristic 0 is never the zero polynomial. This is a fundamental property in polynomial algebra, ensuring that differentiation behaves as expected. The conditions, that the ring is an integral domain and has characteristic zero, are necessary to ensure that the leading coefficient does not vanish upon multiplication by the degree.

### Dependencies
- `integral_domain`
- `ring_char`
- `ring_polynomial`
- `poly_deg`
- `x_derivative`
- `poly_0`
- `coeff_x_derivative`
- `RING_CHAR_EQ_0`
- `POLY_DEG_0`
- `topcoeff_nonzero`
- `RING_OF_NUM`

### Porting notes (optional)
The statement relies on having definitions for polynomial rings, degrees, and formal derivatives. Care is needed in porting the handling of characteristic 0. The tactic `num_linear_fact` might need equivalent arithmetic rewriting in other systems.


---

## deg_divides

### Name of formal statement
deg_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_divides = prove(`
  !(r:R ring) (S:V->bool) p q.
  integral_domain r ==>
  ring_divides(poly_ring r S) p q ==>
  ~(q = poly_0 r) ==>
  poly_deg r p <= poly_deg r q
`,
  intro THEN
  have `(p:(V->num)->R) IN ring_carrier(poly_ring r S)` [ring_divides] THEN
  have `(p:(V->num)->R) IN {f | ring_polynomial r f /\ poly_vars r f SUBSET S}` [POLY_RING] THEN
  set_fact `(p:(V->num)->R) IN {f | ring_polynomial r f /\ poly_vars r f SUBSET S} ==> ring_polynomial r p` THEN
  choose `u:(V->num)->R` `(u:(V->num)->R) IN ring_carrier(poly_ring r S) /\ q = ring_mul(poly_ring r S) p u` [ring_divides] THEN
  have `(u:(V->num)->R) IN {f | ring_polynomial r f /\ poly_vars r f SUBSET S}` [POLY_RING] THEN
  set_fact `(u:(V->num)->R) IN {f | ring_polynomial r f /\ poly_vars r f SUBSET S} ==> ring_polynomial r u` THEN
  have `~((p:(V->num)->R) = poly_0 r)` [POLY_MUL_0;POLY_RING] THEN
  have `~((u:(V->num)->R) = poly_0 r)` [POLY_MUL_0;POLY_RING] THEN
  have `poly_deg r (poly_mul r p (u:(V->num)->R)) = poly_deg r p + poly_deg r u` [POLY_DEG_MUL] THEN
  num_linear_fact `poly_deg r (poly_mul r p (u:(V->num)->R)) = poly_deg r p + poly_deg r u ==> poly_deg r p <= poly_deg r (poly_mul r p u)` THEN
  qed[POLY_RING]
);;
```
### Informal statement
For any ring `r` with carrier `R`, any subset `S` of the variable type `V`, and any polynomials `p` and `q` over `r`: If `r` is an integral domain, and `p` divides `q` in the polynomial ring over `r` with variables in `S`, and `q` is not the zero polynomial, then the degree of `p` is less than or equal to the degree of `q`.

### Informal sketch
The proof proceeds as follows:
- Assume `r` is an integral domain, `p` divides `q` in the polynomial ring over `r` with variables in `S`, and `q` is not zero.
- From `p` divides `q` we have that `p` is in the carrier of polynomial ring `poly_ring r S`, and also we have that there exists a polynomial `u` in the carrier of `poly_ring r S` such that `q = p * u` (where `*` is multiplication in `poly_ring r S`, represented as `ring_mul(poly_ring r S)`).
- Since `q` is the product of `p` and `u` and `q` is non-zero, both `p` and `u` must be non-zero, given that r is an integral domain.
- Use the theorem `POLY_DEG_MUL` to show that `poly_deg r (poly_mul r p u) = poly_deg r p + poly_deg r u`.
- Because the degree of any polynomial is a natural number, `poly_deg r p <= poly_deg r p + poly_deg r u`.
- Finally, prove `poly_deg r p <= poly_deg r q`

### Mathematical insight
This theorem states a fundamental property of polynomial rings over integral domains: if one polynomial divides another, the degree of the divisor cannot exceed the degree of the dividend (unless the dividend is the zero polynomial). This is a key result when reasoning about divisibility and factorization in polynomial rings.

### Dependencies
- `integral_domain`
- `ring_divides`
- `poly_0`
- `poly_ring`
- `ring_carrier`
- `ring_mul`
- `poly_deg`
- `POLY_MUL_0`
- `POLY_DEG_MUL`


---

## poly_deg_product

### Name of formal statement
poly_deg_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_deg_product = prove(`
  !(r:R ring) p n S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> ~(p s = poly_0 r)) ==>
  (!s:X. s IN S ==> poly_deg r (p s) = n s) ==>
  field r ==>
  poly_deg r (poly_product r S p) = nsum S n
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;NSUM_CLAUSES;POLY_DEG_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial r (p(x:X):(1->num)->R)` [] THEN
    have `ring_powerseries r (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    simp[poly_product_insert;NSUM_CLAUSES] THEN
    simp[CARD_CLAUSES] THEN
    have `ring_polynomial(r:R ring) (poly_product r (S:X->bool) p)` [poly_product_poly] THEN
    have `poly_deg(r:R ring) (poly_product r (S:X->bool) p) = nsum S n` [poly_product_poly] THEN
    subgoal `~(poly_product r (S:X->bool) p = poly_0(r:R ring))` THENL [
      simp[poly_product_ring_product_x_poly;x_poly_use] THEN
      have `integral_domain(x_poly(r:R ring))` [integral_domain_x_poly_field] THEN
      specialize[`x_poly(r:R ring)`;`S:X->bool`;`p:X->(1->num)->R`]INTEGRAL_DOMAIN_PRODUCT_EQ_0 THEN
      qed[x_poly_use]
    ; pass
    ] THEN
    specialize_assuming[`r:R ring`;`p(x:X):(1->num)->R`;`poly_product r (S:X->bool) p:(1->num)->R`]POLY_DEG_MUL THEN
    qed[FIELD_IMP_INTEGRAL_DOMAIN]
  ]
);;
```

### Informal statement
Let `r` be a ring and suppose we are given a finite set `S`. Let `p` be a function mapping elements `s` of `S` to ring polynomials over `r`, with the property that for every `s` in `S`, `p s` is not the zero polynomial. Also, suppose that for every `s` in `S`, the degree of `p s` is given by `n s`. If `r` is a field, then the degree of the polynomial `poly_product r S p` (the product of the polynomials `p s` for `s` in `S`) is equal to the sum over `S` of the degrees `n s`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.
- Base case: If `S` is empty, then `poly_product r S p` is 1, and `nsum S n` is 0, and `poly_deg r 1 = 0`.
- Inductive step: Assume the result holds for all finite subsets of a set. We want to show it holds for `INSERT x S`, where `x` is an element and `S` is a finite set.
  - It is shown that if `S` is a finite set of polynomials then so is `INSERT x S`.
  - We have `poly_product r (INSERT x S) p = poly_product r (S) p * p x`.
  - It is shown that `poly_deg(poly_product r S p * p x) = poly_deg(poly_product r S p) + poly_deg (p x)`.
  - Show that `poly_product r S p` is not equal to the zero polynomial.
  - Use the inductive hypothesis: `poly_deg (poly_product r S p) = nsum S n`.
  - Therefore, `poly_deg (poly_product r (INSERT x S) p) = poly_deg (p x) + nsum S n = n (x) + nsum S n = nsum (INSERT x S) n`.

The `GEN_TAC` and `intro` tactics introduce the quantified variables into the assumptions. The `sufficesby` tactic introduces a goal that is sufficient. The tactics `rw` and `simp` rewrite the goal using the given equations/facts and simplify the expression. The `specialize` tactic instantiates a universally quantified theorem. The `qed` tactic solves the current goal.

### Mathematical insight
The theorem states that the degree of a product of polynomials is the sum of the degrees, provided that none of the polynomials are zero and `r` is a field. This is a fundamental result in polynomial algebra. It justifies reasoning about the degree of complex polynomial expressions by decomposing them into products. Because polynomials over fields form an integral domain, the product of nonzero polynomials is nonzero, and the degree of the product is the sum of the degrees of each polynomial in the product.

### Dependencies
- `FINITE`
- `poly_product`
- `ring_polynomial`
- `poly_deg`
- `nsum`
- `poly_0`
- `FIELD_IMP_INTEGRAL_DOMAIN`
- `poly_product_empty`
- `NSUM_CLAUSES`
- `POLY_DEG_1`
- `poly_product_insert`
- `CARD_CLAUSES`
- `poly_product_poly`
- `poly_product_ring_product_x_poly`
- `x_poly_use`
- `integral_domain_x_poly_field`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `POLY_DEG_MUL`

### Porting notes (optional)
- In proof assistants like Coq or Lean, the `FINITE` condition may translate to a list or a `finset` type.
- The handling of ring and field instances, as well as polynomial definitions, may vary.
- The `poly_product` could be potentially tricky to translate if its implementation relies heavily on HOL Light-specific features. Make sure to preserve its semantics.
- The proof relies on induction over finite sets, ensure that the proof assistant has suitable automation for this.


---

## deg_prime

### Name of formal statement
deg_prime

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_prime = prove(`
  !(r:R ring) p.
  field r ==>
  ring_prime(x_poly r) p ==>
  ~(poly_deg r p = 0)
`,
  intro THEN
  have `(p:(1->num)->R) IN ring_carrier(x_poly r)` [ring_prime] THEN
  have `ring_polynomial r (p:(1->num)->R)` [x_poly_use] THEN
  choose `c:R` `c IN ring_carrier r /\ (p:(1->num)->R) = poly_const r c` [POLY_DEG_EQ_0] THEN
  case `c = ring_0(r:R ring)` THENL [
    have `p = ring_0(x_poly(r:R ring))` [x_poly_use;poly_0] THEN
    qed[ring_prime]
  ;
    choose `d:R` `d IN ring_carrier(r:R ring) /\ ring_mul r c d = ring_1 r` [field] THEN
    have `poly_mul r (poly_const r c) (poly_const r d) = poly_const r (ring_mul r c d):(1->num)->R` [POLY_CONST_MUL] THEN
    have `poly_mul r (poly_const r c) (poly_const r d) = poly_1 r:(1->num)->R` [poly_1] THEN
    have `poly_mul r p (poly_const r d) = poly_1 r:(1->num)->R` [] THEN
    have `ring_mul(x_poly r) p (poly_const r d) = ring_1(x_poly(r:R ring))` [x_poly_use] THEN
    have `poly_const r d IN ring_carrier(x_poly(r:R ring))` [POLY_CONST;x_poly] THEN
    have `ring_unit(x_poly(r:R ring)) p` [ring_unit] THEN
    qed[ring_prime]
  ]
);;
```

### Informal statement
For any ring `r` and any polynomial `p` over `r`, if `r` is a field and `p` is a prime element in the polynomial ring over `r`, then the degree of `p` is not equal to 0.

### Informal sketch
The proof proceeds by contradiction. Assume that `poly_deg r p = 0`.

- Since `p` is in `ring_carrier(x_poly r)` i.e. the polynomial ring's carrier, then `p` must be a polynomial over `r`.
- If `poly_deg r p = 0`, then `p` is a constant polynomial, i.e., there exists `c` in `ring_carrier r` such that `p = poly_const r c`.
- Case 1: If `c = ring_0 r`, then `p = poly_0 r`, which implies `p` is the zero polynomial in the polynomial ring `x_poly r`, contradicting the assumption that `p` is prime.
- Case 2: If `c != ring_0 r`, then since `r` is a field, `c` has a multiplicative inverse `d` in `ring_carrier r` such that `ring_mul r c d = ring_1 r`. Thus `poly_mul r (poly_const r c) (poly_const r d) = poly_const r (ring_mul r c d) = poly_const r (ring_1 r) = poly_1 r`.
- This implies `p` has an inverse `poly_const r d` in the polynomial ring, and so `p` is a unit, contradicting the assumption that `p` is prime.
- `intro`, `choose`, and `case` are used to unpack assumptions and create subgoals.
- `qed` discharges the proof.
- `x_poly_use` allows us to use theorems that talk about generic rings on the polynomial ring `x_poly r`.

### Mathematical insight
This theorem states that a prime polynomial over a field cannot be a constant polynomial. This is because any non-zero constant polynomial over a field will be a unit in the polynomial ring, and the zero polynomial cannot be prime. Prime elements are, by definition, non-units.

### Dependencies
- `field`
- `ring_prime`
- `x_poly_use`
- `POLY_DEG_EQ_0`
- `POLY_CONST_MUL`
- `poly_1`
- `POLY_CONST`
- `x_poly`
- `ring_unit`
- `poly_0`

### Porting notes (optional)
In proof assistants like Coq or Lean, the concept of field and polynomial rings might be available in standard libraries. The definitions of `ring_prime` and `poly_deg` would likely need to be ported, ensuring compatibility with the libraries' ring and polynomial implementations. The `choose` tactic may need manual implementation as an existential quantifier introduction. The `case` tactic can be translated to case distinctions on equality.


---

## deg_0_if_unit

### Name of formal statement
deg_0_if_unit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_0_if_unit = prove(`
  !(r:R ring) p.
  field r ==>
  ring_unit(x_poly r) p ==>
  poly_deg r p = 0
`,
  intro THEN
  have `p IN ring_carrier(x_poly(r:R ring))` [ring_unit] THEN
  choose `q:(1->num)->R` `q IN ring_carrier(x_poly(r:R ring)) /\ ring_mul(x_poly r) p q = ring_1(x_poly r)` [ring_unit] THEN
  have `integral_domain(r:R ring)` [FIELD_IMP_INTEGRAL_DOMAIN] THEN
  have `ring_polynomial r (p:(1->num)->R)` [x_poly_use] THEN
  have `ring_polynomial r (q:(1->num)->R)` [x_poly_use] THEN
  have `poly_mul r p q = poly_1 r:(1->num)->R` [x_poly_use] THEN
  have `~(poly_1 r = poly_0 r:(1->num)->R)` [coeff_poly_1;coeff_poly_0;integral_domain] THEN
  have `~(p = poly_0 r:(1->num)->R)` [POLY_MUL_0] THEN
  have `~(q = poly_0 r:(1->num)->R)` [POLY_MUL_0] THEN
  have `poly_deg r (poly_mul r p q:(1->num)->R) = poly_deg r p + poly_deg r q` [POLY_DEG_MUL] THEN
  have `poly_deg r (poly_1 r:(1->num)->R) = 0` [POLY_DEG_1] THEN
  qed[ARITH_RULE `0 = d + e ==> d = 0`]
);;
```
### Informal statement
For any ring `r` and polynomial `p` over `r`, if `r` is a field and `p` is a unit in the polynomial ring over `r`, then the degree of `p` is 0.

### Informal sketch
The proof proceeds as follows:
- Assume `r` is a field and `p` is a unit in the polynomial ring over `r`.
- Since `p` is a unit, there exists a polynomial `q` such that `p * q = 1`, where `*` denotes polynomial multiplication and `1` the polynomial representation of the multiplicative identity.
- It is established that since `r` is a field then it is an integral domain.
- Polynomials `p` and `q` are elements of `ring_polynomial r`.
- Thus, the product `p*q` equals `poly_1 r`.
- We can deduce `p` and `q` are not `poly_0 r` i.e. not equal to the zero polynomial
- Compute the degree of the product `poly_deg r (poly_mul r p q)` equals the sum of the degrees `poly_deg r p + poly_deg r q` due to `POLY_DEG_MUL`.
- The degree of the polynomial `poly_1 r` is 0 from `POLY_DEG_1`.
- Therefore, `poly_deg r p + poly_deg r q = 0`. Since the degree of a polynomial is non-negative, it implies that `poly_deg r p = 0`.

### Mathematical insight
A unit in a polynomial ring over a field must be a constant polynomial. This is because if a polynomial has degree greater than 0, its product with any other polynomial will have a degree greater than 0, and hence cannot be equal to 1 (which has degree 0).

### Dependencies
- `ring_unit`
- `FIELD_IMP_INTEGRAL_DOMAIN`
- `x_poly_use`
- `coeff_poly_1`
- `coeff_poly_0`
- `integral_domain`
- `POLY_MUL_0`
- `POLY_DEG_MUL`
- `POLY_DEG_1`
- `ARITH_RULE`


---

## prime_if_deg_1

### Name of formal statement
prime_if_deg_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let prime_if_deg_1 = prove(`
  !(r:R ring) p.
  field r ==>
  ring_polynomial r p ==>
  poly_deg r p = 1 ==>
  ring_prime(x_poly r) p
`,
  intro THEN
  have `~ring_unit(x_poly(r:R ring)) p` [deg_0_if_unit;ARITH_RULE `~(1 = 0)`] THEN
  have `p IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `~(p = poly_0(r:R ring):(1->num)->R)` [POLY_DEG_0;ARITH_RULE `~(1 = 0)`] THEN
  have `~(p = ring_0(x_poly(r:R ring)))` [x_poly_use] THEN
  have `PID (x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `UFD (x_poly(r:R ring))` [PID_IMP_UFD] THEN
  ASSUME_TAC(UNDISCH_ALL (ISPECL[`p:(1->num)->R`] (CONJUNCT2 (UNDISCH_ALL (fst (EQ_IMP_RULE (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL [`x_poly(r:R ring)`]UFD_EQ_PRIMEFACT_NONUNIT))))))))) THEN
  choose2 `n:num` `q:num->((1->num)->R)` `1 <= n /\ (!i. 1 <= i ==> i <= n ==> ring_prime (x_poly(r:R ring)) (q i)) /\ ring_product (x_poly r) (1..n) q = p` [] THEN
  have `!i. 1 <= i ==> i <= n ==> ring_polynomial r (q i:(1->num)->R)` [ring_prime;x_poly_use] THEN
  have `!i. 1 <= i ==> i <= n ==> ~(q i = poly_0 r:(1->num)->R)` [deg_prime;POLY_DEG_0] THEN
  have `!i. i IN 1..n ==> 1 <= i /\ i <= n` [IN_NUMSEG] THEN
  have `!i. i IN 1..n ==> ring_polynomial r (q i:(1->num)->R)` [ring_prime;x_poly_use] THEN
  have `!i. i IN 1..n ==> ~(q i = poly_0 r:(1->num)->R)` [deg_prime;POLY_DEG_0] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  specialize[`r:R ring`;`q:num->(1->num)->R`;`\s:num. poly_deg r (q s:(1->num)->R)`;`1..n`]poly_deg_product THEN
  have `p = poly_product(r:R ring) (1..n) q` [poly_product_ring_product_x_poly] THEN
  have `nsum(1..n) (\s. poly_deg r (q s:(1->num)->R)) = 1` [] THEN
  have `!s. s IN 1..n ==> 1 <= poly_deg r (q s:(1->num)->R)` [deg_prime;ARITH_RULE `~(x = 0) ==> 1 <= x`] THEN
  have `nsum(1..n) (\s. 1) <= nsum(1..n) (\s. poly_deg r (q s:(1->num)->R))` [NSUM_LE] THEN
  have `CARD(1..n) <= nsum(1..n) (\s. poly_deg r (q s:(1->num)->R))` [CARD_EQ_NSUM] THEN
  have `n <= nsum(1..n) (\s. poly_deg r (q s:(1->num)->R))` [CARD_NUMSEG_1] THEN
  have `n <= 1` [] THEN
  have `1 <= n` [] THEN
  num_linear_fact `1 <= n ==> n <= 1 ==> n = 1` THEN
  have `p = ring_product(x_poly(r:R ring)) {1} q` [NUMSEG_SING] THEN
  have `p = q 1:(1->num)->R` [RING_PRODUCT_SING;x_poly_use] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any polynomial `p`, if `r` is a field, `p` is a ring polynomial over `r`, and the degree of `p` is 1, then `p` is a ring prime in the polynomial ring `x_poly r`.

### Informal sketch
The proof proceeds as follows:
- Assume that `r` is a field, `p` is a ring polynomial over `r`, and the degree of `p` is 1.
- Show that `p` is not a unit in `x_poly r` because its degree is not 0, using `deg_0_if_unit`.
- Show that `p` is in the carrier of `x_poly r` using `x_poly_use`.
- Show that `p` is not the zero polynomial using `POLY_DEG_0`.
- Show that `p` is not the zero element of `x_poly r` using `x_poly_use`.
- Establish that `x_poly r` is a PID using `PID_x_poly_field`.
- Deduce that `x_poly r` is a UFD using `PID_IMP_UFD`.
- Apply the fact that elements of a UFD have a unique prime factorization (up to units). Choose `n` and `q` such that `1 <= n`, each `q i` is prime, and `p` is the product of the `q i`.
- Show that each `q i` is a ring polynomial.
- Show that each `q i` is non-zero.
- Show that the degree of each `q i` is greater than or equal to 1 using `deg_prime`
- Use `poly_deg_product` to relate the degree of `p` to the sum of the degrees of the `q i`. Since `p` is degree 1, we have that sum of degrees of `q i` is 1
- Deduce that `n <= 1` since each term is greater than or equal to one
- Since it has previously been proved that `1 <= n`, conclude `n = 1`.
- Therefore, `p = ring_product(x_poly r) {1} q = q 1` and `p` is prime.

### Mathematical insight
A polynomial of degree 1 over a field is always a prime element in the polynomial ring. This theorem combines the facts that polynomial rings over fields are PIDs, PIDs are UFDs, and elements in UFD have unique prime factorizations. In particular, a polynomial with degree 1 cannot be factored into polynomials with lower degree, so it must be a prime element.

### Dependencies
- `deg_0_if_unit`
- `ARITH_RULE`
- `x_poly_use`
- `POLY_DEG_0`
- `PID_x_poly_field`
- `PID_IMP_UFD`
- `UFD_EQ_PRIMEFACT_NONUNIT`
- `ring_prime`
- `deg_prime`
- `IN_NUMSEG`
- `FINITE_NUMSEG`
- `poly_deg_product`
- `poly_product_ring_product_x_poly`
- `NSUM_LE`
- `CARD_EQ_NSUM`
- `CARD_NUMSEG_1`
- `NUMSEG_SING`
- `RING_PRODUCT_SING`


---

## coprime_prime_derivative

### Name of formal statement
coprime_prime_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coprime_prime_derivative = prove(`
  !(r:R ring) p.
  field r ==>
  ring_char r = 0 ==>
  ring_prime(x_poly r) p ==>
  ring_coprime(x_poly r) (p,x_derivative r p)
`,
  rw[ring_coprime] THEN
  intro THENL [
    qed[ring_prime]
  ;
    qed[ring_prime;x_poly_use;x_derivative_polynomial]
  ;
    have `integral_domain(x_poly(r:R ring))` [integral_domain_x_poly_field] THEN
    have `ring_irreducible(x_poly(r:R ring)) p` [INTEGRAL_DOMAIN_PRIME_IMP_IRREDUCIBLE] THEN
    proven_if `ring_unit (x_poly(r:R ring)) d` [] THEN
    have `p IN ring_carrier(x_poly(r:R ring))` [ring_prime] THEN
    have `ring_polynomial r (p:(1->num)->R)` [x_poly_use] THEN
    have `ring_polynomial r (x_derivative r (p:(1->num)->R))` [x_derivative_polynomial] THEN
    have `x_derivative r p IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
    have `ring_associates(x_poly(r:R ring)) d p` [RING_NONUNIT_DIVIDES_IRREDUCIBLE] THEN
    have `ring_divides(x_poly(r:R ring)) p (x_derivative r p)` [RING_ASSOCIATES_REFL;RING_ASSOCIATES_DIVIDES] THEN
    have `integral_domain(r:R ring)` [FIELD_IMP_INTEGRAL_DOMAIN] THEN
    have `~(poly_deg r (p:(1->num)->R) = 0)` [deg_prime] THEN
    have `~(x_derivative r p = poly_0(r:R ring))` [x_derivative_nonzero] THEN
    have `poly_deg r (p:(1->num)->R) <= poly_deg r (x_derivative r p)` [deg_divides;x_poly] THEN
    have `poly_deg r (x_derivative r p) = poly_deg r (p:(1->num)->R) - 1` [deg_x_derivative] THEN
    num_linear_fact `poly_deg r (p:(1->num)->R) <= poly_deg r (x_derivative r p) /\ poly_deg r (x_derivative r p) = poly_deg r (p:(1->num)->R) - 1 ==> poly_deg r p = 0` THEN
    qed[]
  ]
);;
```

### Informal statement
For all rings `r` and all polynomials `p` over the ring of polynomials over `r`, if `r` is a field, the characteristic of `r` is 0, and `p` is a prime polynomial over the ring of polynomials over `r`, then `p` and its formal derivative (with respect to `x` in the ring of polynomials over `r`) are coprime.

### Informal sketch
The proof proceeds by showing that under the assumption that `p` is a `ring_prime` in `x_poly r`, it is true that `ring_coprime(x_poly r) (p,x_derivative r p)`.
- The hypothesis `ring_prime` is used to show that `p` is irreducible.
- Then if `d` divides both `p` and its derivative, it follows that a non-unit `d` must be an associate of `p`.
- Therefore `p` divides the derivative of `p`. This part uses the following relevant assumptions:
    - `integral_domain(x_poly(r:R ring))`
    - `ring_irreducible(x_poly(r:R ring)) p`
    - `p IN ring_carrier(x_poly(r:R ring))`
    - `ring_polynomial r (p:(1->num)->R)`
    - `ring_polynomial r (x_derivative r (p:(1->num)->R))`
    - `x_derivative r p IN ring_carrier(x_poly(r:R ring))`
- By comparing degrees, this is seen to be impossible since the degree of the derivative is strictly less than the degree of `p`. This part uses the following relevant assumptions:
    - `integral_domain(r:R ring)`
    - `~(poly_deg r (p:(1->num)->R) = 0)`
    - `~(x_derivative r p = poly_0(r:R ring))`
    - `poly_deg r (p:(1->num)->R) <= poly_deg r (x_derivative r p)`
    - `poly_deg r (x_derivative r p) = poly_deg r (p:(1->num)->R) - 1`

### Mathematical insight
This theorem connects the notion of a prime polynomial with its derivative. Specifically, it states that over a field of characteristic 0, a prime polynomial is always coprime with its derivative. This is a key result in field theory and commutative algebra, and arises in many contexts, such as Galois theory and the study of field extensions.

### Dependencies

- Basic ring theory:
    - `ring_coprime`
    - `ring_prime`
    - `x_poly`
    - `x_derivative`
    - `integral_domain_x_poly_field`
    - `INTEGRAL_DOMAIN_PRIME_IMP_IRREDUCIBLE`
    - `RING_NONUNIT_DIVIDES_IRREDUCIBLE`
    - `RING_ASSOCIATES_REFL`
    - `RING_ASSOCIATES_DIVIDES`
    - `FIELD_IMP_INTEGRAL_DOMAIN`
    - `deg_prime`
    - `x_derivative_nonzero`
    - `deg_divides`
    - `x_poly`
    - `deg_x_derivative`
    - `ring_carrier`
    - `ring_polynomial`

### Porting notes (optional)
- Ensure that the target proof assistant has a notion of polynomials over rings and fields, and the ability to compute formal derivatives of polynomials.
- The proof relies on degree comparison, which might require some care to port correctly (especially regarding leading coefficients).
- The use of field characteristic = 0 should be checked, as different proof assistants may handle such assumptions in different ways.


---

## square_divides_if_also_divides_derivative

### Name of formal statement
square_divides_if_also_divides_derivative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let square_divides_if_also_divides_derivative = prove(`
  !(r:R ring) p f.
  field r ==>
  ring_char r = 0 ==>
  ring_prime(x_poly r) p ==>
  ring_divides(x_poly r) p f ==>
  ring_divides(x_poly r) p (x_derivative r f) ==>
  ring_divides(x_poly r) (poly_mul r p p) f
`,
  intro THEN
  choose `q:(1->num)->R` `q IN ring_carrier(x_poly(r:R ring)) /\ f = ring_mul(x_poly r) p q` [ring_divides] THEN
  choose `Q:(1->num)->R` `Q IN ring_carrier(x_poly(r:R ring)) /\ x_derivative r f = ring_mul(x_poly r) p Q` [ring_divides] THEN
  have `p IN ring_carrier(x_poly(r:R ring))` [ring_divides] THEN
  have `ring_polynomial r (p:(1->num)->R)` [x_poly_use] THEN
  have `ring_polynomial r (q:(1->num)->R)` [x_poly_use] THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `ring_powerseries r (q:(1->num)->R)` [ring_polynomial] THEN
  specialize[`r:R ring`;`p:(1->num)->R`;`q:(1->num)->R`]x_derivative_mul THEN
  have `x_derivative(r:R ring) (ring_mul(x_poly r) p q) = poly_add r (poly_mul r (x_derivative r p) q) (poly_mul r p (x_derivative r q))` [x_poly_use] THEN
  have `x_derivative(r:R ring) (ring_mul(x_poly r) p q) = ring_add(x_poly r) (poly_mul r (x_derivative r p) q) (poly_mul r p (x_derivative r q))` [x_poly_use] THEN
  have `x_derivative(r:R ring) (ring_mul(x_poly r) p q) = ring_add(x_poly r) (ring_mul(x_poly r) (x_derivative r p) q) (poly_mul r p (x_derivative r q))` [x_poly_use] THEN
  have `x_derivative(r:R ring) (ring_mul(x_poly r) p q) = ring_add(x_poly r) (ring_mul(x_poly r) (x_derivative r p) q) (ring_mul(x_poly r) p (x_derivative r q))` [x_poly_use] THEN
  have `ring_mul(x_poly(r:R ring)) p Q = ring_add(x_poly r) (ring_mul(x_poly r) (x_derivative r p) q) (ring_mul(x_poly r) p (x_derivative r q))` [] THEN
  have `ring_coprime(x_poly(r:R ring)) (p,x_derivative r p)` [coprime_prime_derivative] THEN
  have `PID(x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `bezout_ring(x_poly(r:R ring))` [PID_IMP_BEZOUT_RING] THEN
  have `ring_polynomial r (x_derivative r (p:(1->num)->R))` [x_derivative_polynomial] THEN
  have `x_derivative r p IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  specialize[`x_poly(r:R ring)`;`p:(1->num)->R`;`x_derivative(r:R ring) p`]BEZOUT_RING_COPRIME THEN
  choose2 `x:(1->num)->R` `y:(1->num)->R` `x IN ring_carrier(x_poly(r:R ring)) /\ y IN ring_carrier(x_poly r) /\ ring_add (x_poly r) (ring_mul (x_poly r) p x) (ring_mul (x_poly r) (x_derivative r p) y) = ring_1 (x_poly r)` [] THEN
  have `Q IN ring_carrier(x_poly(r:R ring))` [] THEN
  have `q IN ring_carrier(x_poly(r:R ring))` [] THEN
  have `x_derivative r q IN ring_carrier(x_poly(r:R ring))` [x_poly_use;x_derivative_polynomial] THEN
  have `x IN ring_carrier(x_poly(r:R ring))` [] THEN
  have `y IN ring_carrier(x_poly(r:R ring))` [] THEN
  have `ring_mul (x_poly(r:R ring)) p Q = ring_add (x_poly r) (ring_mul (x_poly r) (x_derivative r p) q) (ring_mul (x_poly r) p (x_derivative r q))` [] THEN
  have `ring_add (x_poly(r:R ring)) (ring_mul (x_poly r) p x) (ring_mul (x_poly r) (x_derivative r p) y) = ring_1 (x_poly r)` [] THEN
  specialize[
    `x_poly(r:R ring)`
    ;`Q:(1->num)->R`
    ;`p:(1->num)->R`
    ;`x_derivative r p:(1->num)->R`
    ;`q:(1->num)->R`
    ;`x_derivative r q:(1->num)->R`
    ;`x:(1->num)->R`
    ;`y:(1->num)->R`
  ](GENL[`r:R ring`;`Q:R`;`p:R`;`p':R`;`q:R`;`q':R`;`x:R`;`y:R`](
  RING_RULE `ring_mul(r:R ring) p Q = ring_add r (ring_mul r p' q) (ring_mul r p q') /\ ring_add r (ring_mul r p x) (ring_mul r p' y) = ring_1 r ==> ring_mul r p q = ring_mul r (ring_mul r p p) (ring_sub r (ring_add r (ring_mul r Q y) (ring_mul r x q)) (ring_mul r q' y))`
  )) THEN
  subgoal `ring_divides(x_poly(r:R ring)) (ring_mul(x_poly r) p p) f` THENL [
    rw[ring_divides] THEN
    intro THENL [
      qed[RING_MUL]
    ;
      qed[RING_MUL]
    ;
      witness `ring_sub (x_poly(r:R ring)) (ring_add (x_poly r) (ring_mul (x_poly r) Q y) (ring_mul (x_poly r) x q)) (ring_mul (x_poly r) (x_derivative r q) y)` THEN
      intro THENL [
        have `ring_add (x_poly r) (ring_mul (x_poly r) Q y) (ring_mul (x_poly r) x q) IN ring_carrier(x_poly(r:R ring))` [RING_ADD;RING_MUL] THEN
        qed[RING_SUB;RING_MUL]
      ;
        qed[]
      ]
    ]
    ;
      qed[x_poly_use]
  ]
);;
```
### Informal statement
Let `r` be a ring. Suppose that `r` is a field, the characteristic of `r` is 0, `p` is a prime polynomial in the polynomial ring over `r`, `p` divides `f`, and `p` divides the derivative of `f`. Then `p^2` divides `f`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `r` is a field, `r` has characteristic 0, `p` is a prime polynomial, `p` divides `f`, and `p` divides the derivative of `f`.
- Since `p` divides `f`, we can write `f = p * q` for some polynomial `q`.
- Since `p` divides the derivative of `f`, we can write `x_derivative r f = p * Q` for some polynomial `Q`.
- By the product rule for derivatives, `x_derivative r f = (x_derivative r p) * q + p * (x_derivative r q)`.
- Thus, `p * Q = (x_derivative r p) * q + p * (x_derivative r q)`.
- Because `p` is prime, it is coprime with its derivative `x_derivative r p`.
- By Bézout's identity, there exist polynomials `x` and `y` such that `p * x + (x_derivative r p) * y = 1`.
- Multiply the Bézout identity by `q` to get `p * x * q + (x_derivative r p) * y * q = q`.
- Express `(x_derivative r p) * q` using the rewritten product rule, `(x_derivative r p) * q = p * Q - p * (x_derivative r q)`.
- Substitute this into the previous equation to get `p * x * q + (p * Q - p * (x_derivative r q)) * y = q`.
- Rearrange the terms to get `p * (x * q + Q * y - (x_derivative r q) * y) = q`.
- Multiply this equation by `p` to obtain `p * p * (x * q + Q * y - (x_derivative r q) * y) = p * q = f`.
- Therefore, `p^2` divides `f`.

### Mathematical insight
This theorem states that if a prime polynomial divides both a polynomial and its derivative, then the square of the prime polynomial divides the original polynomial. This is analogous to the statement in number theory that if a prime number `p` divides a number `n` and also divides the derivative of `n`, then `p^2` divides `n`.

### Dependencies
- `ring_divides`
- `x_poly_use`
- `x_derivative_mul`
- `coprime_prime_derivative`
- `PID_x_poly_field`
- `PID_IMP_BEZOUT_RING`
- `x_derivative_polynomial`

### Porting notes (optional)
The proof relies heavily on the properties of polynomial rings over fields and the existence of derivatives. The key steps involve Bézout's identity. Ensure that the target proof assistant has sufficient support for polynomial rings, derivatives, and Bézout's identity in PID.


---

## poly_divides_product

### Name of formal statement
poly_divides_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_divides_product = prove(`
  !(r:R ring) p (f:X->(1->num)->R) S t.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (f s)) ==>
  t IN S ==>
  ring_divides(x_poly r) p (f t) ==>
  ring_divides(x_poly r) p (poly_product r S f)
`,
  intro THEN
  have `FINITE (S DELETE (t:X))` [FINITE_DELETE] THEN
  specialize[`r:R ring`;`f:X->(1->num)->R`;`S DELETE (t:X)`;`t:X`]poly_product_insert THEN
  set_fact `(t:X) IN S ==> t INSERT (S DELETE t) = S` THEN
  have `ring_powerseries(r:R ring) (f(t:X):(1->num)->R)` [ring_polynomial] THEN
  set_fact `~(t:X IN (S DELETE t))` THEN
  have `poly_product(r:R ring) S f = poly_mul r (f(t:X)) (poly_product r (S DELETE t) f)` [] THEN
  have `poly_product(r:R ring) S f = ring_mul(x_poly r) (f(t:X)) (poly_product r (S DELETE t) f)` [x_poly_use] THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial(r:R ring) (f s:(1->num)->R)` [IN_DELETE] THEN
  qed [RING_DIVIDES_RMUL;poly_product_poly;x_poly_use]
);;
```

### Informal statement
Given a ring `r` and a finite set `S` of elements of type `X`, and a function `f` from `X` to polynomials over `r`, if for all `s` in `S`, `f(s)` is a polynomial over `r`, and `t` is an element of `S`, and the polynomial `p` over `r` divides `f(t)` multiplied by the `x_poly r` polynomial, then `p` divides the product of the polynomials `f(s)` for all `s` in `S` multiplied by `x_poly r`.

### Informal sketch
The proof proceeds by induction on the size of the finite set `S`.
- First, we remove an element t from S, which results in `S DELETE t`
- We specialize to the case `S DELETE t` in the theorem `poly_product_insert`, thus relating `poly_product S f` to `poly_product (S DELETE t) f`
- Then, the statement `t IN S ==> t INSERT (S DELETE t) = S` can be proved.
- Also the statement `~(t:X IN (S DELETE t))` can be proved.
- After this, the polynomial `poly_product(r:R ring) S f ` is expressed as `poly_mul r (f(t:X)) (poly_product r (S DELETE t) f)`, then the term `poly_mul` is changed to  `ring_mul`.
- Finally, using `IN_DELETE`, `RING_DIVIDES_RMUL`, `poly_product_poly`, and `x_poly_use` finishes the proof.

### Mathematical insight
This theorem essentially states that if a polynomial `p` divides one of the factors in a product of polynomials (with `x_poly r`), then it divides the entire product (with `x_poly r`). It's a fundamental result concerning divisibility in polynomial rings.

### Dependencies
- `FINITE_DELETE`
- `poly_product_insert`
- `ring_polynomial`
- `x_poly_use`
- `RING_DIVIDES_RMUL`
- `poly_product_poly`
- `IN_DELETE`


---

## poly_divides_sum

### Name of formal statement
poly_divides_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_divides_sum = prove(`
  !(r:R ring) p (f:X->(1->num)->R) S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_divides(x_poly r) p (f s)) ==>
  ring_polynomial r p ==>
  ring_divides(x_poly r) p (poly_sum r S f)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_sum_empty;x_poly_use] THEN
    qed[RING_DIVIDES_0;x_poly_use]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `!s:X. s IN x INSERT S ==> f s IN ring_carrier(x_poly(r:R ring))` [ring_divides] THEN
    have `ring_powerseries r (f(x:X):(1->num)->R)` [x_poly_use;ring_polynomial] THEN
    simp[poly_sum_insert] THEN
    have `!s:X. s IN S ==> ring_divides(x_poly(r:R ring)) p (f s)` [] THEN
    have `ring_divides(x_poly(r:R ring)) p (f(x:X))` [] THEN
    have `ring_divides(x_poly(r:R ring)) p (poly_sum r S (f:X->(1->num)->R))` [] THEN
    qed[RING_DIVIDES_ADD;x_poly_use]
  ]
);;
```
### Informal statement
For any ring `r`, polynomial `p` over `r`, and a function `f` from a type `X` to polynomials over `r`, and any finite set `S` of type `X`, if `p` divides `f s` for all `s` in `S`, and `p` is a polynomial over `r`, then `p` divides the polynomial sum of `f s` over all `s` in `S`. More formally: For any ring `r`, any polynomial `p`, any function `f` mapping elements of type `X` to polynomials, and any set `S` of type `X`, if `S` is finite and for all `s` in `S`, the polynomial `x_poly r` divides `p * f s` and `p` is a ring polynomial over `r`, then `x_poly r` divides `p * (poly_sum r S f)`.

### Informal sketch
The proof proceeds by strong induction on the cardinality of the finite set `S`.

- Base case: If `S` is empty, then `poly_sum r S f` is 0. Since any polynomial divides 0, the result holds.
- Inductive step: Suppose the result holds for all sets of size less than the cardinality of `S`. Pick an element `x` in `S` and consider `S` as `x INSERT S'`, where `S'` is the set S with x removed. Then S' is smaller than S so the induction hypothesis can be applied.
  - By the inductive hypothesis, `p` divides `poly_sum r S' f`.
  - We also know that `p` divides `f x` by the assumption that for all `s` in `S`, `p` divides `f s`.
  - Since `poly_sum r S f = f x + poly_sum r S' f`, and `p` divides both `f x` and `poly_sum r S' f`, it follows that `p` divides their sum.
  - Therefore, `p` divides `poly_sum r S f`.

### Mathematical insight
This theorem states that if a polynomial divides each element in a finite sum of polynomials, then it divides the entire sum. This is a basic property of divisibility in polynomial rings and is essential for many polynomial-related proofs.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_sum_empty`
- `RING_DIVIDES_0`
- `poly_sum_insert`
- `RING_DIVIDES_ADD`
- `x_poly_use`
- `ring_divides`
- `ring_polynomial`
- `ring_powerseries`

### Porting notes (optional)
- The definition of `ring_divides` needs to be available.
- The inductive proof on finite sets needs to be appropriately represented in the target proof assistant, usually by induction on the cardinality of the set or on the structure of the finite set.
- Ensure that the basic operations on polynomials (addition, multiplication by polynomials) are defined.


---

## poly_divides_delta

### Name of formal statement
poly_divides_delta

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_divides_delta = prove(`
  !(r:R ring) p t (f:X->(1->num)->R) S.
  FINITE S ==>
  t IN S ==>
  ring_polynomial r (f t) ==>
  (!s:X. s IN S ==> ~(s = t) ==> ring_divides(x_poly r) p (f s)) ==>
  ring_divides(x_poly r) p (poly_sum r S f) ==>
  ring_divides(x_poly r) p (f t)
`,
  intro THEN
  have `f(t:X) IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `ring_sum(x_poly(r:R ring)) (S DELETE (t:X)) f = ring_sub(x_poly r) (ring_sum(x_poly r) S f) (f t)` [RING_SUM_DELETE] THEN
  have `!s:X. s IN S ==> ring_polynomial r (f(s:X):(1->num)->R)` [ring_divides;x_poly_use] THEN
  set_fact `!s:X. s IN S DELETE t ==> s IN S` THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial r (f(s:X):(1->num)->R)` [ring_divides;x_poly_use] THEN
  have `FINITE (S DELETE(t:X))` [FINITE_DELETE] THEN
  have `poly_sum(r:R ring) (S DELETE (t:X)) f = ring_sub(x_poly r) (ring_sum(x_poly r) S f) (f t)` [poly_sum_ring_sum_x_poly;x_poly_use] THEN
  have `poly_sum(r:R ring) (S DELETE (t:X)) f = ring_sub(x_poly r) (poly_sum r S f) (f t)` [poly_sum_ring_sum_x_poly] THEN
  have `poly_sum(r:R ring) (S DELETE(t:X)) f IN ring_carrier(x_poly(r:R ring))` [poly_sum_poly;x_poly_use] THEN
  have `poly_sum(r:R ring) (S:X->bool) f IN ring_carrier(x_poly(r:R ring))` [poly_sum_poly;x_poly_use] THEN
  specialize[`x_poly(r:R ring)`
    ;`poly_sum(r:R ring) (S DELETE(t:X)) f`
    ;`poly_sum(r:R ring) (S:X->bool) f`
    ;`f(t:X):(1->num)->R`
  ](GENL[`r:R ring`;`A:R`;`B:R`;`C:R`
  ](RING_RULE `A = ring_sub(r:R ring) B C ==> C = ring_sub r B A`)) THEN
  set_fact `!s:X. s IN S DELETE t ==> ~(s = t)` THEN
  have `!s:X. s IN S DELETE t ==> ring_divides(x_poly r) p (f(s:X):(1->num)->R)` [] THEN
  have `ring_polynomial r (p:(1->num)->R)` [ring_divides;x_poly_use] THEN
  specialize[`r:R ring`;`p:(1->num)->R`;`f:X->(1->num)->R`;`S DELETE (t:X)`]poly_divides_sum THEN
  qed[RING_DIVIDES_SUB]
);;
```

### Informal statement
Given a ring `r`, a polynomial `p`, a term `t` of type `X`, a function `f` from `X` to polynomials such that `f t` is a polynomial, and a finite set `S` of type `X`, if `t` is an element of `S`, `f t` is a polynomial, and for all `s` in `S` such that `s` is not equal to `t`, the polynomial `x_poly r` divides `p` divides `f(s)`, then `x_poly r` divides `p` divides to polynomial `poly_sum r S f`, then `x_poly r` divides `p` divides `f t`.

### Informal sketch
The proof proceeds as follows:
- Assume `FINITE S`, `t IN S`, `ring_polynomial r (f t)`, and `!s:X. s IN S ==> ~(s = t) ==> ring_divides(x_poly r) p (f s)`.
- Show `ring_divides(x_poly r) p (poly_sum r S f)` implies `ring_divides(x_poly r) p (f t)`.
- Use `RING_SUM_DELETE` to rewrite `ring_sum r S f` as `ring_sum r (S DELETE t) f + f t`. Since `S` is finite, `S DELETE t `is finite, and one can use the hypothesis that all members except `t` are divisible by `x_poly(r)` apply `poly_divides_sum` to conclude that `x_poly(r) | ring_sum(S DELETE t) f`.
- We wish to prove `ring_divides p (f t)`. Using `RING_RULE` to rewrite the hypothesis to `f t = ring_sub (ring_sum S f) (ring_sum (S DELETE t) f)`. Since `x_poly r` divides both `ring_sum r S f` and `ring_sum r (S DELETE t) f`, apply `RING_DIVIDES_SUB` to obtain the result.
- Show `ring_divides p (f t)`.

### Mathematical insight
This theorem essentially states that if the polynomial `x_poly r` divides `p` divides the sum of a family of polynomials indexed by a finite set `S`, and `x_poly r` divides `p` divides all the polynomials in the family except possibly the one indexed by `t`, then `x_poly r` divides `p` divides the polynomial indexed by `t`. This is a form of "difference" argument where a property of a sum and all but one element implies the property holds for the remaining element.

### Dependencies
- `FINITE`
- `RING_SUM_DELETE`
- `poly_divides_sum`
- `RING_RULE`
- `RING_DIVIDES_SUB`
- `x_poly`
- `ring_polynomial`
- `ring_divides`
- `ring_sum`
- `ring_sub`
- `poly_sum`

### Porting notes (optional)
- The proof relies on rewriting the sum over `S` as a sum over `S \ {t}` plus the term `f t`, and then using the assumption that `x_poly r` divides the sum over `S`. A similar approach should be applicable in other proof assistants, assuming they have suitable libraries for finite sets and polynomial rings.


---

## coprime_product

### Name of formal statement
coprime_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coprime_product = prove(`
  !(r:R ring) p (f:X->R) S.
  FINITE S ==>
  (UFD r \/ (integral_domain r /\ bezout_ring r)) ==>
  p IN ring_carrier r ==>
  (!s:X. s IN S ==> ring_coprime r (p,f s)) ==>
  ring_coprime r (p,ring_product r S f)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  STRIP_TAC THENL [
    REPEAT DISCH_TAC THEN
    rw[RING_PRODUCT_CLAUSES] THEN
    simp[ring_coprime_1]
  ;
    REPEAT DISCH_TAC THEN
    REPEAT GEN_TAC THEN
    REPEAT DISCH_TAC THEN
    set_fact `(x:X) IN x INSERT S` THEN
    have `ring_coprime(r:R ring) (p,f(x:X))` [] THEN
    have `f(x:X) IN ring_carrier(r:R ring)` [ring_coprime] THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `!s:X. s IN S ==> ring_coprime(r:R ring) (p,f s)` [] THEN
    have `!s:X. s IN S ==> f s IN ring_carrier(r:R ring)` [ring_coprime] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    qed[RING_COPRIME_RMUL;RING_PRODUCT]
  ]
);;
```
### Informal statement
For any ring `r` with ring carrier `ring_carrier r`, any element `p` in `ring_carrier r`, and any function `f` from a type `X` to `R`, given a finite set `S` of type `X`, if `r` is a unique factorization domain (UFD) or `r` is an integral domain that is also a Bezout ring, and if for all `s` in `S`, `p` and `f s` are coprime in ring `r`, then `p` and the product of `f s` over `S` in ring `r` are coprime.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- **Base case:** If `S` is empty, then the product over `S` is the multiplicative identity `1`. Since `p` and `1` are coprime (as expressed by `ring_coprime_1`), the conclusion holds.
- **Inductive step:** Assume `S` is non-empty. Let `x` be an element of `INSERT S`. We assume (induction hypothesis) that for all subsets `S'` of `x INSERT S` such that `S'` is a proper subset of `x INSERT S`, if for all `s` in `S'`, `p` and `f s` are coprime, then `p` and the product of `f s` over `S'` are coprime.  We also have the assumptions that `p` is coprime to `f x`, and that `p` is coprime to `f s` for all `s` in `S`. We want to show that `p` is coprime to the product of `f s` over `x INSERT S`. The product over `x INSERT S` can be rewritten as `ring_product r (x INSERT S) f = ring_rmul r (f x) (ring_product r S f)`. Applying `RING_COPRIME_RMUL` and `RING_PRODUCT`, we conclude that `ring_coprime r (p, ring_product r (x INSERT S) f)` holds, completing the inductive step.

### Mathematical insight
This theorem states that if an element `p` is coprime to each element in a finite collection, then it's coprime to their product. This result is important for reasoning about divisibility and factorization in rings, especially in unique factorization domains and Bezout domains.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `RING_PRODUCT_CLAUSES`
- `ring_coprime_1`
- `RING_COPRIME_RMUL`
- `RING_PRODUCT`


---

## divides_factor_and_derivative_product

### Name of formal statement
divides_factor_and_derivative_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let divides_factor_and_derivative_product = prove(`
  !(r:R ring) S t p (f:X->(1->num)->R).
  field r ==>
  FINITE S ==>
  t IN S ==>
  ring_divides(x_poly r) p (f t) ==>
  (!s:X. s IN S DELETE t ==> ring_coprime(x_poly r) (p,f s)) ==>
  ring_divides(x_poly r) p (x_derivative r (poly_product r S f)) ==>
  ring_divides(x_poly r) p (x_derivative r (f t))
`,
  intro THEN
  subgoal `!s:X. s IN S ==> f s IN ring_carrier(x_poly(r:R ring))` THENL [
    intro THEN
    case `s = t:X` THENL [
      qed[ring_divides]
    ;
      qed[ring_coprime;IN_DELETE]
    ]
  ; pass
  ] THEN
  have `!s:X. s IN S ==> ring_polynomial r (f s:(1->num)->R)` [x_poly_use] THEN
  have `!s:X. s IN S ==> ring_powerseries r (f s:(1->num)->R)` [ring_polynomial] THEN
  specialize[`r:R ring`;`f:X->(1->num)->R`;`S:X->bool`]x_derivative_product THEN
  have `ring_divides(x_poly(r:R ring)) p (poly_sum r S (\s:X. poly_mul r (x_derivative r (f s)) (poly_product r (S DELETE s) f)))` [x_poly_use] THEN
  subgoal `!s:X. s IN S ==> ~(s = t) ==> ring_divides(x_poly(r:R ring)) p (poly_mul r (x_derivative r (f s)) (poly_product r (S DELETE s) f))` THENL [
    intro THEN
    rw[x_poly_use] THEN
    sufficesby RING_DIVIDES_LMUL THEN
    set_fact `t IN S /\ s IN S /\ ~(s = t:X) ==> t IN S DELETE s` THEN
    have `FINITE (S DELETE (s:X))` [FINITE_DELETE] THEN
    have `!u:X. u IN S DELETE s ==> ring_polynomial(r:R ring) (f u:(1->num)->R)` [IN_DELETE] THEN
    specialize[`r:R ring`;`p:(1->num)->R`;`f:X->(1->num)->R`;`S DELETE (s:X)`;`t:X`]poly_divides_product THEN
    qed[x_derivative_polynomial;x_poly_use]
  ; pass
  ] THEN
  have `FINITE (S DELETE (t:X))` [FINITE_DELETE] THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial r (f s:(1->num)->R)` [IN_DELETE] THEN
  have `ring_polynomial(r:R ring) (poly_mul r (x_derivative r (f(t:X))) (poly_product r (S DELETE t) f))` [poly_product_poly;x_derivative_polynomial;RING_POLYNOMIAL_MUL] THEN
  specialize[`r:R ring`;`p:(1->num)->R`;`t:X`;`\s:X. poly_mul(r:R ring) (x_derivative r (f s)) (poly_product r (S DELETE s) f)`;`S:X->bool`]poly_divides_delta THEN
  subgoal `ring_coprime(x_poly(r:R ring)) (p,poly_product r (S DELETE (t:X)) f)` THENL [
    have `UFD(x_poly(r:R ring)) \/ (integral_domain(x_poly r) /\ bezout_ring(x_poly r))` [PID_x_poly_field;PID_IMP_UFD] THEN
    have `p IN ring_carrier(x_poly(r:R ring))` [ring_divides] THEN
    specialize[`x_poly(r:R ring)`;`p:(1->num)->R`;`f:X->(1->num)->R`;`S DELETE (t:X)`]coprime_product THEN
    qed[poly_product_ring_product_x_poly]
  ;
    have `UFD (x_poly(r:R ring)) \/ integral_domain (x_poly r) /\ bezout_ring (x_poly r)` [PID_x_poly_field;PID_IMP_UFD] THEN
    have `x_derivative r (f(t:X)) IN ring_carrier(x_poly(r:R ring))` [x_derivative_polynomial;x_poly_use] THEN
    have `poly_product r (S DELETE (t:X)) f IN ring_carrier (x_poly(r:R ring))` [poly_product_poly;x_poly_use] THEN
    have `ring_divides (x_poly(r:R ring)) p (ring_mul (x_poly r) (x_derivative r (f(t:X))) (poly_product r (S DELETE t) f))` [x_poly_use] THEN
    have `ring_coprime (x_poly(r:R ring)) (poly_product r (S DELETE(t:X)) f,p)` [RING_COPRIME_SYM] THEN
    specialize[`x_poly(r:R ring)`;`x_derivative(r:R ring) (f(t:X))`;`poly_product(r:R ring) (S DELETE(t:X)) f`;`p:(1->num)->R`]RING_COPRIME_DIVPROD_RIGHT THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r` with field property, any finite set `S` of type `X`, any element `t` in `S`, any polynomial `p` over the ring of the `x_poly r` for which `p` divides `f t`, and for which for all `s` in `S` but not equal to `t`, `p` is coprime to `f s`, then `p` divides `x_derivative r (poly_product r S f)` (the derivative of the product of the `f s` for `s` in `S`) and `p` divides `x_derivative r (f t)` (the derivative of `f t`).

### Informal sketch
The proof proceeds by induction on the size of the set `S`.
- First, we introduce assumptions and show that each `f s` for `s` in `S` is in the ring carrier of `x_poly r`. The HOL Light proof handles the cases `s = t` and `s != t`.
- We then use `x_derivative_product` to expand the derivative of the product. This results in a sum where each term involves the derivative of one `f s` multiplied by the product of all other `f u` for `u` in `S` excluding `s`.
- The proof then considers each term in the sum.
    - We need to show that `p` divides `poly_mul r (x_derivative r (f s)) (poly_product r (S DELETE s) f)` for all `s` in `S` such that `s` is not equal to `t`. We use `ring_divides` and `RING_DIVIDES_LMUL` along with `poly_divides_product` and `x_derivative_polynomial`.
- We then address a specific term: `poly_mul r (x_derivative r (f t)) (poly_product r (S DELETE t) f)`.
    - The tactic `poly_divides_delta` is specialized. To apply this specialized version, we need to show that `ring_coprime(x_poly r) (p,poly_product r (S DELETE t) f)`. Using  `coprime_product` this is established.
    - Applying `RING_COPRIME_DIVPROD_RIGHT` completes the proof.

### Mathematical insight
This theorem relates the divisibility properties of a polynomial `p` with a product of functions and its derivative. Specifically, it shows that if `p` divides one of the factors `f t` and is coprime with the other factors, then `p` divides both the derivative of the total product and the derivative of the specific factor 'f t'. This is a useful result when dealing with factorization and root finding in polynomial rings.

### Dependencies
- `ring_divides`
- `x_poly_use`
- `x_derivative_product`
- `FINITE_DELETE`
- `IN_DELETE`
- `poly_divides_product`
- `x_derivative_polynomial`
- `poly_product_poly`
- `RING_POLYNOMIAL_MUL`
- `poly_divides_delta`
- `PID_x_poly_field`
- `PID_IMP_UFD`
- `coprime_product`
- `poly_product_ring_product_x_poly`
- `RING_COPRIME_SYM`
- `RING_COPRIME_DIVPROD_RIGHT`


---

## coprime_derivative_if_squarefree

### Name of formal statement
coprime_derivative_if_squarefree

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coprime_derivative_if_squarefree = prove(`
  !(r:R ring) f.
  field r ==>
  ring_char r = 0 ==>
  ring_polynomial r f ==>
  ~(f = poly_0 r) ==>
  ring_squarefree(x_poly r) f ==>
  ring_coprime(x_poly r) (f,x_derivative r f)
`,
  intro THEN
  have `PID (x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `integral_domain(x_poly(r:R ring))` [PID_IMP_INTEGRAL_DOMAIN] THEN
  have `f IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `~(f = ring_0(x_poly(r:R ring)))` [x_poly_use] THEN
  proven_if `ring_unit(x_poly(r:R ring)) f` [ring_coprime_if_unit;x_derivative_polynomial;x_poly_use] THEN
  have `UFD (x_poly(r:R ring))` [PID_IMP_UFD] THEN
  ASSUME_TAC(UNDISCH_ALL (ISPECL[`f:(1->num)->R`] (CONJUNCT2 (UNDISCH_ALL (fst (EQ_IMP_RULE (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL [`x_poly(r:R ring)`]UFD_EQ_PRIMEFACT_NONUNIT))))))))) THEN
  choose2 `n:num` `q:num->(1->num)->R` `1 <= n /\ (!i. 1 <= i /\ i <= n ==> ring_prime(x_poly(r:R ring)) (q i)) /\ ring_product(x_poly r) (1..n) q = f` [] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  have `!i:num. i IN (1..n) ==> q i IN ring_carrier(x_poly(r:R ring))` [ring_prime;IN_NUMSEG] THEN
  subgoal `!i j. 1 <= i /\ i <= n /\ 1 <= j /\ j <= n /\ ring_divides(x_poly(r:R ring)) (q i) (q j) /\ ~(i = j) ==> F` THENL [
    intro THEN
    have `i IN (1..n)` [IN_NUMSEG] THEN
    have `j IN (1..n)` [IN_NUMSEG] THEN
    specialize[`x_poly(r:R ring)`;`1..n`;`q:num->(1->num)->R`;`i:num`;`j:num`]square_divides_product_if_factor_divides_factor THEN
    have `ring_divides(x_poly(r:R ring)) (poly_mul r (q(i:num)) (q(i))) f` [x_poly_use] THEN
    have `q(i:num):(1->num)->R IN ring_carrier(x_poly r)` [] THEN
    have `~(ring_unit(x_poly r) (q(i:num):(1->num)->R))` [ring_prime] THEN
    have `ring_divides(x_poly r) (ring_mul(x_poly r) (q(i:num)) (q(i))) (f:(1->num)->R)` [x_poly_use] THEN
    specialize[`x_poly(r:R ring)`;`f:(1->num)->R`;`q(i:num):(1->num)->R`]not_squarefree_if_divisible_by_square THEN
    qed[]
  ; pass
  ] THEN
  simp[UFD_COPRIME] THEN
  intro THENL [
    qed[x_poly_use;x_derivative_polynomial]
  ; pass
  ] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  specialize[`x_poly(r:R ring)`;`p:(1->num)->R`;`1..n`;`q:num->(1->num)->R`]RING_PRIME_DIVIDES_PRODUCT THEN
  choose `i:num` `i IN 1..n /\ ring_divides(x_poly(r:R ring)) p (q i)` [] THEN
  have `i IN 1..n` [] THEN
  have `ring_divides(x_poly(r:R ring)) p (q(i:num))` [] THEN
  have `!i:num. i IN 1..n ==> ring_polynomial(r:R ring) (q i:(1->num)->R)` [x_poly_use] THEN
  specialize[`r:R ring`;`q:num->(1->num)->R`;`1..n`]poly_product_ring_product_x_poly THEN
  have `ring_divides(x_poly(r:R ring)) p (x_derivative r (poly_product r (1..n) q))` [] THEN
  subgoal `!j:num. j IN (1..n) DELETE i ==> ring_coprime(x_poly(r:R ring)) (p,q j)` THENL [
    intro THEN
    have `j IN (1..n)` [IN_DELETE] THEN
    have `q(j:num) IN ring_carrier(x_poly(r:R ring))` [] THEN
    specialize[`x_poly(r:R ring)`;`p:(1->num)->R`;`q(j:num):(1->num)->R`]INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME THEN
    case `ring_divides(x_poly(r:R ring)) p (q(j:num))` THENL [
      have `1 <= i /\ i <= n` [IN_NUMSEG] THEN
      have `1 <= j /\ j <= n` [IN_NUMSEG] THEN
      have `~(i = j:num)` [IN_DELETE] THEN
      have `ring_divides(x_poly(r:R ring)) (q(i:num)) (q j)` [prime_divides_prime_and;PID_IMP_UFD] THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize[`r:R ring`;`1..n`;`i:num`;`p:(1->num)->R`;`q:num->(1->num)->R`]divides_factor_and_derivative_product THEN
  have `1 <= i /\ i <= n` [IN_NUMSEG] THEN
  have `ring_prime(x_poly(r:R ring)) (q(i:num))` [] THEN
  specialize[`r:R ring`;`q(i:num):(1->num)->R`]coprime_prime_derivative THEN
  qed[ring_coprime;ring_prime]
);;
```

### Informal statement
For any ring `r` of type `R`, and any `f`, if `r` is a field, the characteristic of `r` is 0, `f` is a polynomial over `r`, `f` is not the zero polynomial over `r`, and `f` is squarefree over `r`, then `x_poly r` and the derivative of `f` are coprime over `r`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `r` is a field, the characteristic of `r` is 0, `f` is a polynomial over `r`, `f` is not the zero polynomial, and `f` is squarefree.
- Use `PID_x_poly_field` to show that `x_poly r` is a PID.
- Use `PID_IMP_INTEGRAL_DOMAIN` to show that `x_poly r` is an integral domain.
- Apply `x_poly_use` to show `f` is in the carrier of `x_poly r` and `f` is not the zero element.
- The result is proven if `f` is a unit (using `ring_coprime_if_unit`, `x_derivative_polynomial`, `x_poly_use`).
- Use `PID_IMP_UFD` to show that `x_poly r` is a UFD.
- Assume the negation of the goal, which amounts to assuming that `x_poly r` and the derivative of `f` aren't coprime. Since `x_poly r` is a UFD, there is a common prime factor `p` of `f` and the derivative of `f`. From the assumption that `f` is not a unit, `f` can be written as a product of `n` primes `q i`, where `1 <= i <= n`.
- Show that the primes `q i` are distinct. Otherwise, if there exist `i` and `j`, `1 <= i <= n`, `1 <= j <= n`, `q i | q j`, and `i != j`, then `q i^2 | f`. Then `f` is not squarefree which contradicts our hypothesis.
- Derive that a `i` and `j` where `q i = q j` exist
- Use the assumption that `p` is a common prime factor. Since `ring_prime` of `p`, there exist an `i` s.t. `p | q i`
- Thus `p | x_derivative r (poly_product r (1..n) q)`. Use `divides_factor_and_derivative_product` to show that `p | q i`.
- Use `coprime_prime_derivative` to show that `q i` and its derivative `x_derivative r (q i)` are comprime.

### Mathematical insight
The theorem states that if a polynomial `f` over a field `r` is squarefree, then `f` and its derivative are coprime. This is a fundamental result in polynomial algebra and is often used to determine whether a polynomial has repeated roots. The proof relies on the fact that a polynomial ring over a field is a unique factorization domain (UFD), which allows us to decompose the polynomial into a product of prime factors.

### Dependencies
- `PID_x_poly_field`
- `PID_IMP_INTEGRAL_DOMAIN`
- `ring_coprime_if_unit`
- `x_derivative_polynomial`
- `x_poly_use`
- `PID_IMP_UFD`
- `FINITE_NUMSEG`
- `ring_prime`
- `IN_NUMSEG`
- `square_divides_product_if_factor_divides_factor`
- `ring_unit`
- `not_squarefree_if_divisible_by_square`
- `UFD_COPRIME`
- `RING_PRIME_DIVIDES_PRODUCT`
- `poly_product_ring_product_x_poly`
- `INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME`
- `prime_divides_prime_and`
- `divides_factor_and_derivative_product`
- `coprime_prime_derivative`


---

## gcd_poly_linear_combination

### Name of formal statement
gcd_poly_linear_combination

### Type of the formal statement
theorem

### Formal Content
```ocaml
let gcd_poly_linear_combination = prove(`
  !(r:R ring) a b.
  field r ==>
  ring_polynomial r a ==>
  ring_polynomial r b ==>
  ?x y.
    ring_polynomial r x /\
    ring_polynomial r y /\
    poly_add r (poly_mul r a x) (poly_mul r b y)
      = ring_gcd(x_poly r) (a,b)
`,
  intro THEN
  have `PID(x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `bezout_ring(x_poly(r:R ring))` [PID_IMP_BEZOUT_RING] THEN
  have `a IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  have `b IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  specialize[`x_poly(r:R ring)`;`a:(1->num)->R`;`b:(1->num)->R`]BEZOUT_RING_IMP_GCD THEN
  choose2 `x:(1->num)->R` `y:(1->num)->R` `x IN ring_carrier(x_poly r) /\ y IN ring_carrier(x_poly r) /\ ring_add (x_poly r) (ring_mul (x_poly r) a x) (ring_mul (x_poly r) b y) = ring_gcd (x_poly r) (a,b):(1->num)->R` [] THEN
  witness `x:(1->num)->R` THEN
  witness `y:(1->num)->R` THEN
  have `ring_mul(x_poly(r:R ring)) a x = poly_mul r a x` [x_poly_use] THEN
  have `ring_mul(x_poly(r:R ring)) b y = poly_mul r b y` [x_poly_use] THEN
  qed[x_poly_use]
);;
```
### Informal statement
For any ring `r` that is also a field, and any polynomials `a` and `b` over `r`, there exist polynomials `x` and `y` over `r` such that `poly_add r (poly_mul r a x) (poly_mul r b y)` equals the greatest common divisor `ring_gcd(x_poly r) (a,b)`.

### Informal sketch
The proof demonstrates that for any field `r` and polynomials `a` and `b` over `r`, there exist polynomials `x` and `y` such that `a*x + b*y = gcd(a,b)`.

- It starts by introducing the assumption that `r` is a field and that `a` and `b` are polynomials.
- It uses `PID_x_poly_field` to show `x_poly r` is a principal ideal domain.
- Next, `PID_IMP_BEZOUT_RING` shows `x_poly r` is a Bezout ring.
- The proof then shows that `a` and `b` are elements of the carrier of `x_poly r` using `x_poly_use`.
- Then Bezout's identity `BEZOUT_RING_IMP_GCD` is specialized to `x_poly r`, `a`, and `b`.
- It uses `choose2` to obtain the polynomials `x` and `y` such that `a*x + b*y = gcd(a,b)`.
- Finally, it rewrites `ring_mul(x_poly r) a x` to `poly_mul r a x` and `ring_mul(x_poly r) b y` to `poly_mul r b y` using `x_poly_use` and concludes the result.

### Mathematical insight
This theorem establishes that polynomials over a field satisfy Bézout's identity, which is a fundamental result in algebra and number theory, which states that the greatest common divisor of two polynomials can be expressed as a linear combination of those polynomials. This is a key property used in many algorithms related to polynomial manipulation and factorization.

### Dependencies
- `PID_x_poly_field`
- `PID_IMP_BEZOUT_RING`
- `BEZOUT_RING_IMP_GCD`
- `x_poly_use`


---

## linear_combination_if_coprime_poly

### Name of formal statement
linear_combination_if_coprime_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let linear_combination_if_coprime_poly = prove(`
  !(r:R ring) a b.
  field r ==>
  ring_coprime(x_poly r) (a,b) ==>
  ?x y.
    ring_polynomial r x /\
    ring_polynomial r y /\
    poly_add r (poly_mul r a x) (poly_mul r b y) = poly_1 r
`,
  intro THEN
  have `PID(x_poly(r:R ring))` [PID_x_poly_field] THEN
  have `bezout_ring(x_poly(r:R ring))` [PID_IMP_BEZOUT_RING] THEN
  specialize_forward[`x_poly(r:R ring)`;`a:(1->num)->R`;`b:(1->num)->R`]BEZOUT_RING_COPRIME THEN
  choose2 `x:(1->num)->R` `y:(1->num)->R` `x IN ring_carrier(x_poly r) /\ y IN ring_carrier(x_poly r) /\ ring_add (x_poly r) (ring_mul (x_poly r) a x) (ring_mul (x_poly r) b y) = ring_1 (x_poly r):(1->num)->R` [] THEN
  witness `x:(1->num)->R` THEN
  witness `y:(1->num)->R` THEN
  have `ring_mul(x_poly(r:R ring)) a x = poly_mul r a x` [x_poly_use] THEN
  have `ring_mul(x_poly(r:R ring)) b y = poly_mul r b y` [x_poly_use] THEN
  qed[x_poly_use]
);;
```

### Informal statement
For any ring `r` that is also a field, and any polynomials `a` and `b` over `r`, if `a` and `b` are coprime in the polynomial ring over `r` (`x_poly r`), then there exist polynomials `x` and `y` over `r` such that `poly_add r (poly_mul r a x) (poly_mul r b y)` equals the polynomial `poly_1 r` (the polynomial representing 1).

### Informal sketch
- The proof starts by assuming that `r` is a field and that polynomials `a` and `b` are coprime in the polynomial ring over `r`.
- It uses the theorem `PID_x_poly_field` to establish that `x_poly r` is a principal ideal domain (PID) when `r` is a field.
- It invokes `PID_IMP_BEZOUT_RING` to deduce that `bezout_ring(x_poly r)` holds, meaning that the polynomial ring `x_poly r` satisfies the Bezout property, which states that for coprime elements, there exists a linear combination that equals 1.
- Applying `BEZOUT_RING_COPRIME` provides polynomials `x` and `y` in `ring_carrier(x_poly r)` such that `ring_add (x_poly r) (ring_mul (x_poly r) a x) (ring_mul (x_poly r) b y) = ring_1 (x_poly r)`.
- Finally, it uses `x_poly_use` (which simplifies polynomial operations in the ring `x_poly r` to the corresponding polynomial operations) to show that these `x` and `y` satisfy `poly_add r (poly_mul r a x) (poly_mul r b y) = poly_1 r`.

### Mathematical insight
This theorem is a specific instance of Bézout's identity for polynomials. Bézout's identity generally states that if two elements (in this case, polynomials) are coprime, then there exists a linear combination of those elements that equals their greatest common divisor (GCD). Here, since `a` and `b` are coprime, their GCD is 1, thus the linear combination equals 1. This is a fundamental result in polynomial algebra and is crucial for many applications, such as partial fraction decomposition and solving linear Diophantine equations over polynomials.

### Dependencies
- `PID_x_poly_field`
- `PID_IMP_BEZOUT_RING`
- `BEZOUT_RING_COPRIME`
- `x_poly_use`


---

## coprime_poly_if_linear_combination

### Name of formal statement
coprime_poly_if_linear_combination

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coprime_poly_if_linear_combination = prove(`
  !(r:R ring) a b x y.
  ring_polynomial r a ==>
  ring_polynomial r b ==>
  ring_polynomial r x ==>
  ring_polynomial r y ==>
  poly_add r (poly_mul r a x) (poly_mul r b y) = poly_1 r ==>
  ring_coprime(x_poly r) (a,b)
`,
  rw[ring_coprime] THEN
  intro THENL [
    qed[x_poly_use]
  ;
    qed[x_poly_use]
  ;
    have `ring_mul(x_poly(r:R ring)) a x = poly_mul r a x` [x_poly_use] THEN
    have `ring_mul(x_poly(r:R ring)) b y = poly_mul r b y` [x_poly_use] THEN
    have `ring_add(x_poly(r:R ring)) (ring_mul(x_poly r) a x) (ring_mul(x_poly r) b y) = ring_1(x_poly r)` [x_poly_use] THEN
    choose `u:(1->num)->R` `u IN ring_carrier(x_poly(r:R ring)) /\ a = ring_mul(x_poly r) d u` [ring_divides] THEN
    choose `v:(1->num)->R` `v IN ring_carrier(x_poly(r:R ring)) /\ b = ring_mul(x_poly r) d v` [ring_divides] THEN
    have `a IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
    have `b IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
    have `d IN ring_carrier(x_poly(r:R ring))` [ring_divides;x_poly_use] THEN
    have `u IN ring_carrier(x_poly(r:R ring))` [] THEN
    have `v IN ring_carrier(x_poly(r:R ring))` [] THEN
    have `x IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
    have `y IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
    have `a = ring_mul(x_poly(r:R ring)) d u` [x_poly_use] THEN
    have `b = ring_mul(x_poly(r:R ring)) d v` [x_poly_use] THEN
    specialize[
      `x_poly(r:R ring)`;
      `a:(1->num)->R`;
      `b:(1->num)->R`;
      `d:(1->num)->R`;
      `u:(1->num)->R`;
      `v:(1->num)->R`;
      `x:(1->num)->R`;
      `y:(1->num)->R`
      ](
      GENL[
      `r:R ring`;`a:R`;`b:R`;`d:R`;`u:R`;`v:R`;`x:R`;`y:R`
      ](
      RING_RULE `a = ring_mul(r:R ring) d u /\ b = ring_mul r d v /\ ring_add r (ring_mul r a x) (ring_mul r b y) = ring_1 r ==> ring_mul r d (ring_add r (ring_mul r u x) (ring_mul r v y)) = ring_1 r`
      )
      ) THEN
    rw[ring_unit] THEN
    intro THENL [
      qed[ring_divides]
    ;
      witness `ring_add (x_poly(r:R ring)) (ring_mul (x_poly r) u x) (ring_mul (x_poly r) v y)` THEN
      qed[x_poly_use;ring_unit;RING_ADD;RING_MUL]
    ]
  ]
);;
```
### Informal statement
For any ring `r`, if `a` and `b` are polynomials over `r`, and `x` and `y` are also polynomials over `r`, and if `a * x + b * y = 1` (where `1` is the multiplicative identity) as polynomials over `r`, then `a` and `b` are coprime in the ring `x_poly r`, which is the ring of polynomials with coefficients from underlying ring of `r`.

### Informal sketch
The proof demonstrates that if a linear combination of polynomials `a` and `b` equals 1, then `a` and `b` are coprime in the ring of polynomials over `r`. The proof proceeds as follows:

- Expand `ring_coprime` to its definition. This results in proving that if a polynomial `d` divides both `a` and `b` in the polynomial ring, then `d` must be a unit.
- Assume that `d` is a common divisor of `a` and `b`. Hence `a=d*u` and `b=d*v` for some polynomials `u` and `v`.
- Substitute `a` and `b` in `a*x + b*y = 1` and factor out `d` to get `d*(u*x + v*y) = 1`.
- This means that `d` divides `1`, hence `d` must be a unit.
- Conclude that `a` and `b` are coprime..

### Mathematical insight
This theorem establishes a sufficient condition for two polynomials to be coprime: if they have a linear combination that equals the multiplicative identity (1), then they must be coprime. This is a standard result in abstract algebra, particularly in the context of polynomial rings. The condition `a*x + b*y = 1` is often referred to as Bézout's identity, and the theorem shows that Bézout's identity implies coprimality.

### Dependencies
- `ring_coprime`
- `ring_divides`
- `ring_polynomial`
- `x_poly_use` (likely a simplification rule or conversion related to the x_poly ring construction)
- `ring_unit`
- `RING_ADD`
- `RING_MUL`

### Porting notes (optional)
- The `x_poly r` construction (the polynomials with coefficients in ring r) could require some additional setup to function correctly if it's not part of the target proof assistant's standard library.
- The frequent use of `x_poly_use` likely refers to simplification or rewriting rules specific to HOL Light's treatment of `x_poly r`. These will need to be adapted based on how polynomial rings are represented in the target system.


---

## nonzero_poly_mul

### Name of formal statement
nonzero_poly_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_poly_mul = prove(`
  !(r:R ring) p (q:(1->num)->R).
  integral_domain r ==>
  ring_powerseries r p ==>
  ring_powerseries r q ==>
  ~(p = poly_0 r) ==>
  ~(q = poly_0 r) ==>
  ~(poly_mul r p q = poly_0 r)
`,
  rw[x_series_use] THEN
  intro THEN
  have `integral_domain(x_series(r:R ring))` [INTEGRAL_DOMAIN_POWSER_RING;x_series] THEN
  qed[integral_domain]
);;
```
### Informal statement
For any ring `r` within the ring class `R`, and any `p` and `q` which are functions from natural numbers to elements of `R` (i.e. `p` and `q` are power series over `r`), if `r` is an integral domain, `p` and `q` are ring power series over `r`, `p` is not the zero power series over `r`, and `q` is not the zero power series over `r`, then the power series product of `p` and `q` over `r` is not the zero power series over `r`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using `x_series_use` which rewrites to `integral_domain(x_series(r:R ring)) ==> ring_powerseries (x_series r) p ==> ring_powerseries (x_series r) q ==> ~(p = poly_0 (x_series r)) ==> ~(q = poly_0 (x_series r)) ==> ~(poly_mul (x_series r) p q = poly_0 (x_series r))`.
- Introduce the assumptions.
- Prove `integral_domain(x_series(r:R ring))` by using `INTEGRAL_DOMAIN_POWSER_RING` and resolving with `x_series`.
- Conclude the proof by using `integral_domain`.

### Mathematical insight
This theorem states that the ring of power series over an integral domain is itself an integral domain. In particular, if two power series `p` and `q` are non-zero, then their product `poly_mul r p q` is also non-zero. This is a fundamental result when working with power series and integral domains.

### Dependencies
The proof depends on the following theorems:
- `x_series_use`
- `INTEGRAL_DOMAIN_POWSER_RING`
- `x_series`
- `integral_domain`


---

## nonzero_poly_pow

### Name of formal statement
nonzero_poly_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_poly_pow = prove(`
  !(r:R ring) (p:(1->num)->R) n.
  integral_domain r ==>
  ring_powerseries r p ==>
  ~(p = poly_0 r) ==>
  ~(poly_pow r p n = poly_0 r)
`,
  rw[x_series_use;x_series_use_pow] THEN
  intro THEN
  have `integral_domain(x_series(r:R ring))` [INTEGRAL_DOMAIN_POWSER_RING;x_series] THEN
  qed[INTEGRAL_DOMAIN_POW_EQ_0]
);;
```
### Informal statement
For any ring `r` and any power series `p` over `r` represented as a function from natural numbers to `R`, and any natural number `n`, if `r` is an integral domain, `p` is a ring powerseries, and `p` is not equal to the zero polynomial `poly_0 r`, then `poly_pow r p n` is not equal to the zero polynomial `poly_0 r`.

### Informal sketch
The proof proceeds by:
- Applying a rewriting rule based on `x_series_use` twice.
- Introducing the assumptions.
- Showing that `x_series(r:R ring)` is an integral domain using `INTEGRAL_DOMAIN_POWSER_RING` and `x_series` theorems.
- Using `INTEGRAL_DOMAIN_POW_EQ_0` to conclude the proof.

### Mathematical insight
This theorem captures the fact that if you take a non-zero polynomial in an integral domain and raise it to a non-zero power, the result is also a non-zero polynomial. This is a fundamental property used in reasoning about polynomials and power series. It relies on the critical property of integral domains that the product of non-zero elements is non-zero.

### Dependencies
- Theorems: `INTEGRAL_DOMAIN_POWSER_RING`, `INTEGRAL_DOMAIN_POW_EQ_0`
- Definitions: `x_series`, `x_series_use`, `x_series_use_pow`, `poly_0`, `poly_pow`, `integral_domain`, `ring_powerseries`


---

## nonzero_poly_product

### Name of formal statement
nonzero_poly_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_poly_product = prove(`
  !(r:R ring) S p.
  integral_domain r ==>
  FINITE S ==>
  (!s:X. s IN S ==> ~(p s = poly_0 r)) ==>
  ~(poly_product r S p = poly_0 r)
`,
  rw[poly_product] THEN
  intro THEN
  have `integral_domain(x_series(r:R ring))` [INTEGRAL_DOMAIN_POWSER_RING;x_series] THEN
  qed[INTEGRAL_DOMAIN_PRODUCT_EQ_0;x_series_use]
);;
```
### Informal statement
For any ring `r` satisfying the `integral_domain` property, and for any finite set `S`, and for any function `p` from `S` into the polynomials over `r`, if for every element `s` in `S`, `p s` is not the zero polynomial, then the product of the polynomials `p s` for `s` in `S` is not the zero polynomial.

### Informal sketch
The proof proceeds as follows:
- Rewrite the `poly_product` term using its definition.
- Introduce assumptions from the goal into the context.
- Establish that the ring of formal power series `x_series(r)` (polynomials) over an integral domain `r` is itself an integral domain using `INTEGRAL_DOMAIN_POWSER_RING`.
- Apply the theorem `INTEGRAL_DOMAIN_PRODUCT_EQ_0` to show that the product of non-zero elements in an integral domain is non-zero. This step also uses the term `x_series_use`.

### Mathematical insight
The theorem states that the product of non-zero polynomials over an integral domain is also a non-zero polynomial, provided we are taking a finite product. This is a fundamental property of integral domains and is crucial in polynomial algebra. The integral domain property ensures that there are no zero divisors, which is essential for this result to hold.

### Dependencies
- Definitions: `poly_product`
- Theorems: `INTEGRAL_DOMAIN_POWSER_RING`, `INTEGRAL_DOMAIN_PRODUCT_EQ_0`

### Porting notes (optional)
- The theorem `INTEGRAL_DOMAIN_PRODUCT_EQ_0` likely has analogs in other proof assistants, possibly under a different name. Ensure that the underlying integral domain theory is well-established before porting this theorem.
- Recreating this argument may require explicitly constructing the ring of formal power series.


---

## irred_x_minus_const

### Name of formal statement
irred_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let irred_x_minus_const = prove(`
  !(r:R ring) c.
  field r ==>
  c IN ring_carrier r ==>
  (
    ring_polynomial r (x_minus_const r c) /\
    ring_irreducible (x_poly r) (x_minus_const r c) /\
    monic r (x_minus_const r c)
  )
`,
  intro_gendisch THEN
  have `ring_polynomial(r:R ring) (x_minus_const r c)` [x_minus_const_poly] THEN
  have `poly_deg(r:R ring) (x_minus_const r c) = 1` [deg_x_minus_const;field] THEN
  have `ring_prime(x_poly(r:R ring)) (x_minus_const r c)` [prime_if_deg_1] THEN
  have `ring_irreducible(x_poly(r:R ring)) (x_minus_const r c)` [prime_iff_irreducible_over_field] THEN
  have `monic(r:R ring) (x_minus_const r c)` [monic_x_minus_const] THEN
  qed[]
);;
```
### Informal statement
For all rings `r` in the type `R ring` and all `c` such that `c` is an element of the carrier of the ring `r`, if `r` is a field, then the polynomial `x - c` over `r` is a ring polynomial, is irreducible with respect to the polynomial `x` over `r`, and is monic over `r`.

### Informal sketch
The proof proceeds by showing that `x - c` is a ring polynomial, then that its degree is 1, then that it is a prime polynomial with respect to `x_poly r` and then that it is irreducible with respect to `x_poly r`, and finally that it is monic based on established theorems and the assumption that `r` is a field.
- Introduce the assumptions using `intro_gendisch`.
- Show that `x - c` is a ring polynomial; justified by `x_minus_const_poly`.
- Show that the polynomial degree of `x - c` is 1 using `deg_x_minus_const` and the field assumption.
- Show that `x - c` is a prime polynomial, `ring_prime (x_poly r) (x_minus_const r c)`, using `prime_if_deg_1`.
- Show that `x - c` is irreducible using `prime_iff_irreducible_over_field`.
- Show that `x - c` is monic using `monic_x_minus_const`.

### Mathematical insight
This theorem states that polynomials of the form `x - c` over a field are irreducible and monic. This is a fundamental result in polynomial theory, as it establishes that linear polynomials over fields cannot be factored into non-constant polynomials of lower degree, and their leading coefficient is the ring's unit. This also highlights the relationship between prime and irreducible elements in the specific polynomial ring `r[x]`.

### Dependencies
- Definitions:
  - `x_minus_const`
  - `ring_polynomial`
  - `ring_irreducible`
  - `monic`
  - `x_poly`
  - `field`
  - `ring_carrier`
- Theorems:
  - `x_minus_const_poly`
  - `deg_x_minus_const`
  - `prime_if_deg_1`
  - `prime_iff_irreducible_over_field`
  - `monic_x_minus_const`


---

## monic_factorization

### Name of formal statement
monic_factorization

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_factorization = prove(`
  !(r:R ring) f.
  field r ==>
  ring_polynomial r f ==>
  monic r f ==>
  ?n p. (
    (!i. i IN (1..n) ==> ring_polynomial r (p i)) /\
    (!i. i IN (1..n) ==> monic r (p i)) /\
    (!i. i IN (1..n) ==> ring_irreducible(x_poly r) (p i)) /\
    poly_product r (1..n) p = f
  )
`,
  intro THEN
  have `UFD(x_poly(r:R ring))` [UFD_x_poly_field] THEN
  case `poly_deg r (f:(1->num)->R) = 0` THENL [
    witness `0:num` THEN
    witness `\i:num. poly_0 r:(1->num)->R` THEN
    have `!i. ~(i IN 1..0)` [IN_NUMSEG;ARITH_RULE `~(1 <= i /\ i <= 0)`] THEN
    set_fact `(!i. ~(i IN 1..0)) ==> 1..0 = {}` THEN
    simp[poly_product_empty] THEN
    qed[poly_1_if_monic_deg_0]
  ; pass
  ] THEN
  have `~(f = poly_0(r:R ring):(1->num)->R)`  [monic_poly_0;field] THEN
  have `~(f = ring_0(x_poly(r:R ring)))`  [x_poly_use] THEN
  have `~(ring_unit(x_poly(r:R ring)) f)` [deg_0_if_unit] THEN
  have `f IN ring_carrier(x_poly(r:R ring))` [x_poly_use] THEN
  ASSUME_TAC(UNDISCH_ALL (ISPECL[`f:(1->num)->R`] (CONJUNCT2 (UNDISCH_ALL (fst (EQ_IMP_RULE (UNDISCH_ALL (REWRITE_RULE [IMP_CONJ] (ISPECL [`x_poly(r:R ring)`]UFD_EQ_PRIMEFACT_NONUNIT))))))))) THEN
  choose2 `n:num` `p:num->((1->num)->R)` `1 <= n /\ (!i. 1 <= i ==> i <= n ==> ring_prime (x_poly r) (p i)) /\ ring_product (x_poly r) (1..n) p = f:(1->num)->R` [] THEN
  witness `n:num` THEN
  def `q:num->(1->num)->R` `\i:num. @qi. ring_polynomial(r:R ring) qi /\ monic r qi /\ ring_associates(x_poly r) (p i) qi` THEN
  witness `q:num->(1->num)->R` THEN
  subgoal `!i. i IN 1..n ==> ring_polynomial (r:R ring) (q i) /\ monic r (q i) /\ ring_associates(x_poly r) (p i) (q i)` THENL [
    rw[IN_NUMSEG] THEN
    intro THEN
    have `p(i:num) IN ring_carrier(x_poly(r:R ring))` [ring_prime] THEN
    have `ring_polynomial r (p(i:num):(1->num)->R)` [x_poly_use] THEN
    have `~(p(i:num):((1->num)->R) = poly_0 r)` [ring_prime;x_poly_use] THEN
    specialize[
      `r:R ring`;
      `p(i:num):(1->num)->R`
    ]x_poly_field_monic_associate THEN
    qed[]
  ; pass
  ] THEN
  have `!i. i IN 1..n ==> ring_prime(x_poly(r:R ring)) (q i)` [RING_ASSOCIATES_PRIME;IN_NUMSEG] THEN
  specialize_assuming[
    `x_poly(r:R ring)`;
    `1..n`;
    `p:num->(1->num)->R`;
    `q:num->(1->num)->R`
  ]RING_ASSOCIATES_PRODUCT THEN
  have `FINITE(1..n)` [FINITE_NUMSEG] THEN
  have `ring_associates(x_poly(r:R ring)) (ring_product(x_poly r) (1..n) p) (ring_product(x_poly r) (1..n) q)` [] THEN
  have `ring_associates(x_poly(r:R ring)) f (ring_product(x_poly r) (1..n) q)` [FINITE_NUMSEG] THEN
  have `ring_product(x_poly r) (1..n) q = poly_product(r:R ring) (1..n) q` [poly_product_ring_product_x_poly] THEN
  specialize_assuming[
    `r:R ring`;
    `q:num->(1->num)->R`;
    `1..n`
  ]monic_poly_product THEN
  have `monic(r:R ring) (poly_product r (1..n) q)` [] THEN
  have `ring_associates(x_poly(r:R ring)) f (poly_product r (1..n) q)` [] THEN
  specialize_assuming[
    `r:R ring`;
    `f:(1->num)->R`;
    `(poly_product r (1..n) q):(1->num)->R`
  ]monic_associates THEN
  qed[prime_iff_irreducible_over_field]
);;
```

### Informal statement
Given a ring `r` of type `R` and a polynomial `f` over `r`, if `r` is a field, `f` is a ring polynomial, and `f` is monic, then there exist a natural number `n` and a function `p` from `1..n` to ring polynomials over `r` such that:
1. For all `i` in the range `1..n`, `p i` is a ring polynomial over `r`.
2. For all `i` in the range `1..n`, `p i` is monic.
3. For all `i` in the range `1..n`, `p i` is ring irreducible with respect to `x_poly r` (the polynomial ring over `r`).
4. The product of the polynomials `p i` from `i = 1` to `n` (using `poly_product`) is equal to `f`.

### Informal sketch
The proof proceeds as follows:
- Start with assumptions that `r` is a field, `f` is a ring polynomial over `r`, and `f` is monic.
- Utilize the fact that `UFD(x_poly r)` (the polynomial ring over the field `r`) is a unique factorization domain, based on `UFD_x_poly_field`.
- Case split on whether the degree of `f` is 0.
  - If `poly_deg r f = 0`, choose `n = 0` and `p i` as the zero polynomial for all `i`. Then, show that the product from 1 to 0 is 1, and use `poly_1_if_monic_deg_0` to show it equals to `f`.
  - If `poly_deg r f != 0`, use the assumption that `f` is monic and the field property to derive `~(f = poly_0 r)`. Also establish that `f` is not a unit in the polynomial ring.
- Apply the theorem `UFD_EQ_PRIMEFACT_NONUNIT` to factorize `f` into irreducible elements of the polynomial ring `x_poly r`. This gives `n` and `p` such that `1 <= n`, each `p i` is a ring prime in `x_poly r`, and their product is `f`.
- Define `q i` to be a monic polynomial that is associated with `p i` in `x_poly r` using a choice function.
- Show that each `q i` is a ring polynomial and monic, and that it is an associate of `p i`. This uses the theorem `x_poly_field_monic_associate`.
- Prove that each `q i` is ring prime in `x_poly r` using `RING_ASSOCIATES_PRIME`.
- Apply `RING_ASSOCIATES_PRODUCT` to rewrite the product of `p i` as the product of `q i`, keeping the polynomials associates.
- Use `poly_product_ring_product_x_poly` to show that the `ring_product` of `q` is equal to the `poly_product` of `q`.
- Apply `monic_poly_product` to show the product of monic polynomial is monic.
- Use `monic_associates` to conclude `f` is the product of `q i`, which are irreducible and monic.
- Finally, apply `prime_iff_irreducible_over_field` to prove that each `q i` is ring irreducible.

### Mathematical insight
The theorem `monic_factorization` establishes the existence of a factorization of a monic polynomial over a field into a product of monic irreducible polynomials. This is a fundamental result in polynomial ring theory. It follows from the fact that polynomial rings over fields are unique factorization domains (UFDs). The key idea is to leverage the UFD property to obtain a factorization into irreducible elements, and then to normalize these irreducible factors to be monic by choosing appropriate associates.

### Dependencies
- Theorems:
  - `UFD_x_poly_field`
  - `monic_poly_0`
  - `deg_0_if_unit`
  - `prime_iff_irreducible_over_field`
  - `RING_ASSOCIATES_PRIME`
  - `RING_ASSOCIATES_PRODUCT`
  - `monic_poly_product`
  - `monic_associates`
- Definitions:
  - `x_poly`
  - `ring_polynomial`
  - `monic`
  - `ring_irreducible`
  - `poly_product`
  - `UFD`
  - `poly_0`
  - `ring_0`
  - `ring_unit`
  - `ring_carrier`
  - `ring_prime`
  - `ring_product`
  - `field`

### Porting notes (optional)
- The most complex part is likely the reliance on `UFD` which various proof assistants may have different ways of expressing.
- HOL Light's automation (e.g., `prove`, `THENL`, `specialize_assuming`) is used heavily in the proof search. Recreating this level of automation may need significant effort depending on the capabilities of the target proof assistant.
- The use of choice functions (`@qi`) may require care in systems with different foundations.


---

## monic_factorization_exponents

### Name of formal statement
monic_factorization_exponents

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_factorization_exponents = prove(`
  !(r:R ring) f.
  field r ==>
  ring_polynomial r f ==>
  monic r f ==>
  ?P e. (
    FINITE P /\
    (!p. p IN P ==> ring_polynomial r p) /\
    (!p. p IN P ==> monic r p) /\
    (!p. p IN P ==> ring_irreducible(x_poly r) p) /\
    (!p. p IN P ==> ~(e p = 0)) /\
    poly_product r P (\p. poly_pow r p (e p)) = f
  )
`,
  intro THEN
  choose2 `n:num` `q:num->(1->num)->R` `(!i. i IN 1..n ==> ring_polynomial(r:R ring) (q i)) /\ (!i. i IN 1..n ==> monic r (q i)) /\ (!i. i IN 1..n ==> ring_irreducible (x_poly r) (q i)) /\ poly_product r (1..n) q = f` [monic_factorization] THEN
  def `P:((1->num)->R)->bool` `IMAGE q (1..n):((1->num)->R)->bool` THEN
  def `e:((1->num)->R)->num` `\p:(1->num)->R. CARD({i | i IN 1..n /\ q i = p})` THEN
  witness `P:((1->num)->R)->bool` THEN
  witness `e:((1->num)->R)->num` THEN
  have `FINITE(1..n)` [FINITE_NUMSEG] THEN
  intro THENL [
    qed[FINITE_IMAGE]
  ;
    choose `i:num` `p:(1->num)->R = q i /\ i IN 1..n` [IN_IMAGE] THEN
    qed[]
  ;
    choose `i:num` `p:(1->num)->R = q i /\ i IN 1..n` [IN_IMAGE] THEN
    qed[]
  ;
    choose `i:num` `p:(1->num)->R = q i /\ i IN 1..n` [IN_IMAGE] THEN
    qed[]
  ;
    specialize[
      `1..n`;
      `\i:num. q i = p:(1->num)->R`
    ]FINITE_RESTRICT THEN
    have `{i | i IN 1..n /\ q i = p:(1->num)->R} = {}` [CARD_EQ_0] THEN
    choose `i:num` `p:(1->num)->R = q i /\ i IN 1..n` [IN_IMAGE] THEN
    havetac `i IN {i | i IN 1..n /\ q i = p:(1->num)->R}` (simp[IN_ELIM_THM]) THEN
    have `i:num IN {}` [] THEN
    set_fact `~(i:num IN {})` THEN
    qed[]
  ;
    have `ring_product(x_poly(r:R ring)) (1..n) q = f` [poly_product_ring_product_x_poly] THEN
    specialize[
      `x_poly(r:R ring)`;
      `q:num->(1->num)->R`;
      `q:num->(1->num)->R`;
      `1..n`
    ]RING_PRODUCT_IMAGE_GEN THEN
    have `f = ring_product (x_poly(r:R ring)) (IMAGE q (1..n)) (\y. ring_product (x_poly r) {x | x IN 1..n /\ q x = y} q)` [] THEN
    subgoal `ring_product (x_poly(r:R ring)) (IMAGE q (1..n)) (\y. ring_product (x_poly r) {x | x IN 1..n /\ q x = y} q) = ring_product (x_poly r) (IMAGE q (1..n)) (\p. ring_pow(x_poly r) p (e p))` THENL [
      sufficesby RING_PRODUCT_EQ THEN
      rw[IN_IMAGE;BETA_THM] THEN
      intro THEN
      subgoal `ring_product (x_poly(r:R ring)) {x | x IN 1..n /\ q x = a} q = ring_product (x_poly r) {x | x IN 1..n /\ q x = a} (\x. a)` THENL [
        sufficesby RING_PRODUCT_EQ THEN
        rw[BETA_THM;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      simp[] THEN
      set_fact `{x' | x' IN 1..n /\ q x' = q x:(1->num)->R} SUBSET 1..n` THEN
      have `FINITE {x' | x' IN 1..n /\ q x' = q x:(1->num)->R}` [FINITE_SUBSET] THEN
      have `q(x:num):(1->num)->R IN ring_carrier(x_poly r)` [x_poly_use] THEN
      simp[ring_product_const]
    ; pass
    ] THEN
    have `f = ring_product (x_poly(r:R ring)) (IMAGE q (1..n)) (\p. ring_pow (x_poly r) p (e p))` [] THEN
    rw[x_poly_use_pow] THEN
    subgoal `!p:(1->num)->R. p IN P ==> ring_polynomial r (ring_pow (x_poly r) p (e p))` THENL [
      intro THEN
      rw[GSYM x_poly_use_pow] THEN
      sufficesby poly_pow_poly THEN
      choose `i:num` `p:(1->num)->R = q i /\ i IN 1..n` [IN_IMAGE] THEN
      qed[]
    ; pass
    ] THEN
    have `FINITE(P:((1->num)->R)->bool)` [FINITE_IMAGE] THEN
    specialize[
      `r:R ring`;
      `\p:(1->num)->R. ring_pow (x_poly r) p (e p)`;
      `P:((1->num)->R)->bool`
    ]poly_product_ring_product_x_poly THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r` of type `R` such that `r` is a field, and for any polynomial `f` over `r` such that `f` is a ring polynomial and `f` is monic, there exist a finite set `P` of polynomials over `r` and a function `e` from polynomials over `r` to natural numbers such that:
- `P` is a finite set.
- Every element `p` of `P` is a ring polynomial over `r`.
- Every element `p` of `P` is monic over `r`.
- Every element `p` of `P` is ring irreducible (with respect to `x_poly r`).
- For every element `p` of `P`, `e(p)` is not equal to 0.
- The product of polynomials `p` raised to the power of `e(p)` over the set `P` equals `f`.

### Informal sketch
The proof proceeds as follows:
- Assume that `r` is a field, `f` is a ring polynomial, and `f` is monic.
- Apply the theorem `monic_factorization` to obtain a natural number `n`, a function `q` from `1..n` to polynomials over `r`, such that all `q i` are ring polynomials, monic, ring irreducible (w.r.t. `x_poly r`), and `poly_product r (1..n) q = f`.
- Define `P` to be the image of `q` over the set `1..n`.
- Define `e` to be a function that maps a polynomial `p` to the cardinality of the set of indices `i` in `1..n` such that `q i = p`.
- Witness `P` and `e` in the existential quantifier.
- Prove `FINITE P` using `FINITE_IMAGE` and `FINITE_NUMSEG`.
- Prove `!p. p IN P ==> ring_polynomial r p`, `!p. p IN P ==> monic r p`, and `!p. p IN P ==> ring_irreducible(x_poly r) p` by choosing an `i` such that `p = q i /\ i IN 1..n` and leveraging the properties of `q`.
- To prove `!p. p IN P ==> ~(e p = 0)`, assume `p IN P`. By contradiction, assume `e p = 0`, meaning `CARD {i | i IN 1..n /\ q i = p} = 0`. Choose an `i` such that `p = q i /\ i IN 1..n`. Then i is in the set `{i | i IN 1..n /\ q i = p}`, but that set is empty, leading to a contradiction.
- To prove `poly_product r P (\p. poly_pow r p (e p)) = f`, we first show that `ring_product (x_poly(r:R ring)) (1..n) q = f` using `poly_product_ring_product_x_poly`. Then using `RING_PRODUCT_IMAGE_GEN` we derive the equation `f = ring_product (x_poly(r:R ring)) (IMAGE q (1..n)) (\y. ring_product (x_poly r) {x | x IN 1..n /\ q x = y} q)`. Using `RING_PRODUCT_EQ` and `ring_product_const` we rewrite the latter ring product as `ring_product (x_poly(r:R ring)) (IMAGE q (1..n)) (\p. ring_pow(x_poly r) p (e p))`. Then using `poly_product_ring_product_x_poly` we obtain the equation `poly_product r P (\p. poly_pow r p (e p)) = f`.

### Mathematical insight
This theorem states that any monic polynomial over a field can be factored uniquely into a product of monic irreducible polynomials, each raised to a certain power. The set `P` represents the set of distinct monic irreducible factors, and `e(p)` represents the exponent of the factor `p` in the factorization. This is a fundamental result in polynomial algebra, essential for understanding the structure of polynomials over fields.

### Dependencies
- `FINITE_NUMSEG`
- `IN_IMAGE`
- `FINITE_IMAGE`
- `CARD_EQ_0`
- `IN_ELIM_THM`
- `poly_product_ring_product_x_poly`
- `RING_PRODUCT_IMAGE_GEN`
- `RING_PRODUCT_EQ`
- `BETA_THM`
- `FINITE_SUBSET`
- `x_poly_use`
- `ring_product_const`
- `x_poly_use_pow`
- `poly_pow_poly`
- `monic_factorization`

### Porting notes (optional)
- The theorem relies heavily on the correspondence between `poly_product` and `ring_product`. Ensure similar theorems relating polynomial products to ring products exist in the target proof assistant.
- The tactic `choose` is used multiple times. In other proof assistants, this may correspond to applying an existential elimination rule.


---

## x_truncreverse

### Name of formal statement
- x_truncreverse

### Type of the formal statement
- new_definition

### Formal Content
- The full HOL Light statement will be inserted here **after generation**.
```ocaml
let x_truncreverse = new_definition `
  x_truncreverse (r:R ring) n (p:(1->num)->R)
  = \m. if m one <= n then p (\v. n - m one) else ring_0 r
`;;
```

### Informal statement
- For any ring `r`, natural number `n`, and function `p` from functions of type `(1->num)->R` to `R`, the polynomial `x_truncreverse r n p` is defined as the function that maps `m` to `p (\v. n - m one)` if `m` is less than or equal to `n`, and to the ring zero `ring_0 r` otherwise. In other words, `x_truncreverse r n p m = if m one <= n then p (\v. n - m one) else ring_0 r`.

### Informal sketch
- The definition introduces `x_truncreverse`, which reverses a polynomial by truncating at a given degree `n`.
- The polynomial `x_truncreverse r n p` is defined piecewise.
- If `m` (the index) is within the range [0, `n`], the coefficient is obtained by evaluating `p` with an argument that reverses the index relative to `n`. Namely, it uses `lambda v. n - m one`.
- If `m` exceeds `n`, the coefficient is set to zero (`ring_0 r`).

### Mathematical insight
- This definition provides a way to reverse the order of coefficients in a polynomial up to a given degree. The reversal is achieved by using `n - m one` as the argument to the original coefficient function `p`. The truncation provides a clean way to handle polynomials with differing degrees, effectively padding with zeros. This construction is common when dealing with polynomial arithmetic and transformations.

### Dependencies
- `ring`
- `ring_0`


---

## coeff_x_truncreverse

### Name of formal statement
coeff_x_truncreverse

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_x_truncreverse = prove(`
  !(r:R ring) n p d.
  coeff d (x_truncreverse r n p)
  = if d <= n then coeff (n - d) p else ring_0 r
`,
  rw[x_truncreverse;coeff;x_monomial]
);;
```
### Informal statement
For any ring `r`, any natural number `n`, any polynomial `p` over the ring `r`, and any natural number `d`, the coefficient of the `d`-th power of the variable `x` in the truncated reverse of `p` of length `n` is equal to the coefficient of the `(n - d)`-th power of the variable `x` in `p` if `d` is less than or equal to `n`, and is equal to the ring zero otherwise.

### Informal sketch
The proof proceeds by rewriting using the definitions of `x_truncreverse`, `coeff`, and `x_monomial`.
- The definition of `x_truncreverse` expands the truncated reverse of a polynomial.
- The definition of `coeff` extracts the coefficients of a polynomial.
- The definition of `x_monomial` defines a monomial term `a * x pow n`.
- The result follows from these simplifications, with the conditional expression arising naturally.

### Mathematical insight
The theorem describes how the coefficients of a polynomial are rearranged when the polynomial is reversed and truncated. The truncated reverse `x_truncreverse r n p` takes a polynomial `p`, reverses the order of its coefficients, and truncates the result to length `n`. The theorem `coeff_x_truncreverse` then specifies which coefficient of the original polynomial `p` corresponds to a given coefficient in the truncated and reversed polynomial. This result clarifies the relationship between polynomial coefficients under reversal and truncation, which is useful in various polynomial manipulations.

### Dependencies
- Definition: `x_truncreverse`
- Definition: `coeff`
- Definition: `x_monomial`


---

## x_truncreverse_series

### Name of formal statement
x_truncreverse_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_series = prove(`
  !(r:R ring) n p.
  ring_powerseries r p ==>
  ring_powerseries r (x_truncreverse r n p)
`,
  rw[coeff_series_in_ring] THEN
  rw[coeff_x_truncreverse] THEN
  qed[RING_0]
);;
```
### Informal statement
For any ring `r`, any natural number `n`, and any formal power series `p` over `r`, if `p` is a ring power series, then `x_truncreverse r n p` is also a ring power series.
Here, `x_truncreverse r n p` denotes the truncation (at `n`) of the formal power series obtained by reversing the coefficients of `p`.

### Informal sketch
The proof shows that if `p` is a ring power series, then `x_truncreverse r n p` is also a ring power series.
- The proof proceeds by rewriting using `coeff_series_in_ring` to express the ring power series property in terms of its coefficients.
- Next, it rewrites using `coeff_x_truncreverse` to express the coefficients of `x_truncreverse r n p`.
- Finally, it concludes using the simplifier `RING_0`, likely indicating that under the hypotheses and after the rewrites, the goal simplifies to a trivial statement about ring arithmetic (e.g., 0 = 0 or an obvious equality).

### Mathematical insight
The theorem states that truncating and reversing a formal power series preserves the ring power series property. This is significant because it demonstrates the closure of the class of ring power series under a particular transformation. Reversing and truncating power series often arises when manipulating functional equations or solving for coefficients in power series representations of functions.

### Dependencies
- `coeff_series_in_ring`
- `coeff_x_truncreverse`
- `ring_powerseries`


---

## x_truncreverse_poly

### Name of formal statement
x_truncreverse_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly = prove(`
  !(r:R ring) n p.
  ring_powerseries r p ==>
  ring_polynomial r (x_truncreverse r n p)
`,
  intro THEN
  have `ring_powerseries(r:R ring) (x_truncreverse r n p)` [x_truncreverse_series] THEN
  have `!d. ~(coeff d (x_truncreverse r n p) = ring_0(r:R ring)) ==> d <= n` [coeff_x_truncreverse] THEN
  qed[polynomial_if_coeff]
);;
```
### Informal statement
For any ring `r` and any natural number `n`, if `p` is a ring power series over `r`, then `x_truncreverse r n p` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a ring powerseries over the ring `r`.
- Show that `x_truncreverse r n p` is a ring powerseries over `r` using the theorem `x_truncreverse_series`.
- Show that if the coefficient of `d` in `x_truncreverse r n p` is not zero, then `d` is less than or equal to `n`. This uses the theorem `coeff_x_truncreverse`.
- Conclude that `x_truncreverse r n p` is a polynomial over the ring `r` using `polynomial_if_coeff`. This theorem states that a ring power series is a ring polynomial if all but finitely many of its coefficients are zero.

### Mathematical insight
The theorem states that truncating and reversing a power series results in a polynomial. This is a crucial property when working with power series and polynomials, as it allows us to move between these two structures. Truncating a power series ensures that only a finite number of terms are considered, hence forming a polynomial. This result can be used to approximate power series with polynomials.

### Dependencies
- Theorems:
  - `x_truncreverse_series`
  - `coeff_x_truncreverse`
  - `polynomial_if_coeff`


---

## deg_x_truncreverse_le

### Name of formal statement
deg_x_truncreverse_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_x_truncreverse_le = prove(`
  !(r:R ring) n p.
  ring_powerseries r p ==>
  poly_deg r (x_truncreverse r n p) <= n
`,
  intro THEN
  have `ring_powerseries(r:R ring) (x_truncreverse r n p)` [x_truncreverse_series] THEN
  have `!d. ~(coeff d (x_truncreverse r n p) = ring_0(r:R ring)) ==> d <= n` [coeff_x_truncreverse] THEN
  qed[deg_le_coeff]
);;
```
### Informal statement
For any ring `r` and any powerseries `p` over `r`, if `p` is a ring powerseries, then the degree of `x_truncreverse r n p` is less than or equal to `n`.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is a ring powerseries over `r`.
- Show that `x_truncreverse r n p` is a ring powerseries. This uses the theorem `x_truncreverse_series`.
- Show that if a coefficient of `x_truncreverse r n p` is not equal to the zero element of the ring `r`, then its index `d` must be less than or equal to `n`. This uses the theorem `coeff_x_truncreverse`.
- The result then follows using the theorem `deg_le_coeff`, which states that the degree of a powerseries is less than or equal to `n` if all coefficients with index greater than `n` are zero.

### Mathematical insight
This theorem establishes an upper bound on the degree of the truncated reverse of a polynomial. The `x_truncreverse` operation effectively reverses the order of the first `n+1` coefficients of a power series. The theorem states that the degree of the resulting series is no more than `n`. This is a fundamental property used in reasoning about polynomial approximations and manipulations of power series.

### Dependencies
- Definitions: `ring_powerseries`, `x_truncreverse`, `poly_deg`, `ring_0`, `coeff`
- Theorems: `x_truncreverse_series`, `coeff_x_truncreverse`, `deg_le_coeff`


---

## x_truncreverse_poly_add

### Name of formal statement
x_truncreverse_poly_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly_add = prove(`
  !(r:R ring) n p q.
  x_truncreverse r n (poly_add r p q)
  = poly_add r (x_truncreverse r n p) (x_truncreverse r n q)
`,
  intro THEN
  sufficesby eq_coeff THEN
  rw[coeff_x_truncreverse;coeff_poly_add] THEN
  qed[RING_ADD_LZERO;RING_0]
);;
```
### Informal statement
For any ring `r`, any natural number `n`, and any polynomials `p` and `q` over `r`, the `x_truncreverse` of the polynomial sum of `p` and `q` truncated to degree `n` is equal to the polynomial sum of the `x_truncreverse` of `p` truncated to degree `n` and the `x_truncreverse` of `q` truncated to degree `n`.

### Informal sketch
The proof proceeds by:
- Introducing the universally quantified variables `r`, `n`, `p`, and `q`.
- Showing that it suffices to prove that the coefficients of both sides of the equation are equal. (Uses tactic `eq_coeff`)
- Rewriting both sides of the equation using the definitions of `coeff_x_truncreverse` and `coeff_poly_add`.
- Concluding by applying the ring property that the addition of the zero element leaves the other element unchanged (`RING_ADD_LZERO`) and the ring property of `RING_0`.

### Mathematical insight
The `x_truncreverse` operation truncates a polynomial to a given degree and then reverses the order of its coefficients. This theorem states that truncating the sum of two polynomials and then reversing the coefficients is the same as truncating and reversing each polynomial individually and then adding the results. This property is useful when manipulating polynomials formally, especially when working with formal power series or when implementing polynomial arithmetic in a computer algebra system. It shows that `x_truncreverse` is a linear operation with respect to polynomial addition.

### Dependencies
- `x_truncreverse`
- `poly_add`
- `coeff_x_truncreverse`
- `coeff_poly_add`
- `RING_ADD_LZERO`
- `RING_0`


---

## x_truncreverse_poly_sub

### Name of formal statement
x_truncreverse_poly_sub

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly_sub = prove(`
  !(r:R ring) n p q.
  x_truncreverse r n (poly_sub r p q)
  = poly_sub r (x_truncreverse r n p) (x_truncreverse r n q)
`,
  intro THEN
  sufficesby eq_coeff THEN
  rw[coeff_x_truncreverse;coeff_poly_sub] THEN
  qed[RING_SUB_RZERO;RING_0]
);;
```
### Informal statement
For any ring `R`, for any natural number `n`, and for all polynomials `p` and `q` over `R`, the truncation-reversal of the polynomial difference of `p` and `q` to degree `n` is equal to the polynomial difference of the truncation-reversal of `p` to degree `n` and the truncation-reversal of `q` to degree `n`.

### Informal sketch
- The proof proceeds by induction on the coefficients.
- Introduce all the variables.
- Reduce the goal to proving the equality of coefficients of the two polynomials.
- Rewrite using the definitions of `coeff_x_truncreverse` and `coeff_poly_sub`.
- The proof is then completed using ring properties `RING_SUB_RZERO` and `RING_0`.

### Mathematical insight
This theorem states that truncation-reversal is a linear operation with respect to polynomial subtraction. This is a fundamental property when working with polynomials and their approximations or series representations. The `x_truncreverse` function effectively reverses the order of the coefficients whilst truncating the polynomial to a certain degree, which is often required when doing formal power series manipulations.

### Dependencies
- Definitions: `x_truncreverse`, `poly_sub`, `coeff_x_truncreverse`, `coeff_poly_sub`
- Theorems: `RING_SUB_RZERO`, `RING_0`


---

## x_truncreverse_poly_const

### Name of formal statement
x_truncreverse_poly_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly_const = prove(`
  !(r:R ring) n c.
  x_truncreverse r n (poly_const r c)
  = const_x_pow r c n
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_x_truncreverse] THEN
  rw[coeff_const_x_pow] THEN
  rw[coeff_poly_const] THEN
  case `d = n:num` THENL [
    num_linear_fact `n <= n:num` THEN
    num_linear_fact `n - n = 0:num` THEN
    qed[]
  ;
    num_linear_fact `~(d = n) ==> ~(d <= n) \/ ~(n - d = 0)` THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `R`, any natural number `n`, and any element `c` in `R`, the `x_truncreverse` of order `n` applied to the polynomial constant `c` is equal to the polynomial `const_x_pow` with constant `c` and power `n`.

### Informal sketch
The proof proceeds by:
- Introducing the variables `r`, `n`, and `c`.
- Reducing the goal to showing that the coefficients of the two polynomials are equal. To do this, the tactic `eq_coeff` is used.
- Introducing a variable `d` that represents the degree of any coefficient.
- Rewriting using the definitions of `coeff_x_truncreverse`, `coeff_const_x_pow`, and `coeff_poly_const` to reduce the goal to case analysis.
- Performing a case split on whether `d = n`.
  - If `d = n`, then proving `n <= n` and `n - n = 0` by linear arithmetic facts and concluding the proof.
  - If `d != n`, then proving `~(d = n) ==> ~(d <= n) \/ ~(n - d = 0)` by a linear arithmetic fact and concluding the proof.

### Mathematical insight
This theorem relates the truncation and reversal of a polynomial to the `const_x_pow` construction. Intuitively, it states that if we truncate and reverse the constant polynomial `c` up to degree `n`, we obtain the polynomial `c * x^n`. This result is likely used in manipulations of polynomials within formal algebra.

### Dependencies
- `coeff_x_truncreverse`
- `coeff_const_x_pow`
- `coeff_poly_const`


---

## x_truncreverse_0_poly_const

### Name of formal statement
x_truncreverse_0_poly_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_0_poly_const = prove(`
  !(r:R ring) c.
  x_truncreverse r 0 (poly_const r c)
  = poly_const r c
`,
  rw[x_truncreverse_poly_const;const_x_pow_0]
);;
```
### Informal statement
For all `r` which is a ring and for all `c`, `x_truncreverse r 0 (poly_const r c)` is equal to `poly_const r c`.

### Informal sketch
The proof proceeds by rewriting using the theorems `x_truncreverse_poly_const` and `const_x_pow_0`.  `x_truncreverse_poly_const` expresses the x truncation followed by reversing of a constant polynomial. `const_x_pow_0` simplifies `poly_const c * X^0` to constant polynomial `c`.

### Mathematical insight
The theorem states that if we take a constant polynomial, truncate it at level 0 with `x_truncreverse`, then we get the same constant polynomial back. This makes sense since a constant polynomial `c` has no powers of `x` other than `x^0`.  Truncating at 0 and reversing effectively does nothing.

### Dependencies
- `x_truncreverse_poly_const`
- `const_x_pow_0`


---

## x_truncreverse_poly_1

### Name of formal statement
x_truncreverse_poly_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly_1 = prove(`
  !(r:R ring) n.
  x_truncreverse r n (poly_1 r)
  = x_pow r n
`,
  rw[poly_1;x_truncreverse_poly_const;x_pow]
);;
```
### Informal statement
For all rings `r` and natural numbers `n`, `x_truncreverse r n (poly_1 r)` is equal to `x_pow r n`.

### Informal sketch
The proof uses the following rewrites:
- `poly_1`: expand `poly_1 r` which is the polynomial x.
- `x_truncreverse_poly_const`: rewrite the function `x_truncreverse` over a constant polynomial
- `x_pow`: Rewrite the exponentiation x^n

The high-level idea here is to show that truncating the reverse of the polynomial `x` (i.e., `poly_1 r`), which is just `x` itself, and then truncating it to degree `n`, results in `x` to the power of `n`.

### Mathematical insight
This theorem provides a simple relationship between the polynomial `x`, its `x_truncreverse`, and the `x_pow` function. It shows that applying `x_truncreverse` to `x` results in `x` raised to the power `n`, essentially creating a truncated power series. This is fundamental for manipulating and reasoning about polynomials in a formal setting.

### Dependencies
- Definition: `poly_1`
- Theorem: `x_truncreverse_poly_const`
- Definition: `x_pow`


---

## x_truncreverse_poly_0

### Name of formal statement
x_truncreverse_poly_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly_0 = prove(`
  !(r:R ring) n.
  x_truncreverse r n (poly_0 r)
  = poly_0 r
`,
  rw[poly_0;x_truncreverse_poly_const;const_0_x_pow]
);;
```
### Informal statement
For any ring `r` and any natural number `n`, the `x_truncreverse` of `poly_0 r` with respect to `r` and `n` is equal to `poly_0 r`.

### Informal sketch
The proof proceeds by rewriting the statement using the following equalities in sequence:
- `poly_0`: Rewrite `poly_0 r` to `:+: ( %0, poly_0 r)`.
- `x_truncreverse_poly_const`: Rewrite `x_truncreverse r n :+:(%c, p)` to `:+: ( %c, x_truncreverse r (n-1) (x *: p))`.
- `const_0_x_pow`: Rewrite `x *: poly_0 r` to `poly_0 r`.

### Mathematical insight
The `x_truncreverse` function reverses the coefficients of a polynomial, truncating at the specified degree `n`. The zero polynomial `poly_0 r` has all coefficients equal to zero. Thus, reversing and truncating it still produces a zero polynomial.

### Dependencies
- Definitions:
    - `poly_0`
    - `x_truncreverse`
- Theorems:
    - `x_truncreverse_poly_const`
    - `const_0_x_pow`


---

## x_truncreverse_poly_sum

### Name of formal statement
x_truncreverse_poly_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_poly_sum = prove(`
  !(r:R ring) n p:X->(1->num)->R S:X->bool.
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries r (p s)) ==>
  x_truncreverse r n (poly_sum r S p)
  = poly_sum r S (\s. x_truncreverse r n (p s))
`,
  rw[poly_sum] THEN
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;GSYM x_series_use;x_truncreverse_poly_0]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    have `p(x:X) IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
    have `ring_powerseries(r:R ring) (x_truncreverse r n (p(x:X)))` [x_truncreverse_series] THEN
    have `x_truncreverse r n (p(x:X)) IN ring_carrier(x_series(r:R ring))` [x_series_use] THEN
    simp[RING_SUM_CLAUSES] THEN
    simp[GSYM x_series_use] THEN
    simp[x_truncreverse_poly_add]
  ]
);;
```
### Informal statement
For any ring `r` with carrier `R`, any natural number `n`, any function `p` from type `X` to the type of formal power series over `r` (i.e., `1->num->R`), and any finite subset `S` of `X`, if for all `s` in `S`, `p s` is a formal power series, then the `x_truncreverse` of order `n` of the sum of the power series `p s` over all `s` in `S` is equal to the sum of the `x_truncreverse` of order `n` of each power series `p s` over all `s` in `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, we apply the definition of `poly_sum` on an empty set, use `x_series_use` to rewrite the `ring_powerseries` goal and then `x_truncreverse_poly_0` to solve the goal.
- Inductive step: Assume the theorem holds for all sets `S'` such that the size of `S'` is less than the size of `S`. Let `S` be `x INSERT S'`, where `x` is an element and `S'` is a set.
  - We unfold the `poly_sum` for `x INSERT S'` using `RING_SUM_CLAUSES`.
  - We need to prove that `ring_powerseries r (p x)` holds (which is assumed), and then that `ring_powerseries r (x_truncreverse r n (p x))` also holds, which follows from `x_truncreverse_series`.
  - We then apply the induction hypothesis on the set `S'` using `simp[RING_SUM_CLAUSES]`. Then, we rewrite using `x_series_use` simplication.
  - Finally, we apply `x_truncreverse_poly_add` to complete the proof.

### Mathematical insight
This result states that the truncation operator `x_truncreverse` distributes over the `poly_sum` operator, which represents the sum of power series. This is crucial for simplifying complex expressions involving sums of truncated power series and is especially useful when dealing with finite sets of power series, as it allows one to truncate each power series individually before summing them.

### Dependencies
- `poly_sum`
- `RING_SUM_CLAUSES`
- `x_series_use`
- `x_truncreverse_poly_0`
- `x_truncreverse_series`
- `x_truncreverse_poly_add`

### Porting notes (optional)
- The HOL Light tactic `FINITE_INDUCT_STRONG` performs strong induction over the finiteness of the set `S`. Most proof assistants will have similar induction schemes.
- The handling of sets and finiteness might differ in other provers (e.g., Isabelle/HOL's `finite` predicate, Coq's `Ensemble` library or similar).


---

## x_truncreverse_const_x_pow

### Name of formal statement
x_truncreverse_const_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_const_x_pow = prove(`
  !(r:R ring) n c.
  x_truncreverse r n (const_x_pow r c n)
  = poly_const r c
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_x_truncreverse] THEN
  rw[coeff_const_x_pow] THEN
  rw[coeff_poly_const] THEN
  case `d = 0:num` THENL [
    num_linear_fact `0 <= n:num` THEN
    num_linear_fact `n-0 = n:num` THEN
    qed[]
  ;
    num_linear_fact `~(d = 0) ==> ~(d <= n) \/ ~(n - d = n)` THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r` and any natural numbers `n` and `c`, the truncated reverse of the polynomial `const_x_pow r c n` is equal to the polynomial `poly_const r c`.

### Informal sketch
The proof proceeds by showing that the coefficients of `x_truncreverse r n (const_x_pow r c n)` and `poly_const r c` are equal.

- The proof starts by introducing the variables `r`, `n`, and `c`.
- It then suffices to show that the coefficients of the two polynomials are equal.
- The definition of `coeff_x_truncreverse`, `coeff_const_x_pow`, and `coeff_poly_const` are applied.
- A case split is done based on whether `d = 0` :
    - If `d = 0`, use arithmetic facts to show that we are done.
    - Otherwise, we can show that either `~(d <= n)` or `~(n - d = n)` and thus we are done.

### Mathematical insight
The theorem states that if we consider the polynomial `c * x^n`, reverse its coefficients, and then truncate it to only consider the first `n+1` terms, we obtain the constant polynomial `c`. This leverages the definition of the truncated reverse, where coefficients are reordered and potentially discarded.

### Dependencies
- Theories: `ring`, `poly`
- Definitions: `x_truncreverse`, `const_x_pow`, `poly_const`, `coeff_x_truncreverse`, `coeff_const_x_pow`, `coeff_poly_const`


---

## x_truncreverse_x_pow

### Name of formal statement
x_truncreverse_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_x_pow = prove(`
  !(r:R ring) n.
  x_truncreverse r n (x_pow r n)
  = poly_1 r
`,
  rw[x_pow;x_truncreverse_const_x_pow;poly_1]
);;
```
### Informal statement
For any ring `r` and any natural number `n`, the `x_truncreverse` of `x_pow r n` with respect to `r` and `n` is equal to `poly_1 r`.

### Informal sketch
- The proof proceeds by rewriting the expression `x_truncreverse r n (x_pow r n)` using the definitions of `x_pow` and `x_truncreverse_const_x_pow`, along with the definition of `poly_1 r`.

### Mathematical insight
This theorem shows how the polynomial `x^n` transforms under the `x_truncreverse` operation. The result is `poly_1 r`, i.e., the polynomial with coefficients `1` at the constant term and `0` elsewhere; this reflects that `x^n` has a leading term which, when reversed, only impacts the constant term.

### Dependencies
- Definitions:
  - `x_pow`
  - `x_truncreverse`
  - `poly_1`
- Theorems:
  - `x_truncreverse_const_x_pow`


---

## x_truncreverse_x_minus_const

### Name of formal statement
x_truncreverse_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_x_minus_const = prove(`
  !(r:R ring) c.
  x_truncreverse r 1 (x_minus_const r c)
  = one_minus_constx r c
`,
  intro THEN
  rw[x_minus_const;one_minus_constx] THEN
  rw[x_truncreverse_poly_sub] THEN
  rw[x_truncreverse_x_pow] THEN
  rw[x_truncreverse_poly_const] THEN
  rw[x_pow_0]
);;
```
### Informal statement
For any ring `r` and any constant `c` in `r`, the truncated reverse of `x_minus_const r c` at index 1 is equal to `one_minus_constx r c`.

### Informal sketch
The proof proceeds by:
- Introducing the universally quantified variables `r` and `c`.
- Rewriting the left-hand side using the definitions of `x_minus_const` and `one_minus_constx`.
- Rewriting using the theorem `x_truncreverse_poly_sub` to decompose the truncated reverse of the subtraction into a subtraction of truncated reverses.
- Rewriting using the theorem `x_truncreverse_x_pow` to compute the truncated reverse of `x_pow r 1`.
- Rewriting using `x_truncreverse_poly_const` to compute the truncated reverse of a constant polynomial.
- Rewriting using `x_pow_0`, which states that any ring element raised to the power 0 is equal to 1.

### Mathematical insight
This theorem connects the truncated reverse of a polynomial formed by subtracting a constant from `x` with another representation `one_minus_constx` of a related polynomial. Truncated reverses are used to analyze convergence properties of power series. The theorem essentially shows an identity that simplifies certain expressions involving these power series, which can be useful when performing algebraic manipulations or verifying convergence conditions.

### Dependencies
#### Definitions
- `x_minus_const`
- `one_minus_constx`

#### Theorems
- `x_truncreverse_poly_sub`
- `x_truncreverse_x_pow`
- `x_truncreverse_poly_const`
- `x_pow_0`


---

## x_truncreverse_one_minus_constx

### Name of formal statement
x_truncreverse_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_one_minus_constx = prove(`
  !(r:R ring) c.
  x_truncreverse r 1 (one_minus_constx r c)
  = x_minus_const r c
`,
  intro THEN
  rw[x_minus_const;one_minus_constx] THEN
  rw[x_truncreverse_poly_sub] THEN
  rw[x_pow_0] THEN
  rw[x_truncreverse_poly_1] THEN
  rw[x_truncreverse_const_x_pow]
);;
```
### Informal statement
For any ring `r` and any constant `c` in `r`, the truncation-reverse of the polynomial `one_minus_constx r c` at degree 1 is equal to the polynomial `x_minus_const r c`.

### Informal sketch
The proof proceeds by first introducing the assumptions and then rewriting using the definitions of `x_minus_const` and `one_minus_constx`. Subsequently, the proof uses the following rewrites:
- `x_truncreverse_poly_sub`: Reduction on polynomial subtraction.
- `x_pow_0`: Simplification of x to the power of 0.
- `x_truncreverse_poly_1`: Simplification of truncation reverse of a polynomial with a constant term.
- `x_truncreverse_const_x_pow`: Reduction on truncation reverse constant times x power.

### Mathematical insight
This theorem establishes a specific relationship between the truncated reverse of a polynomial of the form `1 - c*x` and the polynomial `-c*x`. It is a step in the development of results relating truncated polynomials and polynomial inverses. It shows, in particular, the behaviour of truncation reverse over simple polynomial expressions.

### Dependencies
- Definitions: `x_minus_const`, `one_minus_constx`
- Theorems: `x_truncreverse_poly_sub`, `x_pow_0`, `x_truncreverse_poly_1`, `x_truncreverse_const_x_pow`


---

## x_truncreverse_mul

### Name of formal statement
x_truncreverse_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_mul = prove(`
  !(r:R ring) m p n q.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  poly_deg r p <= m ==>
  poly_deg r q <= n ==>
  x_truncreverse r (m+n) (poly_mul r p q)
  = poly_mul r (x_truncreverse r m p) (x_truncreverse r n q)
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_poly_mul_oneindex;coeff_x_truncreverse] THEN
  have `!d. ~(coeff d p = ring_0(r:R ring)) ==> d <= m` [coeff_deg_le] THEN
  have `!d. ~(coeff d q = ring_0(r:R ring)) ==> d <= n` [coeff_deg_le] THEN
  case `m+n < d:num` THENL [
    simp[ARITH_RULE `m+n < d:num ==> ~(d <= m+n)`] THEN
    sufficesby(GSYM RING_SUM_EQ_0) THEN
    intro THEN
    case `a <= m:num` THENL [
      num_linear_fact `a <= m:num /\ m+n < d ==> ~(d-a <= n)` THEN
      qed[coeff_poly_in_ring;RING_MUL_RZERO]
    ;
      qed[coeff_poly_in_ring;RING_0;RING_MUL_LZERO]
    ]
  ; pass
  ] THEN
  simp[ARITH_RULE `~(m+n < d:num) ==> d <= m+n`] THEN
  specialize[`r:R ring`;`(m+n)-d:num`;`\a. ring_mul(r:R ring) (coeff a p) (coeff ((m + n) - d - a) q)`]ring_sum_numseg_le_reflect THEN
  specialize[`r:R ring`;`(m+n)-d:num`;`d:num`;`\a. ring_mul(r:R ring) (coeff ((m + n) - d - a) p) (coeff ((m + n) - d - ((m + n) - d - a)) q)`]ring_sum_numseg_le_offset THEN
  simp[ARITH_RULE `~(m+n < d:num) ==> (m+n)-d+d = m+n`] THEN
  num_linear_fact `m+n <= m+n+d:num` THEN
  specialize[`r:R ring`;`m+n:num`;`m+n+d:num`;`\b. if d <= b then ring_mul r (coeff ((m + n) - d - (b - d)) p) (coeff ((m + n) - d - ((m + n) - d - (b - d))) q) else ring_0(r:R ring)`]ring_sum_numseg_le_expand THEN
  specialize[`r:R ring`;`d:num`;`n:num`;`\a. ring_mul(r:R ring) (if a <= m then coeff (m - a) p else ring_0 r) (if d - a <= n then coeff (n - (d - a)) q else ring_0 r)`]ring_sum_numseg_le_offset THEN
  num_linear_fact `d+n <= m+n+d:num` THEN
  specialize[`r:R ring`;`d+n:num`;`m+n+d:num`;`\b. if n <= b then ring_mul r (if b - n <= m then coeff (m - (b - n)) p else ring_0 r) (if d - (b - n) <= n then coeff (n - (d - (b - n))) q else ring_0 r) else ring_0(r:R ring)`]ring_sum_numseg_le_expand THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  intro THEN
  case `a < n:num` THENL [
    simp[ARITH_RULE `a < n:num ==> ~(n <= a)`] THEN
    case `d <= a:num` THENL [
      simp[ARITH_RULE `a < n:num ==> a <= m+n`] THEN
      num_linear_fact `a < n:num ==> d <= a ==> ~((m+n)-d-(a-d) <= m)` THEN
      have `coeff ((m+n)-d-(a-d)) p = ring_0(r:R ring)` [] THEN
      simp[] THEN
      qed[RING_MUL_LZERO;coeff_poly_in_ring]
    ; pass
    ] THEN
    simp[] THEN
    qed[COND_ID]
  ; pass
  ] THEN
  simp[ARITH_RULE `~(a < n:num) ==> n <= a`] THEN
  case `a <= m+n:num` THENL [
    simp[ARITH_RULE `a <= m+n:num ==> a-n <= m`] THEN
    case `d <= a:num` THENL [
      simp[ARITH_RULE `~(a < n) ==> d <= a:num ==> d-(a-n) <= n`] THEN
      simp[ARITH_RULE `~(a < n) ==> d <= a:num ==> (m+n)-d-(a-d) = m-(a-n)`] THEN
      simp[ARITH_RULE `a <= m+n ==> ~(a < n) ==> d <= a:num ==> (m+n)-d-(m-(a-n)) = a-d`] THEN
      case `a <= d+n:num` THENL [
        simp[ARITH_RULE `d <= a ==> ~(a < n) ==> a <= d+n ==> a-d = n-(d-(a-n)):num`]
      ; num_linear_fact `d <= a:num ==> ~(a <= d+n) ==> ~(a-d <= n)` THEN
        have `coeff (a-d) q = ring_0(r:R ring)` [] THEN
        simp[] THEN
        qed[RING_MUL_RZERO;coeff_poly_in_ring]
      ]
    ; case `a <= d+n:num` THENL [
        simp[ARITH_RULE `~(d <= a) ==> ~(a < n) ==> ~(d-(a-n) <= n:num)`] THEN
        qed[RING_MUL_RZERO;coeff_poly_in_ring]
      ; simp[]
      ]
    ]
  ; simp[ARITH_RULE `~(a <= m+n) ==> ~(a-n <= m:num)`] THEN
    qed[RING_MUL_LZERO;coeff_poly_in_ring]
  ]
);;
```

### Informal statement
For any ring `r` and ring polynomials `p` and `q` over `r`, if the degree of `p` is at most `m` and the degree of `q` is at most `n`, then the `x_truncreverse` of the polynomial `p * q` truncated at degree `m+n` is equal to the product of the `x_truncreverse` of `p` truncated at degree `m` and the `x_truncreverse` of `q` truncated at degree `n`. Formally:

`!(r:R ring) m p n q. ring_polynomial r p ==> ring_polynomial r q ==> poly_deg r p <= m ==> poly_deg r q <= n ==> x_truncreverse r (m+n) (poly_mul r p q) = poly_mul r (x_truncreverse r m p) (x_truncreverse r n q)`

### Informal sketch
The proof proceeds by showing that the coefficients of the two polynomials being equated are equal. This is achieved by:

- Introducing the variables and hypotheses.
- Rewriting using `coeff_poly_mul_oneindex` and `coeff_x_truncreverse` to expand the definitions of polynomial multiplication and `x_truncreverse` in terms of coefficients.
- Using the facts that if a coefficient is not equal to zero, then the index is less than or equal to the degree for both polynomials `p` and `q` (using `coeff_deg_le`).
- Performing a case split on whether `m+n < d` where `d` is the index of the coefficient:
    - If `m+n < d`, then the coefficient is zero.  This involves a sub-case split on `a <= m` where `a` is the index in the summation. The proof uses `RING_SUM_EQ_0` after doing rewrite with `RING_MUL_RZERO` and `RING_MUL_LZERO`.
    - If `~(m+n < d)`, then `d <= m+n` which is simplified.
- Using `ring_sum_numseg_le_reflect` and `ring_sum_numseg_le_offset` to manipulate the summation indices.
- Expanding summations by splitting at appropriate points using `ring_sum_numseg_le_expand`.
- Simplifying and rewriting to obtain the desired equality. The proof performs a case split on `a < n:num` and `a <= m+n:num` and `d <= a:num` and `a <= d+n:num`.
- Finally, uses `RING_SUM_EQ` to finish the equality and completes the proof.

### Mathematical insight
This theorem states that truncation and reversing (via `x_truncreverse`) "distributes" over polynomial multiplication, subject to appropriate degree bounds. This is useful when working with polynomials of bounded degree, since it allows one to compute the truncated reverse of a product directly from the truncated reverses of the factors without explicitly computing the full product

### Dependencies
- `ring_polynomial`
- `poly_deg`
- `x_truncreverse`
- `poly_mul`
- `coeff_poly_mul_oneindex`
- `coeff_x_truncreverse`
- `coeff_deg_le`
- `RING_SUM_EQ_0`
- `RING_MUL_RZERO`
- `RING_MUL_LZERO`
- `ring_sum_numseg_le_reflect`
- `ring_sum_numseg_le_offset`
- `ring_sum_numseg_le_expand`
- `RING_SUM_EQ`
- `RING_0`

### Porting notes (optional)
The proof relies heavily on rewriting and arithmetic reasoning tactics. In other proof assistants, it may be necessary to guide the simplifier more explicitly with rewrite sequences and arithmetic facts. The use of `ring_sum_numseg_le_reflect`, `ring_sum_numseg_le_offset`, and `ring_sum_numseg_le_expand` suggest a need for careful manipulation of summation ranges, which might require explicit lemmas or tactics in other systems.


---

## x_truncreverse_product

### Name of formal statement
x_truncreverse_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_product = prove(`
  !(r:R ring) n p S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> poly_deg r (p s) <= (n s)) ==>
  x_truncreverse r (nsum S n) (poly_product r S p)
  = poly_product r S (\s. x_truncreverse r (n s) (p s))
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;NSUM_CLAUSES] THEN
    qed[x_truncreverse_0_poly_const;poly_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_polynomial(r:R ring) (p(x:X):(1->num)->R)` [] THEN
    have `ring_powerseries(r:R ring) (p(x:X):(1->num)->R)` [ring_polynomial] THEN
    have `ring_powerseries(r:R ring) (x_truncreverse r (n x) (p(x:X):(1->num)->R))` [x_truncreverse_series] THEN
    simp[poly_product_insert;NSUM_CLAUSES] THEN
    have `ring_polynomial(r:R ring) (poly_product r S (p:X->(1->num)->R))` [poly_product_poly] THEN
    have `poly_deg(r:R ring) (p(x:X):(1->num)->R) <= n x` [] THEN
    have `poly_deg(r:R ring) (poly_product r (S:X->bool) p) <= nsum S n` [poly_deg_product_le] THEN
    specialize[`r:R ring`;`n(x:X):num`;`p(x:X):(1->num)->R`;`nsum (S:X->bool) n`;`poly_product(r:R ring) (S:X->bool) p`]x_truncreverse_mul THEN
    qed[]
  ]
);;
```

### Informal statement
For any ring `r`, any set `S`, any functions `n` and `p` such that `S` is finite and for all `s` in `S`, `p s` is a polynomial over `r`, and for all `s` in `S`, the degree of `p s` is less than or equal to `n s`, then the `x_truncreverse` of the `nsum` of `n` over `S` applied to the product of the polynomials `p s` over `S` is equal to the product over `S` of the `x_truncreverse` of `n s` applied to `p s`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.

- Base case: If `S` is empty, then the `x_truncreverse` of 0 (since `nsum` over the empty set is 0) applied to 1 (since the product over the empty set is 1) is equal to 1 (since the product over the empty set is 1), using `x_truncreverse_0_poly_const` and `poly_1`.
- Inductive step: Assume the theorem holds for any subset of `S`. We need to show that it holds for `x INSERT S`.
  - Simplify the left-hand side of the equation using `poly_product_insert` and `NSUM_CLAUSES`.
  - We have `ring_polynomial(r:R ring) (p(x:X):(1->num)->R))` and `poly_deg(r:R ring) (p(x:X):(1->num)->R) <= n x` from the assumptions.
  - Show that `poly_product r S p` is a polynomial over `r`, using `poly_product_poly`
  - Show that the degree of `poly_product r S p` is less than or equal to `nsum S n`, using `poly_deg_product_le`.
  - Apply `x_truncreverse_mul` on polynomials to complete the proof.

### Mathematical insight
This theorem states that the truncation operation `x_truncreverse` distributes over polynomial products when the truncation degree is greater than or equal to the degree of each polynomial being multiplied.

### Dependencies
- `FINITE`
- `nsum`
- `poly_product`
- `ring_polynomial`
- `poly_deg`
- `x_truncreverse`
- `x_truncreverse_0_poly_const`
- `poly_1`
- `poly_product_empty`
- `NSUM_CLAUSES`
- `poly_product_insert`
- `poly_product_poly`
- `poly_deg_product_le`
- `x_truncreverse_mul`
- `x_truncreverse_series`


---

## x_truncreverse_pow

### Name of formal statement
x_truncreverse_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_pow = prove(`
  !(r:R ring) p d n.
  ring_polynomial r p ==>
  poly_deg r p <= d ==>
  x_truncreverse r (n*d) (poly_pow r p n)
  = poly_pow r (x_truncreverse r d p) n
`,
  intro THEN
  have `ring_powerseries r (p:(1->num)->R)` [ring_polynomial] THEN
  have `ring_powerseries r (x_truncreverse r d (p:(1->num)->R))` [x_truncreverse_series] THEN
  simp[poly_pow_is_product] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  have `CARD (1..n) = n` [CARD_NUMSEG;ARITH_RULE `(n+1)-1 = n`] THEN
  have `nsum (1..n) (\i. d) = CARD(1..n) * d` [NSUM_CONST] THEN
  have `nsum (1..n) (\i. d) = n * d` [] THEN
  have `!i. i IN 1..n ==> ring_polynomial r (p:(1->num)->R)` [] THEN
  have `!i. i IN 1..n ==> poly_deg r (p:(1->num)->R) <= d` [] THEN
  specialize[`r:R ring`;`\i:num. d:num`;`\i:num. p:(1->num)->R`;`1..n`]x_truncreverse_product THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, ring polynomial `p`, natural numbers `d` and `n`, if `p` has a degree less than or equal to `d`, then the `(n*d)`-truncation-reverse of the `n`-th power of `p` is equal to the `n`-th power of the `d`-truncation-reverse of `p`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions: `ring r`, `ring_polynomial r p`, `poly_deg r p <= d`.
- Establish that `p` is a ring power series using `ring_polynomial`.
- Establish that the `x_truncreverse` of `p` is also a ring power series using `x_truncreverse_series`.
- Simplify using that the polynomial power is the product `poly_pow_is_product`.
- Prove `FINITE (1..n)` using `FINITE_NUMSEG`.
- Prove `CARD (1..n) = n` using `CARD_NUMSEG` and arithmetic reasoning.
- Prove `nsum (1..n) (\i. d) = CARD(1..n) * d` using `NSUM_CONST`.
- Prove `nsum (1..n) (\i. d) = n * d`.
- Establish that for all `i` in the range `1..n`, `ring_polynomial r p` and `poly_deg r p <= d` by assumption.
- Specialize the theorem `x_truncreverse_product` with the relevant parameters (`r`, `\i:num. d:num`, `\i:num. p:(1->num)->R`, `1..n`).
- Conclude the proof.

### Mathematical insight
This theorem relates polynomial powers and truncation. It states that the truncation of a polynomial raised to a power is the same as raising the truncated polynomial to the same power; the truncation level of the polynomial power should be the truncation level of the polynomial times the power. This theorem provides a way to reduce computation needed in polynomial algebra.

### Dependencies
- `ring`
- `ring_polynomial`
- `x_truncreverse`
- `poly_pow`
- `poly_deg`
- `x_truncreverse_series`
- `poly_pow_is_product`
- `FINITE_NUMSEG`
- `CARD_NUMSEG`
- `NSUM_CONST`
- `x_truncreverse_product`


---

## deg_monic_vanishing_at

### Name of formal statement
deg_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_deg r (monic_vanishing_at r S c)
  = if ring_1 r = ring_0 r then 0 else CARD S
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[monic_vanishing_at_empty;POLY_DEG_1;card_empty] THEN
    ARITH_TAC
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `!s:X. s IN S ==> c s IN ring_carrier(r:R ring)` [] THEN
    simp[monic_vanishing_at_insert;card_insert] THEN
    have `c(x:X) IN ring_carrier(r:R ring)` [] THEN
    have `ring_polynomial r (x_minus_const(r:R ring) (c(x:X)))` [x_minus_const_poly] THEN
    have `ring_polynomial r (monic_vanishing_at(r:R ring) S (c:X->R))` [monic_vanishing_at_poly] THEN
    have `monic r (x_minus_const(r:R ring) (c(x:X)))` [monic_x_minus_const] THEN
    have `monic r (monic_vanishing_at(r:R ring) S (c:X->R))` [monic_vanishing_at_monic] THEN
    have `poly_deg(r:R ring) (poly_mul r (x_minus_const r (c(x:X))) (monic_vanishing_at r S c)) = poly_deg r (x_minus_const r (c x)) + poly_deg r (monic_vanishing_at r S c)` [deg_monic_poly_mul] THEN
    proven_if `ring_1 r = ring_0(r:R ring)` [deg_zero_ring;ring_polynomial;RING_POLYNOMIAL_MUL] THEN
    have `poly_deg(r:R ring) (x_minus_const r (c(x:X))) = 1` [deg_x_minus_const] THEN
    have `poly_deg(r:R ring) (monic_vanishing_at r S (c:X->R)) = CARD S` [] THEN
    qed[ARITH_RULE `C + 1 = 1 + C`]
  ]
);;
```
### Informal statement
For any ring `r` and any function `c` from a type `X` to the carrier of the ring `r`, if `S` is a finite set of type `X`, and for all `s` in `S`, `c s` is in the carrier of the ring `r`, then the degree of the polynomial `monic_vanishing_at r S c` is equal to 0 if the ring's multiplicative identity `ring_1 r` equals the ring's additive identity `ring_0 r`, and equal to the cardinality of `S` otherwise.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty. We use the definition `monic_vanishing_at_empty` and `POLY_DEG_1` and `card_empty` to show the degree of `monic_vanishing_at r S c` is 0, which is equal to the cardinality of the empty set.

- Inductive step: Assume the theorem holds for all finite subsets of `S`. We want to show it holds for `INSERT x S`. We use the definition `monic_vanishing_at_insert`, which states that `monic_vanishing_at r (INSERT x S) c = poly_mul r (x_minus_const r (c x)) (monic_vanishing_at r S c)`. We also use `card_insert` which states that `CARD (INSERT x S) = 1 + CARD S`.

  - We have: `ring_polynomial r (x_minus_const r (c x))` and `ring_polynomial r (monic_vanishing_at r S c)`.
  - We also have `monic r (x_minus_const r (c x))` and `monic r (monic_vanishing_at r S c)`.
  - Then using `deg_monic_poly_mul` we can split the degree of the product: `poly_deg r (poly_mul r (x_minus_const r (c x)) (monic_vanishing_at r S c)) = poly_deg r (x_minus_const r (c x)) + poly_deg r (monic_vanishing_at r S c)`.
  - Using `deg_zero_ring` we handle the case where `ring_1 r = ring_0 r`.
  - Since `poly_deg r (x_minus_const r (c x)) = 1` we derive `poly_deg(r:R ring) (monic_vanishing_at r S (c:X->R)) = CARD S` from the induction hypothesis.
  - Finally, we use arithmetic to show that `1 + CARD S = CARD (INSERT x S)`.

### Mathematical insight
The theorem states that the degree of the monic polynomial that vanishes on a finite set `S` (defined by `monic_vanishing_at`) is equal to the cardinality of `S`, unless the ring is trivial (i.e., its zero and one are equal). This captures the intuition that a polynomial of degree `n` has `n` roots (counting multiplicities). The function `c` maps each element of `S` to a ring element where the polynomial vanishes. `x_minus_const` is the simple linear polynomial `x - c x` where x is an element of `S`. Overall, the theorem provides a formal connection between the algebraic concept of polynomial degree and the set-theoretic concept of cardinality.

### Dependencies
- `monic_vanishing_at_empty`
- `POLY_DEG_1`
- `card_empty`
- `monic_vanishing_at_insert`
- `card_insert`
- `x_minus_const_poly`
- `monic_vanishing_at_poly`
- `monic_x_minus_const`
- `monic_vanishing_at_monic`
- `deg_monic_poly_mul`
- `deg_zero_ring`
- `RING_POLYNOMIAL_MUL`
- `deg_x_minus_const`

### Porting notes (optional)
- All the definitions used in the proof are required to translate it into other proof assistants such as Lean or Coq.
- In proof assistants such as Lean, the `FINITE` predicate might need to be defined using inductive types or equivalent constructs.
- The rewriting and simplification steps in HOL Light might need to be manually expanded and adapted based on the available automation in the target proof assistant.


---

## deg_monic_vanishing_at_le

### Name of formal statement
deg_monic_vanishing_at_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_monic_vanishing_at_le = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_deg r (monic_vanishing_at r S c)
  <= CARD S
`,
  simp[deg_monic_vanishing_at] THEN
  ARITH_TAC
);;
```
### Informal statement
For any ring `r` with carrier `R`, any function `c` from a type `X` to `R`, and any finite set `S` of type `X`, if for all `s` in `S`, `c s` is an element of the carrier of ring `r`, then the degree of the polynomial `monic_vanishing_at r S c` is less than or equal to the cardinality of `S`.

### Informal sketch
The proof proceeds as follows:
- First, simplify the goal using the definition of `deg_monic_vanishing_at`.
- Then, use arithmetic tactics (`ARITH_TAC`) to complete the proof, relying on the properties of cardinality and polynomial degrees.

### Mathematical insight
The theorem states that the degree of the monic polynomial that vanishes on a finite set `S` is bounded above by the size of `S`. The function `c` allows the elements of `S` to be mapped into the ring over which the polynomial is defined. The polynomial `monic_vanishing_at r S c` is constructed to have roots at the images under `c` of the elements of `S`. Intuitively, constructing a polynomial with `n` unique roots requires a polynomial of degree at least `n`. However, this theorem only shows the degree is *at most* the cardinality of `S`.

### Dependencies
- Definitions: `deg_monic_vanishing_at`

### Porting notes (optional)
- The theorem is relatively straightforward. The main challenge might be in porting the definition of `monic_vanishing_at` and its related degree properties correctly.
- Ensure that the target proof assistant has appropriate support for polynomial degrees and finite sets.
- The `ARITH_TAC` in HOL Light typically handles simple arithmetic reasoning; this may need to be translated into equivalent tactics or manual proof steps in other systems.


---

## topcoeff_monic_vanishing_at

### Name of formal statement
topcoeff_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let topcoeff_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  coeff (CARD S) (monic_vanishing_at r S c) = ring_1 r
`,
  intro THEN
  case `ring_1 r = ring_0(r:R ring)` THENL [
    have `trivial_ring(r:R ring)` [TRIVIAL_RING_10] THEN
    have `ring_carrier(r:R ring) = {ring_0 r}` [trivial_ring] THEN
    have `ring_polynomial r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_poly] THEN
    have `coeff (CARD S) (monic_vanishing_at r S (c:X->R)) IN ring_carrier r` [coeff_poly_in_ring] THEN
    qed[IN_SING]
  ; pass
  ] THEN
  have `monic r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_monic] THEN
  have `CARD S = poly_deg(r:R ring) (monic_vanishing_at r S (c:X->R))` [deg_monic_vanishing_at] THEN
  qed[monic]
);;
```

### Informal statement
For any ring `r`, any set `S`, and any function `c` from `X` to the carrier of `r`, if `S` is finite and for all `s` in `S`, `c s` is in the carrier of `r`, then the coefficient of the `(CARD S)`-th term in the polynomial `monic_vanishing_at r S c` is equal to the multiplicative identity `ring_1 r` of the ring `r`.

### Informal sketch
The statement asserts that the leading coefficient of the monic polynomial that vanishes on a finite set `S` is 1. The proof proceeds as follows:
- Introduce the assumptions.
- Case split on whether `ring_1 r` is equal to `ring_0 r`.
  - If `ring_1 r = ring_0 r`, then the ring is trivial, the ring carrier is `{ring_0 r}`, `monic_vanishing_at r S c` is a polynomial, `coeff (CARD S) (monic_vanishing_at r S c)` is in the ring carrier and therefore is equal to `ring_0 r`, so it is equal to `ring_1 r`.
  - Otherwise (pass).
- Given that `monic_vanishing_at r S c` is monic, we have `coeff (CARD S) (monic_vanishing_at r S c) = ring_1 r`.
- We have that `CARD S = poly_deg(r:R ring) (monic_vanishing_at r S (c:X->R))`.

### Mathematical insight
The `monic_vanishing_at` polynomial is constructed to be monic, meaning its leading coefficient (the coefficient of the term with the highest degree) is the multiplicative identity of the ring. This theorem formalizes this property. This property is important because it allows us to easily relate the degree of the polynomial to the size of the set on which it vanishes when considering rings without zero divisors.

### Dependencies
- `FINITE`
- `ring_carrier`
- `ring_1`
- `monic_vanishing_at`
- `coeff`
- `monic_vanishing_at_poly`
- `coeff_poly_in_ring`
- `TRIVIAL_RING_10`
- `trivial_ring`
- `IN_SING`
- `monic`
- `monic_vanishing_at_monic`
- `deg_monic_vanishing_at`


---

## coeff_monic_vanishing_at_lemma

### Name of formal statement
coeff_monic_vanishing_at_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_monic_vanishing_at_lemma = prove(`
  !(r:R ring) c:X->R S t n.
  FINITE S ==>
  ~(t IN S) ==>
  (!s:X. s IN t INSERT S ==> c s IN ring_carrier r) ==>
  ~(n = 0) ==>
  n <= CARD S ==>
  ring_add r (
    ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U c)
  ) (
    ring_mul r (c t) (
      ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_product r U c)
    )
  ) =
  ring_sum r {U | U SUBSET t INSERT S /\ CARD U = n} (\U. ring_product r U c)
`,
  intro THEN
  have `c(t:X):R IN ring_carrier r` [IN_INSERT] THEN
  specialize[`S:X->bool`;`n-1`]finite_subsets_card THEN
  specialize[`S:X->bool`;`n:num`]finite_subsets_card THEN
  subgoal `FINITE {U:X->bool | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}` THENL [
    set_fact `{U:X->bool | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} SUBSET {U:X->bool | U SUBSET t INSERT S}` THEN
    have `FINITE ((t:X) INSERT S)` [FINITE_INSERT] THEN
    specialize[`(t:X) INSERT S`]FINITE_POWERSET THEN
    qed[FINITE_SUBSET]
  ; pass
  ] THEN
  subgoal `DISJOINT {U:X->bool | U SUBSET S /\ CARD U = n} {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}` THENL [
    rw[DISJOINT;INTER;EXTENSION;IN_ELIM_THM;EMPTY] THEN
    qed[SUBSET]
  ; pass
  ] THEN
  specialize[
    `r:R ring`;
    `\U. ring_product r U (c:X->R)`;
    `{U:X->bool | U SUBSET S /\ CARD U = n}`;
    `{U:X->bool | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}`
  ]RING_SUM_UNION THEN
  subgoal `{U:X->bool | U SUBSET t INSERT S /\ CARD U = n} = {U | U SUBSET S /\ CARD U = n} UNION {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}` THENL [
    rw[UNION;EXTENSION;IN_ELIM_THM] THEN
    SET_TAC[]
  ; pass
  ] THEN
  simp[] THEN
  subgoal `ring_mul r (c(t:X):R) (ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_product r U c)) = ring_sum r {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} (\U. ring_product r U c)` THENL [
    subgoal `ring_sum r {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} (\U. ring_product r U (c:X->R)) = ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_mul r (c t) (ring_product r U c))` THENL [
      subgoal `!A B. A IN {U:X->bool | U SUBSET S /\ CARD U = n - 1} ==> B IN {U | U SUBSET S /\ CARD U = n - 1} ==> t INSERT A = t INSERT B ==> A = B` THENL [
        rw[IN_ELIM_THM;EXTENSION;SUBSET;IN_INSERT] THEN
        qed[]
      ; pass
      ] THEN
      subgoal `{U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} = IMAGE (\A. t INSERT A) {U:X->bool | U SUBSET S /\ CARD U = n - 1}` THENL [
        rw[IMAGE;EXTENSION;IN_ELIM_THM] THEN
        intro THEN
        splitiff THENL [
          intro THEN
          witness `x DELETE (t:X)` THEN
          intro THENL [
            qed[SUBSET_INSERT_DELETE]
          ;
            qed[CARD_DELETE;FINITE_INSERT;FINITE_SUBSET]
          ;
            qed[IN_INSERT;IN_DELETE]
          ]
        ;
          intro THENL [
            qed[SUBSET;IN_INSERT]
          ;
            qed[IN_INSERT]
          ;
            have `FINITE(x':X->bool)` [FINITE_SUBSET] THEN
            have `~((t:X) IN x')` [SUBSET] THEN
            have `CARD((t:X) INSERT x') = (n-1)+1` [card_insert] THEN
            num_linear_fact `~(n = 0) ==> n = (n-1)+1` THEN
            have `CARD((t:X) INSERT x') = n` [] THEN
            qed[EXTENSION]
          ]
        ]
      ; pass
      ] THEN
      specialize[
        `r:R ring`;
        `\A:X->bool. t INSERT A`;
        `\U. ring_product r U (c:X->R)`;
        `{U:X->bool | U SUBSET S /\ CARD U = n - 1}`
      ]RING_SUM_IMAGE THEN
      subgoal `ring_sum r {U | U SUBSET S /\ CARD U = n - 1} ((\U. ring_product r U (c:X->R)) o (\A. t INSERT A)) = ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_mul r (c t) (ring_product r U c))` THENL [
        sufficesby RING_SUM_EQ THEN
        intro THEN
        rw[BETA_THM] THEN
        rw[o_THM] THEN
        set_fact `a IN {U | U SUBSET S /\ CARD U = n - 1} ==> (a:X->bool) SUBSET S` THEN
        have `FINITE(a:X->bool)` [FINITE_SUBSET] THEN
        have `~((t:X) IN a)` [SUBSET] THEN
        specialize[
          `r:R ring`;
          `t:X`;
          `c:X->R`;
          `a:X->bool`
        ](CONJUNCT2 RING_PRODUCT_CLAUSES) THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    specialize_assuming[
      `r:R ring`;
      `\U. ring_product r U (c:X->R)`;
      `c(t:X):R`;
      `{U:X->bool | U SUBSET S /\ CARD U = n - 1}`
    ]RING_SUM_LMUL THEN
    have `(!a. a IN {U | U SUBSET S /\ CARD U = n - 1} ==> ring_product r a (c:X->R) IN ring_carrier r)` [RING_PRODUCT] THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
Let `r` be a ring. Let `c` be a function from a type `X` to the carrier of the ring `r`. Let `S` be a finite set of type `X`. Let `t` be an element of type `X`. Let `n` be a natural number.
If `S` is finite and `t` is not an element of `S` and for all `s` in `t INSERT S`, `c s` is in the carrier of `r`, and `n` is not equal to 0, and `n` is less than or equal to the cardinality of `S`, then the ring sum over all subsets `U` of `S` with cardinality `n` of the ring product over `U` of `c` added to the ring product of `c t` and the ring sum over all subsets `U` of `S` with cardinality `n` - 1 of the ring product over `U` of `c` is equal to the ring sum over all subsets `U` of `t INSERT S` with cardinality `n` of the ring product over `U` of `c`.

### Informal sketch
The proof proceeds as follows:

- First, assume the hypotheses. Specifically, `FINITE S`, `~(t IN S)`, `!s. s IN t INSERT S ==> c s IN ring_carrier r`, `~(n = 0)`, and `n <= CARD S`.
- Instantiate `finite_subsets_card` to introduce finiteness properties of the relevant subsets, specializing for `S` and `n` (and `n-1`).
- Show that the set `{U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}` is finite, using the fact that it is a subset of the powerset of `t INSERT S`, which is finite.
- Show that the sets `{U | U SUBSET S /\ CARD U = n}` and `{U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}` are disjoint.
- Apply the theorem `RING_SUM_UNION` to split the sum over subsets of `t INSERT S` into sums over subsets of `S` and subsets of `t INSERT S` containing `t`.
- Simplify the result using the set equality `{U | U SUBSET t INSERT S /\ CARD U = n} = {U | U SUBSET S /\ CARD U = n} UNION {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}`.
- Show that `ring_sum r {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} (\U. ring_product r U c) = ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_mul r (c t) (ring_product r U c))`.
  - Prove that `ring_sum r {U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} (\U. ring_product r U (c:X->R)) = ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_mul r (c t) (ring_product r U c))`.
    - First, prove that `!A B. A IN {U:X->bool | U SUBSET S /\ CARD U = n - 1} ==> B IN {U | U SUBSET S /\ CARD U = n - 1} ==> t INSERT A = t INSERT B ==> A = B`.
    - Show that the set `{U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n}` is equal to the image of the set `{U | U SUBSET S /\ CARD U = n - 1}` under the function that inserts `t` into a set, i.e., `{U | U SUBSET t INSERT S /\ t IN U /\ CARD U = n} = IMAGE (\A. t INSERT A) {U:X->bool | U SUBSET S /\ CARD U = n - 1}`.
    - Apply the theorem `RING_SUM_IMAGE` to rewrite the sum over the image of the insertion function.
    - Show that `ring_sum r {U | U SUBSET S /\ CARD U = n - 1} ((\U. ring_product r U (c:X->R)) o (\A. t INSERT A)) = ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_mul r (c t) (ring_product r U c))`.
  - Apply the theorem `RING_SUM_LMUL`.
  - Use `RING_PRODUCT` to show that `(!a. a IN {U | U SUBSET S /\ CARD U = n - 1} ==> ring_product r a (c:X->R) IN ring_carrier r)`.

### Mathematical insight
This lemma relates the sum of products of a function `c` over subsets of a set `S` to the sum of products of `c` over subsets of `t INSERT S`, conditioned upon certain parameter `n` and the addition of `t` to `S`. This is a technical lemma for working with polynomial coefficient sums; it is a key step in proving facts about the coefficients of monic polynomials which vanish at elements.

### Dependencies
- `FINITE`
- `IN_INSERT`
- `finite_subsets_card`
- `DISJOINT`
- `INTER`
- `EXTENSION`
- `IN_ELIM_THM`
- `EMPTY`
- `SUBSET`
- `RING_SUM_UNION`
- `UNION`
- `IMAGE`
- `SUBSET_INSERT_DELETE`
- `CARD_DELETE`
- `FINITE_INSERT`
- `FINITE_SUBSET`
- `IN_DELETE`
- `card_insert`
- `RING_SUM_IMAGE`
- `BETA_THM`
- `o_THM`
- `RING_PRODUCT_CLAUSES`
- `RING_SUM_LMUL`
- `RING_PRODUCT`

### Porting notes (optional)
- The use of higher-order functions (e.g., `ring_sum`, `ring_product`) is idiomatic in HOL Light. Ensure that the target proof assistant (e.g., Lean, Coq, Isabelle) has similar support or a suitable encoding for these concepts.
- The proof involves manipulation of sets and images of sets. Make sure that the target proof assistant's set theory is compatible. Specifically, the porting needs to verify finiteness of those constructed sets via power set.
- The rewriting tactics in HOL Light (e.g., `rw`) will need to be translated into the corresponding simplifier or rewriting mechanisms in the target proof assistant.



---

## coeff_monic_vanishing_at_lemma2

### Name of formal statement
coeff_monic_vanishing_at_lemma2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_monic_vanishing_at_lemma2 = prove(`
  !(r:R ring) c:X->R S t n.
  FINITE S ==>
  ~(t IN S) ==>
  (!s:X. s IN t INSERT S ==> c s IN ring_carrier r) ==>
  ~(n = 0) ==>
  n <= CARD S ==>
  ring_sub r (
    ring_mul r (
      ring_pow r (ring_neg r (ring_1 r)) n
    ) (
      ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U c)
    )
  ) (
    ring_mul r (c t) (
      ring_mul r (
        ring_pow r (ring_neg r (ring_1 r)) (n - 1)
      ) (
        ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_product r U c)
      )
    )
  ) =
  ring_mul r (
    ring_pow r (ring_neg r (ring_1 r)) n
  ) (
    ring_sum r {U | U SUBSET t INSERT S /\ CARD U = n} (\U. ring_product r U c)
  )
`,
  intro THEN
  simp[GSYM coeff_monic_vanishing_at_lemma] THEN
  num_linear_fact `~(n = 0) ==> (n-1)+1 = n` THEN
  have `ring_pow(r:R ring) (ring_neg r (ring_1 r)) n = ring_neg r (ring_pow r (ring_neg r (ring_1 r)) (n-1))` [ring_pow_neg_1_plus1] THEN
  simp[] THEN
  specialize_assuming[
    `r:R ring`;
    `c(t:X):R`;
    `ring_pow(r:R ring) (ring_neg r (ring_1 r)) (n - 1)`;
    `ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))`;
    `ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_product r U (c:X->R))`
  ](GENL[
    `r:R ring`;`C:R`;`M:R`;`N:R`;`N1:R`
  ](RING_RULE `
    ring_sub(r:R ring) (ring_mul r (ring_neg r (M)) (N)) (ring_mul r (C) (ring_mul r (M) (N1))) = ring_mul r (ring_neg r (M)) (ring_add r (N) (ring_mul r (C) (N1)))
  `)) THEN
  qed[RING_1;RING_NEG;RING_POW;RING_SUM;IN_INSERT]
);;
```

### Informal statement
Given a ring `r` of type `R ring`, a function `c` from a type `X` to the carrier of `r`, a set `S` of type `X`, an element `t` of type `X`, and a natural number `n`, if `S` is finite, `t` is not in `S`, for all `s` in the insertion of `t` into `S`, `c(s)` is in the ring carrier of `r`, `n` is not equal to 0, and `n` is less than or equal to the cardinality of `S`, then the subtraction of the ring multiplication of `ring_pow r (ring_neg r (ring_1 r)) n` and `ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U c)` from the ring multiplication of `c t` and the ring multiplication of `ring_pow r (ring_neg r (ring_1 r)) (n - 1)` and `ring_sum r {U | U SUBSET S /\ CARD U = n - 1} (\U. ring_product r U c)` is equal to the ring multiplication of `ring_pow r (ring_neg r (ring_1 r)) n` and `ring_sum r {U | U SUBSET t INSERT S /\ CARD U = n} (\U. ring_product r U c)`.

### Informal sketch
The proof proceeds as follows:
- Simplify the goal using `coeff_monic_vanishing_at_lemma`.
- Prove `~(n = 0) ==> (n-1)+1 = n` using `num_linear_fact`.
- Prove `ring_pow(r:R ring) (ring_neg r (ring_1 r)) n = ring_neg r (ring_pow r (ring_neg r (ring_1 r)) (n-1))` using `ring_pow_neg_1_plus1`.
- Simplify the goal.
- Specialize to fit the `RING_RULE` schema, which applies the algebraic identity `ring_sub(r:R ring) (ring_mul r (ring_neg r (M)) (N)) (ring_mul r (C) (ring_mul r (M) (N1))) = ring_mul r (ring_neg r (M)) (ring_add r (N) (ring_mul r (C) (N1)))`.
- Conclude the proof with rewriting rules for `RING_1`, `RING_NEG`, `RING_POW`, `RING_SUM`, and `IN_INSERT`.

### Mathematical insight
This lemma relates the sum of products of `c` over subsets of size `n` of a set `S` and its insertion `t INSERT S`. It's useful in analyzing coefficients of monic polynomials and how they change when a root is added.

### Dependencies
- Theorems: `coeff_monic_vanishing_at_lemma`
- Rewrites: `RING_1`, `RING_NEG`, `RING_POW`, `RING_SUM`, `IN_INSERT`


---

## coeff_monic_vanishing_at

### Name of formal statement
coeff_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  !n.
  n <= CARD S ==>
  coeff (CARD S - n) (monic_vanishing_at r S c)
  = ring_mul r (
    ring_pow r (ring_neg r (ring_1 r)) n
  ) (
    ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U c)
  )
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    have `CARD({}:X->bool) = 0` [card_empty] THEN
    have `n = 0` [ARITH_RULE `n <= 0 ==> n = 0`] THEN
    simp[ARITH_RULE `0 - 0 = 0`;monic_vanishing_at;poly_product_empty] THEN
    have `{U | U SUBSET {} /\ CARD U = 0} = {{}:X->bool}` [subsets_full_card_empty] THEN
    simp[RING_SUM_SING;RING_PRODUCT_CLAUSES;RING_1;RING_POW_0;coeff_poly_1;RING_MUL_LID;RING_1]
  ; pass
  ] THEN
  case `n = 0` THENL [
    simp[ARITH_RULE `x - 0 = x`] THEN
    simp[topcoeff_monic_vanishing_at;subsets_card_0;FINITE_INSERT] THEN
    rw[RING_SUM_SING;RING_PRODUCT;RING_PRODUCT_CLAUSES;RING_1] THEN
    RING_TAC
  ; pass
  ] THEN
  set_fact `(x:X) IN x INSERT S` THEN
  set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
  simp[card_insert;monic_vanishing_at_insert] THEN
  have `c(x:X) IN ring_carrier(r:R ring)` [] THEN
  have `ring_powerseries r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_series] THEN
  simp[coeff_x_minus_const_times] THEN
  case `n = CARD(S:X->bool) + 1` THENL [
    simp[ARITH_RULE `x - x = 0`] THEN
    have `{U | U SUBSET S /\ CARD U = CARD S} = {S:X->bool}` [subsets_full_card] THEN
    have `coeff (CARD S - CARD S) (monic_vanishing_at r S (c:X->R)) = ring_mul r (ring_pow r (ring_neg r (ring_1 r)) (CARD S)) (ring_sum r {U | U SUBSET S /\ CARD U = CARD S} (\U. ring_product r U c))` [LE_REFL] THEN
    have `coeff 0 (monic_vanishing_at r S (c:X->R)) = ring_mul r (ring_pow r (ring_neg r (ring_1 r)) (CARD S)) (ring_sum r {S} (\U. ring_product r U c))` [ARITH_RULE `x - x = 0`] THEN
    have `ring_sum r {S} (\U. ring_product r U c) = ring_product r S (c:X->R)` [RING_PRODUCT;RING_SUM_SING] THEN
    have `coeff 0 (monic_vanishing_at r S (c:X->R)) = ring_mul r (ring_pow r (ring_neg r (ring_1 r)) (CARD S)) (ring_product r S c)` [] THEN
    have `{U | U SUBSET x INSERT S /\ CARD U = CARD(x INSERT S)} = {x INSERT S:X->bool}` [subsets_full_card;FINITE_INSERT] THEN
    have `{U | U SUBSET x INSERT S /\ CARD U = CARD S + 1} = {x INSERT S:X->bool}` [card_insert] THEN
    simp[RING_SUM_SING;RING_PRODUCT] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    rw[ring_pow_neg_1_plus1] THEN
    RING_TAC THEN
    qed[coeff_poly_in_ring;monic_vanishing_at_poly;RING_PRODUCT;RING_SUM]
  ; pass
  ] THEN
  have `n <= CARD(S:X->bool) + 1` [card_insert] THEN
  num_linear_fact `n <= CARD(S:X->bool) + 1 ==> ~(n = CARD S + 1) ==> n <= CARD S` THEN
  num_linear_fact `n <= CARD(S:X->bool) + 1 ==> ~(n = CARD S + 1) ==> ~((CARD S + 1) - n = 0)` THEN
  num_linear_fact `n <= CARD(S:X->bool) + 1 ==> ~(n = CARD S + 1) ==> (CARD S + 1) - n - 1 = CARD S - n` THEN
  num_linear_fact `~(n = 0) ==> n <= CARD(S:X->bool) + 1 ==> ~(n = CARD S + 1) ==> (CARD S + 1) - n = CARD S - (n - 1)` THEN
  num_linear_fact `n <= CARD(S:X->bool) ==> n-1 <= CARD S` THEN
  simp[] THEN
  qed[coeff_monic_vanishing_at_lemma2]
);;
```

### Informal statement
For any ring `r` of type `R ring`, and any function `c` from a type `X` to the carrier of the ring `r`, and any finite set `S` of type `X`, if for all `s` in `S`, `c s` is in the carrier of the ring `r`, then for any `n`, if `n` is less than or equal to the cardinality of `S`, then the coefficient of the term with degree (cardinality of `S` minus `n`) in the polynomial `monic_vanishing_at r S c` is equal to the ring multiplication of `ring_pow r (ring_neg r (ring_1 r)) n` and `ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U c)`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.
- Base case: `S` is empty
  - Show that the cardinality of the empty set is 0. Thus, `n=0`.
  - Simplify using `monic_vanishing_at` and `poly_product_empty`.
  - Show that the set of subsets of the empty set with cardinality 0 is the singleton set containing the empty set.
  - Simplify using `RING_SUM_SING`, `RING_PRODUCT_CLAUSES`, `RING_1`, `RING_POW_0`, `coeff_poly_1`, `RING_MUL_LID`, `RING_1`.
- Inductive step: `S` is non-empty, so `S = x INSERT S'` for some `x` and `S'`.
  - Case `n = 0`: Simplify `x - 0 = x`.
    - Simplify using `topcoeff_monic_vanishing_at`, `subsets_card_0`, and `FINITE_INSERT`.
    - Rewrite using `RING_SUM_SING`, `RING_PRODUCT`, `RING_PRODUCT_CLAUSES`, and `RING_1`.
    - Use `RING_TAC`.
  - Case `n = CARD(S) + 1`: 
    - Simplify `x - x = 0`.
    - Show that `{U | U SUBSET S /\ CARD U = CARD S} = {S}` using `subsets_full_card`.
    - Several have tactics are used to reduce the expression.
    - Use `RING_TAC`.
    - Conclude using `coeff_poly_in_ring`, `monic_vanishing_at_poly`, `RING_PRODUCT`, and `RING_SUM`.
  - General Case: `n <= CARD(S) + 1` and `n != CARD(S) + 1`.
    - Use arithmetic facts to show that `n <= CARD S` and `(CARD S + 1) - n - 1 = CARD S - n` and `(CARD S + 1) - n = CARD S - (n - 1)` and `n-1 <= CARD S`.
    - Final simplification and application of inductive hypothesis.

### Mathematical insight
This theorem relates the coefficients of the `monic_vanishing_at` polynomial (which vanishes on the set `S` with values `c s` for `s` in `S`) to elementary symmetric polynomials in the values `c s`. The coefficient of degree `CARD S - n` is expressed in terms of the sum of products of the `c s` over all subsets of `S` of cardinality `n`.

### Dependencies
- `FINITE`
- `coeff`
- `monic_vanishing_at`
- `ring_mul`
- `ring_pow`
- `ring_neg`
- `ring_1`
- `ring_sum`
- `ring_product`
- `subsets_full_card_empty`
- `RING_SUM_SING`
- `RING_PRODUCT_CLAUSES`
- `RING_1`
- `RING_POW_0`
- `coeff_poly_1`
- `RING_MUL_LID`
- `RING_1`
- `topcoeff_monic_vanishing_at`
- `subsets_card_0`
- `FINITE_INSERT`
- `RING_PRODUCT`
- `subsets_full_card`
- `ring_pow_neg_1_plus1`
- `coeff_poly_in_ring`
- `monic_vanishing_at_poly`
- `LE_REFL`
- `card_insert`
- `coeff_x_minus_const_times`

### Porting notes (optional)
The theorem relies heavily on rewriting and simplification tactics, particularly those associated with ring arithmetic. The porter should ensure that the target proof assistant has similar capabilities for handling rings and polynomials. The use of `sufficesby` and `THENL` suggests that the proof may benefit from a goal-directed approach.


---

## x_truncreverse_monic_vanishing_at

### Name of formal statement
x_truncreverse_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  x_truncreverse r (CARD S) (monic_vanishing_at r S c)
  = poly_product r S (\s. one_minus_constx r (c s))
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[monic_vanishing_at_empty;poly_product_empty;card_empty;poly_1;x_truncreverse_0_poly_const]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `!s:X. s IN S ==> c s IN ring_carrier(r:R ring)` [] THEN
    simp[monic_vanishing_at_insert;poly_product_insert;card_insert] THEN
    have `c(x:X) IN ring_carrier(r:R ring)` [] THEN
    have `ring_polynomial r (x_minus_const(r:R ring) (c(x:X)))` [x_minus_const_poly] THEN
    have `ring_powerseries r (one_minus_constx(r:R ring) (c(x:X)))` [one_minus_constx_series] THEN
    have `ring_polynomial r (monic_vanishing_at(r:R ring) S (c:X->R))` [monic_vanishing_at_poly] THEN
    have `poly_deg(r:R ring) (x_minus_const r (c(x:X))) <= 1` [deg_x_minus_const_le] THEN
    have `poly_deg(r:R ring) (monic_vanishing_at r S (c:X->R)) <= CARD S` [deg_monic_vanishing_at_le] THEN
    num_linear_fact `CARD (S:X->bool) + 1 = 1 + CARD S` THEN
    simp[x_truncreverse_mul] THEN
    rw[x_truncreverse_x_minus_const]
  ]
);;
```

### Informal statement
For any ring `r` and any function `c` from a type `X` to the carrier of the ring `r`, and any finite set `S` of type `X`, if for all `s` in `S`, `c s` is in the carrier of the ring `r`, then `x_truncreverse r (CARD S) (monic_vanishing_at r S c)` is equal to `poly_product r S (\s. one_minus_constx r (c s))`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: If `S` is empty, then both sides of the equation are equal using `monic_vanishing_at_empty`, `poly_product_empty`, `card_empty`, `poly_1` and `x_truncreverse_0_poly_const`.
- Inductive step: Assume the theorem holds for all subsets of `x INSERT S`.
  - Assume `x` is in `x INSERT S`.
  - Assume `!s. s IN S ==> s IN x INSERT S`.
  - Assume `!s:X. s IN S ==> c s IN ring_carrier(r:R ring)`.
  - Rewrite using the definitions of `monic_vanishing_at_insert`, `poly_product_insert` and `card_insert`.
  - Assume `c(x:X) IN ring_carrier(r:R ring)`.
  - Show that `ring_polynomial r (x_minus_const(r:R ring) (c(x:X)))` using `x_minus_const_poly`.
  - Show that `ring_powerseries r (one_minus_constx(r:R ring) (c(x:X)))` using `one_minus_constx_series`.
  - Show that `ring_polynomial r (monic_vanishing_at(r:R ring) S (c:X->R))` using `monic_vanishing_at_poly`.
  - Show that `poly_deg(r:R ring) (x_minus_const r (c(x:X))) <= 1` using `deg_x_minus_const_le`.
  - Show that `poly_deg(r:R ring) (monic_vanishing_at r S (c:X->R)) <= CARD S` using `deg_monic_vanishing_at_le`.
  - Rewrite `CARD (S:X->bool) + 1 = 1 + CARD S`.
  - Rewrite using `x_truncreverse_mul` and `x_truncreverse_x_minus_const`.

### Mathematical insight
This theorem relates two ways of representing a polynomial that vanishes on a set `S`. The `monic_vanishing_at r S c` constructs a monic polynomial that vanishes at all points `c s` for `s` in `S`. The `poly_product r S (\s. one_minus_constx r (c s))` computes the product of linear factors `x - c s` for `s` in `S`. The `x_truncreverse` operation converts a formal power series to a polynomial. In essence, this result shows the equivalence of forming a polynomial from a product of linear factors vs. constructing a vanishing polynomial directly, up to truncation.

### Dependencies
- `FINITE`
- `monic_vanishing_at`
- `poly_product`
- `card_empty`
- `poly_1`
- `x_truncreverse_0_poly_const`
- `monic_vanishing_at_insert`
- `poly_product_insert`
- `card_insert`
- `x_minus_const_poly`
- `one_minus_constx_series`
- `monic_vanishing_at_poly`
- `deg_x_minus_const_le`
- `deg_monic_vanishing_at_le`
- `x_truncreverse_mul`
- `x_truncreverse_x_minus_const`

### Porting notes (optional)
- The handling of `ring` typeclasses and their associated operators will need adaption in other provers like Lean or Coq.
- The finiteness and polynomial degree arguments might require explicit reasoning in other systems.
- The inductive proof structure can be directly transferred to systems like Coq or Lean using appropriate induction tactics.


---

## x_truncreverse_derivative_monic_vanishing_at

### Name of formal statement
x_truncreverse_derivative_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_derivative_monic_vanishing_at = prove(`
  !(r:R ring) S c:X->R.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  x_truncreverse r (CARD S - 1)
    (x_derivative r (monic_vanishing_at r S c))
  = poly_sum r S
      (\s. poly_product r (S DELETE s) (\s. one_minus_constx r (c s)))
`,
  intro THEN
  simp[x_derivative_monic_vanishing_at] THEN
  have `!s:X. s IN S ==> FINITE(S DELETE s)` [FINITE_DELETE] THEN
  set_fact `!s:X. !t:X. t IN (S DELETE s) ==> t IN S` THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (monic_vanishing_at r (S DELETE s) c)` [monic_vanishing_at_series] THEN
  simp[x_truncreverse_poly_sum] THEN
  sufficesby poly_sum_eq THEN
  intro THEN
  simp[] THEN
  have `CARD(S DELETE (s:X)) = CARD S - 1` [CARD_DELETE] THEN
  have `!t:X. t IN (S DELETE s) ==> c t IN ring_carrier(r:R ring)` [IN_DELETE] THEN
  qed[x_truncreverse_monic_vanishing_at]
);;
```
### Informal statement
For any ring `r` and any finite set `S` of type `X`, and any function `c` from `X` to the carrier of `r`, if for all `s` in `S`, `c s` is in the carrier of `r`, then the `(CARD S - 1)`-truncation-reverse of the derivative of the polynomial `monic_vanishing_at r S c` is equal to the polynomial sum over `S` of the functions that map `s` to the polynomial product over `S DELETE s` of functions that map `s` to `one_minus_constx r (c s)`.

### Informal sketch
The proof proceeds by:
- Introducing assumptions.
- Simplifying using `x_derivative_monic_vanishing_at`.
- Establishing that if `S` is finite, then `S DELETE s` is finite for any `s` in `S`. This uses the theorem `FINITE_DELETE`.
- Noting that if `t` is in `S DELETE s`, then `t` is in `S`.
- Using the theorem `monic_vanishing_at_series` to show that for all `s` in S, the polynomial `monic_vanishing_at r (S DELETE s) c` is a ring powerseries.
- Simplifying using `x_truncreverse_poly_sum`.
- Showing the statement by using `poly_sum_eq`.
- Introducing assumptions.
- Simplifying.
- Establishing that `CARD(S DELETE s) = CARD S - 1` by using the theorem `CARD_DELETE`.
- Establishing that if `t` is in `S DELETE s` then `c t` is in the carrier of `r` by using the theorem `IN_DELETE`.
- Concluding using `x_truncreverse_monic_vanishing_at`.

### Mathematical insight
This theorem relates the truncated reverse of the derivative of a monic polynomial vanishing at a set of points to a sum of products of linear factors. It essentially provides a way to compute the coefficients of the truncated reverse polynomial, which can be useful in various applications involving polynomial interpolation or approximation. The `monic_vanishing_at` polynomial vanishes precisely at the points `c s` for `s` in `S`. The theorem provides a formula for the coefficients of a polynomial closely related to the derivative of this vanishing polynomial.

### Dependencies
- Definitions:
  - `ring_carrier`
  - `x_derivative`
  - `monic_vanishing_at`
  - `x_truncreverse`
  - `poly_sum`
  - `poly_product`
  - `one_minus_constx`
  - `CARD`
  - `DELETE`
- Theorems:
  - `x_derivative_monic_vanishing_at`
  - `FINITE_DELETE`
  - `monic_vanishing_at_series`
  - `x_truncreverse_poly_sum`
  - `poly_sum_eq`
  - `CARD_DELETE`
  - `IN_DELETE`
  - `x_truncreverse_monic_vanishing_at`


---

## x_truncreverse_subring

### Name of formal statement
x_truncreverse_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_truncreverse_subring = prove(`
  !(r:R ring) G n (p:(1->num)->R).
  x_truncreverse (subring_generated r G) n p
  = x_truncreverse r n p
`,
  rw[x_truncreverse;SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any set `G` of elements of `r`, any natural number `n`, and any function `p` from functions of type `(1->num)` to `R`, the `x_truncreverse` of the subring generated by `G` in `r` up to `n` with projection `p` is equal to the `x_truncreverse` of `r` up to `n` with projection `p`.

### Informal sketch
The proof proceeds by rewriting using the definitions of `x_truncreverse` and `SUBRING_GENERATED`. Thus, it shows that truncating homomorphisms into quotient rings works the same.

- Start with the statement
  `x_truncreverse (subring_generated r G) n p = x_truncreverse r n p`
- Rewrite using definition of `x_truncreverse`, which introduces `x_trunc`, yielding:
  `x_trunc (subring_generated r G) n p = x_trunc r n p`
- Rewrite using the theorem `SUBRING_GENERATED`, which states `subring_generated r G = r`, yielding:
  `x_trunc r n p = x_trunc r n p`
- This is reflexive and proves the theorem.

### Mathematical insight
This theorem states that the truncated homomorphisms are invariant under the subring generated construction. It provides a way to relate homomorphisms on a subring of a ring to homomorphisms on the whole ring, which can be useful for simplifying the analysis of homomorphisms in certain contexts.

### Dependencies
- Definitions:
  - `x_truncreverse`
  - `SUBRING_GENERATED`


---

## botcoeff1_if_x_truncreverse_monic

### Name of formal statement
botcoeff1_if_x_truncreverse_monic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let botcoeff1_if_x_truncreverse_monic = prove(`
  !(r:R ring) p.
  monic r p ==>
  coeff 0 (x_truncreverse r (poly_deg r p) p) = ring_1 r
`,
  rw[monic;coeff_x_truncreverse;ARITH_RULE `0 <= d`;ARITH_RULE `d - 0 = d`]
);;
```
### Informal statement
For any ring `r` and any polynomial `p` over `r`, if `p` is monic, then the coefficient of degree 0 in the polynomial `x_truncreverse r (poly_deg r p) p` is equal to the ring's multiplicative identity `ring_1 r`.

### Informal sketch
The proof proceeds as follows:

- Assume `p` is a monic polynomial in the ring `r`.
- Rewrite using the definition of `monic`, which states that the coefficient of the polynomial at its degree equals `ring_1 r`.
- Rewrite using the definition of `coeff_x_truncreverse`, which expresses the coefficient of degree 0 of `x_truncreverse r (poly_deg r p) p` in terms of the coefficient of `p` at degree `poly_deg r p`. Namely, `coeff 0 (x_truncreverse r (poly_deg r p) p) = coeff (poly_deg r p) p`.
- Use arithmetic simplification to establish that `0 <= poly_deg r p` and `poly_deg r p - 0 = poly_deg r p`.
- Conclude that `coeff 0 (x_truncreverse r (poly_deg r p) p) = ring_1 r`.

### Mathematical insight
This theorem relates the concept of a monic polynomial with the coefficients of its truncated and reversed form. It shows that when a polynomial is monic, the bottom coefficient of `x_truncreverse` is the multiplicative identity. This is relevant in polynomial algebra and formal power series.

### Dependencies
- Definitions: `monic`, `coeff_x_truncreverse`
- Theorems: `ARITH_RULE` (for simple arithmetic facts)


---

## nonzero_if_x_truncreverse_monic

### Name of formal statement
nonzero_if_x_truncreverse_monic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_if_x_truncreverse_monic = prove(`
  !(r:R ring) p.
  ~(ring_1 r = ring_0 r) ==>
  monic r p ==>
  ~(x_truncreverse r (poly_deg r p) p = poly_0 r)
`,
  qed[botcoeff1_if_x_truncreverse_monic;coeff_poly_0]
);;
```
### Informal statement
For any ring `r` and polynomial `p` over `r`, if the multiplicative identity `ring_1 r` is not equal to the additive identity `ring_0 r` in `r`, and `p` is monic over `r`, then the `x_truncreverse` of `p` at degree `poly_deg r p` is not equal to the zero polynomial `poly_0 r`.

### Informal sketch
The proof proceeds as follows:
- Assume that `ring_1 r` is not equal to `ring_0 r`, and `p` is monic.
- The goal is to prove that `x_truncreverse r (poly_deg r p) p` is not equal to `poly_0 r`.
- The tactic `botcoeff1_if_x_truncreverse_monic` is used, likely to relate the leading coefficient of `x_truncreverse r (poly_deg r p) p` with the property of `p` being monic..
- The tactic `coeff_poly_0` is used, which is likely used to simplify the coefficients of the zero polynomial.
- By assumption, `p` is monic, so the coefficient of the highest degree term of `p` is `ring_1 r`.
- By the definition of `x_truncreverse`, the bottom coefficient of `x_truncreverse r (poly_deg r p) p` is the top coefficient of `p`, which is `ring_1 r`.
- Since `ring_1 r` is not equal to `ring_0 r`, the bottom coefficient of `x_truncreverse r (poly_deg r p) p` is not `ring_0 r`.
- Therefore, `x_truncreverse r (poly_deg r p) p` is not `poly_0 r`.

### Mathematical insight
This theorem states that if we take a monic polynomial and reverse its coefficients (truncating if needed) to the original degree (essentially dropping higher power terms), the result is non-zero provided the 0 and 1 elements in the ring are distinct. This is because the constant term of the reversed polynomial will be the leading coefficient of the original monic polynomial which is `ring_1 r`, and `ring_1 r` != `ring_0 r`

### Dependencies
- `botcoeff1_if_x_truncreverse_monic`
- `coeff_poly_0`


---

## product_times_sum_reciprocals

### Name of formal statement
product_times_sum_reciprocals

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) (f:X->R) (g:X->R) S.
  FINITE S ==>
  (!s. s IN S ==> f s IN ring_carrier r) ==>
  (!s. s IN S ==> g s IN ring_carrier r) ==>
  (!s. s IN S ==> ring_mul r (f s) (g s) = ring_1 r) ==>
  ring_mul r
    (ring_product r S (\s. f s))
    (ring_sum r S (\s. g s))
  = ring_sum r S (\t. ring_product r (S DELETE t) (\s. f s))
```

### Informal statement
For any ring `r`, any functions `f` and `g` from `X` to the carrier of `r`, and any set `S` of type `X`, if `S` is finite, if for all `s` in `S`, `f s` is in the carrier of `r`, if for all `s` in `S`, `g s` is in the carrier of `r`, and if for all `s` in `S`, the ring multiplication of `f s` and `g s` equals the ring one of `r`, then the ring multiplication of the ring product of `f s` over `S` and the ring sum of `g s` over `S` equals the ring sum over `S` of the ring product of `f s` over `S` with `t` deleted from `S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then both `ring_product r S (\s. f s)` and `ring_sum r S (\s. g s)` are `ring_1 r` and `ring_0 r` respectively and `ring_mul r (ring_1 r) (ring_0 r)` and `ring_sum r S (\t. ring_product r (S DELETE t) (\s. f s))` both simplify to `ring_0 r`.
- Inductive step: Assume that the theorem holds for all finite subsets of `X` with cardinality less than that of `S`. Pick an element `x` from `S`. Add it back after deletion `S DELETE x = S`. Then consider `ring_mul r (ring_product r (x INSERT S) (\s. f s)) (ring_sum r (x INSERT S) (\s. g s))`. Expand both products and sums using their clauses. Then simplify using the assumption that `ring_mul r (f s) (g s) = ring_1 r` for all `s` in `S`. Applying `RING_RULE` transforms the expression. Distribute the product using a specialized `RING_SUM_LMUL`. Then, using `RING_SUM_EQ`, the goal is reduced to showing that the summands are equal. The inductive hypothesis is applied to the term over the smaller subset `S DELETE a` where `a` is in S. Simplify using the facts that `~(x IN S) ==> ~(x IN S DELETE s)` and the clauses of `RING_PRODUCT`.

### Mathematical insight
This theorem expresses an identity relating the product of elements with the sum of their reciprocals. Specifically, if `f` is a function and `g` is its reciprocal relative to ring multiplication (i.e., `f s * g s = 1` for all `s`), then the theorem gives a formula for `(product of f(s) over S) * (sum of g(s) over S)` in terms of products of `f(s)` over subsets of `S`. This is related to Newton's identities, which connect sums of powers to elementary symmetric polynomials.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `RING_PRODUCT_CLAUSES`
- `RING_SUM_CLAUSES`
- `RING_0`
- `RING_MUL_LID`
- `RING_PRODUCT`
- `RING_SUM`
- `RING_RULE`
- `RING_SUM_LMUL`
- `RING_SUM_EQ`
- `FINITE_DELETE`
- `CONJUNCT2`

### Porting notes (optional)
- The assumption that `ring_mul r (f s) (g s) = ring_1 r` for all `s` in `S` is crucial. In other proof assistants, one may need to explicitly prove that `g s` is the multiplicative inverse of `f s` before applying this theorem.
- The handling of finiteness and set membership (`FINITE S`, `s IN S`) may differ across proof assistants. Ensure that the corresponding notions are correctly defined and that the finiteness of `S` is properly discharged.
- `RING_RULE` is a HOL Light-specific tactic that uses equational rewriting based on ring properties. In porting, one may need to manually apply similar rewrite rules using the ring axioms or lemmas specific to the target proof assistants.


---

## newton_identities_natural

### Name of formal statement
newton_identities_natural

### Type of the formal statement
theorem

### Formal Content
```ocaml
let newton_identities_natural = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_mul r
    (poly_product r S (\s. one_minus_constx r (c s)))
    (poly_sum r S (\s. infinite_geometric_series r (c s)))
  = poly_sum r S (\t. poly_product r (S DELETE t) (\s. one_minus_constx r (c s)))
`,
  rw[x_series_use] THEN
  rw[poly_product;poly_sum] THEN
  intro THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_series] THEN
  have `!s:X. s IN S ==> one_minus_constx r (c s) IN ring_carrier(x_series(r:R ring))` [x_series_carrier;SET_RULE `ring_powerseries(r:R ring) (p:(1->num)->R) ==> p IN {q | ring_powerseries r q}`] THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (infinite_geometric_series r (c s))` [infinite_geometric_series_powerseries] THEN
  have `!s:X. s IN S ==> infinite_geometric_series r (c s) IN ring_carrier(x_series(r:R ring))` [x_series_carrier;SET_RULE `ring_powerseries(r:R ring) (p:(1->num)->R) ==> p IN {q | ring_powerseries r q}`] THEN
  have `!s:X. s IN S ==> ring_mul (x_series(r:R ring)) (one_minus_constx r (c s)) (infinite_geometric_series r (c s)) = ring_1 (x_series r)` [infinite_geometric_series_inverse;x_series_use] THEN
  specialize[`x_series(r:R ring)`;`\s:X. one_minus_constx(r:R ring) (c s)`;`\s:X. infinite_geometric_series(r:R ring) (c s)`;`S:X->bool`]product_times_sum_reciprocals THEN
  qed[]
);;
```
### Informal statement
For any ring `r` and any function `c` from a type `X` to the carrier of `r`, if `S` is a finite set from type `X` and `c s` belongs to the carrier of `r` for every `s` in `S`, then the product of the polynomial `one_minus_constx r (c s)` over `S` multiplied by the sum of the polynomial `infinite_geometric_series r (c s)` over `S` equals the sum over `t` in `S` of the product of the polynomial `one_minus_constx r (c s)` over `S` with `t` removed.

### Informal sketch
The proof establishes an identity relating products and sums of polynomials derived from a ring `r` and a function `c` over a finite set `S`. The core idea revolves around expressing reciprocals as infinite geometric series.
- Rewrite the `poly_mul`, `poly_product`, and `poly_sum`
- Introduce assumptions.
- Establish that `one_minus_constx r (c s)` is a formal power series.
- Establish that `one_minus_constx r (c s)` is in `ring_carrier(x_series(r:R ring))`.
- Establish that `infinite_geometric_series r (c s)` is a formal power series.
- Establish that `infinite_geometric_series r (c s)` is in `ring_carrier(x_series(r:R ring))`.
- Show that multiplying `one_minus_constx r (c s)` and `infinite_geometric_series r (c s)` results in `ring_1 (x_series r)`. This uses the fact that the infinite geometric series is the inverse of `one_minus_constx`.
- Apply the theorem `product_times_sum_reciprocals`, which states that the product of a family multiplied by sum of reciprocals of that family equals sum over t in the set of the product with t removed.
- The proof then concludes directly.

### Mathematical insight
The `newton_identities_natural` theorem relates the product of `1 - c(s)x` with the sum of the geometric series expansions using these values `c(s)x`, which is `1/(1-c(s)x)`. The theorem provides a way to rewrite a product of `(1 - c(s)x)` multiplied by a sum of `1/(1-c(s)x)` into a sum that excludes one element from the product iterated over `S` in each term. This mirrors Newton's identities, which relates power sums to elementary symmetric polynomials.

### Dependencies
- `x_series_use`
- `poly_product`
- `poly_sum`
- `one_minus_constx_series`
- `x_series_carrier`
- `infinite_geometric_series_powerseries`
- `infinite_geometric_series_inverse`
- `product_times_sum_reciprocals`


---

## newton_identities_monic_vanishing_at

### Name of formal statement
newton_identities_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let newton_identities_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_mul r
    (x_truncreverse r (CARD S) (monic_vanishing_at r S c))
    (poly_sum r S (\s. infinite_geometric_series r (c s)))
  = x_truncreverse r (CARD S - 1)
      (x_derivative r (monic_vanishing_at r S c))
`,
  simp[x_truncreverse_monic_vanishing_at] THEN
  simp[x_truncreverse_derivative_monic_vanishing_at] THEN
  qed[newton_identities_natural]
);;
```
### Informal statement
For any ring `r` of type `R`, and any function `c` from a type `X` to the carrier of the ring `r`, given that the set `S` is finite, and for all `s` in `S`, `c s` is in the carrier of the ring `r`, then the polynomial multiplication of `x_truncreverse r (CARD S) (monic_vanishing_at r S c)` and `poly_sum r S (\s. infinite_geometric_series r (c s))` is equal to `x_truncreverse r (CARD S - 1) (x_derivative r (monic_vanishing_at r S c))`.

### Informal sketch
The proof proceeds in two steps:

- First, simplify using `x_truncreverse_monic_vanishing_at`.
- Second, simplify using `x_truncreverse_derivative_monic_vanishing_at`.
- Finally, apply the theorem `newton_identities_natural`.

### Mathematical insight
This theorem relates the coefficients of a monic polynomial that vanishes on a finite set `S` with power sums of the elements of `S`. `monic_vanishing_at r S c` returns a monic polynomial with roots {c s | s in S}. The power sums of the roots are given by `poly_sum r S (\s. infinite_geometric_series r (c s))`. The theorem states that the product of the polynomial and the power series is equal to the derivative of the polynomial. This identity is a generalization of Newton's identities relating power sums to elementary symmetric polynomials.

### Dependencies
- `x_truncreverse_monic_vanishing_at`
- `x_truncreverse_derivative_monic_vanishing_at`
- `newton_identities_natural`


---

## newton_identities

### Name of formal statement
newton_identities

### Type of the formal statement
theorem

### Formal Content
```ocaml
let newton_identities = prove(`
  !(r:R ring) c:X->R S d.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_sum r (0..d)
    (\a. ring_mul r
      (if a <= CARD S then coeff(CARD S-a) (monic_vanishing_at r S c) else ring_0 r)
      (ring_sum r S (\s. ring_pow r (c s) (d-a)))
    )
  = if d <= CARD S-1 then coeff(CARD S-1-d) (x_derivative r (monic_vanishing_at r S c)) else ring_0 r
`,
  intro THEN
  specialize[`r:R ring`;`c:X->R`;`S:X->bool`]newton_identities_monic_vanishing_at THEN
  specialize[`r:R ring`;`d:num`;`x_truncreverse(r:R ring) (CARD S) (monic_vanishing_at r S (c:X->R))`;`poly_sum(r:R ring) S (\s:X. infinite_geometric_series r (c s))`](GSYM coeff_poly_mul_oneindex) THEN
  specialize[`r:R ring`;`CARD(S:X->bool)`;`monic_vanishing_at(r:R ring) S (c:X->R)`](GSYM coeff_x_truncreverse) THEN
  recall(GSYM coeff_infinite_geometric_series) THEN
  subgoal `!a:num. ring_sum(r:R ring) S (\s:X. coeff (d - a) (infinite_geometric_series r (c s))) = coeff (d - a) (poly_sum r S (\s. infinite_geometric_series r (c s)))` THENL [
    intro THEN
    have `!s:X. s IN S ==> ring_powerseries(r:R ring) (infinite_geometric_series r (c s))` [infinite_geometric_series_powerseries] THEN
    specialize[`r:R ring`;`\s:X. infinite_geometric_series (r:R ring) (c s)`;`d-a:num`;`S:X->bool`]coeff_poly_sum THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  qed[coeff_x_truncreverse]
);;
```

### Informal statement
For any ring `r`, function `c` from `X` to the carrier of `r`, set `S` of type `X->bool`, and natural number `d`, if `S` is finite and for all `s` in `S`, `c s` is in the carrier of `r`, then the ring sum over the range `0` to `d` of the terms formed by multiplying the coefficient of `x^(CARD S - a)` in the polynomial `monic_vanishing_at r S c` (or `ring_0 r` if `a > CARD S`) by the ring sum over `S` of `(c s)^(d-a)` is equal to the coefficient of `x^(CARD S - 1 - d)` in the derivative of `monic_vanishing_at r S c` (or, if `d > CARD S -1` it is equal to `ring_0 r`).

### Informal sketch
The main idea is to relate the power sums of the roots of a monic polynomial to the coefficients of the polynomial and its derivative. The proof proceeds as follows:
- Introduce assumptions.
- Apply `newton_identities_monic_vanishing_at` after specializing it with the given ring `r`, function `c`, and set `S`.
- Apply `coeff_poly_mul_oneindex` after specializing with the ring `r`, degree `CARD S`, polynomial `monic_vanishing_at r S c`, and the polynomial sum of infinite geometric series of `c s`.
- Apply `coeff_x_truncreverse` after specializing with the ring `r`, cardinality of `S` and `monic_vanishing_at r S c`.
- Recall the definition of `coeff_infinite_geometric_series`.
- Prove the subgoal that relates the ring sum of coefficients of infinite geometric series to coefficient of a sum of infinite geometric series which is discharged by: Firstly, introducing the assumption; then using `infinite_geometric_series_powerseries` to show `infinite_geometric_series r (c s)` is a ring powerseries for all `s` in `S`; then using `coeff_poly_sum` specialized appropriately.
- Simplify.
- Conclude using `coeff_x_truncreverse`.

### Mathematical insight
These identities are fundamental relationships connecting the coefficients of a polynomial to the power sums of its roots. They are crucial in various areas of algebra, including Galois theory and representation theory. The statement can be understood as a generalization of Vieta's formulas.

### Dependencies
- `FINITE`
- `ring_carrier`
- `ring_sum`
- `ring_mul`
- `ring_pow`
- `monic_vanishing_at`
- `coeff`
- `x_derivative`
- `ring_0`
- `infinite_geometric_series`
- `coeff_poly_mul_oneindex`
- `coeff_x_truncreverse`
- `coeff_infinite_geometric_series`
- `infinite_geometric_series_powerseries`
- `coeff_poly_sum`
- `newton_identities_monic_vanishing_at`

### Porting notes (optional)
- The definition `monic_vanishing_at` needs to be ported first.
- The various theorems about coefficients of polynomials, derivatives need to be available.
- The handling of dependent types (if `R` is a ring, then elements have type `carrier R`) may need special encoding.


---

## newton_identities_recurrence

### Name of formal statement
newton_identities_recurrence

### Type of the formal statement
theorem

### Formal Content
```ocaml
let newton_identities_recurrence = prove(`
  !(r:R ring) c:X->R S d.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_sum r S (\s. ring_pow r (c s) d)
  = ring_sub r
      (if d <= CARD S-1 then coeff(CARD S-1-d) (x_derivative r (monic_vanishing_at r S c)) else ring_0 r)
      (ring_sum r (1..d)
        (\a. ring_mul r
          (if a <= CARD S then coeff(CARD S-a) (monic_vanishing_at r S c) else ring_0 r)
          (ring_sum r S (\s. ring_pow r (c s) (d-a)))
        )
      )
`,
  intro THEN
  specialize[`r:R ring`;`c:X->R`;`S:X->bool`;`d:num`](GSYM newton_identities) THEN
  simp[] THEN
  num_linear_fact `0 <= d` THEN
  have `FINITE (0..d)` [FINITE_NUMSEG] THEN
  have `0 IN 0..d` [IN_NUMSEG_0] THEN
  have `ring_mul(r:R ring) (if 0 <= CARD S then coeff (CARD S - 0) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s:X. ring_pow r (c s) (d - 0))) IN ring_carrier r` [RING_MUL;RING_SUM;coeff_poly_in_ring;monic_vanishing_at_poly;RING_0] THEN
  specialize[`r:R ring`;`\a. ring_mul(r:R ring) (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s:X. ring_pow r (c s) (d - a)))`;`0..d`;`0:num`]RING_SUM_DELETE THEN
  subgoal `1..d = (0..d) DELETE 0` THENL [
    rw[EXTENSION;IN_DELETE;IN_NUMSEG] THEN
    ARITH_TAC
  ; pass
  ] THEN
  simp[] THEN
  have `ring_sum r (0..d) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s:X. ring_pow r (c s) (d - a)))) IN ring_carrier(r:R ring)` [RING_SUM] THEN
  have `ring_mul r (coeff (CARD S - 0) (monic_vanishing_at r S c)) (ring_sum r S (\s:X. ring_pow r (c s) (d - 0))) IN ring_carrier(r:R ring)` [RING_SUM;RING_MUL;monic_vanishing_at_poly;coeff_poly_in_ring] THEN
  simp[RING_RULE `ring_sub(r:R ring) x (ring_sub r x y) = y`] THEN
  simp[ARITH_RULE `x - 0 = x`] THEN
  simp[topcoeff_monic_vanishing_at] THEN
  qed[RING_MUL_LID;RING_SUM]
);;
```

### Informal statement
For any ring `r`, any function `c` from a type `X` to the carrier of `r`, any finite set `S` of type `X`, and any natural number `d`, if `c s` is in the carrier of `r` for all `s` in `S`, then the ring sum of `(c s) ^ d` over all `s` in `S` is equal to the ring subtraction of the following two terms:
1. If `d` is less than or equal to `CARD S - 1`, then the coefficient of `x^(CARD S - 1 - d)` in the derivative of the monic polynomial vanishing at `S` under `c`; otherwise, `0`.
2. The ring sum, over `a` from 1 to `d`, of the ring product of:
    - If `a` is less than or equal to `CARD S`, then the coefficient of `x^(CARD S - a)` in the monic polynomial vanishing at `S` under `c`; otherwise, `0`.
    - The ring sum of `(c s) ^ (d - a)` over all `s` in `S`.

### Informal sketch
The proof proceeds by specializing the general Newton's Identities (`newton_identities`) to specific variables, then simplifying. The main idea is to split the ring sum from `0` to `d` into deleting `0` and summing from `1` to `d`, then using arithmetic simplifications, rewriting using `EXTENSION`, `IN_DELETE`, `IN_NUMSEG` and `ARITH_TAC`. Simplification rules like `ring_sub x (ring_sub x y) = y` and `x - 0 = x` are used, followed by rewriting with `topcoeff_monic_vanishing_at`. Finally, `RING_MUL_LID` and `RING_SUM` are applied.

### Mathematical insight
This recurrence expresses the power sum symmetric polynomials in terms of the coefficients of the polynomial having the elements of `S` (evaluated by `c`) as roots. This provides a recursive method to compute power sums.

### Dependencies
- `newton_identities`
- `FINITE_NUMSEG`
- `IN_NUMSEG_0`
- `RING_MUL`
- `RING_SUM`
- `coeff_poly_in_ring`
- `monic_vanishing_at_poly`
- `RING_0`
- `RING_SUM_DELETE`
- `EXTENSION`
- `IN_DELETE`
- `IN_NUMSEG`
- `RING_RULE ring_sub(r:R ring) x (ring_sub r x y) = y`
- `ARITH_RULE x - 0 = x`
- `topcoeff_monic_vanishing_at`
- `RING_MUL_LID`

### Porting notes (optional)
The proof relies heavily on simplification and arithmetic reasoning. Ensure that the target proof assistant has comparable automation for these areas. The handling of dependent types (e.g., `X->R ring`) might require adaptation depending on the target system.


---

## powersums_subring_if_poly_subring

### Name of formal statement
powersums_subring_if_poly_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powersums_subring_if_poly_subring = prove(`
  !(r:R ring) G S c:X->R d.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  (!n. coeff n (monic_vanishing_at r S c) IN ring_carrier(subring_generated r G)) ==>
  ring_sum r S (\s. ring_pow r (c s) d) IN ring_carrier(subring_generated r G)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby num_WF THEN
  intro THEN
  specialize[`r:R ring`;`c:X->R`;`S:X->bool`;`d:num`]newton_identities_recurrence THEN
  have `ring_0(r:R ring) IN ring_carrier(subring_generated r G)` [RING_0;SUBRING_GENERATED] THEN
  specialize[`r:R ring`;`monic_vanishing_at r S (c:X->R)`;`CARD(S:X->bool) - 1 - d`]coeff_x_derivative THEN
  have `ring_of_num(r:R ring) (CARD(S:X->bool)-1-d+1) IN ring_carrier(subring_generated r G)` [RING_OF_NUM;RING_OF_NUM_SUBRING_GENERATED] THEN
  have `coeff (CARD S-1-d+1) (monic_vanishing_at r S (c:X->R)) IN ring_carrier(subring_generated r G)` [] THEN
  specialize[`subring_generated(r:R ring) G`;`ring_of_num(r:R ring) (CARD(S:X->bool) - 1 - d + 1)`;`coeff (CARD S - 1 - d + 1) (monic_vanishing_at r S (c:X->R))`]RING_MUL THEN
  have `ring_mul (subring_generated r G) (ring_of_num r (CARD S - 1 - d + 1)) (coeff (CARD S - 1 - d + 1) (monic_vanishing_at r S c)) = ring_mul r (ring_of_num r (CARD S - 1 - d + 1)) (coeff (CARD S - 1 - d + 1) (monic_vanishing_at r S (c:X->R)))` [SUBRING_GENERATED] THEN
  have `ring_mul r (ring_of_num r (CARD S - 1 - d + 1)) (coeff (CARD S - 1 - d + 1) (monic_vanishing_at r S (c:X->R))) IN ring_carrier(subring_generated r G)` [] THEN
  have `coeff(CARD S - 1 - d) (x_derivative r (monic_vanishing_at r S (c:X->R))) IN ring_carrier(subring_generated r G)` [RING_MUL] THEN
  subgoal `!a. a IN (1..d) ==> ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s:X. ring_pow r (c s) (d - a))) IN ring_carrier(subring_generated(r:R ring) G)` THENL [
    intro THEN
    have `!m. m < d ==> ring_sum r S (\s:X. ring_pow r (c s:R) m) IN ring_carrier (subring_generated r G)` [] THEN
    have `1 <= a` [IN_NUMSEG] THEN
    have `a <= d:num` [IN_NUMSEG] THEN
    num_linear_fact `1 <= a /\ a <= d ==> d-a < d` THEN
    have `ring_sum r S (\s:X. ring_pow r (c s:R) (d-a)) IN ring_carrier (subring_generated r G)` [] THEN
    have `(if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) IN ring_carrier(subring_generated r G)` [] THEN
    specialize[`subring_generated(r:R ring) G`;`(if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r)`;`ring_sum r S (\s:X. ring_pow r (c s:R) (d - a))`]RING_MUL THEN
    qed[SUBRING_GENERATED]
  ; pass
  ] THEN
  specialize[`r:R ring`;`G:R->bool`;`1..d`;`\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (d - a)))`](GSYM ring_sum_subring_generated_v2) THEN
  specialize[`subring_generated(r:R ring) G`;`1..d`;`\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (d - a)))`]RING_SUM THEN
  have `(if d <= CARD S - 1 then coeff (CARD S - 1 - d) (x_derivative r (monic_vanishing_at r S (c:X->R))) else ring_0 r) IN ring_carrier(subring_generated r G)` [] THEN
  specialize[`subring_generated(r:R ring) G`;`if d <= CARD S - 1 then coeff (CARD S - 1 - d) (x_derivative r (monic_vanishing_at r S (c:X->R))) else ring_0 r`;`ring_sum (subring_generated r G) (1..d) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (d - a))))`]RING_SUB THEN
  have `ring_sub r (if d <= CARD S - 1 then coeff (CARD S - 1 - d) (x_derivative r (monic_vanishing_at r S (c:X->R))) else ring_0 r) (ring_sum (subring_generated r G) (1..d) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (d - a))))) IN ring_carrier (subring_generated r G)` [RING_SUB_SUBRING_GENERATED] THEN
  have `ring_sub r (if d <= CARD S - 1 then coeff (CARD S - 1 - d) (x_derivative r (monic_vanishing_at r S (c:X->R))) else ring_0 r) (ring_sum r (1..d) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (d - a))))) IN ring_carrier (subring_generated r G)` [] THEN
  qed[]
);;
```
### Informal statement
Let `r` be a ring, `G` be a subset of the ring carrier of `r`, `S` be a finite set, `c` be a function from `X` to the ring carrier of `r`, and `d` be a natural number. If for every `s` in `S`, `c s` is in the ring carrier of `r`, and for every `n`, the coefficient of `n` in the monic polynomial vanishing at `r S c` is in the ring carrier of the subring generated by `G`, then the ring sum of `r` over `S` of `ring_pow r (c s) d` is in the ring carrier of the subring generated by `G`.

### Informal sketch
The proof proceeds by induction on `d`.

- Base Case: The base case follows easily since `ring_0` is in `ring_carrier(subring_generated r G)`.
- Inductive Step: Assume that for all `m < d`, `ring_sum r S (\s:X. ring_pow r (c s:R) m)` is in `ring_carrier (subring_generated r G)`.
  - Use `newton_identities_recurrence` to express `ring_sum r S (\s:X. ring_pow r (c s:R) d)` in terms of `coeff`, `ring_sum`, and `ring_pow` with smaller exponents.
  - Show that `ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (d - a)))` `IN ring_carrier(subring_generated(r:R ring) G)` for each `a IN (1..d)`. This uses the inductive hypothesis as well as the assumption on the coefficients of `monic_vanishing_at r S c`.
  - Combine the above facts to conclude that `ring_sum r S (\s. ring_pow r (c s) d)` is in `ring_carrier (subring_generated r G)`.

### Mathematical insight
This theorem relates the membership of powersums of elements in a set `S` to the subring generated by a set G, conditional on the coefficients of certain polynomials vanishing on S being in the same subring. The result depends on Newton's identities that relates these power sums to the coefficients (elementary symmetric polynomials).

### Dependencies
- `newton_identities_recurrence`
- `RING_0`
- `SUBRING_GENERATED`
- `coeff_x_derivative`
- `RING_OF_NUM`
- `RING_OF_NUM_SUBRING_GENERATED`
- `RING_MUL`
- `IN_NUMSEG`
- `GSYM ring_sum_subring_generated_v2`
- `RING_SUM`
- `RING_SUB`
- `RING_SUB_SUBRING_GENERATED`


---

## powersums_subring_if_poly_subring_denominators_waterfall

### Name of formal statement
powersums_subring_if_poly_subring_denominators_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powersums_subring_if_poly_subring_denominators_waterfall = prove(`
  !(r:R ring) G S c:X->R D.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  D IN ring_carrier r ==>
  (!i. ring_mul r
         (ring_pow r D i)
         (coeff (CARD S - i) (monic_vanishing_at r S c))
       IN ring_carrier(subring_generated r G)) ==>
  !j.
  ring_mul r
    (ring_pow r D j)
    (ring_sum r S (\s. ring_pow r (c s) j))
  IN ring_carrier(subring_generated r G)
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  sufficesby num_WF THEN
  intro THEN
  case `j = 0` THENL [
    simp[RING_POW_0;ring_sum_1] THEN
    simp[RING_MUL_LID;RING_OF_NUM] THEN
    qed[RING_OF_NUM_SUBRING_GENERATED;RING_OF_NUM]
  ; pass
  ] THEN
  labelspecialize "newton" [`r:R ring`;`c:X->R`;`S:X->bool`;`j:num`] newton_identities_recurrence THEN
  (ASM once_rw)[] THEN
  removelabeled "newton" THEN
  rw[coeff_x_derivative] THEN
  have `coeff (CARD S-1-j+1) (monic_vanishing_at r S (c:X->R)) IN ring_carrier r` [coeff_poly_in_ring;monic_vanishing_at_poly] THEN
  have `ring_pow r D j IN ring_carrier(r:R ring)` [RING_POW] THEN
  have `(if j <= CARD S - 1 then ring_mul r (ring_of_num r (CARD S - 1 - j + 1)) (coeff (CARD S - 1 - j + 1) (monic_vanishing_at r S (c:X->R))) else ring_0 r) IN ring_carrier r` [RING_MUL;RING_OF_NUM;RING_0] THEN
  have `ring_sum r (1..j) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - a)))) IN ring_carrier r` [RING_SUM] THEN
  labelspecialize "distrib" [`r:R ring`;`ring_pow(r:R ring) D j`;`if j <= CARD S - 1 then ring_mul r (ring_of_num r (CARD S - 1 - j + 1)) (coeff (CARD S - 1 - j + 1) (monic_vanishing_at r S (c:X->R))) else ring_0 r`;`ring_sum r (1..j) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - a))))`]RING_SUB_LDISTRIB THEN
  simp[] THEN
  removelabeled "distrib" THEN
  have `FINITE (1..j)` [FINITE_NUMSEG] THEN
  have `!a. a IN (1..j) ==> ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - a))) IN ring_carrier r` [RING_MUL;coeff_poly_in_ring;monic_vanishing_at_poly;RING_SUM;RING_0] THEN
  labelspecialize "distrib2" [`r:R ring`;`\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - a)))`;`ring_pow(r:R ring) D j`;`1..j`](GSYM RING_SUM_LMUL) THEN
  simp[] THEN
  removelabeled "distrib2" THEN
  subgoal `ring_mul r (ring_pow r D j) (if j <= CARD S - 1 then ring_mul r (ring_of_num r (CARD S - 1 - j + 1)) (coeff (CARD S - 1 - j + 1) (monic_vanishing_at r S (c:X->R))) else ring_0 r) IN ring_carrier(subring_generated r G)` THENL [
    case `j <= CARD(S:X->bool) - 1` THENL [
      have `ring_of_num(r:R ring) (CARD(S:X->bool)-1-j+1) IN ring_carrier r` [RING_OF_NUM] THEN
      simp[RING_MUL_ASSOC] THEN
      simp[RING_MUL_SYM] THEN
      simp[GSYM RING_MUL_ASSOC] THEN
      have `ring_mul r (ring_pow r D j) (coeff (CARD S - j) (monic_vanishing_at r S (c:X->R))) IN ring_carrier (subring_generated r G)` [] THEN
      num_linear_fact `~(j = 0) ==> j <= CARD(S:X->bool) - 1 ==> CARD S - 1 - j + 1 = CARD S - j` THEN
      have `ring_mul r (ring_pow r D j) (coeff (CARD S - j) (monic_vanishing_at r S (c:X->R))) IN ring_carrier (subring_generated r G)` [] THEN
      have `ring_mul r (ring_pow r D j) (coeff (CARD S - 1 - j + 1) (monic_vanishing_at r S (c:X->R))) IN ring_carrier (subring_generated r G)` [] THEN
      have `ring_of_num(r:R ring) (CARD(S:X->bool) - 1 - j + 1) IN ring_carrier(subring_generated r G)` [RING_OF_NUM_SUBRING_GENERATED;RING_OF_NUM] THEN
      qed[SUBRING_GENERATED;RING_MUL]
    ; pass
    ] THEN
    simp[] THEN
    have `ring_mul(r:R ring) (ring_pow r D j) (ring_0 r) = ring_0 r` [RING_MUL_RZERO;RING_POW] THEN
    qed[RING_0;SUBRING_GENERATED]
  ; pass
  ] THEN
  subgoal `ring_sum r (1..j) (\x. ring_mul r (ring_pow r D j) (ring_mul r (if x <= CARD S then coeff (CARD S - x) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - x))))) IN ring_carrier(subring_generated r G)` THENL [
    subgoal `!x. x IN 1..j ==> ring_mul r (ring_pow r D j) (ring_mul r (if x <= CARD S then coeff (CARD S - x) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - x)))) IN ring_carrier(subring_generated r G)` THENL [
      intro THEN
      case `x <= CARD(S:X->bool)` THENL [
        have `x <= j:num` [IN_NUMSEG] THEN
        num_linear_fact `x <= j:num ==> x + (j-x) = j` THEN
        have `ring_pow(r:R ring) D j = ring_mul r (ring_pow r D x) (ring_pow r D (j-x))` [RING_POW_ADD] THEN
        simp[] THEN
        have `ring_pow(r:R ring) D x IN ring_carrier r` [RING_POW] THEN
        have `ring_pow(r:R ring) D (j-x) IN ring_carrier r` [RING_POW] THEN
        have `ring_sum r S (\s:X. ring_pow r (c s:R) (j-x)) IN ring_carrier r` [RING_SUM] THEN
        have `coeff (CARD S-x) (monic_vanishing_at r S (c:X->R)) IN ring_carrier r` [coeff_poly_in_ring;monic_vanishing_at_poly] THEN
        specialize[`r:R ring`
          ;`coeff(CARD S-x) (monic_vanishing_at r S (c:X->R))`
          ;`ring_sum r S (\s:X. ring_pow r (c s:R) (j - x))`
          ;`ring_pow(r:R ring) D x`
          ;`ring_pow(r:R ring) D (j-x)`;
        ](GENL[`r:R ring`;`a:R`;`b:R`;`x:R`;`y:R`](
          RING_RULE `ring_mul(r:R ring) (ring_mul r x y) (ring_mul r a b) = ring_mul r (ring_mul r x a) (ring_mul r y b)`
        )) THEN
        simp[] THEN
        have `!s:X. s IN S ==> ring_pow r (c s:R) (j-x) IN ring_carrier r` [RING_POW] THEN
        have `1 <= x` [IN_NUMSEG] THEN
        num_linear_fact `1 <= x ==> x <= j ==> j-x < j` THEN
        have `ring_mul r (ring_pow r D (j-x)) (ring_sum r S (\s:X. ring_pow r (c s:R) (j-x))) IN ring_carrier(subring_generated r G)` [] THEN
        have `ring_mul(subring_generated r G) (ring_mul r (ring_pow r D x) (coeff (CARD S - x) (monic_vanishing_at r S (c:X->R)))) (ring_mul r (ring_pow r D (j - x)) (ring_sum r S (\s. ring_pow r (c s) (j - x)))) IN ring_carrier (subring_generated r G)` [RING_MUL] THEN
        qed[SUBRING_GENERATED]
      ; pass
      ] THEN
      simp[RING_MUL_LZERO;RING_SUM;RING_MUL_RZERO;RING_POW] THEN
      qed[RING_0;SUBRING_GENERATED]
    ; pass
    ] THEN
    specialize[`r:R ring`;`G:R->bool`;`1..j`;`\x. ring_mul r (ring_pow r D j) (ring_mul r (if x <= CARD S then coeff (CARD S - x) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - x))))`](GSYM ring_sum_subring_generated_v2) THEN
    simp[] THEN
    qed[RING_SUM]
  ; pass
  ] THEN
  have `ring_sub(subring_generated r G) (ring_mul r (ring_pow r D j) (if j <= CARD S - 1 then ring_mul r (ring_of_num r (CARD S - 1 - j + 1)) (coeff (CARD S - 1 - j + 1) (monic_vanishing_at r S (c:X->R))) else ring_0 r)) (ring_sum r (1..j) (\x. ring_mul r (ring_pow r D j) (ring_mul r (if x <= CARD S then coeff (CARD S - x) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (j - x)))))) IN ring_carrier (subring_generated r G)` [RING_SUB] THEN
  qed[RING_SUB_SUBRING_GENERATED]
);;
```

### Informal statement
Let `r` be a ring, `G` a subset of the ring carrier of `r` which generates a subring. Let `S` be a finite set, and `c` a function from `X` to the ring carrier of `r` such that for all `s` in `S`, `c s` is in the ring carrier of `r`. Let `D` be an element of the ring carrier of `r`. Suppose that for all `i`, the ring multiplication of `(ring_pow r D i)` and `(coeff (CARD S - i) (monic_vanishing_at r S c))` is in the carrier set of the subring generated by `G`. Then, for all `j`, the ring multiplication of `(ring_pow r D j)` and `(ring_sum r S (\s. ring_pow r (c s) j))` is in the carrier set of the subring generated by `G`.

### Informal sketch
The proof proceeds by induction on `j`.

- Base case: `j = 0`.  We show that `(ring_pow r D 0)` * `(ring_sum r S (\s. ring_pow r (c s) 0))` is in the subring generated by `G`. Reducing `ring_pow r D 0` to `ring_1 r` and `ring_sum r S (\s. ring_pow r (c s) 0)` to the numerical value `CARD S`, this becomes showing that `ring_of_num r (CARD S)` is in the subring generated by `G`.

- Inductive step: Assume the result holds for all values less than `j`. Apply `newton_identities_recurrence` to express the `j`-th power sum in terms of lower power sums and coefficients of the monic polynomial vanishing on `S`. The recurrence expresses `ring_sum r S (\s. ring_pow r (c s) j)` as a linear combination of coefficients of `(monic_vanishing_at r S c)` and lower power sums `ring_sum r S (\s. ring_pow r (c s) (j - a))`. Then multiply both sides of the Newton identity by `ring_pow r D j`. Using the induction hypothesis, the fact that `ring_mul r (ring_pow r D x) (coeff (CARD S - x) (monic_vanishing_at r S (c:X->R))))` lives inside the subring generated by `G`, along with the subring properties of the generated ring, we conclude that `ring_mul r (ring_pow r D j) (ring_sum r S (\s. ring_pow r (c s) j))` lies in the subring generated by `G`.

### Mathematical insight
This theorem shows that if certain expressions involving powers of an element `D` scaled by coefficients of the monic polynomial vanishing at points in `S` lie in a subring generated by `G`, then expressions involving powers of `D` scaled by power sums of elements in S also lie in the subring generated by `G`. In particular for D=1, it says that the powersums lies in the subring if the polynomials lies in there, which is powersums_subring_if_poly_subring_denominators.

### Dependencies

- ring theory : `RING_OF_NUM_SUBRING_GENERATED`, `RING_OF_NUM`
- ring operations : `RING_POW_0`, `RING_SUM_1`, `RING_MUL_LID`
- polynomial coefficient property: `coeff_x_derivative`, `coeff_poly_in_ring`
- polynomial construction:`monic_vanishing_at_poly`
- set theory: `FINITE_NUMSEG`,`IN_NUMSEG`
- tactic :`GSYM`
- fundamental theorem: `newton_identities_recurrence`

### Porting notes (optional)
- The tactic `num_linear_fact` likely requires a custom implementation in other proof assistants.
- The `labelspecialize` and `removelabeled` tactics are specific to HOL Light's proof management, and should be translated into analogous operations for managing assumptions in other systems.


---

## powersums_subring_if_poly_subring_denominators

### Name of formal statement
powersums_subring_if_poly_subring_denominators

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powersums_subring_if_poly_subring_denominators = prove(`
  !(r:R ring) G S c:X->R D j.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  D IN ring_carrier r ==>
  (!i. ring_mul r
         (ring_pow r D i)
         (coeff (CARD S - i) (monic_vanishing_at r S c))
       IN ring_carrier(subring_generated r G)) ==>
  ring_mul r
    (ring_pow r D j)
    (ring_sum r S (\s. ring_pow r (c s) j))
  IN ring_carrier(subring_generated r G)
`,
  qed[powersums_subring_if_poly_subring_denominators_waterfall]
);;
```

### Informal statement
Let `r` be a ring, `G` be a subset of the ring carrier of `r`, `S` be a finite set, `c` be a function from `X` to the ring carrier of `r` such that for all `s` in `S`, `c s` is in the ring carrier of `r`, and `D` be an element in the ring carrier of `r`. Suppose that for all `i`, the ring multiplication of `ring_pow r D i` and `coeff (CARD S - i) (monic_vanishing_at r S c)` is in the ring carrier of the subring generated by `G`. Then for all `j`, the ring multiplication of `ring_pow r D j` and the ring sum of `ring_pow r (c s) j` over all `s` in `S` is in the ring carrier of the subring generated by `G`.

### Informal sketch
The proof proceeds by induction on the size of the set `S`.
- The base case, when `S` is empty, is straightforward.
- In the inductive step, assume the theorem holds for sets of size `n`. Let `S` be a set of size `n+1`.
- Let `a` be an element in `S`, and let `S'` be `S` without `a`.
- The theorem will hold for `S'` and `c` restricted to `S'`: `ring_mul r (ring_pow r D j) (ring_sum r S' (\s. ring_pow r (c s) j)) IN ring_carrier(subring_generated r G)`.
- The key idea is to relate the power sum over `S` to the power sum over `S'` and the coefficients of the monic vanishing polynomial `monic_vanishing_at r S c`. Specifically, use Newton's identities to show that `ring_mul r (ring_pow r D j) (ring_sum r S (\s. ring_pow r (c s) j))` can be expressed as a combination of terms that are in `ring_carrier(subring_generated r G)` by the inductive hypothesis and the assumption.
- The term `monic_vanishing_at r S c` is a monic polynomial of degree `CARD S` which vanishes at all points in `S`. Its coefficients determine a recursive relation on the sums of the j-th powers of the roots.
- The coefficients `coeff (CARD S - i) (monic_vanishing_at r S c)` multiplied by powers of `D` are in `ring_carrier(subring_generated r G)` by an assumption.
- Use `powersums_subring_if_poly_subring_denominators_waterfall` to generalize the proof.

### Mathematical insight
This theorem provides a sufficient condition for power sums of elements of a finite set `S` to belong to the subring generated by `G`. The condition states that certain expressions involving the coefficients of the monic vanishing polynomial for `S` must belong to the subring generated by `G`. It's useful in contexts where you want to show that certain symmetric expressions (power sums) lie in a particular subring.

### Dependencies
- `powersums_subring_if_poly_subring_denominators_waterfall`


---

## newton_identities_reverse

### Name of formal statement
newton_identities_reverse

### Type of the formal statement
theorem

### Formal Content
```ocaml
let newton_identities_reverse = prove(`
  !(r:R ring) c:X->R S n.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  n <= CARD S ==>
  ring_mul r (
    ring_neg r (ring_of_num r n)
  ) (
    coeff(CARD S - n) (monic_vanishing_at r S c)
  )
  =
  ring_sum r (1..n) (\a.
    ring_mul r (
      coeff(CARD S - (n - a)) (monic_vanishing_at r S c)
    ) (
      ring_sum r S (\s. ring_pow r (c s) a)
    )
  )
`,
  intro THEN
  have `ring_polynomial r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_poly] THEN
  case `n = 0` THENL [
    have `1..n = {}` [EMPTY_NUMSEG;ARITH_RULE `0 < 1`] THEN
    simp[RING_OF_NUM_0;RING_NEG_0;RING_SUM_CLAUSES;RING_MUL_LZERO;coeff_poly_in_ring]
  ; pass
  ] THEN
  specialize[`r:R ring`;`c:X->R`;`S:X->bool`;`n:num`]newton_identities THEN
  subgoal `ring_sum r (0..n) (\a. ring_mul r (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (n - a)))) = ring_mul r (ring_of_num r (CARD S - n)) (coeff (CARD S - n) (monic_vanishing_at r S c))` THENL [
    subgoal `(if n <= CARD S - 1 then coeff (CARD S - 1 - n) (x_derivative r (monic_vanishing_at r S (c:X->R))) else ring_0 r) = ring_mul r (ring_of_num r (CARD S - n)) (coeff (CARD S - n) (monic_vanishing_at r S c))` THENL [
      rw[coeff_x_derivative] THEN
      case `n = CARD(S:X->bool):num` THENL [
        num_linear_fact `~(n = 0) ==> n = CARD(S:X->bool) ==> ~(n <= CARD S - 1)` THEN
        have `ring_polynomial r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_poly] THEN
        simp[ARITH_RULE `CARD(S:X->bool) - CARD S = 0`;RING_OF_NUM_0;RING_NEG_0;RING_SUM_CLAUSES;RING_MUL_LZERO;coeff_poly_in_ring]
      ; pass
      ] THEN
      num_linear_fact `~(n = 0) ==> ~(n = CARD(S:X->bool)) ==> n <= CARD S ==> n <= CARD S - 1` THEN
      num_linear_fact `~(n = 0) ==> ~(n = CARD(S:X->bool)) ==> n <= CARD S ==> CARD S - 1 - n + 1 = CARD S - n` THEN
      simp[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_sum r (0..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) b))) = ring_mul r (ring_of_num r (CARD S - n)) (coeff (CARD S - n) (monic_vanishing_at r S c))` THENL [
    specialize[
      `r:R ring`;
      `n:num`;
      `\a. ring_mul(r:R ring) (if a <= CARD S then coeff (CARD S - a) (monic_vanishing_at r S c) else ring_0 r) (ring_sum r S (\s:X. ring_pow r (c s) (n - a)))`
    ]ring_sum_numseg_le_reflect THEN
    subgoal `ring_sum r (0..n) (\b. ring_mul r (if n - b <= CARD S then coeff (CARD S - (n - b)) (monic_vanishing_at r S (c:X->R)) else ring_0 r) (ring_sum r S (\s. ring_pow r (c s) (n - (n - b))))) = ring_sum r (0..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) (b))))` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      rw[BETA_THM] THEN
      subgoal `ring_sum r S (\s. ring_pow r (c(s:X):R) (n - (n - a))) = ring_sum r S (\s. ring_pow r (c s) a)` THENL [
        sufficesby RING_SUM_EQ THEN
        intro THEN
        rw[BETA_THM] THEN
        have `a <= n:num` [IN_NUMSEG] THEN
        num_linear_fact `a <= n: num ==> n - (n - a) = a` THEN
        qed[]
      ; pass
      ] THEN
      num_linear_fact `n <= CARD S ==> n - a <= CARD(S:X->bool)` THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_add r (ring_mul r (coeff (CARD S - (n - 0)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) 0))) (ring_sum r (0 + 1..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S c)) (ring_sum r S (\s. ring_pow r (c s) b)))) = ring_mul r (ring_of_num r (CARD S - n)) (coeff (CARD S - n) (monic_vanishing_at r S c))` THENL [
    num_linear_fact `0 <= n` THEN
    specialize[
      `r:R ring`;
      `\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) b))`;
      `0`;
      `n:num`;
    ]RING_SUM_CLAUSES_LEFT THEN
    have `ring_mul r (coeff (CARD S - (n - 0)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) 0)) IN ring_carrier r` [RING_MUL;coeff_poly_in_ring;monic_vanishing_at_poly;RING_SUM] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_add r (ring_mul r (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))) (ring_of_num r (CARD S))) (ring_sum r (1..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S c)) (ring_sum r S (\s. ring_pow r (c s) b)))) = ring_mul r (ring_of_num r (CARD S - n)) (coeff (CARD S - n) (monic_vanishing_at r S c))` THENL [
    subgoal `ring_add r (ring_mul r (coeff (CARD S - (n - 0)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) 0))) (ring_sum r (0 + 1..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S c)) (ring_sum r S (\s. ring_pow r (c s) b)))) = ring_add r (ring_mul r (coeff (CARD S - n) (monic_vanishing_at r S c)) (ring_of_num r (CARD S))) (ring_sum r (1..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S c)) (ring_sum r S (\s. ring_pow r (c s) b))))` THENL [
      rw[ARITH_RULE `0 + 1 = 1`] THEN
      rw[ARITH_RULE `n - 0 = n`] THEN
      rw[RING_POW_0] THEN
      simp[ring_sum_1]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_add r (ring_mul r (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))) (ring_of_num r (CARD S))) (ring_sum r (1..n) (\b. ring_mul r (coeff (CARD S - (n - b)) (monic_vanishing_at r S c)) (ring_sum r S (\s. ring_pow r (c s) b)))) = ring_add r (ring_mul r (coeff (CARD S - n) (monic_vanishing_at r S c)) (ring_of_num r (CARD S))) (ring_mul r (ring_neg r (ring_of_num r n)) (coeff (CARD S - n) (monic_vanishing_at r S c)))` THENL [
    subgoal `ring_mul r (ring_of_num r (CARD S - n)) (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))) = ring_add r (ring_mul r (coeff (CARD S - n) (monic_vanishing_at r S c)) (ring_of_num r (CARD S))) (ring_mul r (ring_neg r (ring_of_num r (n))) (coeff (CARD S - n) (monic_vanishing_at r S c)))` THENL [
      num_linear_fact `n <= CARD(S:X->bool) ==> CARD S = (CARD S - n) + n` THEN
      have `ring_of_num(r:R ring) (CARD(S:X->bool)) = ring_add r (ring_of_num r (CARD S - n)) (ring_of_num r n)` [RING_OF_NUM_ADD] THEN
      simp[] THEN
      specialize_assuming[
        `r:R ring`;
        `coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))`;
        `ring_of_num(r:R ring) (CARD(S:X->bool) - n)`;
        `ring_of_num(r:R ring) n`;
      ](GENL[
        `r:R ring`;`C:R`;`Sn:R`;`n:R`
      ](RING_RULE `
        ring_mul(r:R ring) Sn C = ring_add r (ring_mul r C (ring_add r Sn n)) (ring_mul r (ring_neg r n) C)
      `)) THEN
      qed[RING_OF_NUM;coeff_poly_in_ring;monic_vanishing_at_poly]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize_assuming[
    `r:R ring`;
    `ring_mul r (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))) (ring_of_num r (CARD S))`;
    `ring_mul r (ring_neg r (ring_of_num r n)) (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R)))`;
    `ring_sum r (1..n) (\a. ring_mul r (coeff (CARD S - (n - a)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) a)))`
  ]RING_ADD_LCANCEL THEN
  qed[RING_OF_NUM;coeff_poly_in_ring;monic_vanishing_at_poly;RING_MUL;RING_SUM;RING_NEG]
);;
```

### Informal statement
For any ring `r`, any function `c` from a type `X` to the carrier of `r`, and any finite set `S` of type `X`, such that for every `s` in `S`, `c s` is an element of the carrier of `r`, and for any natural number `n` such that `n` is less than or equal to the cardinality of `S`, the following equality holds: the product in `r` of the negation in `r` of the representation in `r` of `n` and the coefficient of the term with degree (cardinality of S minus n) in the monic polynomial vanishing at `S` with respect to `c`, is equal to the sum in `r`, from 1 to `n`, of the terms obtained by multiplying in `r` the coefficient of the term with degree (cardinality of S minus (n minus a)) in the monic polynomial vanishing at `S` with respect to `c`, by the sum in `r` over the elements `s` of `S` of the `a`-th power in `r` of `c s`.

### Informal sketch
The proof proceeds by induction and rewriting using the forward Newton identities.

- Base Case: `n = 0`. Simplifies to true by definitions of `ring_of_num`, `ring_neg`, `ring_sum`, `ring_mul`, and `coeff`.
- Inductive Step:
  - Specialize the forward Newton identities (theorem `newton_identities`) with suitable parameters `r`, `c`, `S`, and `n`.
  - Reduce the goal to proving two subgoals.
  - Subgoal 1: Expressing a coefficient related to the derivative of the monic polynomial in terms of coefficients of the polynomial itself. This involves using `coeff_x_derivative` and considering the cases `n = CARD S` and `n <= CARD S - 1`. Also, uses the fact that  `monic_vanishing_at r S c` is a polynomial.
  - Subgoal 2: Rewriting a sum using `ring_sum_numseg_le_reflect` and simplifying. The core step here rewrites the inner summation `ring_sum r S (\s. ring_pow r (c s) (n - (n - a)))` into `ring_sum r S (\s. ring_pow r (c s) a)`.
  - Further steps involve using `RING_SUM_CLAUSES_LEFT`, arithmetic simplification, and the definition of `monic_vanishing_at` to rewrite terms and cancel terms using ring properties such as `RING_ADD_LCANCEL`.
  - These steps transform the equation to a point where it can be simplified to `true`.

### Mathematical insight
This theorem provides a recursive way to compute the coefficients of a polynomial given the power sums of its roots. It's the reverse of the standard Newton's identities, which express power sums in terms of coefficients. This is useful in situations where the power sums are known, and the polynomial coefficients are desired.

### Dependencies
- `ring_sum_numseg_le_reflect`
- `monic_vanishing_at`
- `newton_identities`
- `coeff_x_derivative`
- `ring_of_num`
- `ring_neg`
- `ring_sum`
- `ring_mul`
- `RING_SUM_CLAUSES`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification using algebraic properties of rings.
- The extensive use of `ARITH_RULE` suggests that a robust arithmetic simplifier is needed in the target proof assistant.
- The calls to `specialize` with HOL Light's `GENL` tactic may need adapting to match the method for applying theorems in other assistants.


---

## coeff_poly_subring_if_powersums_subring_lemma

### Name of formal statement
coeff_poly_subring_if_powersums_subring_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_subring_if_powersums_subring_lemma = prove(`
  !(r:R ring) G S c:X->R.
  ring_hasQ(subring_generated r G) ==>
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  (!d. ring_sum r S (\s. ring_pow r (c s) d) IN ring_carrier(subring_generated r G)) ==>
  !n.
  n <= CARD S ==>
  coeff (CARD S - n) (monic_vanishing_at r S c) IN ring_carrier(subring_generated r G)
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  sufficesby num_WF THEN
  intro THEN
  subgoal `ring_mul r (ring_neg r (ring_of_num r n)) (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))) IN ring_carrier (subring_generated r G)` THENL [
    specialize[`r:R ring`;`c:X->R`;`S:X->bool`;`n:num`]newton_identities_reverse THEN
    subgoal `ring_sum r (1..n) (\a. ring_mul r (coeff (CARD S - (n - a)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) a))) IN ring_carrier(subring_generated r G)` THENL [
      sufficesby ring_sum_in_subring THEN
      intro THEN
      rw[BETA_THM] THEN
      sufficesby RING_MUL_IN_SUBRING_GENERATED THEN
      have `1 <= s` [IN_NUMSEG] THEN
      have `s <= n:num` [IN_NUMSEG] THEN
      num_linear_fact `1 <= s ==> s <= n ==> n - s < n` THEN
      num_linear_fact `n - s < n ==> n <= CARD(S:X->bool) ==> n - s <= CARD S` THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  case `n = 0` THENL [
    have `monic r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_monic] THEN
    have `ring_char(r:R ring) = 0` [RING_CHAR_SUBRING_GENERATED;ring_hasQ] THEN
    have `CARD S = poly_deg r (monic_vanishing_at r S (c:X->R))` [deg_monic_vanishing_at;TRIVIAL_RING_10;RING_CHAR_EQ_1;ARITH_RULE `~(1 = 0)`] THEN
    num_linear_fact `n = 0 ==> CARD(S:X->bool) - n = CARD S` THEN
    have `coeff (CARD S - n) (monic_vanishing_at r S (c:X->R)) = ring_1 r` [monic] THEN
    qed[SUBRING_GENERATED;RING_1]
  ; pass
  ] THEN
  have `ring_neg r (ring_of_num r n) = ring_neg(subring_generated(r:R ring) G) (ring_of_num(subring_generated r G) n)` [RING_OF_NUM_SUBRING_GENERATED;SUBRING_GENERATED] THEN
  have `ring_neg r (ring_of_num r n) IN ring_carrier(subring_generated(r:R ring) G)` [RING_OF_NUM;RING_NEG] THEN
  have `ring_unit(subring_generated(r:R ring) G) (ring_neg r (ring_of_num r n))` [ring_hasQ_neg] THEN
  choose `v:R` `v IN ring_carrier(subring_generated(r:R ring) G) /\ ring_mul(subring_generated r G) (ring_neg r (ring_of_num r n)) v = ring_1(subring_generated r G)` [ring_unit] THEN
  specialize_assuming[
    `r:R ring`;
    `coeff (CARD S - n) (monic_vanishing_at r S (c:X->R))`;
    `ring_neg(r:R ring) (ring_of_num r n)`;
    `v:R`
  ](GENL[
    `r:R ring`;`c:R`;`u:R`;`v:R`
  ](RING_RULE `
    ring_mul(r:R ring) u v = ring_1 r ==>
    c = ring_mul r v (ring_mul r u c)
  `)) THEN
  have `coeff (CARD S - n) (monic_vanishing_at r S (c:X->R)) = ring_mul r v (ring_mul r (ring_neg r (ring_of_num r n)) (coeff (CARD S - n) (monic_vanishing_at r S c)))` [coeff_poly_in_ring;monic_vanishing_at_poly;RING_CARRIER_SUBRING_GENERATED_SUBSET;SUBSET;SUBRING_GENERATED] THEN
  have `ring_mul(subring_generated r G) v (ring_mul r (ring_neg r (ring_of_num r n)) (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R)))) IN ring_carrier(subring_generated r G)` [RING_MUL] THEN
  have `ring_mul r v (ring_mul r (ring_neg r (ring_of_num r n)) (coeff (CARD S - n) (monic_vanishing_at r S (c:X->R)))) IN ring_carrier(subring_generated r G)` [SUBRING_GENERATED] THEN
  qed[]
);;
```
### Informal statement
Let `r` be a ring, `G` a subset of the ring carrier of `r`, `S` a finite set, and `c` a function from a type `X` to the ring carrier of `r`. Suppose that the subring generated by `G` has characteristic zero. Also, assume that for every element `s` in `S`, `c s` is in the ring carrier of `r`. Further, suppose that for every natural number `d`, the ring sum of `ring_pow r (c s) d` over all `s` in `S` is in the ring carrier of the subring generated by `G`. Then, for every natural number `n` such that `n` is less than or equal to the cardinality of `S`, the coefficient of degree `CARD S - n` in the monic polynomial vanishing at `S` with values `c` is in the ring carrier of the subring generated by `G`.

### Informal sketch
The proof demonstrates that if the power sums of elements `c s` for `s` in `S` lie in the subring generated by `G`, then the coefficients of the monic polynomial vanishing at `S` with values `c` also lie in the subring generated by `G`.

- The proof begins by induction on `n`.
- The base case `n = 0` is handled separately. In this case, the coefficient is `ring_1 r`, which lies in every subring.
- For the inductive step, assume the statement holds for all values less than `n`.
- The goal is to show that `coeff (CARD S - n) (monic_vanishing_at r S c)` is in `ring_carrier(subring_generated r G)`.
- `newton_identities_reverse` is used to express `coeff (CARD S - n) (monic_vanishing_at r S c)` in terms of power sums and coefficients of lower degrees.
- The main step relies on establishing that `ring_sum r (1..n) (\a. ring_mul r (coeff (CARD S - (n - a)) (monic_vanishing_at r S (c:X->R))) (ring_sum r S (\s. ring_pow r (c s) a)))` is in `ring_carrier(subring_generated r G)`.
- The inductive hypothesis is applied to show that `coeff (CARD S - (n - a)) (monic_vanishing_at r S c)` is in the `ring_carrier` of the generated subring.
- The hypothesis ensures that `ring_sum r S (\s. ring_pow r (c s) a)` is in the `ring_carrier` of the generated subring.
- Finally, using the properties of subrings, we can conclude that the `ring_mul` of these elements is also in the `ring_carrier` of the generated subring, completing the induction.

### Mathematical insight
This theorem is crucial in algebraic settings where one wishes to demonstrate that polynomial coefficients belong to specific rings or fields. The key idea is that if power sums of roots of a polynomial belong to a subring, then under appropriate conditions, the polynomial's coefficients also belong to that subring. The `monic_vanishing_at` polynomial is a standard construction, and its coefficients encode vital information about the roots `S` and values `c`. The reliance on `newton_identities_reverse` highlights the importance of Newton's identities in relating power sums and polynomial coefficients.

### Dependencies
- `ring_hasQ`
- `subring_generated`
- `FINITE`
- `ring_carrier`
- `ring_sum`
- `ring_pow`
- `monic_vanishing_at`
- `coeff`
- `newton_identities_reverse`
- `ring_mul`
- `BETA_THM`
- `monic_vanishing_at_monic`
- `RING_CHAR_SUBRING_GENERATED`
- `deg_monic_vanishing_at`
- `TRIVIAL_RING_10`
- `RING_CHAR_EQ_1`
- `RING_OF_NUM_SUBRING_GENERATED`
- `SUBRING_GENERATED`
- `RING_OF_NUM`
- `RING_NEG`
- `ring_hasQ_neg`
- `ring_unit`
- `RING_RULE`
- `monic_vanishing_at_poly`
- `RING_CARRIER_SUBRING_GENERATED_SUBSET`
- `SUBSET`

### Porting notes (optional)
- The definition and manipulation of subrings and their carrier sets might require explicit handling depending on the target proof assistant.
- The `newton_identities_reverse` theorem is central, so an equivalent statement or computational procedure needs to be available.
- The use of `ring_sum` over a finite set `S` will likely need an equivalent construct in the target system.


---

## coeff_poly_subring_if_powersums_subring

### Name of formal statement
coeff_poly_subring_if_powersums_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_poly_subring_if_powersums_subring = prove(`
  !(r:R ring) G S c:X->R.
  ring_hasQ(subring_generated r G) ==>
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  (!d. ring_sum r S (\s. ring_pow r (c s) d) IN ring_carrier(subring_generated r G)) ==>
  !n.
  coeff n (monic_vanishing_at r S c) IN ring_carrier(subring_generated r G)
`,
  intro THEN
  case `n <= CARD(S:X->bool)` THENL [
    num_linear_fact `n <= CARD(S:X->bool) ==> CARD S - (CARD S - n) = n` THEN
    num_linear_fact `CARD S - n <= CARD(S:X->bool)` THEN
    specialize[
      `r:R ring`;
      `G:R->bool`;
      `S:X->bool`;
      `c:X->R`
    ]coeff_poly_subring_if_powersums_subring_lemma THEN
    qed[]
  ; pass
  ] THEN
  proven_if `coeff n (monic_vanishing_at r S (c:X->R)) = ring_0 r` [RING_0;SUBRING_GENERATED] THEN
  have `ring_polynomial r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_poly] THEN
  have `poly_deg r (monic_vanishing_at r S (c:X->R)) <= CARD S` [deg_monic_vanishing_at_le] THEN
  qed[coeff_deg_le]
);;
```

### Informal statement
For any ring `r`, any subset `G` of the ring carrier of `r`, any set `S`, and any function `c` from `S` to the ring carrier of `r`, if the subring generated by `G` is a Q-ring, `S` is finite, every element in the image of `c` lies in the ring carrier of `r`, and for every natural number `d`, the ring sum of the `d`-th powers of `c s` over all `s` in `S` is in the ring carrier of the subring generated by `G`, then for every natural number `n`, the `n`-th coefficient of the monic vanishing polynomial at `S` with respect to `c` is in the ring carrier of the subring generated by `G`.

### Informal sketch
The proof proceeds by induction on whether `n` is less than or equal to the cardinality of `S`.

- Case `n <= CARD(S)`:
  Specialize the lemma `coeff_poly_subring_if_powersums_subring_lemma` with the given ring `r`, subset `G`, set `S`, and function `c`. This directly proves the goal.

- Case `~(n <= CARD(S))`:
  Use the theorem `proven_if` to show that `coeff n (monic_vanishing_at r S c) = ring_0 r`. This requires `RING_0` and `SUBRING_GENERATED`.
  Show that `monic_vanishing_at r S c` is a ring polynomial using `monic_vanishing_at_poly`.
  Show that the degree of `monic_vanishing_at r S c` is less than or equal to `CARD S` using `deg_monic_vanishing_at_le`.
  Then, use `coeff_deg_le` to conclude the proof.

### Mathematical insight
This theorem provides a sufficient condition for the coefficients of the monic vanishing polynomial to lie within a specified subring of the ring `r`. The condition requires that the power sums of the values of the function `c` on the set `S` lie in the subring generated by `G`. The monic vanishing polynomial at `S` with respect to `c` is the polynomial that evaluates to zero at each `c s` for `s` in `S`. This theorem is useful in algebraic number theory and Galois theory.

### Dependencies
- `ring_hasQ`
- `subring_generated`
- `FINITE`
- `ring_carrier`
- `ring_sum`
- `ring_pow`
- `monic_vanishing_at`
- `coeff`
- `coeff_poly_subring_if_powersums_subring_lemma`
- `RING_0`
- `SUBRING_GENERATED`
- `monic_vanishing_at_poly`
- `deg_monic_vanishing_at_le`
- `coeff_deg_le`


---

## poly_subring_if_powersums_subring

### Name of formal statement
poly_subring_if_powersums_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_subring_if_powersums_subring = prove(`
  !(r:R ring) G S c:X->R.
  ring_hasQ(subring_generated r G) ==>
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  (!d. ring_sum r S (\s. ring_pow r (c s) d) IN ring_carrier(subring_generated r G)) ==>
  ring_polynomial(subring_generated r G) (monic_vanishing_at r S c)
`,
  intro THEN
  have `!n. coeff n (monic_vanishing_at r S (c:X->R)) IN ring_carrier(subring_generated r G)` [coeff_poly_subring_if_powersums_subring] THEN
  have `ring_polynomial r (monic_vanishing_at r S (c:X->R))` [monic_vanishing_at_poly] THEN
  qed[ring_polynomial_subring_if_coeffs]
);;
```

### Informal statement
For any ring `r` with carrier `R`, any set `G` contained in `R`, set `S`, and function `c` from `X` to `R`, if the subring generated by `G` has characteristic zero (i.e., `ring_hasQ(subring_generated r G)`), `S` is finite, for all `s` in `S`, `c s` is in the carrier of the ring `r`, and for any `d`, the sum of `(c s)^d` for all `s` in `S` is in the carrier of the subring generated by `G` (i.e., `ring_sum r S (\s. ring_pow r (c s) d) IN ring_carrier(subring_generated r G)`), then the monic polynomial vanishing at `S` evaluated by `c` (i.e., `monic_vanishing_at r S c`) is a polynomial over the subring generated by `G` (i.e., `ring_polynomial(subring_generated r G) (monic_vanishing_at r S c)`).

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions of the theorem.
- Establish that all coefficients of the monic vanishing polynomial at `S` evaluated by `c` lie in `ring_carrier(subring_generated r G)` using a helper theorem `coeff_poly_subring_if_powersums_subring`.
- Show that `monic_vanishing_at r S (c:X->R)` is a polynomial over `r` (i.e. `ring_polynomial r (monic_vanishing_at r S (c:X->R))`) using the theorem `monic_vanishing_at_poly`.
- Conclude that the monic vanishing polynomial is a polynomial over the subring generated by `G` using `ring_polynomial_subring_if_coeffs`.

### Mathematical insight
This theorem provides a condition under which a monic polynomial vanishing at a set `S` is a polynomial over a subring. The condition involves the power sums of the evaluation of `c` at `S` lying in the carrier of the subring generated by `G`. This is important because it relates the algebraic properties of the roots of a polynomial to the coefficients of the polynomial, and allows us to conclude that certain polynomials are in fact polynomials over subrings under suitable conditions.

### Dependencies
- `ring_hasQ`
- `subring_generated`
- `FINITE`
- `ring_carrier`
- `ring_sum`
- `ring_pow`
- `monic_vanishing_at`
- `ring_polynomial`

The proof also depends on the following theorems:
- `coeff_poly_subring_if_powersums_subring`
- `monic_vanishing_at_poly`
- `ring_polynomial_subring_if_coeffs`


---

## symfun_subring_if_powersums_subring

### Name of formal statement
symfun_subring_if_powersums_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symfun_subring_if_powersums_subring = prove(`
  !(r:R ring) G S c:X->R n.
  ring_hasQ(subring_generated r G) ==>
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  (!d. ring_sum r S (\s. ring_pow r (c s) d) IN ring_carrier(subring_generated r G)) ==>
  ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U c)
  IN ring_carrier(subring_generated r G)
`,
  intro THEN
  case `n <= CARD(S:X->bool)` THENL [
    have `coeff (CARD S - n) (monic_vanishing_at r S (c:X->R)) IN ring_carrier(subring_generated r G)` [coeff_poly_subring_if_powersums_subring] THEN
    have `ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))) IN ring_carrier(subring_generated r G)` [coeff_monic_vanishing_at] THEN
    specialize[`r:R ring`;`n:num`]ring_pow_neg_1_mul_refl THEN
    subgoal `ring_mul r (ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_pow r (ring_neg r (ring_1 r)) n)) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))) IN ring_carrier (subring_generated r G)` THENL [
      have `ring_pow(subring_generated r G) (ring_neg r (ring_1 r)) n:R IN ring_carrier(subring_generated r G)` [RING_POW;SUBRING_GENERATED;RING_NEG;RING_1] THEN
      have `ring_pow r (ring_neg r (ring_1 r)) n:R IN ring_carrier(subring_generated r G)` [RING_POW_SUBRING_GENERATED] THEN
      have `ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R)))) IN ring_carrier (subring_generated r G)` [RING_MUL;SUBRING_GENERATED] THEN
      have `ring_mul r (ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_pow r (ring_neg r (ring_1 r)) n)) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))) = ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))))` [RING_MUL_ASSOC;RING_POW;RING_NEG;RING_1;RING_SUM] THEN
      qed[]
    ; pass
    ] THEN
    have `ring_mul r (ring_1 r) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))) IN ring_carrier (subring_generated r G)` [ring_pow_neg_1_mul_refl] THEN
    qed[RING_MUL_LID;RING_SUM]
  ; pass
  ] THEN
  simp[subsets_card_toobig] THEN
  rw[RING_SUM_CLAUSES] THEN
  qed[SUBRING_GENERATED;RING_0]
);;
```
### Informal statement
Let `r` be a ring, `G` a set, `S` a finite set, and `c` a function from some type `X` to the carrier of `r`.
If the subring generated by `G` has a quotient ring, `S` is finite, the values of `c` on `S` are in the carrier of `r`, and for every natural number `d`, the ring sum of the `d`-th powers of `c s` for `s` in `S` is in the carrier of the subring generated by `G`; then the ring sum over all subsets `U` of `S` of cardinality `n` of the ring product over `U` of `c` is in the subring generated by `G`.

### Informal sketch
The proof proceeds by induction on `n`.
- The base case (`n > CARD S`) is handled by `subsets_card_toobig`, `RING_SUM_CLAUSES` and `SUBRING_GENERATED` (with `RING_0`)
- The inductive step uses the assumption that for all natural numbers `d`, the sums of the `d`-th powers of the elements `c s` for `s` in `S` are in the subring generated by `G`.
- First, prove the case when `n <= CARD S`. We use the theorem `coeff_poly_subring_if_powersums_subring` to show that the coefficient `coeff (CARD S - n) (monic_vanishing_at r S c)` is in the carrier.
- Then, using `coeff_monic_vanishing_at`, we have `ring_mul r (ring_pow r (ring_neg r (ring_1 r)) n) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))) IN ring_carrier(subring_generated r G)`.
- Apply `ring_pow_neg_1_mul_refl` to simplify to `ring_mul r (ring_1 r) (ring_sum r {U | U SUBSET S /\ CARD U = n} (\U. ring_product r U (c:X->R))) IN ring_carrier (subring_generated r G)`.
- Finally, apply `RING_MUL_LID` and `RING_SUM` to obtain the desired result.

### Mathematical insight
This theorem relates power sums of elements in a ring to sums of products of elements, showing that if power sums lie within a subring, then sums of products also lie within that subring. This establishes a connection between these two types of symmetric functions and their containment within subrings, conditioned on the finiteness of the set `S`. The theorem is useful for constructing subrings with specific properties.

### Dependencies
- `RING_HASQ`
- `SUBRING_GENERATED`
- `FINITE`
- `RING_CARRIER`
- `RING_SUM`
- `RING_POW`
- `RING_PRODUCT`
- `SUBSET`
- `CARD`
- `RING_NEG`
- `RING_1`
- `coeff_poly_subring_if_powersums_subring`
- `coeff_monic_vanishing_at`
- `RING_POW_NEG_1_MUL_REFL`
- `RING_POW`
- `RING_MUL`
- `RING_MUL_ASSOC`
- `subsets_card_toobig`
- `RING_SUM_CLAUSES`
- `RING_0`
- `RING_MUL_LID`
- `RING_POW_SUBRING_GENERATED`

### Porting notes (optional)
- The proof depends on properties of finite sets and rings, which are standard in most proof assistants. Ensure that analogous lemmas about cardinality and subrings are available.
- The use of `ring_sum` and `ring_product` might require adaptation depending on how sums and products over sets are defined in the target system.


---

## pow_newton_identities_natural

### Name of formal statement
pow_newton_identities_natural

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_newton_identities_natural = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_mul r
    (poly_product r S (\s.
       poly_pow r (one_minus_constx r (c s)) (e+1)
    ))
    (poly_sum r S (\s.
       series_from_coeffs (\n.
         ring_mul r
           (ring_of_num r (binom(n+e,e)))
           (ring_pow r (c s) n)
       )
    ))
  = poly_sum r S (\t.
      poly_product r (S DELETE t) (\s.
        poly_pow r (one_minus_constx r (c s)) (e+1)
      )
    )
`,
  rw[x_series_use] THEN
  rw[poly_product;poly_sum] THEN
  intro THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_series] THEN
  have `!s:X. s IN S ==> one_minus_constx r (c s) IN ring_carrier(x_series(r:R ring))` [x_series_carrier;SET_RULE `ring_powerseries(r:R ring) (p:(1->num)->R) ==> p IN {q | ring_powerseries r q}`] THEN
  have `!s:X. s IN S ==> poly_pow r (one_minus_constx r (c s)) (e+1) IN ring_carrier(x_series(r:R ring))` [x_series_use_pow;RING_POW] THEN
  def `q:X->(1->num)->R` `\s:X. series_from_coeffs (\n. ring_mul(r:R ring) (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n))` THEN
  have `!s:X n:num. s IN S ==> ring_mul(r:R ring) (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n) IN ring_carrier r` [RING_OF_NUM;RING_POW;RING_MUL] THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (q s:(1->num)->R)` [series_series_from_coeffs] THEN
  have `!s:X. s IN S ==> q s IN ring_carrier(x_series(r:R ring))` [x_series_carrier;SET_RULE `ring_powerseries(r:R ring) (p:(1->num)->R) ==> p IN {q | ring_powerseries r q}`] THEN
  subgoal `!s:X. s IN S ==> poly_mul(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1)) (q s) = poly_1 r` THENL [
    intro THEN
    have `c(s:X) IN ring_carrier(r:R ring)` [] THEN
    specialize[`r:R ring`;`c(s:X):R`;`e:num`]pow_infinite_geometric_series_inverse THEN
    qed[]
  ; pass
  ] THEN
  have `!s:X. s IN S ==> ring_mul (x_series(r:R ring)) (poly_pow r (one_minus_constx r (c s)) (e+1)) (q s) = ring_1(x_series r)` [x_series_use] THEN
  specialize[`x_series(r:R ring)`;`\s:X. poly_pow r (one_minus_constx(r:R ring) (c s)) (e+1)`;`q:X->(1->num)->R`;`S:X->bool`](product_times_sum_reciprocals) THEN
  qed[RING_SUM_EQ]
);;
```

### Informal statement
For any ring `r` and any function `c` from a type `X` to the carrier of `r`, for any finite set `S` of type `X`, if for all `s` in `S`, `c s` is in the carrier of ring `r`, then the following equation holds:
```
poly_mul r
    (poly_product r S (\s.
       poly_pow r (one_minus_constx r (c s)) (e+1)
    ))
    (poly_sum r S (\s.
       series_from_coeffs (\n.
         ring_mul r
           (ring_of_num r (binom(n+e,e)))
           (ring_pow r (c s) n)
       )
    ))
  = poly_sum r S (\t.
      poly_product r (S DELETE t) (\s.
        poly_pow r (one_minus_constx r (c s)) (e+1)
      )
    )
```
where:
*   `poly_mul r p1 p2` denotes polynomial multiplication in the ring `r`
*   `poly_product r S f` denotes the product of polynomials `f s` for `s` in `S` within the ring `r`.
*   `poly_pow r p n` denotes polynomial `p` to the power of `n` in ring `r`.
*   `one_minus_constx r c` represents the polynomial `1 - c*x` in ring `r` where c is a constant.
*   `poly_sum r S f` denotes the sum of polynomials `f s` for `s` in `S` in the ring `r`.
*   `series_from_coeffs f` creates a power series from the coefficient function `f`.
*   `ring_mul r a b` is ring multiplication between a and b within ring `r`
*   `ring_of_num r n` converts the natural number `n` to an element of the ring `r`.
*   `binom(n, k)` denotes the binomial coefficient "n choose k".
*   `ring_pow r a n` is ring exponentiation of a to the power of `n` in ring `r`.
*   `S DELETE t` represents the set `S` with the element `t` removed.
*   `poly_1 r` represents the polynomial `1` in ring `r`

### Informal sketch
The proof proceeds by the following steps:
*   Rewrite using `x_series_use`, `poly_product`, and `poly_sum` to express terms as polynomials.
*   Introduce assumptions.
*   Establish that, for any `s` in `S`, `one_minus_constx r (c s)` has a power series representation, and that `one_minus_constx r (c s)` is in the carrier of the ring `x_series(r:R ring)`. Also, `poly_pow r (one_minus_constx r (c s)) (e+1)` is in the carrier of the ring `x_series(r:R ring)`.
*   Define a function `q s` representing the power series derived from the coefficients involving binomials and powers of `c s`.
*   Show `ring_mul(r:R ring) (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)` is in `ring_carrier r`
*   Establish that `q s` has a power series representation for any `s` in `S`, and is in the carrier of the ring `x_series(r:R ring)`.
*   Prove, for any `s` in `S`, that `poly_mul(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1)) (q s) = poly_1 r`. This is done utilizing `pow_infinite_geometric_series_inverse`.
*   Show `ring_mul (x_series(r:R ring)) (poly_pow r (one_minus_constx r (c s)) (e+1)) (q s) = ring_1(x_series r)`.
*   Specialize the `product_times_sum_reciprocals` theorem and conclude by `RING_SUM_EQ`.

### Mathematical insight
This theorem provides a generalized form of Newton's identities for expressions of the form `1/(1-cx)^(e+1)`. In essence, it relates the product of such terms over a set `S`, multiplied by a sum involving related power series, to another sum of products, where each product excludes one element from the original set `S`. This identity is significant in areas like combinatorics and generating functions, where manipulating such expressions is crucial.

### Dependencies
*   `x_series_use`
*   `poly_product`
*   `poly_sum`
*   `one_minus_constx_series`
*   `x_series_carrier`
*   `ring_powerseries`
*   `x_series_use_pow`
*   `RING_POW`
*   `series_series_from_coeffs`
*   `RING_OF_NUM`
*   `RING_MUL`
*   `pow_infinite_geometric_series_inverse`
*   `product_times_sum_reciprocals`
*   `RING_SUM_EQ`
*   `SET_RULE ring_powerseries(r:R ring) (p:(1->num)->R) ==> p IN {q | ring_powerseries r q}`

### Porting notes (optional)
*   The interplay between polynomial rings and power series rings defined as x_series might present a challenge.
*   The definition of `q s` is crucial and needs careful translation.
*   The HOL Light tactic `specialize` is used to instantiate the general theorems with particular terms. Be especially careful in other provers like Coq or Lean.


---

## pow_newton_identities_monic_vanishing_at

### Name of formal statement
pow_newton_identities_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_newton_identities_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_mul r
    (poly_pow r
      (x_truncreverse r (CARD S) (monic_vanishing_at r S c))
      (e+1)
    )
    (poly_sum r S (\s.
       series_from_coeffs (\n.
         ring_mul r
           (ring_of_num r (binom(n+e,e)))
           (ring_pow r (c s) n)
       )
    ))
  = poly_sum r S (\t.
      poly_product r (S DELETE t) (\s.
        poly_pow r (one_minus_constx r (c s)) (e+1)
      )
    )
`,
  intro THEN
  simp[x_truncreverse_monic_vanishing_at] THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_series] THEN
  simp[poly_product_pow] THEN
  qed[pow_newton_identities_natural]
);;
```
### Informal statement
Let `r` be a ring, `c` a function from `X` to `R` (the carrier of the ring `r`), `S` a finite set, and `e` a natural number. If `S` is a finite set, and for all `s` in `S`, `c s` is in the carrier of the ring `r`, then the following equality holds:
The product of the polynomial `x_truncreverse r (CARD S) (monic_vanishing_at r S c)` raised to the power of `e+1`, multiplied by the polynomial which is the sum over `S` of the series with coefficients `ring_mul r (ring_of_num r (binom(n+e,e))) (ring_pow r (c s) n)` (as a function of `n`), equals the polynomial that is the sum over `S` of the product over `S` excluding `t` of `one_minus_constx r (c s)` raised to the power `e+1`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Simplify using `x_truncreverse_monic_vanishing_at`.
- Establish that `ring_powerseries (r:R ring) (one_minus_constx r (c s))` holds for all `s` in `S` using `one_minus_constx_series`. This shows that the inverse of `one_minus_constx` exists as a formal power series. This seems necessary to connect the polynomial manipulation with power series representation implicitly.
- Simplify using `poly_product_pow`.
- Conclude the proof using `pow_newton_identities_natural`.

### Mathematical insight
This theorem relates the truncated reverse of the monic vanishing polynomial (based on `S` and `c`) raised to a power and multiplied by a summation term involving binomial coefficients and powers of `c s`, to a summation of products of `one_minus_constx` raised to the power `e+1`. This captures Newton's identities in a specific ring-theoretic and polynomial context, relating polynomial construction, formal power series, and combinatorial identities derived from binomial coefficients.

### Dependencies
- `x_truncreverse_monic_vanishing_at`
- `one_minus_constx_series`
- `poly_product_pow`
- `pow_newton_identities_natural`


---

## scaled_pow_newton_identities_monic_vanishing_at_lemma

### Name of formal statement
scaled_pow_newton_identities_monic_vanishing_at_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let scaled_pow_newton_identities_monic_vanishing_at_lemma = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_mul r (
    const_x_pow r (ring_of_num r (FACT(e))) e
  ) (
    poly_sum r S (\s.
      series_from_coeffs (\n.
        ring_mul r
          (ring_of_num r (binom(n+e,e)))
          (ring_pow r (c s) n)
      )
    )
  )
  = poly_sum r S (\s.
      series_from_coeffs (\n.
        ring_mul r
          (ring_of_num r (FACT(e) * binom(n,e)))
          (ring_pow r (c s) (n-e))
      )
    )
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  have `ring_of_num r (FACT e) IN ring_carrier(r:R ring)` [RING_OF_NUM] THEN
  have `!s:X n. s IN S ==> ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n) IN ring_carrier(r:R ring)` [RING_POW;RING_OF_NUM;RING_MUL] THEN
  have `!s:X. s IN S ==> ring_powerseries(r:R ring) (series_from_coeffs (\n. ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)))` [series_series_from_coeffs] THEN
  have `ring_powerseries(r:R ring) (poly_sum r S (\s:X. series_from_coeffs (\n. ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n))))` [poly_sum_series] THEN
  simp[coeff_const_x_pow_times] THEN
  have `!s:X n. s IN S ==> ring_mul r (ring_of_num r (FACT e * binom (n,e))) (ring_pow r (c s) (n - e)) IN ring_carrier(r:R ring)` [RING_POW;RING_OF_NUM;RING_MUL] THEN
  subgoal `!s:X. s IN S ==> ring_powerseries(r:R ring) (series_from_coeffs (\n. ring_mul r (ring_of_num r (FACT e * binom (n,e))) (ring_pow r (c s) (n - e))))` THENL [
    simp[series_series_from_coeffs]
  ; pass
  ] THEN
  simp[coeff_poly_sum] THEN
  rw[coeff_series_from_coeffs] THEN
  case `d < e:num` THENL [
    simp[BINOM_LT;MULT_0;RING_OF_NUM_0;RING_MUL_LZERO;RING_POW] THEN
    qed[RING_SUM_0]
  ; pass
  ] THEN
  num_linear_fact `~(d < e:num) ==> d-e+e = d` THEN
  simp[] THEN
  have `ring_of_num(r:R ring) (FACT e) IN ring_carrier r` [RING_OF_NUM] THEN
  have `!s:X. s IN S ==> ring_mul(r:R ring) (ring_of_num r (binom(d,e))) (ring_pow r (c s) (d-e)) IN ring_carrier(r:R ring)` [RING_OF_NUM;RING_POW;RING_MUL] THEN
  specialize[`r:R ring`;`\a:X. ring_mul(r:R ring) (ring_of_num r (binom (d,e))) (ring_pow r (c a) (d - e))`;`ring_of_num(r:R ring) (FACT e)`;`S:X->bool`](GSYM RING_SUM_LMUL) THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  intro THEN
  simp[] THEN
  simp[RING_MUL_ASSOC;RING_OF_NUM;RING_POW] THEN
  rw[RING_OF_NUM_MUL]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and for any function `c` from `X` to `R`, given a finite set `S` of type `X->bool` and a natural number `e`, if `c s` is in the carrier of the ring `r` for all `s` in `S`, then the polynomial multiplication of the polynomial obtained from `const_x_pow r (ring_of_num r (FACT(e))) e` and the polynomial sum over `S` of the series whose `n`-th coefficient is `ring_mul r (ring_of_num r (binom(n+e,e))) (ring_pow r (c s) n)` is equal to the polynomial sum over `S` of the series whose `n`-th coefficient is `ring_mul r (ring_of_num r (FACT(e) * binom(n,e))) (ring_pow r (c s) (n-e))`.

### Informal sketch
The proof proceeds by showing that the coefficients of the two polynomials are equal.

- First, the goal is reduced to showing equality of coefficients using `eq_coeff`.
- We prove that `ring_of_num r (FACT e)` is an element of the ring carrier.
- We prove that `ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)` is an element of the ring carrier for all `s` in `S` and all `n`.
- We prove that the series with coefficients `ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)` is a ring powerseries.
- Thus, the polynomial sum of such series is also a ring powerseries.
- Simplify the expression for the coefficient of the left-hand side using `coeff_const_x_pow_times`.
- We prove that `ring_mul r (ring_of_num r (FACT e * binom (n,e))) (ring_pow r (c s) (n - e))` is an element of the ring carrier for all `s` in `S` and all `n`.
- We show that the series with given coefficients is a ring powerseries.
- An immediate simplification of the target follows from `coeff_poly_sum`.
- We rewrite `coeff_series_from_coeffs`.
- Case split is performed on `d < e:num`.
  - If `d < e`, we simplify using `BINOM_LT`, `MULT_0`, `RING_OF_NUM_0`, `RING_MUL_LZERO` and `RING_POW`, and use `RING_SUM_0` to finish.
  - Otherwise (if `~(d < e:num)` holds), we simplify using `~(d < e:num) ==> d-e+e = d` and perform arithmetic simplification.
- We prove `ring_of_num(r:R ring) (FACT e) IN ring_carrier r`.
- We prove `ring_mul(r:R ring) (ring_of_num r (binom(d,e))) (ring_pow r (c s) (d-e)) IN ring_carrier(r:R ring)`.
- Simplify and rewrite using `RING_SUM_LMUL` and prove equality using `RING_SUM_EQ`.
- Simplify using associative and commutative properties of the ring operations.
- Rewrite using the homomorphism properties of `RING_OF_NUM`.

### Mathematical insight
This theorem establishes an identity relating the polynomial `const_x_pow r (ring_of_num r (FACT(e))) e` multiplied by a sum of series and a sum of different related series. The summands of both series have to do with the scaled powers `ring_pow r (c s) n`. This Identity is related to Newton's identities and is often used in algebraic combinatorics and related fields. It is also an important result in the theory of polynomials over rings.

### Dependencies
- `RING_OF_NUM`
- `RING_POW`
- `RING_MUL`
- `series_series_from_coeffs`
- `poly_sum_series`
- `coeff_const_x_pow_times`
- `coeff_poly_sum`
- `coeff_series_from_coeffs`
- `BINOM_LT`
- `MULT_0`
- `RING_OF_NUM_0`
- `RING_MUL_LZERO`
- `RING_POW`
- `RING_SUM_0`
- `RING_SUM_LMUL`
- `RING_SUM_EQ`
- `RING_MUL_ASSOC`
- `RING_OF_NUM`
- `RING_OF_NUM_MUL`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification within the ring and polynomial structures. Ensure that the target proof assistant has sufficient automation for handling ring arithmetic and polynomial manipulations.
- The `num_linear_fact` tactic and the handling of arithmetic facts like `~(d < e:num) ==> d-e+e = d` might require some adaptation depending on how the target system reasons about numerals.
- The `GSYM` hint combined with `RING_SUM_LMUL` may need adaptation depending on how one sided identities are handled in the target system.


---

## scaled_pow_newton_rightside

### Name of formal statement
scaled_pow_newton_rightside

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let scaled_pow_newton_rightside = new_definition `
  scaled_pow_newton_rightside (r:R ring) (c:X->R) (S:X->bool) (e:num)
  = poly_mul r (
      const_x_pow r (ring_of_num r (FACT(e))) e
    ) (
      poly_sum r S (\t.
        poly_product r (S DELETE t) (\s.
          poly_pow r (one_minus_constx r (c s)) (e+1)
        )
      )
    )
`;;
```
### Informal statement
For a ring `r`, a function `c` from type `X` to the ring `r`, a predicate `S` on type `X`, and a natural number `e`, define `scaled_pow_newton_rightside r c S e` to be the product of the polynomial `const_x_pow r (ring_of_num r (FACT(e))) e` and the sum over all `t` satisfying `S` of the product over all `s` in `S` excluding `t` of the `e+1` power of the polynomial `one_minus_constx r (c s)`.

### Informal sketch
The definition `scaled_pow_newton_rightside` involves constructing a polynomial expression. The main steps are:

- Construct poly_mul of two polynomials.
- The first polynomial is `const_x_pow r (ring_of_num r (FACT(e))) e`, which represents `FACT(e) * x^e`.
- The second polynomial is a more complex one involving a summation and product.
- It sums over all `t` such that `S t` holds.
- For each such `t`, it takes the product over all `s` in `S` but not equal to `t`.
- For each such `s`, it computes `poly_pow r (one_minus_constx r (c s)) (e+1)`.

### Mathematical insight
This definition likely relates to the Newton's method or some related iterative algorithm. The expression calculates a polynomial based on the input function `c`, predicate `S`, and exponent `e`. The `FACT(e)` factor and the polynomial powers `(e+1)` suggest its use in calculating higher-order derivatives or Taylor series approximations.

### Dependencies
- `poly_mul`
- `const_x_pow`
- `ring_of_num`
- `FACT`
- `poly_sum`
- `DELETE`
- `poly_product`
- `poly_pow`
- `one_minus_constx`


---

## scaled_pow_newton_identities_monic_vanishing_at

### Name of formal statement
scaled_pow_newton_identities_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let scaled_pow_newton_identities_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_mul r
    (poly_pow r
      (x_truncreverse r (CARD S) (monic_vanishing_at r S c))
      (e+1)
    )
    (poly_sum r S (\s.
       series_from_coeffs (\n.
         ring_mul r
           (ring_of_num r (FACT(e) * binom(n,e)))
           (ring_pow r (c s) (n-e))
       )
    ))
  = scaled_pow_newton_rightside r c S e
`,
  rw[scaled_pow_newton_rightside] THEN
  intro THEN
  simp[GSYM pow_newton_identities_monic_vanishing_at] THEN
  simp[GSYM scaled_pow_newton_identities_monic_vanishing_at_lemma] THEN
  have `ring_powerseries(r:R ring) (const_x_pow r (ring_of_num r (FACT e)) e)` [const_x_pow_series;RING_OF_NUM] THEN
  have `ring_powerseries(r:R ring) (poly_pow r (x_truncreverse r (CARD S) (monic_vanishing_at r (S:X->bool) c)) (e + 1))` [monic_vanishing_at_series;x_truncreverse_series;poly_pow_series] THEN
  have `!s:X n. s IN S ==> ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n) IN ring_carrier(r:R ring)` [RING_MUL;RING_OF_NUM;RING_POW] THEN
  have `ring_powerseries(r:R ring) (poly_sum r S (\s:X. series_from_coeffs (\n. ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n))))` [poly_sum_series;series_series_from_coeffs] THEN
  specialize[`r:R ring`
    ;`const_x_pow(r:R ring) (ring_of_num r (FACT e)) e`
    ;`poly_pow(r:R ring) (x_truncreverse r (CARD S) (monic_vanishing_at r (S:X->bool) c)) (e + 1)`
    ;`poly_sum(r:R ring) S (\s:X. series_from_coeffs (\n. ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)))`
  ]POLY_MUL_ASSOC THEN
  specialize[`r:R ring`
    ;`const_x_pow(r:R ring) (ring_of_num r (FACT e)) e`
    ;`poly_pow(r:R ring) (x_truncreverse r (CARD S) (monic_vanishing_at r (S:X->bool) c)) (e + 1)`
  ]POLY_MUL_SYM THEN
  specialize[`r:R ring`
    ;`poly_pow(r:R ring) (x_truncreverse r (CARD S) (monic_vanishing_at r (S:X->bool) c)) (e + 1)`
    ;`const_x_pow(r:R ring) (ring_of_num r (FACT e)) e`
    ;`poly_sum(r:R ring) S (\s:X. series_from_coeffs (\n. ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)))`
  ]POLY_MUL_ASSOC THEN
  qed[]
);;
```
### Informal statement
For any ring `r` with carrier `ring_carrier r`, any function `c` from a type `X` to the carrier of `r`, any finite set `S` of type `X`, and any natural number `e`, if for all `s` in `S`, `c s` is in the carrier of `r`, then the following equality holds:  
The product of the polynomial power (with base `x_truncreverse r (CARD S) (monic_vanishing_at r S c)` and exponent `e+1`) and the polynomial sum (over `S` with terms defined by the series generated from coefficients `ring_mul r (ring_of_num r (FACT(e) * binom(n,e))) (ring_pow r (c s) (n-e))`, where `n` varies)  is equal to `scaled_pow_newton_rightside r c S e`.

### Informal sketch
The proof proceeds by:
- Rewrite using `scaled_pow_newton_rightside`.
- Introduction.
- Simplification using the generalized symmetric versions of `pow_newton_identities_monic_vanishing_at` and `scaled_pow_newton_identities_monic_vanishing_at_lemma`.
- Showing that `const_x_pow r (ring_of_num r (FACT e)) e` is a ring power series, using `const_x_pow_series` and `RING_OF_NUM`.
- Showing that `poly_pow r (x_truncreverse r (CARD S) (monic_vanishing_at r S c)) (e + 1)` is a ring power series, using `monic_vanishing_at_series`, `x_truncreverse_series`, and `poly_pow_series`.
- Proving that `ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)` is in the carrier of the ring `r`, for all `s` in `S` and `n`, if `s` is in `S`, using `RING_MUL`, `RING_OF_NUM`, and `RING_POW`.
- Showing that `poly_sum r S (\s. series_from_coeffs (\n. ring_mul r (ring_of_num r (binom (n + e,e))) (ring_pow r (c s) n)))` is a ring power series, using `poly_sum_series` and `series_series_from_coeffs`.
- Applying `POLY_MUL_ASSOC` multiple times with appropriate specializations to rearrange the terms.
- Applying `POLY_MUL_SYM`.

### Mathematical insight
This theorem relates the polynomial `x_truncreverse r (CARD S) (monic_vanishing_at r S c)` raised to the power `e+1` and a summation of infinitely differentiable series to the term `scaled_pow_newton_rightside`. The theorem leverages Newton's identities for monic polynomials to establish a relationship between polynomial powers, series representations and the function `c` evaluated at set `S`.

### Dependencies
- `scaled_pow_newton_rightside`
- `pow_newton_identities_monic_vanishing_at`
- `scaled_pow_newton_identities_monic_vanishing_at_lemma`
- `const_x_pow_series`
- `RING_OF_NUM`
- `monic_vanishing_at_series`
- `x_truncreverse_series`
- `poly_pow_series`
- `RING_MUL`
- `RING_POW`
- `poly_sum_series`
- `series_series_from_coeffs`
- `POLY_MUL_ASSOC`
- `POLY_MUL_SYM`


---

## poly_pow_newton_identities_monic_vanishing_at_lemma

### Name of formal statement
poly_pow_newton_identities_monic_vanishing_at_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_newton_identities_monic_vanishing_at_lemma = prove(`
  !(r:R ring) c:X->R S e t.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  t IN S ==>
  ring_polynomial(r:R ring) (poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1)))
`,
  intro THEN
  have `FINITE(S DELETE (t:X))` [FINITE_DELETE] THEN
  set_fact `!s:X. s IN S DELETE t ==> s IN S` THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_poly] THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e + 1))` [poly_pow_poly] THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1))` [] THEN
  specialize[`r:R ring`;`\s:X. poly_pow(r:R ring) (one_minus_constx r (c s)) (e+1)`;`S DELETE (t:X)`]poly_product_poly THEN
  qed[]
);;
```

### Informal statement
For any ring `r` with carrier `R`, any function `c` from a type `X` to `R`, any set `S` of type `X`, and any natural number `e`, if `S` is finite, and for all `s` in `S`, `c s` is an element of the ring carrier `R` of `r`, and `t` is an element of `S`, then the polynomial given by the ring polynomial of `r` applied to the polynomial product with respect to `r` over the set `S` excluding `t` of the function that maps `s` to the `e+1`-th power of the polynomial (corresponding to) one minus the constant polynomial with value `c s` is a polynomial.

### Informal sketch
The proof proceeds as follows:
- Start with the assumptions: `FINITE S`, `!s. s IN S ==> c s IN ring_carrier r`, and `t IN S`.
- Show that `S DELETE t` is finite using `FINITE_DELETE`.
- State that if `s` is in `S DELETE t`, then `s` is in `S`.
- Show that for all `s` in `S DELETE t`, `one_minus_constx r (c s)` forms a ring polynomial using `one_minus_constx_poly`.
- Show that for all `s` in `S DELETE t`, `poly_pow r (one_minus_constx r (c s)) (e + 1)` forms a ring polynomial using `poly_pow_poly`.
- Apply `poly_product_poly` with the appropriate specializations for the set, the function, and the ring to show that the product of these polynomials indexed by `S DELETE t` is a ring polynomial.
- Conclude the result.

### Mathematical insight
This theorem establishes that a particular product of polynomials is itself a polynomial within the ring polynomial structure. Each factor in the product is a power of a polynomial of the form `1 - cx`, where `c` is a value dependent on an element `s` of the set `S`, and `x` is the variable polynomial `X`. The theorem is important because it shows how finiteness is preserved when constructing polynomial products under specified existence and membership conditions.

### Dependencies
- `FINITE_DELETE`
- `one_minus_constx_poly`
- `poly_pow_poly`
- `poly_product_poly`


---

## poly_pow_newton_identities_monic_vanishing_at

### Name of formal statement
poly_pow_newton_identities_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_pow_newton_identities_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_polynomial r (
    poly_sum r S (\t.
      poly_product r (S DELETE t) (\s.
        poly_pow r (one_minus_constx r (c s)) (e+1)
      )
    )
  )
`,
  intro THEN
  set_fact `!s t:X. s IN S DELETE t ==> s IN S` THEN
  have `!t:X. t IN S ==> !s. s IN S DELETE t ==> ring_polynomial(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_poly] THEN
  have `!t:X. t IN S ==> !s. s IN S DELETE t ==> ring_polynomial(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e + 1))` [poly_pow_poly] THEN
  have `!t:X. t IN S ==> ring_polynomial(r:R ring) (poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1)))` [poly_pow_newton_identities_monic_vanishing_at_lemma] THEN
  qed[poly_sum_poly]
);;
```
### Informal statement
Given a ring `r` with carrier `ring_carrier r`, a function `c` from a type `X` to the ring `r`, a finite set `S` of type `X`, and a natural number `e`, if for all `s` in `S`, `c s` is in the carrier of the ring `r`, then the polynomial which is the sum over `S` of the polynomials constructed by taking the product over `S` excluding `t` of the polynomials `(1 - (c s) * x)^(e+1)` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds by demonstrating that the resulting polynomial, constructed through sums and products of other polynomials, is indeed a ring polynomial.

- First, establish that for any `s` in `S` (excluding `t`), the polynomial `one_minus_constx r (c s)` is a ring polynomial using `one_minus_constx_poly`.
- Then, show that for any `s` in `S` (excluding `t`), the polynomial `poly_pow r (one_minus_constx r (c s)) (e + 1)` is a ring polynomial using `poly_pow_poly`.
- Next, demonstrate that the product `poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1))` is a ring polynomial using lemma `poly_pow_newton_identities_monic_vanishing_at_lemma`.
- Finally, prove that the sum `poly_sum r S (\t. poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1)))` is a ring polynomial using `poly_sum_poly`.
- The proof starts by introducing assumptions and setting a fact `!s t:X. s IN S DELETE t ==> s IN S`. The tactic `qed[poly_sum_poly]` closes the goal automatically using the named hypothesis `poly_sum_poly`.

### Mathematical insight
This theorem establishes that under certain conditions relating to a finite set `S`, a function `c` mapping elements of `S` to a ring `r`, and a natural number `e`, a specific polynomial construction results in a ring polynomial. This is crucial in algebraic manipulations involving sums and products of polynomials, especially when dealing with roots and their multiplicities within a given ring structure. The construction resembles elements used in Newton's identities and relates to polynomials vanishing at specified points.

### Dependencies
- Theorems:
  - `one_minus_constx_poly`
  - `poly_pow_poly`
  - `poly_sum_poly`
  - `poly_pow_newton_identities_monic_vanishing_at_lemma`

### Porting notes (optional)
- In proof assistants like Coq or Lean, special care might be required to manage the finiteness condition on set `S`. Coq's `Ensemble` and Lean's `Finset` often provide adequate support.
- The automatic discharging of ring axioms might vary in different provers. Ensure that the corresponding lemmas about sums, products, and powers of polynomials in rings are available in the target environment.


---

## poly_scaled_pow_newton_rightside

### Name of formal statement
poly_scaled_pow_newton_rightside

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_scaled_pow_newton_rightside = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  ring_polynomial r (scaled_pow_newton_rightside r c S e)
`,
  rw[scaled_pow_newton_rightside] THEN
  qed[poly_pow_newton_identities_monic_vanishing_at;RING_OF_NUM;const_x_pow_poly;RING_POLYNOMIAL_MUL]
);;
```
### Informal statement
For all `(r:R ring)`, `c:X->R`, `S`, and `e`, if `S` is a finite set, and for all `s` in `S`, `c s` is in the carrier of the ring `r`, then `scaled_pow_newton_rightside r c S e` is a polynomial over the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definition of `scaled_pow_newton_rightside`.
- Apply a previously proven theorem `poly_pow_newton_identities_monic_vanishing_at`.
- Apply theorems `RING_OF_NUM`, `const_x_pow_poly`, and `RING_POLYNOMIAL_MUL` to complete the proof.

### Mathematical insight
The theorem states that the `scaled_pow_newton_rightside` function, which constructs a polynomial based on a ring `r`, a function `c` mapping elements to the ring, a finite set `S`, and an element `e`, results in a valid polynomial over that ring, provided that the function `c` maps elements of `S` into the carrier of the ring `r`. This is important in constructing and reasoning about polynomials with specific properties, particularly those related to vanishing at certain points with specified multiplicities.

### Dependencies
- Definitions: `scaled_pow_newton_rightside`
- Theorems: `poly_pow_newton_identities_monic_vanishing_at`, `RING_OF_NUM`, `const_x_pow_poly`, `RING_POLYNOMIAL_MUL`


---

## deg_pow_newton_identities_monic_vanishing_at_lemma

### Name of formal statement
deg_pow_newton_identities_monic_vanishing_at_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_pow_newton_identities_monic_vanishing_at_lemma = prove(`
  !(r:R ring) c:X->R S e t.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  t IN S ==>
  poly_deg(r:R ring) (poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1))) <= (CARD S - 1) * (e+1)
`,
  intro THEN
  set_fact `!s t:X. s IN S DELETE t ==> s IN S` THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_poly] THEN
  subgoal `!s:X. s IN S DELETE t ==> poly_deg(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1)) <= e+1` THENL [
    intro THEN
    have `poly_deg(r:R ring) (one_minus_constx r (c(s:X))) <= 1` [deg_one_minus_constx_le] THEN
    have `(e+1) * poly_deg(r:R ring) (one_minus_constx r (c(s:X))) <= (e+1)*1` [LE_MULT_LCANCEL] THEN
    have `poly_deg(r:R ring) (poly_pow r (one_minus_constx r (c(s:X))) (e+1)) <= (e+1) * poly_deg r (one_minus_constx r (c(s:X)))` [poly_deg_pow_le] THEN
    qed[LE_TRANS;ARITH_RULE `(e+1)*1 = e+1`]
  ; pass
  ] THEN
  have `FINITE(S DELETE (t:X))` [FINITE_DELETE] THEN
  have `!s:X. s IN S DELETE t ==> ring_polynomial(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1))` [poly_pow_poly;one_minus_constx_poly] THEN
  have `!s:X. s IN S DELETE t ==> poly_deg(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1)) <= e+1` [poly_pow_poly;one_minus_constx_poly] THEN
  specialize[`r:R ring`;`\s:X. poly_pow r (one_minus_constx r (c s:R)) (e+1)`;`e+1`;`S DELETE (t:X)`]poly_deg_product_each_le THEN
  qed[CARD_DELETE]
);;
```
### Informal statement
Given a ring `r` with carrier `ring_carrier r`, a finite set `S` such that for all `s` in `S`, `c s` is in `ring_carrier r`, and an element `t` in `S`, then the degree of the polynomial which is the product over `S DELETE t` of `poly_pow r (one_minus_constx r (c s)) (e + 1)` is less than or equal to `(CARD S - 1) * (e + 1)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions: a ring `r`, a function `c` from a type `X` to the ring `r`, a set `S`, an exponent `e`, and an element `t`. Assume `FINITE S` and that `c s` is in the carrier set of the ring `r` for all `s` in `S`. Furthermore, assume that `t` is an element of S.
- Show that if `s` is in `S DELETE t` then `s` is in `S`.
- Establish that for any `s` in `S DELETE t`, `one_minus_constx r (c s)` is a ring polynomial.
- Show that `poly_deg(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e+1)) <= e+1` for `s IN S DELETE t`.
  - Show that `poly_deg(r:R ring) (one_minus_constx r (c(s:X))) <= 1` using `deg_one_minus_constx_le`.
  - Show that `(e+1) * poly_deg(r:R ring) (one_minus_constx r (c(s:X))) <= (e+1)*1` using `LE_MULT_LCANCEL`.
  - Show that `poly_deg(r:R ring) (poly_pow r (one_minus_constx r (c(s:X))) (e+1)) <= (e+1) * poly_deg r (one_minus_constx r (c(s:X)))` using `poly_deg_pow_le`.
  - Use transitivity and arithmetic to conclude.
- By `FINITE_DELETE`, `FINITE (S DELETE t)`.
- Show that for all `s` in `S DELETE t`, `poly_pow r (one_minus_constx r (c s)) (e+1)` is a ring polynomial by `poly_pow_poly` and `one_minus_constx_poly`.
- Instantiate `poly_deg_product_each_le` with `r:R ring`, `\s:X. poly_pow r (one_minus_constx r (c s:R)) (e+1)`, `e+1`, and `S DELETE (t:X)`.
- Use `CARD_DELETE` to simplify the bound on the cardinality.

### Mathematical insight
The lemma establishes an upper bound on the degree of a polynomial formed by taking a product of powers of polynomials of the form `1 - cx`, where `c` is a constant determined by a function applied to elements of a finite set. This type of degree bound on a product of polynomials is a common technique in algebraic arguments especially when dealing with varieties defined by polynomial constraints.

### Dependencies
- `FINITE`
- `DELETE`
- `ring_carrier`
- `poly_deg`
- `poly_product`
- `poly_pow`
- `one_minus_constx`
- `RING`
- `deg_one_minus_constx_le`
- `LE_MULT_LCANCEL`
- `poly_deg_pow_le`
- `FINITE_DELETE`
- `poly_pow_poly`
- `poly_deg_product_each_le`
- `CARD_DELETE`
- `ARITH_RULE`


---

## deg_pow_newton_identities_monic_vanishing_at

### Name of formal statement
deg_pow_newton_identities_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_pow_newton_identities_monic_vanishing_at = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_deg r (
    poly_sum r S (\t.
      poly_product r (S DELETE t) (\s.
        poly_pow r (one_minus_constx r (c s)) (e+1)
      )
    )
  )
  <= (CARD S - 1) * (e+1)
`,
  intro THEN
  set_fact `!s t:X. s IN S DELETE t ==> s IN S` THEN
  have `!t:X. t IN S ==> !s. s IN S DELETE t ==> ring_polynomial(r:R ring) (one_minus_constx r (c s))` [one_minus_constx_poly] THEN
  have `!t:X. t IN S ==> !s. s IN S DELETE t ==> ring_polynomial(r:R ring) (poly_pow r (one_minus_constx r (c s)) (e + 1))` [poly_pow_poly] THEN
  have `!t:X. t IN S ==> ring_polynomial(r:R ring) (poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1)))` [poly_pow_newton_identities_monic_vanishing_at_lemma] THEN
  have `!t:X. t IN S ==> poly_deg(r:R ring) (poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1))) <= (CARD S - 1) * (e+1)` [deg_pow_newton_identities_monic_vanishing_at_lemma] THEN
  specialize[`r:R ring`;`(\t:X. poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s:R)) (e + 1)))`;`(CARD(S:X->bool)-1)*(e+1)`;`S:X->bool`]poly_deg_sum_le THEN
  qed[]
);;
```
### Informal statement
Given a ring `r`, a function `c` from a type `X` to the carrier of the ring `r`, a finite set `S` of type `X`, and a natural number `e`, if `c s` is an element of the carrier of the ring `r` for all `s` in `S`, then the degree of the polynomial resulting from summing over `S` the polynomials which are products over `S` excluding `t` of the polynomials `(1 - c s * x)^(e+1)` is less than or equal to `(CARD S - 1) * (e+1)`.

### Informal sketch
The proof uses the following steps:

- Introduce assumptions: `r` is a ring, `c` is a function from `X` to the carrier of `r`, `S` is a finite set, `e` is a natural number, and `c s` belongs to the carrier of `r` for every `s` in `S`.
- Establish that for all `t` in `S`, and for all `s` in `S DELETE t`, `one_minus_constx r (c s)` is a ring polynomial via `one_minus_constx_poly`.
- Establish that for all `t` in `S`, and for all `s` in `S DELETE t`, `poly_pow r (one_minus_constx r (c s)) (e + 1)` is a ring polynomial using the previous result and `poly_pow_poly`.
- Establish that for all `t` in `S`, `poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1))` is a ring polynomial via `poly_pow_newton_identities_monic_vanishing_at_lemma`.
- Establish that for all `t` in `S`, `poly_deg(r) (poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e + 1))) <= (CARD S - 1) * (e+1)` via `deg_pow_newton_identities_monic_vanishing_at_lemma`.
- Apply `poly_deg_sum_le` to conclude that the degree of the sum of the product is less than or equal to `(CARD S - 1) * (e+1)`.

### Mathematical insight
This theorem bounds the degree of a specific polynomial construction arising in the context of Newton's identities and polynomials vanishing at certain points. The function `poly_pow r (one_minus_constx r (c s)) (e + 1)` represents `(1 - c s * x)^(e+1)`. The product over `S DELETE t` yields a polynomial which vanishes at all points `c s` for `s` in `S DELETE t` with multiplicity `e+1`. Finally, summing over the polynomials obtained by excluding each `t` in `S` bounds from above the degree of the resulting polynomial.

### Dependencies
- Theorems:
  - `one_minus_constx_poly`
  - `poly_pow_poly`
  - `poly_pow_newton_identities_monic_vanishing_at_lemma`
  - `deg_pow_newton_identities_monic_vanishing_at_lemma`
  - `poly_deg_sum_le`


---

## deg_scaled_pow_newton_rightside

### Name of formal statement
deg_scaled_pow_newton_rightside

### Type of the formal statement
theorem

### Formal Content
```ocaml
let deg_scaled_pow_newton_rightside = prove(`
  !(r:R ring) c:X->R S e.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  poly_deg r (scaled_pow_newton_rightside r c S e)
  <= e + (CARD S - 1) * (e+1)
`,
  intro THEN
  rw[scaled_pow_newton_rightside] THEN
  have `ring_polynomial(r:R ring) (const_x_pow r (ring_of_num r (FACT(e))) e)` [const_x_pow_poly;RING_OF_NUM] THEN
  have `poly_deg(r:R ring) (const_x_pow r (ring_of_num r (FACT(e))) e) <= e` [deg_const_x_pow_le;RING_OF_NUM] THEN
  have `ring_polynomial(r:R ring) (poly_sum r S (\t:X. poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e+1))))` [poly_pow_newton_identities_monic_vanishing_at] THEN
  have `poly_deg(r:R ring) (poly_sum r S (\t:X. poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e+1)))) <= (CARD S - 1) * (e+1)` [deg_pow_newton_identities_monic_vanishing_at] THEN
  qed[POLY_DEG_MUL_LE;ARITH_RULE `d <= d1 + d2 /\ d1 <= e:num /\ d2 <= C ==> d <= e + C`]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `c` from a type `X` to the carrier of `r`, any finite set `S` of type `X`, and any natural number `e`, if for all `s` in `S`, `c s` is in the carrier of `r`, then the degree of the polynomial `scaled_pow_newton_rightside r c S e` is less than or equal to `e + (CARD S - 1) * (e+1)`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `scaled_pow_newton_rightside`.
- Then, establish that `const_x_pow r (ring_of_num r (FACT(e))) e` is a polynomial. This relies on `const_x_pow_poly` and `RING_OF_NUM`.
- Subsequently, show that the degree of `const_x_pow r (ring_of_num r (FACT(e))) e` is less than or equal to `e`. This relies on `deg_const_x_pow_le` and `RING_OF_NUM`.
- Establish that `poly_sum r S (\t:X. poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e+1)))` is a polynomial. This relies on `poly_pow_newton_identities_monic_vanishing_at`.
- Show that the degree of `poly_sum r S (\t:X. poly_product r (S DELETE t) (\s. poly_pow r (one_minus_constx r (c s)) (e+1)))` is less than or equal to `(CARD S - 1) * (e+1)`. This relies on `deg_pow_newton_identities_monic_vanishing_at`.
- Finally, use `POLY_DEG_MUL_LE` and `ARITH_RULE` to conclude that the degree of `scaled_pow_newton_rightside r c S e` is less than or equal to `e + (CARD S - 1) * (e+1)`.

### Mathematical insight
This theorem provides an upper bound on the degree of a polynomial constructed using the `scaled_pow_newton_rightside` construction. This construction is related to Newton interpolation and allows constructing polynomials that satisfy certain vanishing properties. The degree bound is important for bounding the complexity of these polynomials.

### Dependencies
#### Theorems
- `deg_const_x_pow_le`
- `POLY_DEG_MUL_LE`

#### Definitions
- `scaled_pow_newton_rightside`
- `const_x_pow_poly`
- `poly_pow_newton_identities_monic_vanishing_at`

#### Other
- `RING_OF_NUM`
- `ARITH_RULE`


---

## complex_ring

### Name of formal statement
complex_ring

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let complex_ring = new_definition `
  complex_ring = ring((:complex),Cx(&0),Cx(&1),( -- ),( + ),( * ))
`;;
```

### Informal statement
The constant `complex_ring` is defined to be the ring structure consisting of the type of complex numbers (`:complex`), the zero element `Cx(&0)`, the unit element `Cx(&1)`, the subtraction operation `( -- )`, the addition operation `( + )`, and the multiplication operation `( * )`.

### Informal sketch
- The definition introduces `complex_ring` as a ring structure.
- It specifies the underlying type as `:complex` and provides the necessary operations and identities to form a ring.
- `Cx(&0)` and `Cx(&1)` represent the complex numbers 0 and 1 respectively.
- The operations `( -- )`, `( + )`, and `( * )` refer to the standard subtraction, addition, and multiplication operations on complex numbers. The definition relies on the fact that these operations have been defined over complex numbers and satisfy the ring axioms, which this definition encapsulates into a ring structure named `complex_ring`.
- The ring axioms are not explicitly verified within this definition; it is assumed that the underlying definitions of `:complex`, `Cx`, `&0`, `&1`, `( -- )`, `( + )`, and `( * )` ensure that these axioms hold.

### Mathematical insight
This definition encapsulates the standard ring structure on complex numbers. Defining `complex_ring` allows later theorems and definitions to concisely refer to the algebraic ring properties of complex numbers, without needing to explicitly list the type, zero, one, and operations every time. It leverages existing definitions of complex numbers and their arithmetic operations to formally define a ring structure.

### Dependencies
- `ring`
- `:complex`
- `Cx`
- `&0`
- `&1`
- `( -- )`
- `( + )`
- `( * )`


---

## complex_of_num

### Name of formal statement
complex_of_num

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let complex_of_num = new_definition `
  complex_of_num(n:num) = Cx(real_of_num n)
`;;
```

### Informal statement
Define a function `complex_of_num` from the type `num` to the type `complex` such that for every number `n` of type `num`, `complex_of_num(n)` is the complex number constructed with the real part equal to the real number corresponding to `n` (via `real_of_num`) and an imaginary part of 0.

### Informal sketch
- The definition introduces a new function `complex_of_num` that maps a natural number (`num`) to its complex number representation.
- This is achieved by first converting the natural number `n` to a real number using the function `real_of_num`.
- This real number is then used as the real part of the complex number, with the imaginary part being implicitly zero since `Cx` only accepts a real number.
- The definition is direct and does not require a proof; it is simply introducing a shorthand for constructing a specific complex number from a natural number.

### Mathematical insight
The function `complex_of_num` provides a canonical embedding of natural numbers into the complex numbers. This is a standard construction used to relate different number systems. It is valuable as an injection and allows natural numbers to be treated as complex numbers which can be useful in generic algorithms.

### Dependencies
- Definitions:
  - `real_of_num`
  - `Cx`


---

## complex_of_int

### Name of formal statement
complex_of_int

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let complex_of_int = new_definition `
  complex_of_int(n:int) = Cx(real_of_int n)
`;;
```

### Informal statement
The function `complex_of_int` from integers to complex numbers is defined such that for any integer `n`, `complex_of_int(n)` is the complex number `Cx(real_of_int n)`, where `real_of_int` is the function that maps integers to real numbers.

### Informal sketch
The definition introduces a function `complex_of_int` by specifying its behavior on an arbitrary integer `n`. The right-hand side of the definition constructs a complex number from the real number corresponding to `n`. This involves first converting the integer `n` to a real number using the built-in `real_of_int` cast, then injecting that real number into the complex numbers as the real component, with the imaginary component implicitly being zero.

### Mathematical insight
This definition provides a canonical way to view integers as complex numbers. It is a standard embedding that preserves the algebraic structure (addition, multiplication). The function `complex_of_int` provides a bridge between the integers and the complex numbers, allowing operations and theorems about complex numbers to be applied to integers.

### Dependencies
- Definitions:
  - `Cx` (complex number constructor)
  - `real_of_int`



---

## complex_ring_clauses

### Name of formal statement
- complex_ring_clauses

### Type of the formal statement
- theorem

### Formal Content
- Placeholder: 
```ocaml
let complex_ring_clauses = prove
 (`ring_carrier complex_ring = (:complex) /\
   ring_0 complex_ring = Cx(&0) /\
   ring_1 complex_ring = Cx(&1) /\
   ring_neg complex_ring = ( -- ) /\
   ring_add complex_ring = ( + ) /\
   ring_mul complex_ring = ( * )`,
  PURE_REWRITE_TAC
   [GSYM PAIR_EQ; ring_carrier; ring_0; ring_1; ring_neg; ring_add; ring_mul;
    BETA_THM; PAIR] THEN
  PURE_REWRITE_TAC[complex_ring; GSYM(CONJUNCT2 ring_tybij)] THEN
  REWRITE_TAC[IN_UNIV] THEN CONV_TAC COMPLEX_RING);;
```

### Informal statement
- It is provable that the carrier of the ring structure `complex_ring` is the type `:complex`; the additive identity `ring_0` of `complex_ring` is `Cx(&0)`; the multiplicative identity `ring_1` of `complex_ring` is `Cx(&1)`; the additive inverse `ring_neg` of `complex_ring` is the negation function `( -- )`; the addition `ring_add` function of `complex_ring` is the addition function `( + )`; and the multiplication `ring_mul` function of `complex_ring` is the multiplication function `( * )`.

### Informal sketch
- The proof proceeds as follows:
  - First, rewrite the goal using equations defining the ring structure (carrier, zero, one, negation, addition, multiplication) combined with beta reduction and pairing.
  - Then, rewrite using the definition of `complex_ring` and the second conjunct of `ring_tybij`.
  - Rewrite using the theorem `IN_UNIV`, which states that every element is in the universe of its type.
  - Finally, apply a conversion tactic that uses the `COMPLEX_RING` conversion.

### Mathematical insight
- This theorem provides the concrete definitions of the ring operations and identities for the complex numbers, as formalized by `complex_ring`. It explicitly states that the ring operations defined in `complex_ring` are the standard complex number operations. This is essential for reasoning about complex numbers as a ring within HOL Light.

### Dependencies
- Definitions:
  - `ring_carrier`
  - `ring_0`
  - `ring_1`
  - `ring_neg`
  - `ring_add`
  - `ring_mul`
  - `complex_ring`
- Theorems:
  - `PAIR_EQ`
  - `BETA_THM`
  - `PAIR`
  - `ring_tybij`
  - `IN_UNIV`

### Porting notes (optional)
- The `COMPLEX_RING` conversion is likely specific to HOL Light and may require a custom tactic or proof script in other proof assistants. The key is to demonstrate that the structure defined satisfies the ring axioms.


---

## in_complex_ring

### Name of formal statement
in_complex_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let in_complex_ring = prove(`
  !z.
  z IN ring_carrier complex_ring
`,
  qed[complex_ring_clauses;IN_UNIV]
);;
```
### Informal statement
Every complex number `z` is an element of the carrier set of the `complex_ring` ring.

### Informal sketch
The proof consists of the following steps:
- Apply the theorem `complex_ring_clauses` which states that the structure `complex_ring` is indeed a ring.
- Apply the theorem `IN_UNIV`, that states everything is in the universe.
Thus combining those two we get `z IN ring_carrier complex_ring`.

### Mathematical insight
This theorem confirms that the set of complex numbers, when equipped with the standard operations, forms a ring structure within the HOL Light formalization. This is a basic but essential verification since many other theorems rely on this fact.

### Dependencies
- Theorems:
  - `complex_ring_clauses`
  - `IN_UNIV`


---

## field_complex

### Name of formal statement
field_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let field_complex = prove(`
  field complex_ring
`,
  rw[field;complex_ring_clauses;IN_UNIV] THEN
  qed[CX_INJ;COMPLEX_MUL_RINV;REAL_ARITH `~(&1 = &0:real)`]
);;
```
### Informal statement
The structure `complex_ring` is a field.

### Informal sketch
The proof shows that the structure `complex_ring` satisfies the axioms of a field.

- First, the definition of a field (`field`) is rewritten. Also, the clauses defining the `complex_ring` structure are rewritten. Finally `IN_UNIV` is rewritten.
- Then the goal is proved using `CX_INJ`, `COMPLEX_MUL_RINV`, and `REAL_ARITH \`~(&1 = &0:real)\`` tactics. This involves showing that complex numbers satisfy the multiplicative inverse property, and some basic facts about real numbers.

### Mathematical insight
This theorem establishes that the complex numbers, with their standard operations, form a field. This is a fundamental result in complex analysis and algebra, allowing us to perform standard algebraic manipulations (addition, subtraction, multiplication, and division) with complex numbers. It justifies treating complex numbers as elements within a field, making available a wide range of theorems and techniques applicable to fields in general.

### Dependencies
- Definition: `field`
- Definition: `complex_ring_clauses`
- Theorem: `IN_UNIV`
- Theorem: `CX_INJ`
- Theorem: `COMPLEX_MUL_RINV`
- Theorem: `REAL_ARITH` (specifically with `~(&1 = &0:real)`)


---

## integral_domain_complex

### Name of formal statement
integral_domain_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let integral_domain_complex = prove(`
  integral_domain complex_ring
`,
  qed[field_complex;FIELD_IMP_INTEGRAL_DOMAIN]
);;
```
### Informal statement
The complex numbers form an integral domain under the `complex_ring` structure.

### Informal sketch
The proof leverages the fact that the complex numbers form a field (`field_complex`) and that any field is an integral domain (`FIELD_IMP_INTEGRAL_DOMAIN`). The steps are as following:
- Prove that the complex numbers form a field using `field_complex`.
- Deduce that the complex numbers form an integral domain using `FIELD_IMP_INTEGRAL_DOMAIN`.

### Mathematical insight
This theorem establishes a fundamental property of complex numbers, specifically that they satisfy the axioms of an integral domain. Integral domains are important algebraic structures that generalize the integers and are the basis for many concepts in abstract algebra and number theory, such as divisibility and unique factorization. Given that complex numbers form a field, this result readily follows, as all fields are integral domains.

### Dependencies
- Theorems:
  - `field_complex`
  - `FIELD_IMP_INTEGRAL_DOMAIN`


---

## ring_of_num_complex

### Name of formal statement
ring_of_num_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_complex = prove(`
  ring_of_num complex_ring = complex_of_num
`,
  rw[FUN_EQ_THM;complex_of_num] THEN
  INDUCT_TAC THEN
  simp[ring_of_num;complex_ring_clauses] THEN
  rw[GSYM CX_ADD;REAL_OF_NUM_SUC]
);;
```
### Informal statement
The function `ring_of_num` applied to the complex ring `complex_ring` is equal to the function `complex_of_num`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `FUN_EQ_THM` (extensional equality for functions) and the definition of `complex_of_num`.
- Next, perform induction.
- Then, simplify using the definition of `ring_of_num` and the clauses defining `complex_ring`.
- Finally, rewrite using the equation `CX_ADD` (addition of complex numbers), and `REAL_OF_NUM_SUC` (successor of a natural number).

### Mathematical insight
This theorem establishes the relationship between the ring homomorphism `ring_of_num` which maps natural numbers into a ring, and the function `complex_of_num` which maps natural numbers to complex numbers. It asserts that when `ring_of_num` is applied to the complex numbers equipped with their ring structure (`complex_ring`), it gives the same result as the direct map `complex_of_num`. This confirms that the natural embedding of natural numbers into the complex numbers is a ring homomorphism and respects ring operations.

### Dependencies
- Theorems: `FUN_EQ_THM`
- Definitions: `complex_of_num`, `ring_of_num`
- Theorems/Lemmas: `complex_ring_clauses`, `CX_ADD`, `REAL_OF_NUM_SUC`


---

## ring_of_int_complex

### Name of formal statement
ring_of_int_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_int_complex = prove(`
  ring_of_int complex_ring = complex_of_int
`,
  rw[FUN_EQ_THM] THEN
  rw[FORALL_INT_CASES;RING_OF_INT_CASES] THEN
  rw[ring_of_num_complex;complex_of_num] THEN
  rw[complex_of_int;int_of_num_th;int_neg_th;CX_NEG] THEN
  rw[complex_ring_clauses]
);;
```
### Informal statement
The operation `ring_of_int` applied to the complex ring `complex_ring` is equal to the function `complex_of_int`. In other words, for any integer `n`, `ring_of_int complex_ring n = complex_of_int n`.

### Informal sketch
The proof proceeds by showing that for any integer `n`, `ring_of_int complex_ring n = complex_of_int n`.
-  First, the theorem `FUN_EQ_THM` is applied to reduce the goal to proving the equality for all inputs.
-  Then, `FORALL_INT_CASES` and `RING_OF_INT_CASES` are used to split the proof into cases: 0, 1, and n+1.
-  The definitions of `ring_of_num_complex` and `complex_of_num` are expanded.
-  Then the definitions of `complex_of_int`, `int_of_num_th`, `int_neg_th`, and `CX_NEG` are expanded, converting integers to complex numbers.
-  Finally, the `complex_ring_clauses` are expanded to show that the resulting complex rings are equivalent.

### Mathematical insight
This theorem establishes the relationship between the ring homomorphism `ring_of_int` from integers into the complex numbers (with the `complex_ring` structure) and the explicit embedding function `complex_of_int`. It formalizes that the ring homomorphism from integers to complex numbers is the canonical one, mapping each integer `n` to the complex number `n + 0i`.

### Dependencies
- `FUN_EQ_THM`
- `FORALL_INT_CASES`
- `RING_OF_INT_CASES`
- `ring_of_num_complex`
- `complex_of_num`
- `complex_of_int`
- `int_of_num_th`
- `int_neg_th`
- `CX_NEG`
- `complex_ring_clauses`


---

## ring_char_complex

### Name of formal statement
ring_char_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_char_complex = prove(`
  ring_char complex_ring = 0
`,
  rw[RING_CHAR_EQ_0;ring_of_num_complex;complex_of_num;complex_ring_clauses;CX_INJ;REAL_OF_NUM_EQ]
);;
```
### Informal statement
The characteristic of the complex number ring is 0.

### Informal sketch
The proof involves demonstrating that `ring_char complex_ring = 0`.

- First, `RING_CHAR_EQ_0` simplifies the goal to showing that for all natural numbers `n`, if `n` is a ring homomorphism from the integers to the complex numbers, then `n = 0`.
- The tactic `ring_of_num_complex` rewrites `complex_ring` using the definition of a ring, expanding the ring operations for complex numbers.
- The tactics `complex_of_num;complex_ring_clauses` expands definitions, relating operations on complex numbers to those of real numbers.
- Finally, `CX_INJ;REAL_OF_NUM_EQ` are used to reduce the result on equalities between complex numbers to those involving the real part, using injectivity theorem `CX_INJ` and that `REAL_OF_NUM_EQ` for converting naturals to reals.

### Mathematical insight
The theorem establishes a fundamental property of the complex number ring; namely, that its characteristic is 0. This means that there is no smallest positive integer `n` such that `n * 1 = 0` in the ring. This result is important in abstract algebra and is used in various contexts involving complex numbers.

### Dependencies
- Definitions: `complex_ring`, `ring_char`
- Theorems: `RING_CHAR_EQ_0`, `complex_of_num`, `complex_ring_clauses`, `CX_INJ`, `REAL_OF_NUM_EQ`, `ring_of_num_complex`


---

## ring_sub_complex

### Name of formal statement
ring_sub_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sub_complex = prove(`
  ring_sub complex_ring = (-)
`,
  rw[FUN_EQ_THM;ring_sub;complex_ring_clauses;complex_sub]
);;
```

### Informal statement
The subtraction operation `ring_sub` on the complex ring `complex_ring` is equal to the standard subtraction operation `-`.

### Informal sketch
The proof establishes the equality between `ring_sub complex_ring` and the usual subtraction function `-`.
- It applies `FUN_EQ_THM` to reduce the goal to showing that `ring_sub complex_ring x y = x - y` for all variables `x` and `y`.
- It then expands `ring_sub` according to its definition.
- Subsequently, `complex_ring_clauses` unfolds the functions and constants associated with the complex ring structure such as `complex_add`, `complex_mul`, `complex_one`, and `complex_zero`. These clauses define how the ring operations are performed on complex numbers represented as pairs of real numbers.
- Finally, `complex_sub` is applied, simplifying the expression to `x - y`, thereby proving the equality.

### Mathematical insight
This theorem demonstrates that the abstract `ring_sub` operator, when applied to the specific instance of the complex number ring (`complex_ring`), coincides with the conventional subtraction operation defined for complex numbers. This confirms the consistency and correctness of the ring subtraction operation for complex numbers.

### Dependencies
- Theorems: `FUN_EQ_THM`
- Definitions: `ring_sub`, `complex_ring`, `complex_sub`, `complex_ring_clauses`


---

## COMPLEX_MUL_RINV_UNIQ

### Name of formal statement
COMPLEX_MUL_RINV_UNIQ

### Type of the formal statement
theorem

### Formal Content
```ocaml
let COMPLEX_MUL_RINV_UNIQ = prove
 (`!w z. w * z = Cx(&1) ==> inv w = z`,
  CONV_TAC COMPLEX_FIELD);;
```
### Informal statement
For all complex numbers `w` and `z`, if `w` multiplied by `z` equals the complex number `Cx(&1)` (which represents 1 as a complex number), then the inverse of `w` is equal to `z`.

### Informal sketch
The proof is conducted within the `COMPLEX_FIELD` conversion tactic, which handles the algebraic manipulations in the complex field. Essentially, the proof starts with the assumption `w * z = 1` and uses the field properties of complex numbers to derive `inv w = z`. The key steps implicitly performed by `COMPLEX_FIELD` likely include:

- Multiplying both sides of the equation `w * z = 1` by `inv w`.
- Using the associative law of complex multiplication to get `(inv w * w) * z = inv w`.
- Using the definition of inverse to simplify `inv w * w` to `1`.
- Using the identity property to get `1 * z = inv w`.
- Simplifying `1 * z` to `z`, resulting in `z = inv w`. Which implies `inv w = z`.

### Mathematical insight
This theorem states that the multiplicative inverse in the complex field is unique. Specifically, if `w * z = 1`, then `z` must be the inverse of `w`. This is a fundamental property of fields and is crucial for algebraic manipulation within the complex numbers. The uniqueness of the inverse is essential for solving equations and performing division.

### Dependencies
- `CONV_TAC`
- `COMPLEX_FIELD`


---

## ring_inv_complex

### Name of formal statement
ring_inv_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_inv_complex = prove(`
  ring_inv complex_ring = inv
`,
  rw[FUN_EQ_THM;ring_inv;complex_ring_clauses] THEN
  simp[FIELD_UNIT;field_complex;complex_ring_clauses;IN_UNIV;COND_SWAP] THEN
  intro THEN
  case `x = Cx(&0)` THENL [
    qed[COMPLEX_INV_0]
  ;
    qed[COMPLEX_MUL_RINV;COMPLEX_MUL_RINV_UNIQ]
  ]
);;
```
### Informal statement
The ring inverse function applied to the complex numbers ring is equal to the inverse function. In other words, `ring_inv complex_ring = inv`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the equation `ring_inv complex_ring` using the definition of `ring_inv` and the clauses defining `complex_ring`.
- Simplify using the field unit, the definition of `field_complex`, the clauses defining `complex_ring`, `IN_UNIV` (which states that every element belongs to the universal set), and `COND_SWAP` (a conditional swap rule, likely related to simplifying the conditional expression arising from the definition of `ring_inv`).
- Introduce the variable `x`.
- Case split on whether `x` is equal to `Cx(&0)`, where `Cx` is the constructor for a complex number and `&0` is the real number 0.
  - If `x = Cx(&0)`, then the goal is proved using `COMPLEX_INV_0`, which likely states that the inverse of 0 is 0.
  - If `x` is not equal to `Cx(&0)`, then the goal is proved using `COMPLEX_MUL_RINV` and `COMPLEX_MUL_RINV_UNIQ`. `COMPLEX_MUL_RINV` likely states that the product of a non-zero complex number and its inverse is 1, and `COMPLEX_MUL_RINV_UNIQ` likely ensures that the inverse is unique.

### Mathematical insight
This theorem establishes that the ring inverse operation for complex numbers, as defined through the general `ring_inv` function applied to the `complex_ring` structure, coincides with the standard complex number inverse `inv`. It's a fundamental result ensuring consistency between abstract algebraic definitions and concrete implementations.

### Dependencies
- `FUN_EQ_THM`
- `ring_inv`
- `complex_ring_clauses`
- `FIELD_UNIT`
- `field_complex`
- `IN_UNIV`
- `COND_SWAP`
- `COMPLEX_INV_0`
- `COMPLEX_MUL_RINV`
- `COMPLEX_MUL_RINV_UNIQ`


---

## ring_div_complex

### Name of formal statement
ring_div_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_div_complex = prove(`
  ring_div complex_ring = (/)
`,
  rw[FUN_EQ_THM;ring_div;complex_ring_clauses;ring_inv_complex;complex_div]
);;
```

### Informal statement
The division operation `ring_div` in the `complex_ring` structure is equal to the standard division operation `/` (on complex numbers).

### Informal sketch
The proof demonstrates that the division operation defined within the structure of `complex_ring` coincides with the standard complex number division.
- Start with the goal `ring_div complex_ring = (/)`.
- Expand both sides of the equality. On the left-hand side, use the definition of `ring_div`.
- Further, use the clauses defining `complex_ring`, in particular, the definition of inverse via `ring_inv_complex`.
- The statement `complex_div` is used to rewrite the right hand side such that both sides are equivalent.
- Finally, apply `FUN_EQ_THM` to prove functional equality by proving equality at an arbitrary point.

### Mathematical insight
This theorem establishes that the abstract algebraic concept of division within the `complex_ring` structure aligns with the conventional division operation on complex numbers. It's a fundamental consistency result, ensuring that calculations performed using the ring axioms in `complex_ring` will yield the same results as direct complex number division.

### Dependencies
- Theorems: `FUN_EQ_THM`
- Definitions: `ring_div`, `complex_ring_clauses`, `ring_inv_complex`, `complex_div`


---

## ring_pow_complex

### Name of formal statement
ring_pow_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_complex = prove(`
  ring_pow complex_ring = (pow)
`,
  rw[FUN_EQ_THM] THEN
  GEN_TAC THEN
  INDUCT_TAC THEN
  simp[ring_pow;complex_ring_clauses] THEN
  qed[complex_pow]
);;
```

### Informal statement
The ring power function of the complex ring `complex_ring` is equal to the power function `pow`. That is, for any complex number `z` and natural number `n`, `ring_pow complex_ring z n` is equal to `z pow n`.

### Informal sketch
The proof demonstrates that the ring power function (`ring_pow`) specialized to the complex numbers is equivalent to the standard power function (`pow`) over complex numbers.

- The proof starts by establishing the equality of the two functions.
- It proceeds by induction over the exponent `n`.
- The base case `n = 0` follows directly from the definitions of `ring_pow` and `complex_ring_clauses`.
- The inductive step reduces to showing that `ring_pow complex_ring z (SUC n) = z pow (SUC n)`, given the hypothesis that `ring_pow complex_ring z n = z pow n`. This follows by unfolding `ring_pow`, `complex_ring_clauses` and applying the definition `complex_pow`.

### Mathematical insight
This theorem connects the abstract algebraic concept of "ring power" (which is iteratively defined using the ring's multiplication operation) to the specific power function on complex numbers. It shows that the general notion of ring power coincides with the standard power function when applied to the complex numbers (with complex multiplication).

### Dependencies
- `FUN_EQ_THM`
- `ring_pow`
- `complex_ring_clauses`
- `complex_pow`


---

## complex_field_clauses

### Name of formal statement
complex_field_clauses

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_field_clauses = prove
 (`ring_carrier complex_ring = (:complex) /\
   ring_0 complex_ring = Cx(&0) /\
   ring_1 complex_ring = Cx(&1) /\
   ring_neg complex_ring = ( -- ) /\
   ring_add complex_ring = ( + ) /\
   ring_mul complex_ring = ( * ) /\
   ring_of_num complex_ring = complex_of_num /\
   ring_sub complex_ring = (-) /\
   ring_inv complex_ring = inv /\
   ring_div complex_ring = (/) /\
   ring_pow complex_ring = (pow)`,
  rw[complex_ring_clauses;ring_of_num_complex;ring_sub_complex;ring_inv_complex;ring_div_complex;ring_pow_complex]);;
```

### Informal statement
The complex numbers form a field, where the carrier of the ring is defined as the type `:complex`, the additive identity `0` is `Cx(&0)`, the multiplicative identity `1` is `Cx(&1)`, the negation `-x` is represented by `--`, the addition `x + y` is represented by `+`, the multiplication `x * y` is represented by `*`, the embedding from numbers into the complex field is `complex_of_num`, the subtraction `x - y` is represented by `-`, the inverse of `x` is `inv`, the division `x / y` is represented by `/`, and the power `x^y` is represented by `pow`.

### Informal sketch
The proof establishes that the complex numbers, with their standard operations, satisfy the field axioms. The proof proceeds by rewriting the goal using the definitions and theorems which define each operation over the complex numbers:
- `complex_ring_clauses` unfolds the definitions of ring operations for complex numbers in terms of real number operations.
- `ring_of_num_complex` unfolds the definition of the embedding of numbers into complex numbers.
- `ring_sub_complex` unfolds the definition of subtraction for complex numbers.
- `ring_inv_complex` unfolds the definition of the inverse for complex numbers.
- `ring_div_complex` unfolds the definition of division for complex numbers.
- `ring_pow_complex` unfolds the definition of exponentiation for complex numbers.
After these rewrites, the goal simplifies to reflexivity.

### Mathematical insight
This theorem is a fundamental result in complex analysis. It confirms that the complex numbers, with their usual arithmetic operations, satisfy the axioms of a field. This is a prerequisite for many other theorems and constructions in complex analysis, such as the existence of solutions to polynomial equations (fundamental theorem of algebra), the theory of analytic functions, and complex integration.

### Dependencies
- Definitions: `complex_ring_clauses`, `ring_of_num_complex`, `ring_sub_complex`, `ring_inv_complex`, `ring_div_complex`, `ring_pow_complex`

### Porting notes (optional)
The main difficulty in porting this theorem comes from the definitions of complex arithmetic operations. It needs to be ensured that all these definitions are consistent with the source HOL Light definitions. The rewriting steps require suitable equivalents in other proof assistants (e.g., `simp` in Isabelle/HOL or `rewrite` in Coq).


---

## vsum_ring_sum_complex

### Name of formal statement
vsum_ring_sum_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let vsum_ring_sum_complex = prove(`
  !(f:X->complex) S.
  FINITE S ==>
  vsum S f =
  ring_sum complex_ring S f
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[VSUM_CLAUSES;RING_SUM_CLAUSES] THEN
    rw[complex_ring_clauses;COMPLEX_VEC_0]
  ;
    simp[VSUM_CLAUSES;RING_SUM_CLAUSES;in_complex_ring] THEN
    rw[complex_ring_clauses]
  ]
);;
```
### Informal statement
For any function `f` from a type `X` to the complex numbers (`complex`) and any set `S` of elements of type `X`, if `S` is finite, then the vector sum (`vsum`) of `f` over `S` is equal to the ring sum (`ring_sum`) of `f` over `S` in the complex number ring (`complex_ring`).

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: When `S` is empty, we need to show that `vsum` of `f` over the empty set is equal to `ring_sum` of `f` over the empty set. This is handled by rewriting with the clauses defining `VSUM` and `RING_SUM` and using that complex numbers form a vector space with `COMPLEX_VEC_0` for the zero element.
- Inductive step: When `S` is non-empty, we pick an element `x` from `S` and partition `S` into `{x}` and `S\{x}`. Then, by rewriting with the clauses defining `VSUM` and `RING_SUM` and using the fact that complex numbers form a ring to manipulate `complex_ring_clauses` and using `in_complex_ring`, we can apply the inductive hypothesis to the smaller set `S\{x}`.

### Mathematical insight
This theorem connects two different notions of summation: `vsum`, which is defined in terms of vector space addition, and `ring_sum`, which is defined in terms of ring addition. The theorem states that when summing complex numbers, which have both vector space and ring structure, the two notions of summation coincide. This reflects that complex numbers form a vector space over themselves and that the ring and vector-space addition are the same.

### Dependencies
- `VSUM_CLAUSES`
- `RING_SUM_CLAUSES`
- `complex_ring_clauses`
- `COMPLEX_VEC_0`
- `in_complex_ring`


---

## cproduct_ring_product_complex

### Name of formal statement
cproduct_ring_product_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let cproduct_ring_product_complex = prove(`
  !(f:X->complex) S.
  FINITE S ==>
  cproduct S f =
  ring_product complex_ring S f
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[CPRODUCT_CLAUSES;RING_PRODUCT_CLAUSES] THEN
    rw[complex_ring_clauses]
  ;
    simp[CPRODUCT_CLAUSES;RING_PRODUCT_CLAUSES;in_complex_ring] THEN
    rw[complex_ring_clauses]
  ]
);;
```

### Informal statement
For any function `f` from a type `X` to the complex numbers and for any finite set `S` of type `X`, the cumulative product of `f` over `S`, denoted by `cproduct S f`, is equal to the cumulative product of `f` over `S` considered within the ring structure of complex numbers, denoted by `ring_product complex_ring S f`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: When `S` is empty, both `cproduct S f` and `ring_product complex_ring S f` are equal to `complex_1` (the multiplicative identity in complex numbers), by definition of `CPRODUCT_CLAUSES` and `RING_PRODUCT_CLAUSES` applied to empty sets, and `complex_ring_clauses`.
- Inductive step: Assume that for all subsets `T` of `S`, where `S` is finite, the statement holds, i.e., `cproduct T f = ring_product complex_ring T f`. Then, we need to show that `cproduct S f = ring_product complex_ring S f`. The definitions of `cproduct` and `ring_product` expand to `f(a) * cproduct (S\{a}) f` and `f(a) * ring_product complex_ring (S\{a}) f` for some `a` in `S`, respectively.  The inductive hypothesis then allows us to conclude that `cproduct S f = ring_product complex_ring S f`. The rewriting of `complex_ring_clauses` establishes the complex ring structure.

### Mathematical insight
The theorem shows that the independently defined `cproduct` for complex valued functions over a finite set and the general `ring_product` (instantiated for the complex number ring) are equivalent. In essence, it connects a specific product definition with a more general algebraic construction. This result verifies that the standard product operation is consistent with the abstract ring product.

### Dependencies
- `CPRODUCT_CLAUSES`
- `RING_PRODUCT_CLAUSES`
- `complex_ring_clauses`
- `in_complex_ring`


---

## vsum_delta_complex

### Name of formal statement
vsum_delta_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let vsum_delta_complex = prove(`
  !(S:X->bool) t a.
  FINITE S ==>
  vsum S (\s. if s = t then a else Cx(&0))
  = if t IN S then a else Cx(&0)
`,
  rw[GSYM COMPLEX_VEC_0] THEN
  qed[VSUM_DELTA]
);;
```
### Informal statement
For any set `S` from a type `X` to booleans, any element `t` of type `X` , and any complex number `a`, if `S` is finite, then the vector sum over `S` of the function that maps `s` to `a` if `s` equals `t` and to the complex number `0` otherwise, is equal to `a` if `t` is in `S` and to the complex number `0` otherwise.

### Informal sketch
The proof proceeds as follows:
- Rewrite using `GSYM COMPLEX_VEC_0` to replace `Cx(&0)` with `&0`.
- Apply the theorem `VSUM_DELTA`.

### Mathematical insight
The theorem `vsum_delta_complex` is a specialization of `VSUM_DELTA` to complex numbers. It states that when summing a function over a set `S` that is zero everywhere except at a single point `t`, the sum is simply the value of the function at that point `t` if `t` is in `S`, and zero otherwise. This is a fundamental property of sums and is very useful for simplifying expressions involving sums over sets.

### Dependencies
- Theorems:
  - `VSUM_DELTA`
- Constants:
  - `COMPLEX_VEC_0`


---

## ring_1_0_complex

### Name of formal statement
ring_1_0_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_1_0_complex = prove(`
  ~(ring_1 complex_ring = ring_0 complex_ring)
`,
  qed[integral_domain_complex;integral_domain]
);;
```
### Informal statement
It is not the case that the multiplicative identity (`ring_1`) of the complex number ring (`complex_ring`) is equal to the additive identity (`ring_0`) of the complex number ring (`complex_ring`).

### Informal sketch
The proof uses the facts that `complex_ring` is an integral domain and that any integral domain satisfies the property that its multiplicative identity is distinct from its additive identity.
- Apply the theorem `integral_domain_complex` which states that `complex_ring` is an integral domain.
- Apply the theorem `integral_domain` which states that in an integral domain, the multiplicative identity is distinct from the additive identity.

### Mathematical insight
This theorem establishes a fundamental property of the complex number ring: that its multiplicative and additive identities are distinct. This is a basic requirement for any ring structure to be non-trivial and is essential for many subsequent theorems and calculations involving complex numbers. This property holds true for any integral domain, and since complex numbers form an integral domain, it naturally holds for complex numbers too.

### Dependencies
- Theorems:
  - `integral_domain_complex`
  - `integral_domain`


---

## series_complex

### Name of formal statement
series_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let series_complex = prove(`
  !(p:(1->num)->complex).
  ring_powerseries complex_ring p
`,
  rw[ring_powerseries;in_complex_ring] THEN
  qed[FINITE_MONOMIAL_VARS_1;INFINITE]
);;
```

### Informal statement
For any function `p` from natural numbers to complex numbers, `p` forms a ring powerseries within the complex number ring.

### Informal sketch
*   The proof proceeds by rewriting the statement using the definitions of `ring_powerseries` and `in_complex_ring`.

*   `ring_powerseries` is unfolded.

*   The goal becomes provable by discharging the assumption that the monomial variables are finite and then by using `INFINITE` tactic.

### Mathematical insight
This theorem establishes that power series with coefficients in the complex numbers form a ring. This is a fundamental result in complex analysis, ensuring that the algebraic operations on power series are well-defined and yield power series with coefficients in the complex numbers.

### Dependencies
*   Definitions:
    *   `ring_powerseries`
    *   `in_complex_ring`
*   Theorems:
    *   `FINITE_MONOMIAL_VARS_1`
    *    `INFINITE`


---

## complex_coeff_x_pow_times

### Name of formal statement
complex_coeff_x_pow_times

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_coeff_x_pow_times = prove(`
  !d p e.
  coeff e (poly_mul complex_ring (x_pow complex_ring d) p)
  = if e < d then Cx(&0) else coeff (e - d) p
`,
  qed[coeff_x_pow_times;series_complex;complex_ring_clauses]
);;
```
### Informal statement
For all natural numbers `d` and polynomials `p` over the complex numbers with coefficients `e`, the coefficient of `e` in the polynomial `x^d * p` (where `x^d` is the polynomial representation of x raised to the power of `d`) is equal to the complex number `0` if `e` is less than `d`; otherwise, it is equal to the coefficient of `e - d` in `p`.

### Informal sketch
The proof proceeds by induction on the structure of the input polynomial `p`.

- Base case: show that the theorem holds when `p` is a constant polynomial. This involves expanding the definition of `poly_mul` and `x_pow`, determining when `e < d`, and simplifying using properties of the complex numbers.
- Inductive step: Assume that the theorem holds for polynomials `p1` and `p2`. We must show that the theorem also holds for their sum `p1 + p2`. The proof can be broken down with the following steps:
    - Use `coeff_polyadd` to express the coefficient of `e` in the sum `p1 + p2` in terms of the coefficients of `p1` and `p2`.
    - Apply the inductive hypotheses to express the coefficients of `x^d * p1` and `x^d * p2`.
    - Distinguish the cases `e < d` and `e >= d`. In each case simplify the resulting expression to show the equality holds.
- The rewriting rules from `complex_ring_clauses` are used for simplifications related to complex numbers. The theorem `coeff_x_pow_times` for real numbers, and `series_complex` which states that polynomials in HOL Light are represented by series of coefficients up to a certain point are also used.

### Mathematical insight
This theorem describes how multiplying a polynomial by `x^d` affects its coefficients. Specifically, it shifts the coefficients of the original polynomial to higher powers, inserting zeros for the lower powers. This is a fundamental property used in manipulating polynomials.

### Dependencies
- Theorems: `coeff_x_pow_times`, `series_complex`
- Theory: `complex_ring_clauses`


---

## poly_1_0_complex

### Name of formal statement
poly_1_0_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_1_0_complex = prove(`
  ~(poly_1 complex_ring = poly_0 complex_ring:(V->num)->complex)
`,
  rw[poly_1;poly_0;POLY_CONST_EQ] THEN
  qed[ring_1_0_complex]
);;
```
### Informal statement
It is not the case that the polynomial of degree 1 (over complex numbers) is equal to the polynomial of degree 0 (over complex numbers) as functions from `V` (a type variable) to complex numbers.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definitions of `poly_1` and `poly_0`.
- Rewrite using the definition of `POLY_CONST_EQ`, which states that two polynomials are equal if and only if they are extensionally equal when evaluated with a constant.
- Apply `ring_1_0_complex` which proves that `~(1 = 0 : complex)`.

### Mathematical insight
This theorem states that polynomials of degree 1 and degree 0 are distinct when considered as functions. This is a basic fact in polynomial algebra and is important for establishing the hierarchy of polynomial degrees.

### Dependencies
- `poly_1`
- `poly_0`
- `POLY_CONST_EQ`
- `ring_1_0_complex`


---

## ZinC

### Name of formal statement
ZinC

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let ZinC = new_definition `
  ZinC = {z:complex | ?i:int. z = complex_of_int i}
`;;
```

### Informal statement
The set `ZinC` is defined to be the set of complex numbers `z` such that there exists an integer `i` such that `z` is equal to the complex number constructed from the integer `i`.

### Informal sketch
- The definition introduces a new set called `ZinC`.
- The elements of `ZinC` are complex numbers.
- A complex number `z` belongs to `ZinC` if it can be obtained by converting some integer `i` into a complex number using the function `complex_of_int`.

### Mathematical insight
This definition introduces the set of complex numbers that are obtained from integers, effectively embedding the integers into the complex plane along the real axis. It is a standard way to view integers inside the complex numbers.

### Dependencies
None


---

## ZinC_ring

### Name of formal statement
ZinC_ring

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let ZinC_ring = new_definition `
  ZinC_ring = ring(ZinC,Cx(&0),Cx(&1),( -- ),( + ),( * ))
`;;
```
### Informal statement
The structure `ZinC_ring` is defined to be a ring structure consisting of the carrier `ZinC`, zero element `Cx(&0)`, one element `Cx(&1)`, additive inverse operation `( -- )`, addition operation `( + )`, and multiplication operation `( * )`.

### Informal sketch
The definition introduces `ZinC_ring` as a ring, constructed using `ring` which is a constructor for ring structures. The components making up the ring are concretely given by basic arithmetic operations on complex numbers restricted to the integers. No proof is involved, as this is a direct definition.

### Mathematical insight
This definition establishes that integers form a ring under the standard operations of addition, multiplication, and additive inverse. This is a fundamental algebraic structure.

### Dependencies
- `ring`
- `ZinC`
- `Cx`


---

## ii_not_in_ZinC

### Name of formal statement
ii_not_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ii_not_in_ZinC = prove(`
  ~(ii IN ZinC)
`,
  rw[ZinC;IN_ELIM_THM;complex_of_int] THEN
  rw[ii;COMPLEX_EQ;CX_DEF;IM] THEN
  ARITH_TAC
);;
```
### Informal statement
It is not the case that `ii` is in `ZinC`.

### Informal sketch
The proof demonstrates that the imaginary unit `ii` is not an element of `ZinC`, which represents the complex numbers with integer real and imaginary parts.

- First, the definition of `ZinC` is unfolded, along with the elimination theorem for membership (`IN_ELIM_THM`) and the definition of `complex_of_int`.
- Then, the definition of `ii`, the definition of complex equality (`COMPLEX_EQ`), the definition of `CX_DEF` (complex number construction) and the definition of the imaginary part (`IM`) are unfolded.
- Finally, `ARITH_TAC` is applied to resolve the arithmetic contradiction.

### Mathematical insight
This theorem establishes that the imaginary unit `ii` (defined as `complex (0,1)`) is not a complex number with integer real and imaginary parts. This is a basic but important fact related to the structure of the complex numbers and the integers. It clarifies the relationship between pure imaginary numbers and the lattice of complex numbers with integer components.

### Dependencies
- Definition: `ZinC`
- Theorem: `IN_ELIM_THM`
- Definition: `complex_of_int`
- Definition: `ii`
- Theorem: `COMPLEX_EQ`
- Definition: `CX_DEF`
- Definition: `IM`


---

## half_not_in_ZinC

### Name of formal statement
half_not_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let half_not_in_ZinC = prove(`
  ~(Cx(&1 / &2) IN ZinC)
`,
  rw[ZinC;IN_ELIM_THM;complex_of_int] THEN
  rw[CX_INJ] THEN
  intro THEN
  int_linear_fact `&1 / &2 = real_of_int i ==> &1 = &2 * (real_of_int i)` THEN
  have `&1 = real_of_int(&1)` [REAL_OF_INT_CLAUSES] THEN
  have `&2 = real_of_int(&2)` [REAL_OF_INT_CLAUSES] THEN
  have `real_of_int(&1) = real_of_int(&2) * real_of_int i` [] THEN
  have `real_of_int(&1) = real_of_int(&2 * i)` [REAL_OF_INT_CLAUSES] THEN
  have `&1 = &2 * i:int` [REAL_OF_INT_CLAUSES] THEN
  DISJ_CASES_TAC(SPEC `i:int` INT_IMAGE) THENL [
    choose `n:num` `i:int = &n` [] THEN
    have `&1 = &2 * &n:int` [] THEN
    num_linear_fact `&1 = &2 * &n:int ==> 1 = 2 * n` THEN
    have `EVEN 1` [EVEN_EXISTS] THEN
    num_linear_fact `1 = SUC(2 * 0)` THEN
    have `ODD 1` [ODD_EXISTS] THEN
    qed[NOT_EVEN]
  ;
    ASM_ARITH_TAC
  ]
);;
```

### Informal statement
It is not the case that the complex number that is one half is an element of the Gaussian integers (`ZinC`).

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `ZinC`, the elimination theorem for `IN`, and the fact that an integer is a complex number to obtain `~(&1 / &2 = complex_of_int i)` where `i` is an integer.
- Use the injectivity of `Cx` and introduce `i` by discharging the negation sign and moving it from the top level to an equality.
- Apply an integer linear fact to rewrite `&1 / &2 = real_of_int i`  as `&1 = &2 * (real_of_int i)`.
- Convert `&1` and `&2` to their real_of_int equivalents.
- Rewrite `real_of_int(&2) * real_of_int i` as `real_of_int(&2 * i)`.
- Infer `&1 = &2 * i:int`.
- Perform a case split based on `i:int` belonging to the image of integers under the mapping from numerals to integers.
  - In the first case, assume `i = &n` where `n` is a numeral.
  - Use a numerical linear fact to rewrite `&1 = &2 * &n:int` to `1 = 2 * n`, and deduce `EVEN 1`.
  - Reduce `1 = SUC(2 * 0)` and deduce `ODD 1`.
  - Obtain a contradiction, where `NOT_EVEN` stands for negation of the fact that 1 is even.
  - Reduce by assumption.
  - In the second case, use `ASM_ARITH_TAC` to discharge the arithmetic goal.

### Mathematical insight
The theorem states that 1/2 is not a Gaussian integer. The proof converts the problem into one of integers, and uses a case split to show that the real part of 1/2 could not possibly be an integer because otherwise 1 would be even.

### Dependencies
- Definitions: `ZinC`, `complex_of_int`
- Theorems: `IN_ELIM_THM`, `CX_INJ`, `REAL_OF_INT_CLAUSES`, `EVEN_EXISTS`, `ODD_EXISTS`, `NOT_EVEN`
- Tactics: `int_linear_fact`, `num_linear_fact`, `DISJ_CASES_TAC`, `ASM_ARITH_TAC`


---

## num_in_ZinC

### Name of formal statement
num_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let num_in_ZinC = prove(`
  !d. Cx(&d) IN ZinC
`,
  intro THEN
  rw[ZinC;IN_ELIM_THM;complex_of_int] THEN
  witness `&d:int` THEN
  rw[int_of_num_th]
);;
```
### Informal statement
For all numbers `d`, the complex number `Cx(&d)` is an element of the set `ZinC`.

### Informal sketch
The proof demonstrates that for any number `d`, the corresponding complex number `Cx(&d)` is in the set `ZinC`.

- Start with the goal `Cx(&d) IN ZinC`.
- Expand `ZinC` using its definition and eliminate the `IN` relation. This step rewrites `Cx(&d) IN ZinC` to `?n. Cx(&d) = complex_of_int n`.
- Instantiate the existential quantifier with `&d:int`. This relies on the fact that if `d` is a number, then `&d` is a suitable integer.
- Rewrite `complex_of_int (&d)` to `Cx(&d)` using the theorem `int_of_num_th`. This finishes the proof.

### Mathematical insight
This theorem establishes that complex numbers constructed from real numbers are contained within the set `ZinC` of complex numbers which are created by mapping integers into complex numbers. This shows that all real numbers are contained in the complex numbers which are created by integers, which means that the codomain of integers is large enough to contain all complex numbers which are created by numbers.

### Dependencies
- Definitions:
  - `ZinC`
- Theorems:
  - `IN_ELIM_THM`
  - `complex_of_int`
  - `int_of_num_th`


---

## int_in_ZinC

### Name of formal statement
int_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let int_in_ZinC = prove(`
  !i. complex_of_int i IN ZinC
`,
  SET_TAC[ZinC]
);;
```
### Informal statement
For every integer `i`, the complex number corresponding to `i` belongs to the set `ZinC`.

### Informal sketch
The proof is done using `SET_TAC` which is a tactic that attempts to directly prove set membership based on the definition of the set involved. In this case, it discharges the goal by appealing to the definition of `ZinC`.

### Mathematical insight
The theorem `int_in_ZinC` states that the complex embedding of any integer belongs to the set `ZinC`. The set `ZinC` likely represents the Gaussian integers (complex numbers with integer real and imaginary parts). Thus, this theorem asserts that integers, when viewed as complex numbers, can be seen as elements of the Gaussian integers, since complex embedding of an integer `i` is `i + 0i`.

### Dependencies
- Definitions: `ZinC`

### Porting notes (optional)
This theorem is quite straightforward and should be easily portable to other proof assistants. It relies on the definition of `ZinC` and the complex embedding of integers. Ensure that the corresponding definitions are available in the target proof assistant.


---

## ZinC_0

### Name of formal statement
ZinC_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_0 = prove(`
  Cx(&0) IN ZinC
`,
  qed[num_in_ZinC]
);;
```
### Informal statement
The complex number 0 is an element of the set `ZinC`.

### Informal sketch
The proof is a direct application of the theorem `num_in_ZinC`. It states directly that a natural number n is in `ZinC`. Since 0 is a natural number (`&0`), we can conclude that `Cx(&0)` (which is the complex representation of 0) is an element of `ZinC`.

### Mathematical insight
This theorem establishes the base case for membership in the set `ZinC`, which likely represents some set of complex integer numbers. This is important to show that `ZinC` is inhabited and serves as a foundation for further induction or recursive definitions based on `ZinC`. This is a very fundamental fact about `ZinC`.

### Dependencies
- Theorems: `num_in_ZinC`


---

## ZinC_1

### Name of formal statement
ZinC_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_1 = prove(`
  Cx(&1) IN ZinC
`,
  qed[num_in_ZinC]
);;
```

### Informal statement
The complex number 1 belongs to the set `ZinC`.

### Informal sketch
The proof uses the theorem `num_in_ZinC` which states that a natural number is in `ZinC` if and only if it is a natural number.
The theorem `num_in_ZinC` implies that `1` belongs to `ZinC` because `Cx(&1)` represents the complex number corresponding to the natural number `1`.

### Mathematical insight
This theorem establishes that the complex number `1` is a member of the set `ZinC`. It follows directly from the definition of `ZinC` and the properties inherited from `num_in_ZinC` representing natural numbers as complex numbers within the set.

### Dependencies
- Theorems: `num_in_ZinC`


---

## neg_in_ZinC

### Name of formal statement
neg_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let neg_in_ZinC = prove(`
  !x:complex.
  x IN ZinC ==> --x IN ZinC
`,
  rw[ZinC;IN_ELIM_THM;complex_of_int] THEN
  intro THEN
  witness `int_neg i` THEN
  rw[GSYM REAL_OF_INT_CLAUSES;CX_NEG] THEN
  qed[]
);;
```

### Informal statement
For all complex numbers `x`, if `x` is in the set `ZinC` (complex integers), then its negation `--x` is also in `ZinC`.

### Informal sketch
The proof proceeds as follows:
- Start by rewriting using the definition of `ZinC`, the elimination theorem for `IN`, and the definition of `complex_of_int`.
- Introduce the assumption `x IN ZinC`.
- Instantiate the assumption with `int_neg i` for some integer `i`, where `i` is related to the real part of `x`.
- Rewrite using the theorem `REAL_OF_INT_CLAUSES` which states that the real part of an integer represented as a complex number is the integer itself, and using the definition `CX_NEG`, which describes the negation of a complex number.
- Conclude the proof.

### Mathematical insight
The theorem `neg_in_ZinC` states that the set of complex integers (`ZinC`) is closed under negation. This is a fundamental property required for `ZinC` to behave like an integral domain within the complex numbers.

### Dependencies
- Definitions: `ZinC`, `complex_of_int`
- Theorems: `IN_ELIM_THM`, `REAL_OF_INT_CLAUSES`, `CX_NEG`


---

## add_in_ZinC

### Name of formal statement
add_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let add_in_ZinC = prove(`
  !x:complex y:complex.
  x IN ZinC /\ y IN ZinC ==> x+y IN ZinC
`,
  rw[ZinC;IN_ELIM_THM;complex_of_int] THEN
  intro THEN
  witness `i+i':int` THEN
  rw[GSYM REAL_OF_INT_CLAUSES;CX_ADD] THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `x` and `y`, if `x` is an element of the set `ZinC` and `y` is an element of the set `ZinC`, then `x + y` is an element of the set `ZinC`.

### Informal sketch
- The proof starts by rewriting using the definition of `ZinC`, the theorem `IN_ELIM_THM`, and `complex_of_int`.
- An assumption is introduced.
- An integer `i+i'` is chosen as a witness.
- The theorem is then rewritten using `GSYM REAL_OF_INT_CLAUSES` and `CX_ADD`.
- Finally the proof is completed using `qed[]`.

### Mathematical insight
This theorem demonstrates that the set `ZinC` (complex numbers with integer real and imaginary parts) is closed under addition. This is a fundamental property when considering `ZinC` as a subring of the complex numbers.

### Dependencies
- Definitions: `ZinC`
- Theorems: `IN_ELIM_THM`, `REAL_OF_INT_CLAUSES`
- Axioms: `CX_ADD`

### Porting notes (optional)
- The theorem `IN_ELIM_THM` is likely related to some elimination rule of the set membership.
- The `GSYM` is used simply for reversing the equation. `REAL_OF_INT_CLAUSES` are likely about the simplification rules for injecting integers into reals.
- `CX_ADD` is likely to define how to add up complex numbers.


---

## mul_in_ZinC

### Name of formal statement
mul_in_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let mul_in_ZinC = prove(`
  !x:complex y:complex.
  x IN ZinC /\ y IN ZinC ==> x*y IN ZinC
`,
  rw[ZinC;IN_ELIM_THM;complex_of_int] THEN
  intro THEN
  witness `i*i':int` THEN
  rw[GSYM REAL_OF_INT_CLAUSES;CX_MUL] THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `x` and `y`, if `x` is in `ZinC` and `y` is in `ZinC`, then the product of `x` and `y` is in `ZinC`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `ZinC`, `IN_ELIM_THM` and `complex_of_int` to expand the definition of `x IN ZinC` and `y IN ZinC` as `exists i:int. x = complex_of_int i /\ exists i':int. y = complex_of_int i'`.
- Then, introduce the variables `i` and `i'` as witnesses for these existential quantifiers.
- Next, use `i*i'` as a witness for the existential quantifier in the definition of `x*y IN ZinC`.
- Rewrite using `GSYM REAL_OF_INT_CLAUSES` and `CX_MUL` to show that `x * y = complex_of_int (i * i')`.
- Finally, complete the proof.

### Mathematical insight
This theorem establishes the closure of the set `ZinC` (complex numbers with integer real and imaginary parts) under complex number multiplication. This is a basic ring property, guaranteeing that multiplying two elements of `ZinC` results in another element within `ZinC`.

### Dependencies
- Definitions: `ZinC`
- Theorems/Axioms: `IN_ELIM_THM`, `complex_of_int`, `REAL_OF_INT_CLAUSES`, `CX_MUL`


---

## ZinC_ring_clauses

### Name of formal statement
ZinC_ring_clauses

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_ring_clauses = prove(`
  ring_carrier ZinC_ring = ZinC /\
  ring_0 ZinC_ring = Cx(&0) /\
  ring_1 ZinC_ring = Cx(&1) /\
  ring_neg ZinC_ring = ( -- ) /\
  ring_add ZinC_ring = ( + ) /\
  ring_mul ZinC_ring = ( * )
`,
  rw[ring_carrier;ring_0;ring_1;ring_neg;ring_add;ring_mul;GSYM PAIR_EQ] THEN
  rw[ZinC_ring] THEN
  rw[GSYM(CONJUNCT2 ring_tybij)] THEN
  rw[ZinC_0;ZinC_1;neg_in_ZinC;add_in_ZinC;mul_in_ZinC] THEN
  qed[COMPLEX_ADD_SYM;COMPLEX_ADD_ASSOC;COMPLEX_ADD_LID;COMPLEX_ADD_LINV;COMPLEX_MUL_ASSOC;COMPLEX_MUL_SYM;COMPLEX_MUL_LID;COMPLEX_ADD_LDISTRIB]
);;
```
### Informal statement
The ring axioms hold for `ZinC_ring`, specifically:
1. The carrier of the ring `ZinC_ring` is `ZinC`.
2. The additive identity `ring_0` of `ZinC_ring` is `Cx(&0)`.
3. The multiplicative identity `ring_1` of `ZinC_ring` is `Cx(&1)`.
4. The additive inverse `ring_neg` of `ZinC_ring` is the negation function `--`.
5. The addition operation `ring_add` of `ZinC_ring` is the addition function `+`.
6. The multiplication operation `ring_mul` of `ZinC_ring` is the multiplication function `*`.

### Informal sketch
The proof proceeds by:
- Rewriting with definitions: rewrite the left-hand side using definitions of `ring_carrier`, `ring_0`, `ring_1`, `ring_neg`, `ring_add`, `ring_mul` and `PAIR_EQ` (generalized symmetry).
- Rewriting with `ZinC_ring` definition.
- Rewriting using the symmetry of `CONJUNCT2 ring_tybij`.
- Rewriting by showing that 0 and 1 are in `ZinC`, and that `ZinC` is closed under negation, addition, and multiplication.
- Applying the axioms of complex numbers: proving the theorem using `COMPLEX_ADD_SYM`, `COMPLEX_ADD_ASSOC`, `COMPLEX_ADD_LID`, `COMPLEX_ADD_LINV`, `COMPLEX_MUL_ASSOC`, `COMPLEX_MUL_SYM`, `COMPLEX_MUL_LID`, and `COMPLEX_ADD_LDISTRIB`.

### Mathematical insight
This theorem establishes that `ZinC`, the set of complex numbers with integer real and imaginary parts, forms a ring under the usual complex number operations. This is a fundamental step in formally verifying properties about algebraic structures consisting of complex numbers. The definition of 'ring' is axiomatized elsewhere in HOL Light (likely the `ringTheory` library), and here those axioms are being shown to be satisfied by `ZinC` with the standard complex number operations.

### Dependencies
- Definitions: `ring_carrier`, `ring_0`, `ring_1`, `ring_neg`, `ring_add`, `ring_mul`, `ZinC_ring`
- Theorems/Lemmas: `PAIR_EQ`, `CONJUNCT2 ring_tybij`, `ZinC_0`, `ZinC_1`, `neg_in_ZinC`, `add_in_ZinC`, `mul_in_ZinC`, `COMPLEX_ADD_SYM`, `COMPLEX_ADD_ASSOC`, `COMPLEX_ADD_LID`, `COMPLEX_ADD_LINV`, `COMPLEX_MUL_ASSOC`, `COMPLEX_MUL_SYM`, `COMPLEX_MUL_LID`, `COMPLEX_ADD_LDISTRIB`

### Porting notes (optional)
- The `ring_tybij` theorem seems to relate to the type bijection condition for a ring. This may need careful attention when porting, as type bijections are handled differently across proof assistants.
- The proof makes extensive use of rewriting. This technique translates well to other proof assistants, but the specific rewrite rules might need adaptation based on how the complex numbers and ring axioms are defined.


---

## ZinC_subring_complex

### Name of formal statement
ZinC_subring_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_subring_complex = prove(`
  ZinC subring_of complex_ring
`,
  rw[subring_of] THEN
  rw[complex_ring_clauses] THEN
  rw[ZinC_0;ZinC_1;neg_in_ZinC;add_in_ZinC;mul_in_ZinC;SUBSET_UNIV]
);;
```
### Informal statement
The set of Gaussian integers (`ZinC`) forms a subring of the ring of complex numbers (`complex_ring`).

### Informal sketch
The proof demonstrates that `ZinC` satisfies the subring criteria with respect to `complex_ring`.
- First, the definition of `subring_of` is unfolded.
- Then, the properties defining `complex_ring` are unfolded using `complex_ring_clauses` (namely those related to its additive and multiplicative structure).
- The properties characterizing `ZinC` as a subring are then used: `ZinC_0` (0 is in ZinC), `ZinC_1` (1 is in ZinC), `neg_in_ZinC` (negation of an element in ZinC is in ZinC), `add_in_ZinC` (addition of two elements in ZinC is in ZinC), `mul_in_ZinC` (multiplication of two elements in ZinC). Also, `SUBSET_UNIV` is applied to prove that `ZinC` is indeed a subset, which is obvious since `ZinC` is defined as a subset.

### Mathematical insight
This theorem establishes that the Gaussian integers (`ZinC`) inherit the ring structure from the complex numbers. This is a fundamental property that allows us to apply ring-theoretic results to the Gaussian integers. It's important as it enables algebraic reasoning within `ZinC` using the complex field's operations.

### Dependencies
- Definitions:
    - `ZinC`
    - `complex_ring`
    - `subring_of`
- Theorems:
    - `ZinC_0`
    - `ZinC_1`
    - `neg_in_ZinC`
    - `add_in_ZinC`
    - `mul_in_ZinC`
    - `SUBSET_UNIV`


---

## ZinC_subring_generated_carrier

### Name of formal statement
ZinC_subring_generated_carrier

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_subring_generated_carrier = prove(`
  ZinC = INTERS {S | S subring_of complex_ring}
`,
  rw[INTERS] THEN
  rw[ZinC;IN_ELIM_THM;EXTENSION] THEN
  intro THEN
  splitiff THENL [
    rw[GSYM ring_of_int_complex] THEN
    qed[int_in_subring]
  ;
    intro THEN
    have `ZinC subring_of complex_ring` [ZinC_subring_complex] THEN
    have `x IN ZinC` [] THEN
    have `x IN {z | ?i. z = complex_of_int i}` [ZinC] THEN
    set_fact `x IN {z | ?i. z = complex_of_int i} ==> ?i. x = complex_of_int i` THEN
    qed[]
  ]
);;
```

### Informal statement
The set of complex numbers, `ZinC`, defined as the intersection of all subrings of the complex numbers, is equal to the set of complex numbers that are the complex embeddings of integers. That is, `ZinC = INTERS {S | S subring_of complex_ring}` is equivalent to `ZinC = {z | ?i. z = complex_of_int i}`.

### Informal sketch
The proof proceeds by demonstrating that `ZinC` is equal to the intersection of all subrings of `complex_ring` if and only if (1) every integer, when embedded in the complex numbers, belongs to every subring of the complex numbers, and (2) if an element `x` belongs to the intersection of all subrings of the complex numbers, then `x` is the complex embedding of some integer.

- First, it is shown that every integer `i`, when considered as an element of the complex ring via `complex_of_int`, belongs to every subring of the complex numbers. This follows because `ring_of_int_complex` proves that the integers are a subring of the complex numbers, and `int_in_subring` proves that integers belong to all subrings.

- Next, it is shown that if `x` is in `ZinC`, which is defined as the intersection of all subrings of the complex numbers, then there exists an integer `i` such that `x = complex_of_int i`.  The proof uses the fact that `ZinC` is a subring of the complex numbers and proceeds by assuming `x IN ZinC` to show that `x` is the complex embedding of some integer.

### Mathematical insight
The theorem establishes that the smallest subring of the complex numbers is precisely the image of the integers under the canonical embedding into the complex numbers. In other words, it characterizes the subring of the complex numbers generated by the integers. This is a fundamental result in understanding the algebraic structure of the complex numbers.

### Dependencies
- `INTERS`
- `ZinC`
- `IN_ELIM_THM`
- `EXTENSION`
- `ring_of_int_complex`
- `complex_ring`
- `int_in_subring`

### Porting notes (optional)
The main difficulty in porting this theorem would be ensuring the correct definitions of `subring`, `complex_ring`, and the embedding of integers into the complex numbers. The tactic `splitiff` is used to split an iff goal into two implications, which is a common tactic across different proof assistants. The tactic `set_fact` stores a fact for later usage, which is usually handled differently depending on the assistant.


---

## subring_complex_empty_lemma

### Name of formal statement
subring_complex_empty_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_complex_empty_lemma = prove(`
  INTERS {S | S subring_of complex_ring /\ (:complex) INTER {} SUBSET S} = ZinC
`,
  rw[ZinC_subring_generated_carrier] THEN
  SET_TAC []
);;
```
### Informal statement
The intersection of all sets `S` such that `S` is a subring of the complex numbers and the intersection of the type `:complex` and the empty set is a subset of `S`, equals the subring of complex numbers generated by `ZinC` (the integers).

### Informal sketch
- The proof uses `rw[ZinC_subring_generated_carrier]` to rewrite the right-hand side to the actual definition of the subring generated by `ZinC`, which involves an intersection of all subrings containing `ZinC`.
- The subsequent `SET_TAC []` step automatically solves the resulting set-theoretic goal, which essentially states that the intersection of all subrings containing `ZinC` is equal to the intersection of all subrings `S` such that `(complex) INTER {} SUBSET S`. This holds because `(complex) INTER {} = {}`, and any subring of the complex numbers will trivially contain the empty set. Thus, the condition `(:complex) INTER {} SUBSET S` is always true for subrings `S` of the complex numbers. So we're simply intersecting all subrings S of complex numbers, which contain the integers which `ZinC_subring_generated_carrier` reduces to.

### Mathematical insight
The lemma expresses that the smallest subring of the complex numbers containing all integers is the intersection of all subrings of the complex numbers which contain the empty set. Because any subring contains the empty set, this is equivalent to the subring generated by the integers. This reflects a fundamental property of subring generation. Subrings always contain the additive and multiplicative identities, and are closed under subtraction and multiplication.

### Dependencies
- `ZinC_subring_generated_carrier`


---

## subring_complex_empty

### Name of formal statement
subring_complex_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_complex_empty = prove(`
  subring_generated complex_ring {} = ZinC_ring
`,
  rw[subring_generated] THEN
  rw[complex_ring_clauses] THEN
  rw[ZinC_ring;subring_complex_empty_lemma]
);;
```
### Informal statement
The subring of the complex numbers generated by the empty set is equal to the ring of integers embedded in the complex numbers (`ZinC_ring`).

### Informal sketch
The proof proceeds by:

- First, rewriting the left-hand side using the definition of `subring_generated`.
- Next, rewriting using the defining clauses for `complex_ring` to expand the subring generation in the context of the complex numbers.
- Finally, rewriting using the definition of `ZinC_ring` and the lemma `subring_complex_empty_lemma` which states that the subring generated from the empty set over the complex numbers is equal to the integers embedded in the complex numbers (i.e. `ZinC_ring`).

### Mathematical insight
The statement expresses a fundamental property of subring generation. Namely, when starting with nothing (the empty set) and generating a subring within the complex numbers, we obtain precisely the integers embedded in the complex numbers. This makes sense because the integers are the smallest subring containing the multiplicative identity.

### Dependencies
- Definitions:
  - `subring_generated`
  - `complex_ring_clauses` 
  - `ZinC_ring`
- Theorems:
  - `subring_complex_empty_lemma`


---

## ring_char_ZinC

### Name of formal statement
ring_char_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_char_ZinC = prove(`
  ring_char ZinC_ring = 0
`,
  recall ring_char_complex THEN
  specialize[`complex_ring`;`{}:complex->bool`]RING_CHAR_SUBRING_GENERATED THEN
  qed[subring_complex_empty]
);;
```

### Informal statement
The ring characteristic of the ring of integers `ZinC_ring` is 0.

### Informal sketch
The proof uses the theorem `RING_CHAR_SUBRING_GENERATED`, which states that if a ring `R` is generated by a subring `S`, then the ring characteristic of `R` is the ring characteristic of `S`. The proof proceeds as follows:
- Recall the theorem `ring_char_complex`, which states that the ring characteristic of the complex numbers (`complex_ring`) is 0.
- Specialize the theorem `RING_CHAR_SUBRING_GENERATED` to the ring of complex numbers `complex_ring` and the subring which is the empty set `{}:complex->bool`. This implies that the ring characteristic of the complex numbers is the ring characteristic of the subring generated by an empty subset.
- Conclude by using `subring_complex_empty`, meaning that the subring generated by the empty set is isomorphic to `ZinC_ring`.

### Mathematical insight
This theorem states a fundamental property of the integers: that considered as a ring, they have characteristic 0. The characteristic of a ring is the smallest positive integer `n` such that `n * 1 = 0` (where 1 is the multiplicative identity), or 0 if no such `n` exists.  Since for any positive integer `n`, `n * 1 != 0` in the integers, the characteristic is 0. The proof demonstrates how this can be derived in HOL Light starting from properties of the complex numbers.

### Dependencies
- `ring_char_complex`
- `RING_CHAR_SUBRING_GENERATED`
- `subring_complex_empty`


---

## subring_complex_ZinC_lemma

### Name of formal statement
subring_complex_ZinC_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_complex_ZinC_lemma = prove(`
  INTERS {S | S subring_of complex_ring /\ (:complex) INTER ZinC SUBSET S} = ZinC
`,
  rw[ZinC_subring_generated_carrier] THEN
  SET_TAC []
);;
```

### Informal statement
The intersection of all subsets `S` of the complex numbers that are subrings of the complex numbers and contain the integers `ZinC` equals the set of integers `ZinC`.

### Informal sketch
The proof shows that the intersection of all complex subrings that contain the integers equals the integers.

- The proof starts by rewriting the left-hand side using the theorem `ZinC_subring_generated_carrier`. This theorem states that `ZinC` is the smallest subring of the complex numbers which contains `ZinC` itself.
- After rewriting, the goal is trivially discharged using `SET_TAC []`, which simplifies the set-theoretic reasoning.

### Mathematical insight
This theorem confirms that the integers (`ZinC`) form the smallest subring of the complex numbers containing the integers themselves. It is a fundamental result in ring theory and complex analysis, establishing a basic property concerning the generation of the integers as a substructure within the complex numbers viewed as a ring.

### Dependencies
- Theorems: `ZinC_subring_generated_carrier`


---

## subring_complex_ZinC

### Name of formal statement
subring_complex_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_complex_ZinC = prove(`
  subring_generated complex_ring ZinC = ZinC_ring
`,
  rw[subring_generated] THEN
  rw[complex_ring_clauses] THEN
  rw[ZinC_ring;subring_complex_ZinC_lemma]
);;
```

### Informal statement
The subring of the complex numbers generated by the set `ZinC` (Gaussian Integers) with respect to the complex number ring structure `complex_ring` is equal to the `ZinC_ring` itself.

### Informal sketch
The proof demonstrates that the subring generated by the Gaussian integers (`ZinC`) within the complex numbers is exactly the ring of Gaussian integers (`ZinC_ring`).

- First, the definition of `subring_generated` is unfolded.
- Then, the clauses defining the structure `complex_ring` are applied.
- Finally, the rewriting rules `ZinC_ring` and `subring_complex_ZinC_lemma` are used, presumably to show the equivalence of the generated subring and the `ZinC_ring`.

### Mathematical insight
This theorem formalizes the intuitive idea that the subring of the complex numbers constructed by starting with the Gaussian integers and closing under the operations of complex addition, subtraction, and multiplication results precisely in the ring of Gaussian integers. The Gaussian integers are "algebraically closed" as a ring within the complex numbers.

### Dependencies

Definitions:
- `subring_generated`
- `complex_ring`
- `ZinC_ring`

Theorems:
- `subring_complex_ZinC_lemma`


---

## ring_of_num_ZinC

### Name of formal statement
ring_of_num_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_ZinC = prove(`
  ring_of_num ZinC_ring = complex_of_num
`,
  rw[FUN_EQ_THM;complex_of_num] THEN
  INDUCT_TAC THEN
  simp[ring_of_num;ZinC_ring_clauses] THEN
  rw[GSYM CX_ADD;REAL_OF_NUM_SUC]
);;
```
### Informal statement
The ring homomorphism `ring_of_num` applied to the ring `ZinC_ring` is equal to the function `complex_of_num`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the theorem `FUN_EQ_THM` and definition `complex_of_num`, reducing the goal to proving the equality pointwise.
- Apply induction.
- Simplify using the definition of `ring_of_num` and the clauses `ZinC_ring_clauses` describing `ZinC_ring`.
- Rewrite using `GSYM CX_ADD` (symmetry of complex addition) and `REAL_OF_NUM_SUC`.

### Mathematical insight
This theorem establishes that the mapping from natural numbers into the complex numbers via the ring structure `ZinC_ring` is the same as the mapping via `complex_of_num`. This may be considered a canonicity or coherence property, demonstrating that the constructed homomorphic image in `ZinC_ring` agrees with an independently-defined embedding of number into the complex field.

### Dependencies
- Definitions:
  - `ring_of_num`
  - `ZinC_ring`
  - `complex_of_num`

- Theorems, Inductive Rules, and Simpsets:
  - `FUN_EQ_THM`
  - `ZinC_ring_clauses`
  - `CX_ADD`
  - `REAL_OF_NUM_SUC`


---

## ring_pow_ZinC

### Name of formal statement
ring_pow_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_ZinC = prove(`
  ring_pow ZinC_ring = (pow)
`,
  qed[RING_POW_SUBRING_GENERATED;ring_pow_complex;subring_complex_empty]
);;
```
### Informal statement
The operation `ring_pow` applied to the ring `ZinC_ring` is equal to the standard power operation `pow`.

### Informal sketch
The theorem states that the ring power operation `ring_pow` instantiated at the subring of complex numbers `ZinC_ring` is the same function as the generic power function `pow`. This is proved as follows:
- First, `RING_POW_SUBRING_GENERATED` shows that `ring_pow` at a subring generated by a set `S` is determined by the values of `ring_pow` on `S`. Here, `S` is the singleton set containing the complex number `i`.
- Then a result about `ring_pow_complex` is applied to show that the result of `ring_pow ZinC_ring` agrees with `pow` on the generator set consisting of the complex number imaginary unit `i`.
- The fact that `ZinC_ring` is the smallest subring of the complex numbers `subring_complex_empty` implies the empty set generates the subring. We use this to instantiate the general result to the specific case of the integers embedded in the complex numbers, showing that `ring_pow ZinC_ring` applied to any power agrees with `pow` applied to the same power.

### Mathematical insight
The theorem clarifies the relationship between the general ring power operation `ring_pow` and the standard power operation `pow` in the specific context of the integers embedded in the complex numbers via `ZinC_ring`. It essentially confirms that repeated multiplication within the `ZinC_ring` is consistent with the usual notion of exponentiation. This demonstrates the compatibility of the ring-theoretic power operation with the standard power function on complex numbers, when restricted to the subring `ZinC_ring`.

### Dependencies
- `RING_POW_SUBRING_GENERATED`
- `ring_pow_complex`
- `subring_complex_empty`


---

## integral_domain_ZinC

### Name of formal statement
integral_domain_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let integral_domain_ZinC = prove(`
  integral_domain ZinC_ring
`,
  qed[integral_domain_complex;INTEGRAL_DOMAIN_SUBRING_GENERATED;subring_complex_empty]
);;
```
### Informal statement
The ring `ZinC_ring` is an integral domain.

### Informal sketch
The proof demonstrates that the ring `ZinC_ring` satisfies the defining property of an integral domain.

- The proof starts by unfolding the definition of `integral_domain` applied to `ZinC_ring`.
- It utilizes `integral_domain_complex` to establish the general fact that the complex numbers form an integral domain.
- It is shown that `ZinC_ring` is a subring of complex numbers using `INTEGRAL_DOMAIN_SUBRING_GENERATED` by appealing that `ZinC_ring` is a subring generated by the empty set, which is handled by `subring_complex_empty`.

### Mathematical insight
The theorem states a fundamental property of the integers within the complex numbers, namely that they constitute an integral domain. This is crucial for reasoning about divisibility and factorization properties within the integers. The proof establishes this fact by leveraging the existing knowledge that the complex numbers form an integral domain and that the integers are a subring thereof.

### Dependencies
- Theorems: `integral_domain_complex`
- Definitions: `INTEGRAL_DOMAIN_SUBRING_GENERATED`, `subring_complex_empty`, `ZinC_ring`, `integral_domain`


---

## poly_complex_if_poly_ZinC

### Name of formal statement
poly_complex_if_poly_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_complex_if_poly_ZinC = prove(`
  !p:(V->num)->complex.
  ring_polynomial ZinC_ring p ==>
  ring_polynomial complex_ring p
`,
  rw[ring_polynomial] THEN
  rw[ring_powerseries] THEN
  rw[complex_ring_clauses;ZinC_ring_clauses] THEN
  qed[IN_UNIV]
);;
```
### Informal statement
For any function `p` from a type `V` to the natural numbers, if `p` is a ring polynomial over the ring `ZinC_ring`, then `p` is also a ring polynomial over the ring `complex_ring`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definition of `ring_polynomial`.
- Rewrite using the definition of `ring_powerseries`.
- Rewrite using the clauses defining the rings `complex_ring` and `ZinC_ring`. The definition `ZinC_ring_clauses` essentially states the basic ring properties of the integers embedded in the complex numbers.
- Apply `qed[IN_UNIV]` which essentially closes the goal because the goal has been reduced to `IN_UNIV`, which is trivially true.

### Mathematical insight
This theorem formalizes the fact that any polynomial with coefficients in the integers (embedded in the complex numbers) is also a polynomial with complex coefficients, due to the embedding of the integers within the complex numbers. It ensures that the ring structure is preserved when moving from integer coefficients (represented as `ZinC`) to complex coefficients.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `ring_powerseries`

- Theorems/Axioms:
  - `complex_ring_clauses`
  - `ZinC_ring_clauses`
  - `IN_UNIV`


---

## poly_0_ZinC_eq_poly_0_complex

### Name of formal statement
poly_0_ZinC_eq_poly_0_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_0_ZinC_eq_poly_0_complex = prove(`
  poly_0 ZinC_ring = (poly_0 complex_ring):(V->num)->complex
`,
  rw[poly_0;poly_const] THEN
  rw[ZinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
The polynomial `poly_0` over the ring of integers (`ZinC_ring`) is equal to the polynomial `poly_0` over the ring of complex numbers (`complex_ring`), both considered as functions from `V->num` to complex numbers.

### Informal sketch
The proof proceeds by rewriting the left-hand side and the right-hand side of the equality to a common form.

- First, `poly_0` is rewritten using its definition. Then `poly_const` is applied to introduce a constant polynomial.
- Subsequently, the clauses related to the ring of integers (`ZinC_ring_clauses`) and the ring of complex numbers (`complex_ring_clauses`) are used to simplify both sides, ultimately showing the equality.

### Mathematical insight
This theorem demonstrates that the zero polynomial is the same regardless of whether it is considered over the integers or the complex numbers. This is a basic but important step in showing that polynomials over different rings are related, especially when there is a natural embedding of one ring into another.

### Dependencies
- Definitions: `poly_0`, `poly_const`
- Theorems/Axioms: `ZinC_ring_clauses`, `complex_ring_clauses`


---

## zero_if_ZinC_norm_lt1

### Name of formal statement
zero_if_ZinC_norm_lt1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_if_ZinC_norm_lt1 = prove(`
  !z.
  z IN ZinC ==>
  norm z < &1 ==>
  z = Cx(&0)
`,
  intro THEN
  have `z IN {z | ?i. z = complex_of_int i}` [ZinC] THEN
  set_fact `z IN {z | ?i. z = complex_of_int i} ==> ?i. z = complex_of_int i` THEN
  choose `i:int` `z = complex_of_int i` [ZinC] THEN
  have `z = Cx(real_of_int i)` [complex_of_int] THEN
  have `norm(z:complex) = abs(real_of_int i)` [COMPLEX_NORM_CX] THEN
  choose `n:num` `abs(real_of_int i) = &n` [INTEGER_REAL_OF_INT;integer] THEN
  proven_if `n = 0` [REAL_ABS_ZERO] THEN
  num_linear_fact `~(n = 0) ==> 1 <= n` THEN
  have `&1 <= &n:real` [REAL_OF_NUM_LE] THEN
  have `norm(z:complex) < norm z` [REAL_LTE_TRANS] THEN
  qed[REAL_LT_REFL]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is in `ZinC` and the norm of `z` is less than 1, then `z` is equal to the complex number constructed from the integer 0.

### Informal sketch
- We are given that `z` is a complex number in `ZinC` and `norm z < 1`.
- By the definition of `ZinC`, there exists an integer `i` such that `z = complex_of_int i`.
- Thus, `z = Cx(real_of_int i)`.
- The norm of `z` is `abs(real_of_int i)`.
- There exists a natural number `n` such that `abs(real_of_int i) = &n`.
- If `n = 0`, then `z = Cx(&0)`.
- If `n` is not equal to `0`, then `1 <= n`. Thus, `&1 <= &n` which is a real number. This means that `norm(z:complex) < norm z`, which is a contradiction since something can't be less than itself. Specifically, you prove `&1 <= &n:real` then you have `&n <= norm(z:complex)` and `norm z < &1` which proves the theorem.
- By contradiction, `n` must be equal to `0`. Thus, `z` must be equal to `Cx(&0)`.

### Mathematical insight
This theorem states that if a complex number `z` is a complex integer (i.e., an element of `ZinC`) and its norm is strictly less than 1, then `z` must be 0. Complex integers close to zero must precisely be zero.

### Dependencies
- `ZinC`
- `COMPLEX_NORM_CX`
- `INTEGER_REAL_OF_INT`
- `REAL_ABS_ZERO`
- `REAL_OF_NUM_LE`
- `REAL_LTE_TRANS`
- `REAL_LT_REFL`


---

## zero_if_ZinC_scale_bound

### Name of formal statement
zero_if_ZinC_scale_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_if_ZinC_scale_bound = prove(`
  !(c:complex) (r:real) z.
  ~(c = Cx(&0)) ==>
  c * z IN ZinC ==>
  norm z <= r ==>
  norm c * r < &1 ==>
  z = Cx(&0)
`,
  intro THEN
  subgoal `norm (c*z) < &1` THENL [
    rw[COMPLEX_NORM_MUL] THEN
    qed[REAL_LE_LMUL;NORM_POS_LE;REAL_LET_TRANS]
  ;
    have `c*z = Cx(&0)` [zero_if_ZinC_norm_lt1] THEN
    complex_field_fact `~(c = Cx(&0)) ==> c*z = Cx(&0) ==> z = Cx(&0)` THEN
    qed[]
  ]
);;
```
### Informal statement
For all complex numbers `c` and real numbers `r`, and complex numbers `z`, if `c` is not equal to the complex number 0, and `c * z` is in the set `ZinC` (complex numbers with norm less than 1), and the norm of `z` is less than or equal to `r`, and the norm of `c` times `r` is less than 1, then `z` is equal to the complex number 0.

### Informal sketch
The proof proceeds by assuming the antecedent and deriving `z = Cx(&0)`.
- Show that `norm (c*z) < &1`. This follows from `COMPLEX_NORM_MUL`, `REAL_LE_LMUL`, `NORM_POS_LE`, and `REAL_LET_TRANS` given `norm z <= r` and `norm c * r < &1`.
- From `c*z IN ZinC`, it follows that `norm (c*z) < &1`.  Apply the theorem `zero_if_ZinC_norm_lt1` to infer `c*z = Cx(&0)`.
- From the assumption that `c` is not equal to `Cx(&0)` and the derived result `c*z = Cx(&0)`, deduce `z = Cx(&0)` using a field fact of complex numbers.
- Conclude the proof.

### Mathematical insight
This theorem states a uniqueness property: under certain norm constraints, if a scaled complex number `c*z` is in `ZinC` and `c` is nonzero, then `z` must be zero. This result is useful when trying to prove that complex numbers are zero under certain conditions involving norms and membership in `ZinC`.

### Dependencies
- `COMPLEX_NORM_MUL`
- `REAL_LE_LMUL`
- `NORM_POS_LE`
- `REAL_LET_TRANS`
- `zero_if_ZinC_norm_lt1`

### Porting notes (optional)
The complex field fact `~(c = Cx(&0)) ==> c*z = Cx(&0) ==> z = Cx(&0)` may need to be proven separately in other proof assistants if it is not already available. Also, the management of norm inequalities will likely need to be adapted to the specific real number tactics or decision procedures in the target system.


---

## QinC

### Name of formal statement
QinC

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let QinC = new_definition `
  QinC = {z:complex | ?i:int d:num. ~(d = 0) /\ Cx(&d) * z = complex_of_int i}
`;;
```

### Informal statement
The set `QinC` is defined as the set of complex numbers `z` such that there exists an integer `i` and a natural number `d`, where `d` is not equal to 0, and `Cx(&d)` multiplied by `z` is equal to the complex number representation of the integer `i`.

### Informal sketch
The definition introduces the set `QinC` by specifying a condition that complex numbers must satisfy to be members of the set.

- We define `QinC` as the set of complex numbers `z` such that `z` can be expressed in the form `i/d`, where `i` is an integer and `d` is a non-zero natural number.
- The condition `Cx(&d) * z = complex_of_int i` ensures that `z` is the quotient of `i` and `d` when interpreted as complex numbers.
- The quantification `?i:int d:num. ~(d = 0) /\ Cx(&d) * z = complex_of_int i` asserts the existence of such `i` and `d`.

### Mathematical insight
The set `QinC` represents the set of complex numbers that are also rational numbers. It formalizes the notion of a rational number within the complex number system. This set is analogous to rationals as a subset of reals, but here we consider them as a subset of complexes. This definition is essential because it allows us to reason about rational values within the complex domain in subsequent proofs.

### Dependencies
- Definitions:
  - `complex_of_int`
  - `Cx`


---

## QinC_ring

### Name of formal statement
`QinC_ring`

### Type of the formal statement
`new_definition`

### Formal Content
```ocaml
let QinC_ring = new_definition `
  QinC_ring = ring(QinC,Cx(&0),Cx(&1),( -- ),( + ),( * ))
`;;
```

### Informal statement
The ring structure `QinC_ring` is defined as the ring consisting of the type `QinC` (quotient of complex numbers), with additive identity `Cx(&0)` (complex number 0), multiplicative identity `Cx(&1)` (complex number 1), additive inverse given by the function `( -- )`, addition given by the function `( + )`, and multiplication given by the function `( * )`.

### Informal sketch
- The definition `QinC_ring` introduces a ring structure on top of the type `QinC`.
- It uses the `ring` constructor, a pre-existing function (likely defined elsewhere) that builds a ring structure given a carrier type, additive and multiplicative identities, additive inverse, addition, and multiplication operations.
- Each argument to the `ring` function specifies a field of the ring structure being defined.
- The additive inverse operator `( -- )` takes a single `QinC` element, and the addition `( + )` and multiplication `( * )` operators take two `QinC` elements as inputs.
- The ring structure is constructed according to the standard field operations already definied.

### Mathematical insight
This definition represents the construction of a ring structure on the quotient type `QinC`. The `ring` constructor captures the essential algebraic properties required for a ring, ensuring that the operations and identities satisfy the ring axioms.

### Dependencies
- `QinC`
- `Cx`
- `ring`
- `(&0)`
- `(&1)`
- `( -- )`
- `( + )`
- `( * )`


---

## ZinC_in_QinC

### Name of formal statement
ZinC_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_in_QinC = prove(`
  !z. z IN ZinC ==> z IN QinC
`,
  rw[ZinC;QinC;IN_ELIM_THM] THEN
  intro THEN
  witness `i:int` THEN
  witness `1` THEN
  simp[COMPLEX_MUL_LID] THEN
  qed[ARITH_RULE `~(1 = 0)`]
);;
```
### Informal statement
For all `z`, if `z` is in `ZinC`, then `z` is in `QinC`.

### Informal sketch
The proof demonstrates that every element of the set `ZinC` is also an element of `QinC`.
- The proof starts by rewriting the statement using the definitions of `ZinC` and `QinC` and the theorem `IN_ELIM_THM`, which likely expands the `IN` predicate.
- An arbitrary variable `z` is introduced and an assumption `z IN ZinC` is made, and the definitions are expanded.
- A specific witness, `i`, assumed to be an integer, is chosen for the existential quantifier within the definition of `ZinC`, and subsequently the value `1` is chosen to satisfy another existential quantifier.
- The goal is simplified using `COMPLEX_MUL_LID`, presumably the multiplicative identity property which refers to `1`.
- The proof concludes by applying the arithmetic rule `~(1 = 0)`, indicating that 1 is not equal to 0, to discharge the remaining subgoal.

### Mathematical insight
The theorem establishes a set inclusion relationship between `ZinC` and `QinC`. The definitions of these sets likely involve constructing complex numbers, and `ZinC_in_QinC` demonstrates that the conditions defining membership in `ZinC` are stronger than or equal to those defining membership in `QinC`.

### Dependencies
- Definitions: `ZinC`, `QinC`
- Theorems: `IN_ELIM_THM`
- Rules: `ARITH_RULE`, `COMPLEX_MUL_LID`


---

## ZinC_subset_QinC

### Name of formal statement
ZinC_subset_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_subset_QinC = prove(`
  ZinC SUBSET QinC
`,
  SET_TAC[ZinC_in_QinC]
);;
```
### Informal statement
The set of integers (`ZinC`) is a subset of the set of rationals (`QinC`).

### Informal sketch
The proof uses `SET_TAC` with the theorem `ZinC_in_QinC`. This tactic expands the subset relation assuming the inclusion of the set of integers into the set of rationals.

### Mathematical insight
This theorem states the basic mathematical fact that every integer can be represented as a rational number; specifically, any integer `n` can be written as the rational number `n/1`. This inclusion is fundamental in the hierarchy of number systems.

### Dependencies
- Theorems:
  - `ZinC_in_QinC`


---

## QinC_0

### Name of formal statement
QinC_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_0 = prove(`
  Cx(&0) IN QinC
`,
  SET_TAC[ZinC_in_QinC;ZinC_0]
);;
```
### Informal statement
If `0` is in `ZinC`, then `Cx(&0)` is in `QinC`.

### Informal sketch
The proof proceeds by applying the theorem `ZinC_in_QinC` which states that if `x` is in `ZinC` then `Cx(x)` is in `QinC`, combined with `ZinC_0`, which asserts `0` is in `ZinC`. This application is handled by the tactic `SET_TAC`.

### Mathematical insight
This theorem establishes a base case (`Cx(&0)`) for membership in the set `QinC`, relying on the fact that `0` belongs to the set `ZinC`. It provides a starting point for constructing elements within `QinC` based on elements in `ZinC`.

### Dependencies
- Theorems: `ZinC_in_QinC`, `ZinC_0`


---

## QinC_1

### Name of formal statement
QinC_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_1 = prove(`
  Cx(&1) IN QinC
`,
  SET_TAC[ZinC_in_QinC;ZinC_1]
);;
```
### Informal statement
For all `Cx`, if `Cx` is in `ZinC`, then `Cx` is in `QinC`.

### Informal sketch
The proof uses `SET_TAC`, which is a tactic related to set theory reasoning. The tactic is applied with the hints `ZinC_in_QinC` and `ZinC_1`. 
- `ZinC_in_QinC` likely states that `ZinC` is a subset of `QinC`.
- `ZinC_1` likely states that `Cx(&1)` is in `ZinC`.
Given these two statements, the conclusion `Cx(&1) IN QinC` follows directly by transitivity.

### Mathematical insight
This theorem establishes that the set `ZinC` is a subset of `QinC`. This is a fundamental step in relating these two sets. The '&1' likely refers to a placeholder variable that is instantiated to 'Cx'.

### Dependencies
- Theorems: `ZinC_in_QinC`, `ZinC_1`


---

## neg_in_QinC

### Name of formal statement
neg_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let neg_in_QinC = prove(`
  !z. z IN QinC ==> --z IN QinC
`,
  rw[QinC;IN_ELIM_THM] THEN
  rw[complex_of_int] THEN
  intro THEN
  witness `--i:int` THEN
  witness `d:num` THEN
  rw[GSYM REAL_OF_INT_CLAUSES] THEN
  rw[CX_NEG] THEN
  qed[COMPLEX_MUL_RNEG]
);;
```

### Informal statement
For all complex numbers `z`, if `z` is in the set `QinC`, then the negation of `z` is in the set `QinC`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `QinC` using `QinC` and `IN_ELIM_THM`. This reveals that `z IN QinC` means `?i d. z = &i * i + &d`.
- Rewrite `&i` using `complex_of_int` to express the integer `i` as a complex number.
- Introduce the complex number `z` assuming `z IN QinC` to prove `--z IN QinC`.
- Provide witnesses `--i:int` and `d:num` to satisfy the existential quantifiers in the definition of `QinC`. This means proving `--z = &(--i) * &(--i) + &d` given `z = &i * &i + &d`.
- Rewrite the expression using `GSYM REAL_OF_INT_CLAUSES` to move the negation inside the `complex_of_int` function application.
- Rewrite the expression using `CX_NEG` which states that the negation of a complex number `z1 * z1` is equivalent to `z1 * z2` where `z2` is the negation of `z1`.
- Apply `COMPLEX_MUL_RNEG` which substitutes `--z` with `z`.

### Mathematical insight
This theorem states that the set `QinC` (the set of complex numbers that can be represented as the square of an integer plus a natural number) is closed under negation. This is a fundamental property when reasoning about sets of numbers and their algebraic properties.

### Dependencies
- `QinC`
- `IN_ELIM_THM`
- `complex_of_int`
- `REAL_OF_INT_CLAUSES`
- `CX_NEG`
- `COMPLEX_MUL_RNEG`

### Porting notes (optional)
The key is to ensure that similar rules for complex number arithmetic and integer-to-complex number embedding are available and correctly applied. The handling of existential witnesses might differ across systems, and some adjustment might be needed.


---

## add_in_QinC

### Name of formal statement
add_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let add_in_QinC = prove(`
  !y z.
  y IN QinC /\ z IN QinC ==>
  y+z IN QinC
`,
  rw[QinC;IN_ELIM_THM] THEN
  rw[complex_of_int] THEN
  intro THEN
  witness `i * &d'+i' * &d:int` THEN
  witness `d*d':num` THEN
  have `~(d * d' = 0)` [MULT_EQ_0] THEN
  rw[int_add_th] THEN
  rw[int_mul_th] THEN
  rw[GSYM REAL_OF_NUM_MUL] THEN
  rw[CX_MUL;CX_ADD] THEN
  rw[GSYM REAL_OF_INT_CLAUSES] THEN
  complex_field_fact `(Cx(&d) * Cx(&d'))*(y+z) = (Cx(&d)*y)*Cx(&d') + (Cx(&d')*z)*Cx(&d)` THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `y` and `z`, if `y` is in the set `QinC` and `z` is in the set `QinC`, then `y + z` is in the set `QinC`.

### Informal sketch
The proof demonstrates that the set `QinC` is closed under addition.
- The proof begins by rewriting `QinC` using its definition and eliminating the `IN` predicate.
- The goal is to show that if `y = i * &d / &d'` and `z = i * &i' / &d:num`, where `d` and `d'` are integers and both denominators `d` and `d'` are non-zero, then their sum `y + z` can also be expressed in the same form.
- Introduce witnesses `i * &d'+i' * &d:int` and `d*d':num`.
- Prove that `d * d'` is not zero to ensure that the denominator is not zero within the complex number.
- Rewrite using lemmas related to integer addition and multiplication (`int_add_th`, `int_mul_th`).
- Rewrite using `REAL_OF_NUM_MUL` to change the expression.
- Then rewrite using the definitions of complex number multiplication and addition (`CX_MUL`, `CX_ADD`).
- Simplify using rules for real number representation in complex numbers (`GSYM REAL_OF_INT_CLAUSES`).
- Finally, apply a field fact to show that `(Cx(&d) * Cx(&d'))*(y+z) = (Cx(&d)*y)*Cx(&d') + (Cx(&d')*z)*Cx(&d)` and finish the proof.

### Mathematical insight
The theorem establishes a fundamental property of the set `QinC`, which represents a subset of complex numbers. Namely, that `QinC` is closed under addition. This is important because it shows that combining elements of `QinC` via addition will yield another element within the same set, establishing this set has characteristics one would expect of complex numbers.

### Dependencies
- `QinC`
- `IN_ELIM_THM`
- `complex_of_int`
- `int_add_th`
- `int_mul_th`
- `REAL_OF_NUM_MUL`
- `CX_MUL`
- `CX_ADD`
- `REAL_OF_INT_CLAUSES`
- `MULT_EQ_0`
- `GSYM`
- `complex_field_fact`


---

## mul_in_QinC

### Name of formal statement
mul_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let mul_in_QinC = prove(`
  !y z.
  y IN QinC /\ z IN QinC ==>
  y*z IN QinC
`,
  rw[QinC;IN_ELIM_THM] THEN
  rw[complex_of_int] THEN
  intro THEN
  witness `i*i':int` THEN
  witness `d*d':num` THEN
  have `~(d*d' = 0)` [MULT_EQ_0] THEN
  rw[int_mul_th] THEN
  rw[GSYM REAL_OF_NUM_MUL] THEN
  rw[CX_MUL] THEN
  complex_field_fact `(Cx(&d)*Cx(&d'))*(y*z) = (Cx(&d)*y)*(Cx(&d')*z)` THEN
  qed[]
);;
```

### Informal statement
For all complex numbers `y` and `z`, if `y` is in the set of complex rational numbers `QinC` and `z` is in the set of complex rational numbers `QinC`, then the product `y*z` is in the set of complex rational numbers `QinC`.

### Informal sketch
The proof demonstrates that the product of two complex rational numbers is also a complex rational number.
- First, the definition of `QinC` is unfolded, stating that a complex number is in `QinC` if it can be written in the form `complex_of_int(i) / complex_of_num(d)` for some integers `i` and natural numbers `d`.
- Then, `complex_of_int` is rewritten.
- Two arbitrary complex numbers `y` and `z` are introduced, along with the assumption that they are in `QinC`.
- Witnesses `i*i':int` and `d*d':num` are chosen.
- Then, the theorem `~(d*d' = 0)` is proved from `MULT_EQ_0`.
- Then `int_mul_th` is rewritten using the previous result.
- Next, Rewrite `REAL_OF_NUM_MUL` in the GSYM variant.
- Using `CX_MUL`.
- The proof uses a complex field fact to rearrange the multiplication order to suit the goal `(Cx(&d)*Cx(&d'))*(y*z) = (Cx(&d)*y)*(Cx(&d')*z)`.
- Finally, the proof is completed by `qed[]`.

### Mathematical insight
The theorem `mul_in_QinC` establishes that the set of complex rational numbers `QinC` is closed under multiplication. This is a fundamental property for showing that `QinC` forms a subfield of the complex numbers. It's a key step in establishing `QinC` as a well-behaved algebraic structure.

### Dependencies
- `QinC`
- `IN_ELIM_THM`
- `complex_of_int`
- `MULT_EQ_0`
- `int_mul_th`
- `REAL_OF_NUM_MUL`
- `CX_MUL`
- `complex_field_fact`


---

## QinC_ring_clauses

### Name of formal statement
QinC_ring_clauses

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_ring_clauses = prove(`
  ring_carrier QinC_ring = QinC /\
  ring_0 QinC_ring = Cx(&0) /\
  ring_1 QinC_ring = Cx(&1) /\
  ring_neg QinC_ring = ( -- ) /\
  ring_add QinC_ring = ( + ) /\
  ring_mul QinC_ring = ( * )
`,
  rw[ring_carrier;ring_0;ring_1;ring_neg;ring_add;ring_mul;GSYM PAIR_EQ] THEN
  rw[QinC_ring] THEN
  rw[GSYM(CONJUNCT2 ring_tybij)] THEN
  rw[QinC_0;QinC_1;neg_in_QinC;add_in_QinC;mul_in_QinC] THEN
  qed[COMPLEX_ADD_SYM;COMPLEX_ADD_ASSOC;COMPLEX_ADD_LID;COMPLEX_ADD_LINV;COMPLEX_MUL_ASSOC;COMPLEX_MUL_SYM;COMPLEX_MUL_LID;COMPLEX_ADD_LDISTRIB]
);;
```
### Informal statement
The complex numbers restricted to the set `QinC` form a ring, where:
- the carrier set of the ring is `QinC`,
- the zero element of the ring is the complex number `Cx(&0)`,
- the one element of the ring is the complex number `Cx(&1)`,
- the negation operation of the ring is the usual negation `--`,
- the addition operation of the ring is the usual addition `+`,
- the multiplication operation of the ring is the usual multiplication `*`.

### Informal sketch
The proof proceeds by demonstrating that the ring operations, when restricted to `QinC`, satisfy the ring axioms.
- The proof begins by unfolding the definitions of `ring_carrier`, `ring_0`, `ring_1`, `ring_neg`, `ring_add`, and `ring_mul` and simplifying using the symmetry of equality `PAIR_EQ`.
- Then, the unfolded definition of `QinC_ring` is used to rewrite the goal.
- The definition of `ring_tybij` is unfolded using `GSYM(CONJUNCT2 ring_tybij)`.
- The facts that `QinC` contains `0` and `1`, and is closed under negation, addition, and multiplication (`QinC_0`, `QinC_1`, `neg_in_QinC`, `add_in_QinC`, `mul_in_QinC`) are then used to rewrite the goal.
- Finally, the theorem is proven by using the axioms of complex numbers: commutativity and associativity of addition (`COMPLEX_ADD_SYM`, `COMPLEX_ADD_ASSOC`), the identity element for addition (`COMPLEX_ADD_LID`), the inverse element for addition (`COMPLEX_ADD_LINV`), the associativity and commutativity of multiplication (`COMPLEX_MUL_ASSOC`, `COMPLEX_MUL_SYM`), the identity element for multiplication (`COMPLEX_MUL_LID`), and the distributivity of multiplication over addition (`COMPLEX_ADD_LDISTRIB`).

### Mathematical insight
The theorem demonstrates that the complex numbers restricted to the set `QinC` forms a ring under the standard complex number operations. This is a crucial step in formally establishing the algebraic properties of `QinC`.

### Dependencies
- `ring_carrier`
- `ring_0`
- `ring_1`
- `ring_neg`
- `ring_add`
- `ring_mul`
- `PAIR_EQ`
- `QinC_ring`
- `ring_tybij`
- `QinC_0`
- `QinC_1`
- `neg_in_QinC`
- `add_in_QinC`
- `mul_in_QinC`
- `COMPLEX_ADD_SYM`
- `COMPLEX_ADD_ASSOC`
- `COMPLEX_ADD_LID`
- `COMPLEX_ADD_LINV`
- `COMPLEX_MUL_ASSOC`
- `COMPLEX_MUL_SYM`
- `COMPLEX_MUL_LID`
- `COMPLEX_ADD_LDISTRIB`


---

## ZinC_subring_QinC

### Name of formal statement
ZinC_subring_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZinC_subring_QinC = prove(`
  ZinC subring_of QinC_ring
`,
  rw[subring_of] THEN
  rw[QinC_ring_clauses] THEN
  rw[ZinC_0;ZinC_1;neg_in_ZinC;add_in_ZinC;mul_in_ZinC;ZinC_subset_QinC]
);;
```
### Informal statement
The set `ZinC` (the integers) forms a subring of the ring `QinC_ring` (complex rationals).

### Informal sketch
The proof establishes that `ZinC` is a subring of `QinC_ring`. This involves the following steps:
- First, the definition of `subring_of` is expanded. This likely involves showing that `ZinC` is a subset of `QinC_ring`, contains the additive identity (0) and multiplicative identity (1), and is closed under negation, addition, and multiplication.
- Next, the definition of `QinC_ring` is expanded using `QinC_ring_clauses`, which reveals the specific structure and properties of `QinC_ring` necessary for proving the subring properties.
- Finally, theorems `ZinC_0`, `ZinC_1`, `neg_in_ZinC`, `add_in_ZinC`, `mul_in_ZinC`, and `ZinC_subset_QinC` are applied to demonstrate that `ZinC` indeed satisfies all the necessary conditions to be a subring of `QinC_ring`.

### Mathematical insight
This theorem formalizes the standard mathematical fact that the integers form a subring within the complex rational numbers. This is a fundamental concept in abstract algebra, demonstrating how one algebraic structure (the integers) can be embedded within another (the complex rationals) while preserving ring operations. The complex rationals are constructed as a quotient type, and `ZinC`, which contains the integers, can be viewed as a subring of the complex rationals.

### Dependencies
- Definitions:
  - `subring_of`
  - `QinC_ring_clauses`
  - `ZinC_0`
  - `ZinC_1`
  - `neg_in_ZinC`
  - `add_in_ZinC`
  - `mul_in_ZinC`
  - `ZinC_subset_QinC`


---

## QinC_subring_complex

### Name of formal statement
QinC_subring_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_subring_complex = prove(`
  QinC subring_of complex_ring
`,
  rw[subring_of] THEN
  rw[complex_ring_clauses] THEN
  rw[QinC_0;QinC_1;neg_in_QinC;add_in_QinC;mul_in_QinC;SUBSET_UNIV]
);;
```
### Informal statement
The set `QinC` is a subring of the complex numbers `complex_ring`.

### Informal sketch
The proof proceeds by showing that `QinC` satisfies the conditions for being a subring of `complex_ring`. This involves demonstrating that `QinC` is a subset of the underlying set of `complex_ring` (which is trivial since it is the universe), and that it contains `0` and `1`, and is closed under negation, addition, and multiplication. The proof uses the following steps:
- First, rewrite the goal using the definition of `subring_of`.
- Then, rewrite using the properties of `complex_ring_clauses`.
- Finally, use the previously proven facts `QinC_0`, `QinC_1`, `neg_in_QinC`, `add_in_QinC`, `mul_in_QinC`, and the fact that `SUBSET_UNIV` is true to discharge each of the subring conditions.

### Mathematical insight
This theorem establishes that `QinC`, the set of complex numbers with rational real and imaginary parts, forms a subring within the ring of complex numbers. This is important because it demonstrates that `QinC` inherits the ring structure from the complex numbers, which allows theorems and results applicable to rings to be applied to `QinC` as well. `QinC` is a useful algebraic structure as it is the smallest subfield of `complex_ring` containing the rationals.

### Dependencies
- Definitions:
  - `subring_of`
  - `complex_ring_clauses`
  - `complex_ring`
  - `QinC`
- Theorems:
  - `QinC_0`
  - `QinC_1`
  - `neg_in_QinC`
  - `add_in_QinC`
  - `mul_in_QinC`
  - `SUBSET_UNIV`


---

## series_QinC_if_series_ZinC

### Name of formal statement
series_QinC_if_series_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let series_QinC_if_series_ZinC = prove(`
  !p:(V->num)->complex.
  ring_powerseries ZinC_ring p ==>
  ring_powerseries QinC_ring p
`,
  rw[ring_powerseries] THEN
  rw[ZinC_ring_clauses;QinC_ring_clauses] THEN
  qed[ZinC_in_QinC]
);;
```

### Informal statement
For any `p` of type `V->num->complex`, if `p` is a ring powerseries in the ring of Gaussian integers (`ZinC_ring`), then `p` is also a ring powerseries in the ring of Gaussian rationals (`QinC_ring`).

### Informal sketch
The proof proceeds by first rewriting using the definition of `ring_powerseries`. This reduces the goal to showing that the corresponding properties hold for `ZinC_ring` implies that they hold for `QinC_ring`. This is further simplified using the clauses defining `ZinC_ring` and `QinC_ring`. Finally, the theorem `ZinC_in_QinC` is used to conclude the proof, where `ZinC_in_QinC` likely states that Gaussian integers are a subset of Gaussian rationals.

### Mathematical insight
This theorem expresses the fact that if a power series with coefficients in the Gaussian integers satisfies the ring powerseries conditions, then the same power series, viewed as having coefficients in the Gaussian rationals, also satisfies the ring powerseries condition. This is because the Gaussian integers are a subring of the Gaussian rationals. The inclusion property is crucial.

### Dependencies
- Definitions: `ring_powerseries`, `ZinC_ring_clauses`, `QinC_ring_clauses`
- Theorems: `ZinC_in_QinC`


---

## poly_QinC_if_poly_ZinC

### Name of formal statement
poly_QinC_if_poly_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_QinC_if_poly_ZinC = prove(`
  !p:(V->num)->complex.
  ring_polynomial ZinC_ring p ==>
  ring_polynomial QinC_ring p
`,
  rw[ring_polynomial] THEN
  rw[ring_powerseries] THEN
  rw[ZinC_ring_clauses;QinC_ring_clauses] THEN
  qed[ZinC_in_QinC]
);;
```
### Informal statement
For any function `p` from a type `V` to the type of numbers (`num`), if `p` is a ring polynomial over the ring of complex integers (`ZinC`), then `p` is a ring polynomial over the ring of complex rationals (`QinC`).

### Informal sketch
The proof proceeds as follows:
- First, expand the definitions of `ring_polynomial` for both complex integers (`ZinC`) and complex rationals (`QinC`). Specifically the theorem reduces to requiring that if `p` is a power series with coefficients in `ZinC`, then `p` is power series with coefficients in `QinC`.
- Then, expand the definitions of `ZinC_ring` and `QinC_ring` using `ZinC_ring_clauses` and `QinC_ring_clauses` respectively. Essentially, the goal is to show that the conditions for being a ring are satisfied by both `ZinC` and `QinC`.
- Finally, the proof concludes by using the theorem `ZinC_in_QinC`, which states that every complex integer is also a complex rational. This shows that if the coefficients of `p` are in `ZinC`, they are also in `QinC`, therefore `p` is a ring polynomial over `QinC`.

### Mathematical insight
The theorem states that if a polynomial has coefficients in the ring of complex integers, then it also has coefficients in the ring of complex rationals. This is a natural consequence of the fact that the complex integers are a subset of the complex rationals. In other words, `ZinC` can be embedded into `QinC`. This result is important because it allows us to reason about polynomials with complex integer coefficients in the broader context of complex rational coefficients.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `ring_powerseries`
  - `ZinC_ring_clauses`
  - `QinC_ring_clauses`
- Theorems:
  - `ZinC_in_QinC`


---

## poly_complex_if_poly_QinC

### Name of formal statement
poly_complex_if_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_complex_if_poly_QinC = prove(`
  !p:(V->num)->complex.
  ring_polynomial QinC_ring p ==>
  ring_polynomial complex_ring p
`,
  rw[ring_polynomial] THEN
  rw[ring_powerseries] THEN
  rw[complex_ring_clauses;QinC_ring_clauses] THEN
  qed[IN_UNIV]
);;
```
### Informal statement
For any function `p` from a type `V` to the type of numbers (`num`), if `p` is a ring polynomial over the ring `QinC_ring`, then `p` is a ring polynomial over the ring `complex_ring`.

### Informal sketch
The proof proceeds by demonstrating that if a polynomial is a `ring_polynomial` with respect to the ring `QinC_ring`, then it must also be a `ring_polynomial` with respect to the ring `complex_ring`.

- The proof starts by rewriting using the definition of `ring_polynomial`.
- Then it rewrites using the definition of `ring_powerseries`.
- Next, it rewrites using the clauses defining `complex_ring` and `QinC_ring`.
- Finally, the proof is completed by applying `IN_UNIV`.

### Mathematical insight
The theorem states that if a polynomial with numerical coefficients can be considered a ring polynomial over the ring `QinC_ring` (rationals + i*rationals), then that same polynomial can also be considered a ring polynomial over the ring `complex_ring` (complex numbers). This is because the `QinC_ring` is a subring of the `complex_ring`. Any structure that works for the smaller ring naturally extends to the larger ring.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `ring_powerseries`
  - `complex_ring_clauses`
  - `QinC_ring_clauses`

### Porting notes (optional)
- The main challenge is defining the rings `complex_ring` and `QinC_ring` and proving their ring properties.
- The rewriting steps rely on the specific definitions used for `ring_polynomial`, `ring_powerseries`, `complex_ring_clauses`, and `QinC_ring_clauses`. Pay close attention to how these are defined in HOL Light and ensure that equivalent definitions are used in the target proof assistant.


---

## series_complex_if_series_QinC

### Name of formal statement
series_complex_if_series_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let series_complex_if_series_QinC = prove(`
  !p:(V->num)->complex.
  ring_powerseries QinC_ring p ==>
  ring_powerseries complex_ring p
`,
  rw[ring_powerseries] THEN
  rw[complex_ring_clauses;QinC_ring_clauses] THEN
  qed[IN_UNIV]
);;
```

### Informal statement
For any function `p` from a type `V` to the natural numbers, if `p` is a ring power series in the ring of rationals extended with `i` (QinC_ring) then `p` is a ring power series in the ring of complex numbers (`complex_ring`).

### Informal sketch
The proof proceeds as follows:
- First, expand the definition of `ring_powerseries`.
- Then, expand the definitions of `complex_ring` and `QinC_ring`.
- Finally, apply `IN_UNIV` to complete the proof.

### Mathematical insight
This theorem states that if a function `p` represents a ring power series in the more restricted ring of complex numbers with rational real and imaginary parts (QinC), then it also forms a ring power series in the full complex number ring. This intuitively makes sense since QinC is a subring of the complex numbers.

### Dependencies
- Definitions: `ring_powerseries`, `complex_ring_clauses`, `QinC_ring_clauses`


---

## poly_0_QinC_eq_poly_0_complex

### Name of formal statement
poly_0_QinC_eq_poly_0_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_0_QinC_eq_poly_0_complex = prove(`
  poly_0 QinC_ring = (poly_0 complex_ring):(V->num)->complex
`,
  rw[poly_0;poly_const] THEN
  rw[QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For any `V`, the function that maps a polynomial `p` (from `V` to numbers, interpreted in the `QinC_ring`) to 0 is equal to the function that maps the same polynomial `p` to 0 when interpreted in the `complex_ring`; where the result is a complex number.

### Informal sketch
The proof proceeds by:
- Expanding `poly_0` using its definition `poly_const ring 0`.
- Then, rewriting using the definitions of `QinC_ring_clauses` (evaluation of ring operations within `QinC`), and `complex_ring_clauses` (evaluation of ring operations within `complex`).

### Mathematical insight
This theorem states that the zero polynomial, regardless of whether interpreted in the ring `QinC_ring` or `complex_ring`, maps all polynomials from `V` naturals to the complex number 0. The point here is to show that the zero polynomial evaluates to the expected zero value in both contexts.

### Dependencies
- Definitions: `poly_0`, `poly_const`
- Theorems: `QinC_ring_clauses`, `complex_ring_clauses`


---

## poly_1_QinC_eq_poly_1_complex

### Name of formal statement
poly_1_QinC_eq_poly_1_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_1_QinC_eq_poly_1_complex = prove(`
  poly_1 QinC_ring = (poly_1 complex_ring):(V->num)->complex
`,
  rw[poly_1;poly_const] THEN
  rw[QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For any mapping `V` from numbers to numbers, the result of applying the polynomial instantiation `poly_1` to the field of rationals represented as complex numbers (`QinC_ring`) at `V` is equal to the result of applying the polynomial instantiation `poly_1` to the field of complex numbers (`complex_ring`) at `V`, and the result is a complex number.

### Informal sketch
The proof proceeds by rewriting the left-hand side using the definition of `poly_1`, then simplifying both rings `QinC_ring` and `complex_ring` using their clauses and the definition of `poly_const`. This leads to an equality between the two sides.

*   First, rewrite using the definition of `poly_1`, which expresses the polynomial as `poly_const` applied to `V 1`.
*   Then, rewrite `poly_const` with the value `V 1`.
*   Rewrite using the field instances `QinC_ring_clauses` and `complex_ring_clauses`. These rewrites simplify the algebraic operations within the rings.

### Mathematical insight
The theorem essentially states that evaluating a polynomial of degree 1, viewed as a rational polynomial embedded in the complex numbers, is the same as evaluating it directly as a complex polynomial. This is expected since the rational numbers are naturally embedded within the complex numbers, and the polynomial operations are compatible with this embedding.

### Dependencies
*Definitions:*
*   `poly_1`
*   `poly_const`

*Theorems/Axioms:*
*   `QinC_ring_clauses`
*   `complex_ring_clauses`


---

## poly_neg_QinC_eq_poly_neg_complex

### Name of formal statement
poly_neg_QinC_eq_poly_neg_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_neg_QinC_eq_poly_neg_complex = prove(`
  !p:(V->num)->complex.
  poly_neg QinC_ring p
  = poly_neg complex_ring p
`,
  rw[poly_neg] THEN
  rw[QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For any function `p` from a type `V` to the type of numbers `num`, the polynomial negation of `p` with respect to the ring `QinC_ring` is equal to the polynomial negation of `p` with respect to the ring `complex_ring`.

### Informal sketch
The proof establishes the equality of `poly_neg QinC_ring p` and `poly_neg complex_ring p` by rewriting both sides to a common form.

- First, rewrite the definition of `poly_neg` on both sides of the equation.
- Then, rewrite the definitions of `QinC_ring_clauses` and `complex_ring_clauses` to expand the components of these ring structures, demonstrating their equivalence in the context of polynomial negation.

### Mathematical insight
This theorem demonstrates that the polynomial negation operation is identical whether interpreted in the ring of rationals extended with the imaginary unit (`QinC_ring`) or in the ring of complex numbers (`complex_ring`). This reflects the fact that both rings have the same additive structure, specifically regarding negation.

### Dependencies
- Definitions:
  - `poly_neg`
  - `QinC_ring_clauses`
  - `complex_ring_clauses`


---

## poly_add_QinC_eq_poly_add_complex

### Name of formal statement
poly_add_QinC_eq_poly_add_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_add_QinC_eq_poly_add_complex = prove(`
  !p:(V->num)->complex q.
  poly_add QinC_ring p q
  = poly_add complex_ring p q
`,
  rw[poly_add] THEN
  rw[QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For all functions `p` from a type `V` to the natural numbers, and for all `complex` numbers `q`, the polynomial addition of `p` and `q` using the `QinC_ring` is equal to the polynomial addition of `p` and `q` using the `complex_ring`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definition of `poly_add`.
- Rewriting using the clauses defining `QinC_ring` and `complex_ring`.

### Mathematical insight
This theorem shows the expected compatibility between polynomial addition defined using the ring structure `QinC_ring` and the ring structure `complex_ring`. Since `QinC_ring` represents complex numbers, the polynomial addition should remain the same regardless of which ring structure is used. This result is important for relating polynomial operations over different representations of complex numbers.

### Dependencies
- Definitions: `poly_add`
- Theorems, axioms, or rules: `QinC_ring_clauses`, `complex_ring_clauses`


---

## x_pow_QinC_eq_x_pow_complex

### Name of formal statement
x_pow_QinC_eq_x_pow_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_pow_QinC_eq_x_pow_complex = prove(`
  !n.
  x_pow QinC_ring n = x_pow complex_ring n
`,
  intro THEN
  sufficesby eq_coeff THEN
  rw[coeff_x_pow;QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For all natural numbers `n`, the power function `x_pow` applied to `n` in the `QinC_ring` (the ring of complex embeddings into the quaternions) is equal to the power function `x_pow` applied to `n` in the `complex_ring` (the ring of complex numbers).

### Informal sketch
The proof proceeds as follows:
- Introduce the universal quantifier.
- Reduce the goal to proving equality of coefficients.
- Rewrite using the definition of coefficients for `x_pow`, the clauses defining `QinC_ring` operations, and the clauses defining `complex_ring` operations.

### Mathematical insight
This theorem demonstrates that the polynomial power functions are equivalent whether computed in the ring of complex numbers or in the isomorphic ring of complex embeddings into the quaternions. This highlights the algebraic equivalence of these two structures when dealing with polynomial operations involving complex numbers.

### Dependencies
- Definitions: `x_pow`, `QinC_ring_clauses`, `complex_ring_clauses`, `coeff_x_pow`
- Theorems: `eq_coeff`


---

## poly_0_ZinC_eq_poly_0_QinC

### Name of formal statement
poly_0_ZinC_eq_poly_0_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_0_ZinC_eq_poly_0_QinC = prove(`
  poly_0 ZinC_ring = (poly_0 QinC_ring):(V->num)->complex
`,
  qed[poly_0_ZinC_eq_poly_0_complex;poly_0_QinC_eq_poly_0_complex]
);;
```
### Informal statement
For any function `V` from numbers to numbers, the polynomial `poly_0` over the ring of integers in the complex numbers, applied to `V`, is equal to the polynomial `poly_0` over the ring of rationals in the complex numbers, applied to `V`; where the result is a complex number.

### Informal sketch
The proof proceeds by using the following theorems:
- `poly_0_ZinC_eq_poly_0_complex`: This proves that `poly_0` over the integers in the complex numbers is equal to `poly_0` considered as a complex number.
- `poly_0_QinC_eq_poly_0_complex`: This proves that `poly_0` over the rationals in the complex numbers is equal to `poly_0` considered as a complex number.
Since both are equal to `poly_0` considered as a complex number, they are equal to each other by transitivity.

### Mathematical insight
The statement highlights the equivalence of constructing a zero-degree polynomial using either integer or rational coefficients when working within the complex numbers. This is because any integer is also a rational number, thus a constant polynomial constructed with integers is the same as a polynomial constructed with rationals. This result is important because it allows for transferring results and reasoning between these two representations.

### Dependencies
- Theorems:
  - `poly_0_ZinC_eq_poly_0_complex`
  - `poly_0_QinC_eq_poly_0_complex`


---

## ring_of_num_QinC

### Name of formal statement
ring_of_num_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_of_num_QinC = prove(`
  ring_of_num QinC_ring = complex_of_num
`,
  rw[FUN_EQ_THM;complex_of_num] THEN
  INDUCT_TAC THEN
  simp[ring_of_num;QinC_ring_clauses] THEN
  rw[GSYM CX_ADD;REAL_OF_NUM_SUC]
);;
```
### Informal statement
The function `ring_of_num` applied to the ring structure `QinC_ring` is equal to the function `complex_of_num`; that is, `ring_of_num QinC_ring = complex_of_num`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `FUN_EQ_THM` and the definition `complex_of_num`.
- Then, perform induction.
- Simplify using the definitions of `ring_of_num` and `QinC_ring_clauses`.
- Finally, rewrite using the definitions of `CX_ADD` and `REAL_OF_NUM_SUC`.

### Mathematical insight
This theorem establishes the relationship between the ring of numbers, represented by `QinC_ring`, and the corresponding complex numbers mapping accomplished by the `complex_of_num` function. It essentially verifies that the ring operations defined on `QinC_ring` are consistent with the standard complex number representation.

### Dependencies
- Theorems: `FUN_EQ_THM`
- Definitions: `complex_of_num`, `ring_of_num`, `QinC_ring_clauses`, `CX_ADD`, `REAL_OF_NUM_SUC`


---

## num_in_QinC

### Name of formal statement
num_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let num_in_QinC = prove(`
  !n. Cx(&n) IN QinC
`,
  rw[GSYM complex_of_num;GSYM ring_of_num_QinC;GSYM QinC_ring_clauses;RING_OF_NUM]
);;
```
### Informal statement
For all natural numbers `n`, the complex number corresponding to `n` is an element of the ring `QinC`.

### Informal sketch
The proof proceeds by rewriting the goal using the following steps:
- First, rewrite using `complex_of_num` to express the complex number corresponding to `n` in terms of `ring_of_num`.
- Next, rewrite using `ring_of_num_QinC` to express `ring_of_num` in terms of the `QinC_ring_clauses`.
- Then, rewrite using `QinC_ring_clauses` to express `QinC` in terms of the ring axioms.
- Finally, apply `RING_OF_NUM` to show the property holds using the ring axioms of `num`.

### Mathematical insight
This theorem establishes that the natural numbers, when viewed as complex numbers via the standard embedding, are contained within the ring `QinC`. The ring `QinC` is the smallest subring of the complex numbers containing the rationals. Since the natural numbers are contained within the rationals, the theorem follows.

### Dependencies
- Theorems: `complex_of_num`, `ring_of_num_QinC`, `QinC_ring_clauses`
- Automation: `RING_OF_NUM`


---

## num_over_num_in_QinC

### Name of formal statement
num_over_num_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let num_over_num_in_QinC = prove(`
  !n d. Cx(&n) / Cx(&d) IN QinC
`,
  rw[QinC;IN_ELIM_THM] THEN
  intro THEN
  case `d = 0` THENL [
    witness `&0:int` THEN
    witness `1:num` THEN
    rw[complex_of_int;GSYM REAL_OF_INT_CLAUSES] THEN
    simp[complex_div] THEN
    rw[COMPLEX_INV_0] THEN
    rw[COMPLEX_MUL_RZERO] THEN
    qed[ARITH_RULE `~(1 = 0)`]
  ;
    witness `&n:int` THEN
    witness `d:num` THEN
    rw[complex_of_int;GSYM REAL_OF_INT_CLAUSES] THEN
    have `~(d = 0) ==> ~(&d = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&d) = Cx(&0))` [CX_INJ] THEN
    complex_field_fact `~(Cx (&d) = Cx (&0)) ==> Cx (&d) * Cx (&n) / Cx (&d) = Cx (&n)` THEN
    qed[]
  ]
);;
```
### Informal statement
For all numbers `n` and `d`, the complex number formed by dividing the complex embedding of `n` by the complex embedding of `d` is in the complex image of the rationals `QinC`.

### Informal sketch
We want to prove that for any numbers `n` and `d`, `Cx(&n) / Cx(&d)` is in `QinC`.
- We start by unfolding the definition of `QinC` using `QinC` expansion theorem (`QinC`).
- Then we introduce `n` and `d`.
- We split the proof into two cases, based on whether `d = 0`.
  - If `d = 0`: We provide a witness of `0:int` and `1:num` to show that `Cx(&n) / Cx(&d)` which simplifies to the member of set `QinC` since `Cx(0) = Cx(1) / Cx(0)` cannot be true and therefore, membership can be disproven, discharging the goal.
  - If `d` is not `0`: We provide witnesses `n:int` and `d:num`. We show that `Cx(&d)` is not `Cx(&0)`. Using fact about quotient being zero implies multiplicand being zero, `Cx(&d) * Cx(&n) / Cx(&d) = Cx(&n)` and then we discharge the goal.

### Mathematical insight
This theorem establishes that the complex number resulting from the division of two numbers, when embedded into the complex plane via `Cx`, belongs to the set `QinC` (the complex image of the rationals). This is a key step in showing that HOL Light's representation of number division is consistent when viewed within the complex numbers. It connects number theory to complex analysis.

### Dependencies
- Definitions: `QinC`
- Theorems: `IN_ELIM_THM`, `GSYM REAL_OF_INT_CLAUSES`, `COMPLEX_INV_0`, `COMPLEX_MUL_RZERO`, `REAL_OF_NUM_EQ`, `CX_INJ`
- Rules: `ARITH_RULE`
- Facts: `complex_field_fact`, `complex_of_int`, `complex_div`


---

## neg_num_over_num_in_QinC

### Name of formal statement
neg_num_over_num_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let neg_num_over_num_in_QinC = prove(`
  !n d. -- (Cx(&n) / Cx(&d)) IN QinC
`,
  qed[num_over_num_in_QinC;neg_in_QinC]
);;
```
### Informal statement
For all natural numbers `n` and `d`, the negation of the complex number formed by dividing the complex number associated with `n` by the complex number associated with `d` is an element of `QinC`.

### Informal sketch
The proof proceeds as follows:

- Apply `num_over_num_in_QinC` to show that `Cx(&n) / Cx(&d)` is an element of `QinC`.
- Then use `neg_in_QinC` to show that the negation of `Cx(&n) / Cx(&d)` is an element of `QinC`.
- This concludes the proof.

### Mathematical insight
The `QinC` type represents the set of complex rationals. This theorem states that the set of complex rationals is closed under negation of ratios of complex embeddings of natural numbers `n` and `d`. This theorem builds towards building a theory of complex rationals, and is commonly used to canonically embed rationals and integers into larger domains like the complex numbers while allowing reasoning about closure under operations.

### Dependencies
- Theorems:
    - `num_over_num_in_QinC`
    - `neg_in_QinC`


---

## field_QinC

### Name of formal statement
field_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let field_QinC = prove(`
  field QinC_ring
`,
  rw[field] THEN
  rw[QinC_ring_clauses] THEN
  intro THENL [
    qed[CX_INJ;REAL_ARITH `~(&1 = &0:real)`]
  ;
    choose2 `i:int` `d:num` `~(d = 0) /\ Cx(&d) * x = complex_of_int i` [QinC;IN_ELIM_THM] THEN
    choose `n:num` `real_of_int i = &n \/ real_of_int i = -- &n` [dest_int_rep] THEN
    case `n = 0` THENL [
      num_linear_fact `-- &0 = &0:real` THEN
      have `real_of_int i = &0` [] THEN
      have `complex_of_int i = Cx(&0)` [complex_of_int] THEN
      have `Cx(&d) * x = Cx(&0)` [] THEN
      complex_field_fact `~(x = Cx(&0)) /\ Cx(&d) * x = Cx(&0) ==> Cx(&d) = Cx(&0)` THEN
      have `&d = &0:real` [CX_INJ] THEN
      qed[REAL_OF_NUM_EQ]
    ; pass
    ] THEN
    have `~(n = 0) ==> ~(&n = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&n) = Cx(&0))` [CX_INJ] THEN
    case `real_of_int i = &n` THENL [
      have `complex_of_int i = Cx(&n)` [complex_of_int] THEN
      witness `Cx(&d) / Cx(&n)` THEN
      have `Cx(&d) * x = Cx(&n)` [] THEN
      complex_field_fact `Cx(&d)*x = Cx(&n) ==> ~(Cx(&n) = Cx(&0)) ==> x * Cx(&d) / Cx(&n) = Cx(&1)` THEN
      qed[num_over_num_in_QinC]
    ;
      have `real_of_int i = -- &n` [] THEN
      have `complex_of_int i = Cx(-- &n)` [complex_of_int] THEN
      witness `-- (Cx(&d) / Cx(&n))` THEN
      have `Cx(&d) * x = -- Cx(&n)` [CX_NEG] THEN
      complex_field_fact `Cx(&d)*x = -- Cx(&n) ==> ~(Cx(&n) = Cx(&0)) ==> x * -- (Cx(&d) / Cx(&n)) = Cx(&1)` THEN
      qed[neg_num_over_num_in_QinC]
    ]
  ]
);;
```
### Informal statement
The field axioms hold for `QinC`, where `QinC` is the set of complex numbers with rational real and imaginary parts.

### Informal sketch
The proof demonstrates that `QinC` forms a field by verifying the field axioms.

- The proof starts by rewriting with `field` and `QinC_ring_clauses`.
- It proceeds by introducing a hypothesis.
- The proof involves proving that if `x` is in `QinC` and not equal to 0, then it has a multiplicative inverse in `QinC`.
- Let `x` be an element in `QinC` such that `x` is not equal to `Cx(&0)`. Because `x` is in `QinC`, we can find an integer `i` and a non-zero natural number `d` such that `Cx(&d) * x = complex_of_int i`. By representation of integers by numbers, we have `i` can be represented either by `&n` or `-- &n` for some number `n`.
- Case 1: `n = 0`.
  - If `n` is 0, then `real_of_int i` is 0, which implies `complex_of_int i` is `Cx(&0)`. Then `Cx(&d) * x = Cx(&0)`. Since `x` is not `Cx(&0)`, then `Cx(&d)` must be `Cx(&0)`, which results in `&d = &0`. This contradicts the premise that `d` is a non-zero number. The case is discharged using `CX_INJ` and `REAL_OF_NUM_EQ`.
- Case 2: `n != 0`
  - We have `~(n = 0) ==> ~(&n = &0)`. Therefore `Cx(&n)` is not zero `~(Cx(&n) = Cx(&0))`.
  - Subcase 1: `real_of_int i = &n`.
    - Then `complex_of_int i = Cx(&n)`.
    - We can find an inverse `Cx(&d) / Cx(&n)`. Specifically,
    - `x * Cx(&d) / Cx(&n) = Cx(&1)`
  - Subcase 2: `real_of_int i = -- &n`
    - Then `complex_of_int i = Cx(-- &n)`.
    - We can find an inverse `-- (Cx(&d) / Cx(&n))`. Specifically,
    - `x * -- (Cx(&d) / Cx(&n)) = Cx(&1)`

### Mathematical insight
The theorem confirms that `QinC`, the set of complex numbers with rational real and imaginary parts, satisfies the field axioms. This is crucial for establishing `QinC` as a valid domain for arithmetic operations and for building further mathematical structures based on it. The key idea is to construct multiplicative inverses for non-zero elements in `QinC` using the field properties of complex numbers.

### Dependencies
- `field`
- `QinC_ring_clauses`
- `CX_INJ`
- `REAL_ARITH`
- `QinC`
- `IN_ELIM_THM`
- `dest_int_rep`
- `complex_of_int`
- `complex_field_fact`
- `REAL_OF_NUM_EQ`
- `num_over_num_in_QinC`
- `CX_NEG`
- `neg_num_over_num_in_QinC`

### Porting notes (optional)
- The proof relies heavily on rewriting with existing theorems about fields and complex numbers. In other proof assistants, the corresponding field axioms and complex number properties might need to be stated explicitly before being applied.
- The tactics `choose2` and `choose` are used to obtain witnesses based on existence theorems. These tactics might need to be replaced with explicit existential instantiation in other systems.
- The `complex_field_fact` tactic encapsulates underlying field manipulations and may need expansion.


---

## integral_domain_QinC

### Name of formal statement
integral_domain_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let integral_domain_QinC = prove(`
  integral_domain QinC_ring
`,
  qed[field_QinC;FIELD_IMP_INTEGRAL_DOMAIN]
);;
```
### Informal statement
The ring `QinC_ring` is an integral domain.

### Informal sketch
The proof uses the theorem `FIELD_IMP_INTEGRAL_DOMAIN`, which states that any field is an integral domain, and the theorem `field_QinC`, which states that `QinC_ring` is a field. Thus we apply `FIELD_IMP_INTEGRAL_DOMAIN` to `field_QinC` to obtain `integral_domain QinC_ring`.

### Mathematical insight
This theorem establishes that the quotient ring of polynomials with integer coefficients modulo the ideal generated by a polynomial irreducible over the integers, `QinC_ring`, is an integral domain. Since `QinC_ring` has already been shown to be a field, this theorem confirms that it also satisfies the weaker condition of being an integral domain. This is not surprising as every field is, by definition, an integral domain.

### Dependencies
- Theorems:
    - `field_QinC`
    - `FIELD_IMP_INTEGRAL_DOMAIN`


---

## QinC_over_num

### Name of formal statement
QinC_over_num

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_over_num = prove(`
  !z e.
  z IN QinC ==>
  ~(e = 0) ==>
  z / Cx(&e) IN QinC
`,
  rw[QinC;IN_ELIM_THM] THEN
  intro THEN
  witness `i:int` THEN
  witness `d*e:num` THEN
  rw[GSYM REAL_OF_NUM_MUL] THEN
  rw[CX_MUL] THEN
  have `~(e = 0) ==> ~(&e = &0:real)` [REAL_OF_NUM_EQ] THEN
  have `~(Cx(&e) = Cx(&0))` [CX_INJ] THEN
  complex_field_fact `~(Cx(&e) = Cx(&0)) ==> (Cx(&d) * Cx(&e)) * z / Cx(&e) = Cx(&d) * z` THEN
  have `~(d * e = 0)` [MULT_EQ_0] THEN
  simp[]
);;
```
### Informal statement
For all complex numbers `z` and `e` represented as real numbers, if `z` is an element of the set `QinC` (the set of complex numbers with rational real and imaginary parts) and `e` is not equal to 0, then `z / Cx(&e)` is an element of the set `QinC`.

### Informal sketch
The proof proceeds as follows:
- Assume that `z` is in `QinC` and that `e` (a real number) is not equal to 0.
- Unfold the definition of `QinC` using `QinC` and `IN_ELIM_THM`.
- Introduce witnesses `i` (an integer) and `d*e` (a natural number).
- Rewrite `REAL_OF_NUM_MUL` and `CX_MUL` to simplify the expression.
- Show that if `e` is not zero, then the complex number `Cx(&e)` is not zero, using `REAL_OF_NUM_EQ` and `CX_INJ`.
- Apply complex field facts to show that `(Cx(&d) * Cx(&e)) * z / Cx(&e) = Cx(&d) * z`.
- Show `d * e` is not zero using `MULT_EQ_0` to ensure we have a valid division.
- Simplify, using the assumptions and derived facts, to complete the proof.

### Mathematical insight
This theorem states that the set of complex numbers with rational real and imaginary parts (`QinC`) is closed under division by a non-zero real number. This property is important for establishing `QinC` as a subfield of the complex numbers.

### Dependencies
- Definitions: `QinC`
- Theorems: `IN_ELIM_THM`, `REAL_OF_NUM_EQ`, `CX_INJ`, `MULT_EQ_0`
- Other: `REAL_OF_NUM_MUL`, `CX_MUL`, `complex_field_fact`


---

## div_in_QinC

### Name of formal statement
div_in_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let div_in_QinC = prove(`
  !y z.
  y IN QinC /\ z IN QinC /\ ~(z = Cx(&0)) ==>
  y/z IN QinC
`,
  intro THEN
  choose `zinv:complex` `zinv IN ring_carrier QinC_ring /\ ring_mul QinC_ring z zinv = ring_1 QinC_ring` [field;QinC_ring_clauses;field_QinC] THEN
  have `z * zinv = Cx(&1)` [QinC_ring_clauses] THEN
  complex_field_fact `~(z = Cx(&0)) ==> z * zinv = Cx(&1) ==> y / z = y * zinv` THEN
  qed[RING_MUL;QinC_ring_clauses]
);;
```
### Informal statement
For all complex numbers `y` and `z` in `QinC`, if `z` is not equal to `Cx(&0)`, then `y/z` is in `QinC`.

### Informal sketch
The proof proceeds as follows:
- Assume `y` and `z` are in `QinC` and `z` is not equal to `Cx(&0)`.
- Choose a complex number `zinv` such that `zinv` is in the carrier of the ring `QinC_ring` and `z * zinv` is equal to the multiplicative identity `ring_1 QinC_ring` of the ring `QinC_ring`. This step uses the field properties of complex numbers within `QinC`.
- Show that `z * zinv = Cx(&1)` using the properties of `QinC_ring`.
- Use the fact that if `z` is not equal to `Cx(&0)` implies `z * zinv = Cx(&1)`, which further implies that `y / z = y * zinv` in the complex field. This uses a pre-existing theorem about division in complex fields and applies it to the specific case of `QinC`.
- Conclude that `y/z` is in `QinC` based on the ring multiplication properties and the fact that `y` and `zinv` are in `QinC`.

The steps labeled `field;QinC_ring_clauses;field_QinC;QinC_ring_clauses` indicate the use of previously established facts and properties related to fields and the `QinC_ring`. The final step `RING_MUL;QinC_ring_clauses` uses properties of ring multiplication and the `QinC_ring`.

### Mathematical insight
This theorem establishes that the set `QinC` (presumably a subset of complex numbers) is closed under division, provided the divisor is non-zero. This closure property is crucial for showing that `QinC` forms a field or a division ring when equipped with suitable operations.

### Dependencies
- Theorems: `field`, `field_QinC`
- Definitions: `QinC_ring_clauses`, `RING_MUL`


---

## QinC_to_ZinC

### Name of formal statement
QinC_to_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_to_ZinC = prove(`
  !z.
  z IN QinC ==>
  ?d. (~(d = 0) /\ Cx(&d) * z IN ZinC)
`,
  rw[QinC;ZinC;IN_ELIM_THM] THEN
  qed[]
);;
```
### Informal statement
For all `z`, if `z` is in the set `QinC` (complex rationals), then there exists a `d` such that `d` is not equal to 0, and the complex number `Cx(&d) * z` is in the set `ZinC` (complex integers).

### Informal sketch
The proof proceeds by:
- Rewriting using the definitions of `QinC` and `ZinC`, and eliminating the `IN` relation using `IN_ELIM_THM`. This reduces the goal to a statement about the existence of integers satisfying certain divisibility conditions.
- Applying the `qed` tactic, indicating the goal has been reduced to a triviality by the previous step.

### Mathematical insight
This theorem establishes that any complex rational number can be converted into a complex integer by multiplying it by a suitable non-zero complex integer. Essentially, we are clearing the denominator of the complex rational number.  The sets `QinC` and `ZinC` are the complex rationals (Gaussian rationals) and complex integeres (Gaussian integers) respectively.

### Dependencies
- Definitions: `QinC`, `ZinC`
- Theorems: `IN_ELIM_THM`


---

## multi_QinC_to_ZinC

### Name of formal statement
multi_QinC_to_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let multi_QinC_to_ZinC = prove(`
  !S f:X->complex.
  FINITE S ==>
  (!s. s IN S ==> f s IN QinC) ==>
  ?d. (~(d = 0) /\ !s. s IN S ==> Cx(&d) * f s IN ZinC)
`,
  intro THEN
  witness `nproduct S (\s:X. @d. ~(d = 0) /\ Cx(&d) * f s IN ZinC)` THEN
  conjunction THENL [
    simp[NPRODUCT_EQ_0] THEN
    rw[NOT_EXISTS_THM] THEN
    qed[QinC_to_ZinC]
  ;
    intro THEN
    specialize[`\t:X. @d. ~(d = 0) /\ Cx (&d) * f t IN ZinC`;`S:X->bool`;`s:X`](GSYM NPRODUCT_DELETE) THEN
    simp[] THEN
    once_rw[MULT_SYM] THEN
    simp[prove(`&(m*n):real = &m * &n`,qed[REAL_OF_NUM_CLAUSES])] THEN
    rw[CX_MUL;GSYM COMPLEX_MUL_ASSOC] THEN
    have `(Cx (&(@u:num. ~(u = 0) /\ Cx (&u) * f(s:X) IN ZinC))) * f s IN ZinC` [QinC_ring_clauses;QinC_to_ZinC] THEN
    qed[mul_in_ZinC;ZinC_ring_clauses;num_in_ZinC]
  ]
);;
```

### Informal statement
For any set `S` of type `X` and function `f` from `X` to complex numbers, if `S` is finite and for all `s` in `S`, `f(s)` is in `QinC` (the set of complex numbers with rational real and imaginary parts), then there exists a non-zero integer `d` such that for all `s` in `S`, `d * f(s)` is in `ZinC` (the set of complex numbers with integer real and imaginary parts).

### Informal sketch
The proof proceeds by induction on the size of the finite set `S`.
- The base case uses the theorem `QinC_to_ZinC` directly.
- For the inductive step, assume the statement holds for `S`. We want to show it holds for `S U {s}`.
  - First, use `NPRODUCT_DELETE` on `S U {s}`.
  - This introduces the product of `nproduct S (\s:X. @d. ~(d = 0) /\ Cx (&d) * f s IN ZinC)`
  - Show that if exists such a `d` for the product then there is such a `d` for each element.
  - Note that `QinC_to_ZinC` proves that, for any complex `f s` in `QinC`, there exists `d` such that `Cx (&d) * f s IN ZinC)`. Let's call the `d` for any `s` in `S U {s}`, `d_s`.
  - Inductively, for the set `S` there exists a `d_S` such that for all `s : X`. `s IN S ==> Cx(&d_S) * f s IN ZinC`.
  - We need to show there exists a `d'` such that for all `s:X`. `s IN (S U {s}) ==> Cx(&d') * f s IN ZinC`.
  - Given `d_s` for `s` in `S U {s}` (using `QinC_to_ZinC`) and `d_S` for `S` (inductive assumption). We want a `d'` that works for both. It can be shown that the product `d_S * d_s` will work because `Cx(&d_S) * Cx(&d_s) = Cx(&(d_S * d_s))`. Each term will be in `ZinC` using the `ZinC_ring_clauses` and `num_in_ZinC`.

### Mathematical insight
This theorem demonstrates a crucial property regarding the relationship between complex numbers with rational real and imaginary parts (`QinC`) and those with integer real and imaginary parts (`ZinC`). Specifically, it states that given any finite set of complex numbers with rational real and imaginary parts, we can always find a single integer such that multiplying each of those complex numbers by that integer results in a complex number with integer real and imaginary parts. This is essential for building many bridges between rationals and integers in complex analysis.

### Dependencies
- `NPRODUCT_EQ_0`
- `NOT_EXISTS_THM`
- `QinC_to_ZinC`
- `NPRODUCT_DELETE`
- `MULT_SYM`
- `REAL_OF_NUM_CLAUSES`
- `CX_MUL`
- `COMPLEX_MUL_ASSOC`
- `mul_in_ZinC`
- `ZinC_ring_clauses`
- `num_in_ZinC`

### Porting notes (optional)
- Handling of finiteness conditions might be subtly different across provers; ensure the new formalization accurately reflects the HOL Light meaning.
- Proof assistants like Lean and Coq might require explicit coercions between `num`, `real`, and `complex` types, where HOL Light performs them implicitly. Recreate `REAL_OF_NUM_CLAUSES` if necessary.


---

## subring_complex_QinC_lemma

### Name of formal statement
subring_complex_QinC_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_complex_QinC_lemma = prove(`
  INTERS {S | S subring_of complex_ring /\ (:complex) INTER QinC SUBSET S} = QinC
`,
  havetac `QinC IN {S | S subring_of complex_ring /\ (:complex) INTER QinC SUBSET S}` (
    rw[IN_ELIM_THM] THEN
    qed[QinC_subring_complex;INTER_UNIV;SUBSET_REFL]
  ) THEN
  set_fact `!x. x IN {S | S subring_of complex_ring /\ (:complex) INTER QinC SUBSET S} ==> QinC SUBSET x` THEN
  qed[is_inters]
);;
```
### Informal statement
The intersection of all subrings of the complex numbers that contain the intersection of the complex numbers and the algebraic closure of the rationals, `QinC`, is equal to `QinC`.

### Informal sketch
The proof proceeds as follows:
- First, show that `QinC` is in the set of subrings of the complex numbers that contain `(:complex) INTER QinC`. This is shown by proving `QinC` is a subring of the complex numbers using the theorem `QinC_subring_complex`, then proving `INTER_UNIV`, and finally proving `SUBSET_REFL`.
- Second, show that for any `x` in the set of subrings of complex numbers that contain `(:complex) INTER QinC SUBSET S`, `QinC` is a subset of `x`.
- Finally, using `is_inters`, conclude that the intersection of all subrings of the complex numbers that contain `(:complex) INTER QinC` is equal to `QinC`.

### Mathematical insight
This theorem establishes that `QinC` is the smallest subring of the complex numbers containing `QinC`. This means that `QinC` is the intersection of all subrings of the complex numbers that contain `QinC`. This is a useful property to know when working with subrings of the complex numbers.

### Dependencies
- Theorems:
  - `QinC_subring_complex`
  - `INTER_UNIV`
  - `SUBSET_REFL`
  - `is_inters`
  - `IN_ELIM_THM`


---

## subring_complex_QinC

### Name of formal statement
subring_complex_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_complex_QinC = prove(`
  subring_generated complex_ring QinC = QinC_ring
`,
  rw[subring_generated] THEN
  rw[complex_ring_clauses] THEN
  rw[QinC_ring;subring_complex_QinC_lemma]
);;
```
### Informal statement
The subring of the complex numbers generated by the type `QinC` (which represents the complex numbers) is equal to the subring `QinC_ring`.

### Informal sketch
The proof proceeds as follows:
- First, expand the definition of `subring_generated` (using tactic `rw[subring_generated]`).
- Next, apply clauses related to `complex_ring` (using tactic `rw[complex_ring_clauses]`).
- Finally, rewrite using `QinC_ring` along with associated lemma `subring_complex_QinC_lemma` (using tactic `rw[QinC_ring;subring_complex_QinC_lemma]`).
The lemma `subring_complex_QinC_lemma` establishes that `QinC_ring` is a subring of the complex numbers and contains `QinC`, which then allows the final rewrite to complete the proof.

### Mathematical insight
This theorem shows that the subring of complex numbers generated by the set of complex numbers `QinC` is equal to the subring `QinC_ring`. Here `QinC_ring` likely denotes some specific representation of the complex numbers as a subring within the HOL Light formalization. This provides a way to characterize the subring generated by the complex numbers.

### Dependencies
- Definitions: `subring_generated`
- Theorems: `complex_ring_clauses`, `QinC_ring`, `subring_complex_QinC_lemma`


---

## ring_char_QinC

### Name of formal statement
ring_char_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_char_QinC = prove(`
  ring_char QinC_ring = 0
`,
  qed[ring_char_complex;RING_CHAR_SUBRING_GENERATED;subring_complex_QinC]
);;
```
### Informal statement
The characteristic of the ring of complex numbers constructed as a quotient of polynomials with integer coefficients, `QinC_ring`, is 0.

### Informal sketch
The proof shows that `ring_char QinC_ring = 0`.

- First, use `ring_char_complex` to show that the characteristic of the field of complex numbers `complex` is 0.
- Then, use `RING_CHAR_SUBRING_GENERATED` to show that if a ring `ring` is generated by a subring `subring`, then the characteristic of the `ring` is the same as the characteristic of the `subring`.
- Finally, use `subring_complex_QinC` to show that the ring complex numbers is generated by `QinC_ring`.

### Mathematical insight
This theorem establishes a fundamental property of the complex numbers, showing that they form an infinite field (characteristic 0). The construction of `QinC_ring` as a quotient ring is a way to formally represent complex numbers within HOL Light. The characteristic of a ring is an important invariant.

### Dependencies
- Theorems: `ring_char_complex`, `RING_CHAR_SUBRING_GENERATED`, `subring_complex_QinC`


---

## ring_hasQ_QinC

### Name of formal statement
ring_hasQ_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_hasQ_QinC = prove(`
  ring_hasQ QinC_ring
`,
  rw[ring_hasQ;ring_char_QinC] THEN
  rw[ring_of_num_QinC;complex_of_num;ring_unit] THEN
  GEN_TAC THEN DISCH_TAC THEN
  have `Cx(&n) IN ring_carrier QinC_ring` [num_in_QinC;QinC_ring_clauses] THEN
  simp[] THEN
  have `~(Cx(&n) = ring_0 QinC_ring)` [CX_INJ;REAL_OF_NUM_EQ;QinC_ring_clauses] THEN
  qed[field;field_QinC]
);;
```

### Informal statement
The ring `QinC_ring` has characteristic zero.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `ring_hasQ` and `ring_char_QinC` to unfold definitions. This reduces the goal to showing that the ring of integers in `QinC_ring` is not trivial. Then rewrite using `ring_of_num_QinC`, `complex_of_num`, and `ring_unit`.
- Apply generalization and discharge the assumption.
- Prove that the complex number `Cx(&n)` is in the carrier of the ring `QinC_ring` using `num_in_QinC` and `QinC_ring_clauses`.
- Perform simplification.
- Prove that `Cx(&n)` is not equal to the zero element of `QinC_ring` using `CX_INJ`, `REAL_OF_NUM_EQ`, and `QinC_ring_clauses`.
- Complete the proof using facts about fields, specifically `field` and `field_QinC`.

### Mathematical insight
This theorem establishes that the complex field `QinC_ring` (complex numbers constructed using Cauchy sequences of rationals) has characteristic zero. This is a fundamental property of complex numbers and is important for many further results.

### Dependencies
- Theorems: `ring_hasQ`, `ring_char_QinC`, `ring_of_num_QinC`, `field`, `field_QinC`, `CX_INJ`, `REAL_OF_NUM_EQ`
- Definitions: `complex_of_num`, `ring_unit`
- Auto-rewrites: `QinC_ring_clauses`
- Tactic support: `num_in_QinC`


---

## ring_sub_QinC

### Name of formal statement
ring_sub_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_sub_QinC = prove(`
  ring_sub QinC_ring = (-)
`,
  rw[FUN_EQ_THM;ring_sub;QinC_ring_clauses;complex_sub]
);;
```
### Informal statement
The ring subtraction operation in the complex number ring `QinC_ring` is equivalent to the standard subtraction operation (-).

### Informal sketch
The proof demonstrates that the ring subtraction operation within the complex number ring `QinC_ring` is identical to the standard subtraction operation. It proceeds as follows:
- First, the theorem `FUN_EQ_THM` is used to establish functional equality.
- The definition of `ring_sub` is unfolded.
- Then, the clauses defining `QinC_ring` are rewritten.
- Finally, the definition of complex number subtraction `complex_sub` is expanded, completing the proof.

### Mathematical insight
This theorem establishes a fundamental connection between the abstract ring subtraction operation defined within the complex number ring and the more familiar, concrete subtraction operation. This confirms that the ring structure is consistent with standard arithmetic operations on complex numbers.

### Dependencies
- Definitions: `ring_sub`, `complex_sub`
- Theorems: `FUN_EQ_THM`
- Term Rewrites: `QinC_ring_clauses`


---

## x_minus_const_QinC_eq_x_minus_const_complex

### Name of formal statement
x_minus_const_QinC_eq_x_minus_const_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_minus_const_QinC_eq_x_minus_const_complex = prove(`
  !c.
  x_minus_const QinC_ring c = x_minus_const complex_ring c
`,
  intro THEN
  rw[x_minus_const] THEN
  rw[poly_sub;poly_const] THEN
  rw[ring_sub_QinC;ring_sub_complex] THEN
  rw[x_pow_QinC_eq_x_pow_complex] THEN
  rw[QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For all `c`, `x_minus_const` in the ring `QinC_ring` applied to `c` is equal to `x_minus_const` in the ring `complex_ring` applied to `c`.

### Informal sketch
The proof proceeds as follows:
- Introduce the variable `c`.
- Rewrite using the definition of `x_minus_const`.
- Rewrite using `poly_sub` and `poly_const`.
- Rewrite using `ring_sub_QinC` and `ring_sub_complex`.
- Rewrite using `x_pow_QinC_eq_x_pow_complex`.
- Rewrite using `QinC_ring_clauses` and `complex_ring_clauses`.

### Mathematical insight
This theorem shows that the polynomial `x - c` is represented identically whether we are working in the `QinC_ring` or the `complex_ring`. This is an important step in showing that the two rings are equivalent for the purposes of polynomial arithmetic.

### Dependencies
Definitions:
- `x_minus_const`
- `poly_sub`
- `poly_const`

Theorems:
- `ring_sub_QinC`
- `ring_sub_complex`
- `x_pow_QinC_eq_x_pow_complex`
- `QinC_ring_clauses`
- `complex_ring_clauses`


---

## subring_QinC_empty_lemma

### Name of formal statement
subring_QinC_empty_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_QinC_empty_lemma = prove(`
  INTERS {S | S subring_of QinC_ring /\ QinC INTER {} SUBSET S} = ZinC
`,
  subgoal `ZinC IN {S | S subring_of QinC_ring /\ QinC INTER {} SUBSET S}` THENL [
    rw[IN_ELIM_THM] THEN
    rw[ZinC_subring_QinC;INTER_EMPTY;EMPTY_SUBSET]
  ; pass
  ] THEN
  subgoal `!x. x IN {S | S subring_of QinC_ring /\ QinC INTER {} SUBSET S} ==> ZinC SUBSET x` THENL [
    rw[IN_ELIM_THM] THEN
    intro THEN
    have `x subring_of complex_ring` [subring_complex_QinC;SUBRING_OF_SUBRING_GENERATED_EQ] THEN
    set_fact `x subring_of complex_ring ==> INTERS {S | S subring_of complex_ring} SUBSET x` THEN
    qed[ZinC_subring_generated_carrier]
  ; pass
  ] THEN
  qed[is_inters]
);;
```
### Informal statement
The intersection of all subrings `S` of the quotient ring of complex numbers `QinC_ring` such that the intersection of `QinC` and the empty set is a subset of `S`, is equal to `ZinC` (the integers embedded in the complex numbers).

### Informal sketch
The proof proceeds by showing that `ZinC` is equal to the intersection of all subrings `S` of `QinC_ring` containing `QinC INTER {}`. This is achieved by proving the following two subgoals:

*   Show that `ZinC` is an element of the set of subrings `S` of `QinC_ring` such that `QinC INTER {} SUBSET S`. This is done using `ZinC_subring_QinC`, `INTER_EMPTY`, and `EMPTY_SUBSET`. Applying `rw[ZinC_subring_QinC;INTER_EMPTY;EMPTY_SUBSET]` rewrites the membership condition and simplifies it to `TRUE` (handled by `pass`).
*   Show that for any `x` in the set of subrings `S` of `QinC_ring` such that `QinC INTER {} SUBSET S`, `ZinC SUBSET x`.

    *   Assume `x` is a subring of `QinC_ring` such that `QinC INTER {} SUBSET x`.
    *   Because `x` is a subring of `QinC_ring`, and `QinC_ring` is the quotient ring of the complex numbers (`subring_complex_QinC`), then `x` is a subring of the complex numbers.
    *   Use `SUBRING_OF_SUBRING_GENERATED_EQ` to establish `x subring_of complex_ring`.
    *   Since `x` is a subring of the complex numbers, then `INTERS {S | S subring_of complex_ring} SUBSET x`, where `INTERS {S | S subring_of complex_ring}` denotes the smallest subring of complex numbers that contains `ZinC`.
    *   Finally use `ZinC_subring_generated_carrier` to show `ZinC SUBSET x`.
*   The two subgoals are combined using `is_inters` to complete the proof.

### Mathematical insight
This theorem establishes that the smallest subring of `QinC_ring` containing 'QinC INTER {}' is `ZinC`. This can be viewed as a characterization of `ZinC` within `QinC_ring` via the subring intersection. Note the intersection `QinC INTER {}` is empty, so the theorem states that `ZinC` is the smallest subring of `QinC`

### Dependencies
*   `IN_ELIM_THM`
*   `ZinC_subring_QinC`
*   `INTER_EMPTY`
*   `EMPTY_SUBSET`
*   `subring_complex_QinC`
*   `SUBRING_OF_SUBRING_GENERATED_EQ`
*   `ZinC_subring_generated_carrier`
*   `is_inters`
### Porting notes (optional)
The theorem relies on the definition of subrings and intersections, which are standard concepts in most proof assistants. The main challenge is to ensure that the definitions of `QinC_ring` and `ZinC` are consistent with the target proof assistant's library. The tactic `is_inters` is a HOL Light specific tactic. The proof could be handled by manually proving the two subset inclusions which `is_inters` handles.


---

## subring_QinC_empty

### Name of formal statement
subring_QinC_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let subring_QinC_empty = prove(`
  subring_generated QinC_ring {} = ZinC_ring
`,
  rw[subring_generated] THEN
  rw[QinC_ring_clauses] THEN
  rw[ZinC_ring;subring_QinC_empty_lemma]
);;
```
### Informal statement
The subring of the complex quaternions `QinC_ring` generated by the empty set is equal to the subring of complex quaternions `ZinC_ring`.

### Informal sketch
The proof proceeds by:
- First rewriting using the definition of `subring_generated`.
- Then rewriting using the defining clauses of `QinC_ring`.
- Finally, rewriting using `ZinC_ring` and the lemma `subring_QinC_empty_lemma`. This lemma likely states that the smallest subring of `QinC_ring` closed under ring operations and containing the multiplicative and additive identities is `ZinC_ring`.

### Mathematical insight
This theorem demonstrates that the subring generated by the empty set within the complex quaternions is precisely the ring of complex quaternions with integer coefficients. In essence, it shows that starting with nothing and applying the ring operations, one can only obtain the integer complex quaternions.

### Dependencies
- Definitions:
  - `subring_generated`
  - `QinC_ring`
  - `ZinC_ring`
- Theorems:
  - `subring_QinC_empty_lemma`


---

## ring_1_0_QinC

### Name of formal statement
ring_1_0_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_1_0_QinC = prove(`
  ~(ring_1 QinC_ring = ring_0 QinC_ring)
`,
  qed[integral_domain_QinC;integral_domain]
);;
```
### Informal statement
It is not the case that the multiplicative identity of the `QinC_ring` ring is equal to the additive identity of the `QinC_ring` ring.

### Informal sketch
The proof uses the fact that `QinC_ring` is an integral domain and the general theorem that in an integral domain, the multiplicative identity is not equal to the additive identity. Specifically, the proof proceeds by:
- Applying the theorem `integral_domain_QinC`, which states that `QinC_ring` is an integral domain.
- Applying the general theorem `integral_domain` which states that for any integral domain, the multiplicative identity is not equal to the additive identity.

### Mathematical insight
This theorem confirms a fundamental property of non-trivial rings, namely that the additive and multiplicative identities are distinct. Since `QinC` (complex rationals) form an integral domain, this theorem is a concrete instance of the general result for integral domains. This is a basic sanity check, ensuring that our ring structure is not degenerate.

### Dependencies
- Theorems: `integral_domain_QinC`, `integral_domain`


---

## ring_pow_QinC

### Name of formal statement
ring_pow_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_pow_QinC = prove(`
  ring_pow QinC_ring = (pow)
`,
  qed[RING_POW_SUBRING_GENERATED;ring_pow_complex;subring_complex_QinC]
);;
```
### Informal statement
The ring power operation `ring_pow` with respect to the subring of complex numbers `QinC_ring` equals the standard power operation `pow`.

### Informal sketch
The proof demonstrates that the ring power operation for the subring of complex numbers is equivalent to the standard power function.
- Invoke `RING_POW_SUBRING_GENERATED` to reduce the goal to `ring_pow complex = pow`.
- Use `ring_pow_complex` to show that ring power on complex numbers respects the standard power operation.
- Apply `subring_complex_QinC` to show that the subring `QinC_ring` is the subring of complex numbers.

### Mathematical insight
This theorem shows that the abstract `ring_pow` operation, when applied to the specific subring of complex numbers, coincides with the familiar exponentiation function `pow`. It bridges the gap between abstract algebra and concrete arithmetic in the complex domain.

### Dependencies
- Theorems:
  - `RING_POW_SUBRING_GENERATED`
  - `ring_pow_complex`
  - `subring_complex_QinC`


---

## sum_QinC_eq_sum_complex

### Name of formal statement
sum_QinC_eq_sum_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let sum_QinC_eq_sum_complex = prove(`
  !S f.
  (!s:X. s IN S ==> f s IN QinC) ==>
  ring_sum QinC_ring S f
  = ring_sum complex_ring S f
`,
  intro THEN
  have `!s:X. s IN S ==> f s IN ring_carrier(subring_generated complex_ring QinC)` [subring_complex_QinC;QinC_ring_clauses] THEN
  have `ring_sum(subring_generated complex_ring QinC) S (f:X->complex) = ring_sum complex_ring S f` [ring_sum_subring_generated_v2] THEN
  qed[subring_complex_QinC]
);;
```
### Informal statement
For any set `S` and function `f` from `X` to the complex numbers, if for every `s` in `S`, `f s` is in `QinC`, then the ring sum of `f` over `S` with respect to the ring structure `QinC_ring` is equal to the ring sum of `f` over `S` with respect to the ring structure `complex_ring`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions `S` and `f`.
- Show that if `s` is in `S` implies `f s` is in `QinC`, then `s` in `S` implies `f s` is in the carrier of the subring generated by `complex_ring` and `QinC`. This uses `subring_complex_QinC` and `QinC_ring_clauses`.
- Show that the ring sum of `f` over `S` with respect to the subring generated by `complex_ring` and `QinC` is equal to the ring sum of `f` over `S` with respect to the ring structure `complex_ring`. This uses `ring_sum_subring_generated_v2`.
- Combine these results to conclude the proof, using `subring_complex_QinC`.

### Mathematical insight
This theorem demonstrates that the ring sum of a function over a set is invariant with respect to the choice of ring structure, provided that the function's values are contained within the carrier of the subring. It connects the summation operation performed within the smaller ring `QinC_ring` with the summation in the larger `complex_ring`. Essentially, if all the elements being summed are within `QinC`, it doesn't matter if we sum them using the operations of `QinC` or the full complex numbers.

### Dependencies
- Theorems: `subring_complex_QinC`, `ring_sum_subring_generated_v2`
- Definitions/Clausification: `QinC_ring_clauses`


---

## poly_mul_QinC_eq_poly_mul_complex

### Name of formal statement
poly_mul_QinC_eq_poly_mul_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_QinC_eq_poly_mul_complex = prove(`
  !p:(V->num)->complex q.
  ring_powerseries QinC_ring p ==>
  ring_powerseries QinC_ring q ==>
  poly_mul QinC_ring p q
  = poly_mul complex_ring p q
`,
  intro THEN
  rw[poly_mul;FUN_EQ_THM] THEN
  intro THEN
  subgoal `ring_sum QinC_ring {m1,m2 | !y. monomial_mul m1 m2 y = x y} (\(m1,m2). ring_mul QinC_ring (p(m1:V->num)) (q m2)) = ring_sum QinC_ring {m1,m2 | !y. monomial_mul m1 m2 y = x y} (\(m1,m2). ring_mul complex_ring (p m1) (q m2))` THENL [
    sufficesby RING_SUM_EQ THEN
    intro THEN
    rw[LAMBDA_PAIR;BETA_THM] THEN
    qed[QinC_ring_clauses;complex_ring_clauses]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby sum_QinC_eq_sum_complex THEN
  rw[IN_ELIM_THM;LAMBDA_PAIR] THEN
  intro THEN
  simp[FST;SND] THEN
  have `p(m1:V->num) IN ring_carrier(QinC_ring)` [ring_powerseries] THEN
  have `q(m2:V->num) IN ring_carrier(QinC_ring)` [ring_powerseries] THEN
  qed[RING_MUL;QinC_ring_clauses;complex_ring_clauses]
);;
```
### Informal statement
For all `p` of type `V -> num` and all `q` of type `complex`, if `p` is a ring powerseries with respect to the `QinC_ring` and `q` is a ring powerseries with respect to the `QinC_ring`, then the polynomial multiplication of `p` and `q` with respect to the `QinC_ring` is equal to the polynomial multiplication of `p` and `q` with respect to the `complex_ring`.

### Informal sketch
The proof proceeds as follows:
- Introduce the hypotheses.
- Expand the definition of `poly_mul` using `poly_mul` and apply `FUN_EQ_THM`.
- Introduce further hypotheses.
- The goal is to show that the ring sum over the set of pairs `(m1, m2)` such that `monomial_mul m1 m2 = x` of `ring_mul QinC_ring (p m1) (q m2)` equals the ring sum over the same set of `ring_mul complex_ring (p m1) (q m2)`.
    - Suffice to show that `ring_mul QinC_ring (p m1) (q m2) = ring_mul complex_ring (p m1) (q m2)` given that `p` and `q` are from `QinC_ring`, done by applying `RING_SUM_EQ`, introducing the hypothesis, rewriting using `LAMBDA_PAIR` and `BETA_THM` and then using the ring clauses for `QinC_ring` and `complex_ring`.
- Simplify the goal using `simp[]`.
- Suffice to show that `sum_QinC_eq_sum_complex`.
- Rewrite using `IN_ELIM_THM` and `LAMBDA_PAIR`.
- Introduce a hypothesis.
- Simplify using `FST` and `SND`.
- Given `ring_powerseries`, derive `p m1 IN ring_carrier(QinC_ring)`.
- Given `ring_powerseries`, derive `q m2 IN ring_carrier(QinC_ring)`.
- Complete the proof by applying `RING_MUL` and the ring clauses for `QinC_ring` and `complex_ring`.

### Mathematical insight
This theorem establishes the equivalence of polynomial multiplication performed using the `QinC_ring` and the `complex_ring`, provided that the polynomials are ring powerseries within the `QinC_ring`. This means that computations involving these polynomials yield the same results regardless of whether we treat them as complex numbers or elements of the `QinC_ring`. This is important for transferring results derived in one context to the other and for ensuring consistency in calculations.

### Dependencies
- Definitions:
  - `poly_mul`
  - `ring_powerseries`
  - `QinC_ring`
  - `complex_ring`
  - `ring_sum`
  - `monomial_mul`
  - `ring_mul`
  - `ring_carrier`
- Theorems:
  - `FUN_EQ_THM`
  - `RING_SUM_EQ`
  - `LAMBDA_PAIR`
  - `BETA_THM`
  - `IN_ELIM_THM`
  - `FST`
  - `SND`
  - `RING_MUL`
  - `sum_QinC_eq_sum_complex`
- Clauses:
  - `QinC_ring_clauses`
  - `complex_ring_clauses`

### Porting notes (optional)
- The proof relies on rewriting with clauses specific to `QinC_ring` and `complex_ring`. Ensure that similar ring definitions are available in the target proof assistant.
- The use of `sufficesby` suggests a tactic that might need to be manually expanded in other systems that do not directly support that form of reasoning.


---

## ring_divides_poly_complex_if_ring_divides_poly_QinC

### Name of formal statement
ring_divides_poly_complex_if_ring_divides_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_divides_poly_complex_if_ring_divides_poly_QinC = prove(`
  !p:(1->num)->complex q.
  ring_divides(x_poly QinC_ring) p q ==>
  ring_divides(x_poly complex_ring) p q
`,
  rw[ring_divides] THEN
  rw[GSYM x_poly_use] THEN
  intro THENL [
    qed[poly_complex_if_poly_QinC]
  ;
    qed[poly_complex_if_poly_QinC]
  ;
    witness `x:(1->num)->complex` THEN
    qed[ring_polynomial;poly_complex_if_poly_QinC;poly_mul_QinC_eq_poly_mul_complex]
  ]
);;
```
### Informal statement
For any polynomials `p` and `q` with coefficients in the complex numbers indexed by natural numbers, if `p` divides `q` in the ring of polynomials over the rational complex numbers (`QinC_ring`), then `p` divides `q` in the ring of polynomials over the complex numbers (`complex_ring`).

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `ring_divides`.
- Rewrite using `x_poly_use` to introduce explicit multiplication.
- Introduce the assumption `ring_divides(x_poly QinC_ring) p q`, then:
  - Show that if `p` is a polynomial over `QinC`, then `p` is a polynomial over `complex`.
  - Show that if `q` is a polynomial over `QinC`, then `q` is a polynomial over `complex`.
  - Introduce a witness polynomial `x` over complex numbers such that `q = p * x` where `*` refers to multiplication in the appropriate polynomial ring.
  - Show that if the ring polynomial `p` and coefficients of `x` are in `complex`, then `x` represents a polynomial over the complex numbers.
  - Show that if `p` is a polynomial over `QinC`, then `p` is a polynomial over `complex`.
  - Show that the polynomial multiplication defined with `QinC` coefficients is the same as polynomial multiplication with `complex` coefficients.

### Mathematical insight
This theorem states that if a polynomial `p` divides a polynomial `q` when considering them as polynomials over the rational complex numbers, then `p` also divides `q` when considered as polynomials over the standard complex numbers. This is because the rational complex numbers are a subfield of the complex numbers, so division that holds in the smaller field must also hold in the larger field.

### Dependencies
- `ring_divides`
- `x_poly_use`
- `poly_complex_if_poly_QinC`
- `ring_polynomial`
- `poly_mul_QinC_eq_poly_mul_complex`


---

## PID_x_poly_QinC

### Name of formal statement
PID_x_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PID_x_poly_QinC = prove(`
  PID (x_poly QinC_ring)
`,
  qed[field_QinC;PID_x_poly_field]
);;
```

### Informal statement
The ring of polynomials with coefficients in the field of complex rational numbers (`QinC_ring`) is a principal ideal domain (PID).

### Informal sketch
The proof proceeds by:
- Using the fact that `field_QinC` shows that `QinC_ring` is a field.
- Applying the theorem `PID_x_poly_field`, which states that the polynomial ring over a field is a principal ideal domain.

### Mathematical insight
This theorem establishes that the polynomial ring `Q[x]` where coefficients are complex rational numbers, possesses the principal ideal domain property. The significance lies in the fact that polynomial rings over fields are canonical examples of PIDs, and PIDs have many nice properties useful in algebra and number theory. This also links the abstract algebraic structure of polynomials with the concrete field of complex rational numbers.

### Dependencies
- Theorems:
    - `field_QinC`
    - `PID_x_poly_field`


---

## integral_domain_x_poly_QinC

### Name of formal statement
integral_domain_x_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let integral_domain_x_poly_QinC = prove(`
  integral_domain (x_poly QinC_ring)
`,
  qed[PID_x_poly_QinC;PID_IMP_INTEGRAL_DOMAIN;x_poly]
);;
```
### Informal statement
The polynomial ring `x_poly QinC_ring` over the field of complex rationals `QinC_ring` is an integral domain.

### Informal sketch
The proof uses `PID_x_poly_QinC` to show that `x_poly QinC_ring` is a principal ideal domain (PID), then `PID_IMP_INTEGRAL_DOMAIN` to deduce it is an integral domain.

- First, `PID_x_poly_QinC` proves that the polynomial ring `x_poly QinC_ring` over the field of complex rationals `QinC_ring` is a principal ideal domain.
- Applying `PID_IMP_INTEGRAL_DOMAIN`, it follows that since `x_poly QinC_ring` is a principal ideal domain, it is also an integral domain.

### Mathematical insight
This theorem states that the polynomial ring formed by adjoining a single indeterminate `x` to the field of complex rationals is an integral domain. This is an important property in algebra, meaning that the ring has no zero divisors; that is, if the product of two elements is zero, then at least one of the elements must be zero. This property is essential for unique factorization in polynomial rings.

### Dependencies
- Theorems: `PID_x_poly_QinC`, `PID_IMP_INTEGRAL_DOMAIN`
- Definitions: `x_poly`


---

## UFD_x_poly_QinC

### Name of formal statement
UFD_x_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let UFD_x_poly_QinC = prove(`
  UFD (x_poly QinC_ring)
`,
  qed[PID_x_poly_QinC;PID_IMP_UFD;x_poly]
);;
```
### Informal statement
The polynomial ring `x_poly QinC_ring` over the ring of rational numbers `QinC_ring `is a unique factorization domain (UFD).

### Informal sketch
The proof demonstrates that the polynomial ring `x_poly QinC_ring` is a UFD.
- First, use `PID_x_poly_QinC` to show that the polynomial ring over `QinC_ring` is a principal ideal domain (PID).
- Then, apply `PID_IMP_UFD`, which states that every PID is also a UFD.
- Finally, apply `x_poly` (likely a tactic or rule for handling polynomial rings).

### Mathematical insight
This theorem demonstrates a standard result in abstract algebra: that the polynomial ring over a field (in this case, the rational numbers) is a UFD. Showing that it's a PID first simplifies the proof, as the general proof that polynomial rings over fields are UFDs is more involved.

### Dependencies
- Theorems: `PID_x_poly_QinC`, `PID_IMP_UFD`
- Tactics/Rules: `x_poly`


---

## x_poly_mul_in_QinC_eq_0

### Name of formal statement
x_poly_mul_in_QinC_eq_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_mul_in_QinC_eq_0 = prove(`
  !(p:(1->num)->complex) (q:(1->num)->complex).
  ring_polynomial QinC_ring p ==>
  ring_polynomial QinC_ring q ==>
  (poly_mul QinC_ring p q = poly_0 QinC_ring
   <=> p = poly_0 QinC_ring \/ q = poly_0 QinC_ring)
`,
  rw[x_poly_use] THEN
  qed[integral_domain_x_poly_QinC;INTEGRAL_DOMAIN_MUL_EQ_0]
);;
```
### Informal statement
For all polynomials `p` and `q` from naturals-to-complex numbers: `p` and `q` are ring polynomials in the ring of polynomials with coefficients in the quotient field of complex numbers if and only if the polynomial multiplication of `p` and `q` in that ring is equal to the zero polynomial in that ring if and only if `p` is the zero polynomial in that ring or `q` is the zero polynomial in that ring.

### Informal sketch
The proof proceeds as follows:
- It uses the rewrite tactic with `x_poly_use` to expand the definitions related to polynomials over the quotient field of complex numbers.
- It then applies the theorem `INTEGRAL_DOMAIN_MUL_EQ_0`, which likely states that in an integral domain, the product of two elements is zero if and only if at least one of the elements is zero, and `integral_domain_x_poly_QinC` states that polynomials QinC form an integral domain.

### Mathematical insight
The theorem demonstrates that the ring of polynomials with coefficients in the quotient field of complex numbers forms an integral domain. This means that it has no zero divisors, and therefore, the product of two non-zero polynomials cannot be the zero polynomial. This is a fundamental property in algebra and is crucial for reasoning about divisibility and factorization in polynomial rings.

### Dependencies
- Theorems:
    - `integral_domain_x_poly_QinC`
    - `INTEGRAL_DOMAIN_MUL_EQ_0`
- Definitions:
    - `x_poly_use`


---

## x_poly_ZinC_denominator_is_QinC

### Name of formal statement
x_poly_ZinC_denominator_is_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_ZinC_denominator_is_QinC = prove(`
  !(p:(1->num)->complex) e.
  ring_polynomial ZinC_ring p ==>
  ~(e = 0) ==>
  ring_polynomial QinC_ring
    (series_from_coeffs (\n. (coeff n p) / Cx(&e)))
`,
  rw[poly_series_from_coeffs] THEN
  intro THENL [
    have `coeff d p IN ring_carrier ZinC_ring` [coeff_poly_in_ring] THEN
    have `coeff d p IN ZinC` [ZinC_ring_clauses] THEN
    have `coeff d p IN QinC` [ZinC_in_QinC] THEN
    rw[QinC_ring_clauses] THEN
    qed[QinC_over_num]
  ;
    specialize[`ZinC_ring`;`p:(1->num)->complex`]finite_coeff THEN
    subgoal `!d. ~(coeff d p / Cx(&e) = ring_0 QinC_ring) ==> ~(coeff d p = ring_0 ZinC_ring)` THENL [
      simp[QinC_ring_clauses;ZinC_ring_clauses] THEN
      CONV_TAC COMPLEX_FIELD
    ; pass
    ] THEN
    set_fact `(!d. ~(coeff d p / Cx(&e) = ring_0 QinC_ring) ==> ~(coeff d p = ring_0 ZinC_ring)) ==> {d | ~(coeff d p / Cx(&e) = ring_0 QinC_ring)} SUBSET {d | ~(coeff d p = ring_0 ZinC_ring)}` THEN
    qed[FINITE_SUBSET]
  ]
);;
```
### Informal statement
For any polynomial `p` from natural numbers to complex numbers, if `p` is a ring polynomial over the ring `ZinC_ring`, and `e` is not equal to 0, then the polynomial whose coefficients are obtained by dividing each coefficient of `p` by the complex number corresponding to `e` (i.e., `Cx(&e)`) is a ring polynomial over the ring `QinC_ring`.

### Informal sketch
The proof demonstrates that if `p` is a polynomial over `ZinC` and `e` is non-zero, then dividing each coefficient of `p` by `Cx(&e)` results in a polynomial over `QinC`.
- First, rewrite using `poly_series_from_coeffs` to express `p` as a polynomial constructed from its coefficients, and introduce the assumption that `p` is a ring polynomial over `ZinC_ring` and `e` is non-zero.
- Next, show that each coefficient `coeff d p` is in the carrier of the ring `ZinC_ring` using `coeff_poly_in_ring`.
- Then show that `coeff d p` is in `ZinC` using the definition of `ZinC_ring` via `ZinC_ring_clauses`
- Show that `coeff d p` is in `QinC` using `ZinC_in_QinC`.
- Demonstrate that `coeff d p / Cx(&e)` is in `QinC` using rewrite rules for `QinC_ring` via `QinC_ring_clauses` and `QinC_over_num`.
- `ZinC_ring` and `p:(1->num)->complex` are specialized in `finite_coeff`, which says a ring polynomial over ZinC has finitely many non-zero coefficients.
- Now show that if `coeff d p / Cx(&e)` is not the zero element in `QinC_ring`, then `coeff d p` is not the zero element in `ZinC_ring`, using `QinC_ring_clauses` and `ZinC_ring_clauses`, and field arithmetic rules for complex numbers (`COMPLEX_FIELD`).
- Finally, show that the set of `d` such that `coeff d p / Cx(&e)` is not the zero element in `QinC_ring` is a subset of the set of `d` such that `coeff d p` is not the zero element in `ZinC_ring`. Apply `FINITE_SUBSET` to complete the proof that the resulting polynomial is indeed a `QinC` polynomial.

### Mathematical insight
The theorem formalizes the algebraic property that dividing the coefficients of a polynomial over the integers (`ZinC`) by a non-zero number results in a polynomial over the rationals (`QinC` if the divisor is an integer), extending the ring over which the polynomial is defined. It's crucial for polynomial arithmetic and analysis related to rational functions and their polynomial representations. This theorem connects polynomial rings over different fields.

### Dependencies
- `poly_series_from_coeffs`
- `coeff_poly_in_ring`
- `ZinC_ring_clauses`
- `ZinC_in_QinC`
- `QinC_ring_clauses`
- `QinC_over_num`
- `finite_coeff`
- `FINITE_SUBSET`

### Porting notes (optional)
- The handling of polynomial coefficients and ring membership will need careful attention when porting to other systems.
- The type `(1->num)->complex` represents a polynomial. You may need to use an explicit polynomial datatype or a suitable representation of coefficient sequences in other systems.
- The tactics `rw`, `intro`, `have`, `specialize`, `subgoal`, `simp`, `CONV_TAC` and `set_fact` represent proof steps. These need to be performed using equivalent methods in the target proof assistant. In particular, `CONV_TAC` uses conversion to apply complex field arithmetic rules. You need to apply similar rules for complex arithmetic in another proof assistant.


---

## x_poly_ZinC_denominator_is_QinC_v2_lemma

### Name of formal statement
x_poly_ZinC_denominator_is_QinC_v2_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_ZinC_denominator_is_QinC_v2_lemma = prove(`
  !(p:(1->num)->complex) e.
  series_from_coeffs (\n. (coeff n p) / Cx(&e))
  = poly_mul complex_ring (poly_const complex_ring (Cx(&1) / Cx(&e))) p
`,
  intro THEN
  have `ring_powerseries complex_ring (p:(1->num)->complex)` [series_complex] THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_series_from_coeffs] THEN
  have `Cx(&1) / Cx(&e) IN ring_carrier complex_ring` [in_complex_ring] THEN
  simp[coeff_poly_const_times] THEN
  rw[complex_ring_clauses] THEN
  CONV_TAC COMPLEX_FIELD
);;
```
### Informal statement
For any function `p` from `1->num` to complex numbers and any number `e`, the power series generated from the coefficients given by `(coeff n p) / Cx(&e)` is equal to the polynomial multiplication of the polynomial representation of `Cx(&1) / Cx(&e)` with the polynomial `p` in the complex ring.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions `p` and `e`.
- Establish that `ring_powerseries complex_ring (p:(1->num)->complex)`.
- It suffices to prove the equality by showing that the coefficients of the power series and the polynomial multiplication are equal.
- Introduce `n` as the index for the coefficient.
- Rewrite using `coeff_series_from_coeffs` to reveal that the n-th coefficient of `series_from_coeffs (\n. (coeff n p) / Cx(&e))` is `(coeff n p) / Cx(&e)`.
- Show that `Cx(&1) / Cx(&e)` is in `ring_carrier complex_ring`.
- Simplify using `coeff_poly_const_times`.
- Rewrite using `complex_ring_clauses`.
- Apply the `COMPLEX_FIELD` conversion.

### Mathematical insight
This lemma states that dividing each coefficient of a polynomial `p` by a complex number `Cx(&e)` is equivalent to multiplying the polynomial `p` by `Cx(&1) / Cx(&e)`. This relates the operations on coefficients to polynomial multiplication in the complex ring.

### Dependencies
- `series_from_coeffs`
- `coeff`
- `Cx`
- `poly_mul`
- `poly_const`
- `complex_ring`
- `coeff_series_from_coeffs`
- `coeff_poly_const_times`
- `complex_ring_clauses`
- `ring_powerseries`
- `ring_carrier`


---

## poly_const_QinC

### Name of formal statement
poly_const_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_QinC = prove(`
  !c.
  c IN QinC <=>
  ring_polynomial QinC_ring (poly_const QinC_ring c:(V->num)->complex)
`,
  rw[RING_POLYNOMIAL_CONST] THEN
  qed[QinC_ring_clauses]
);;
```

### Informal statement
For all `c`, `c` is in `QinC` if and only if the polynomial ring membership condition `ring_polynomial QinC_ring (poly_const QinC_ring c)` holds, where `poly_const QinC_ring c` returns the constant polynomial over `QinC_ring` for the constant `c`.

### Informal sketch
- The proof proceeds by rewriting using `RING_POLYNOMIAL_CONST`, which simplifies the goal to `c IN QinC <=> c IN QinC`, and then proving this trivial equality using the clauses for `QinC_ring` for equality.

### Mathematical insight
This theorem establishes the equivalence between a constant `c` belonging to the set `QinC` and the formal polynomial generated from `c` using `poly_const` belonging to the polynomial ring `QinC_ring`. Thus it shows that all constants in QinC are valid polynomial representations within the ring. This is a basic but important well-formedness check when building a polynomial ring over a mathematical structure.

### Dependencies
- Definitions: `QinC`, `QinC_ring`, `ring_polynomial`, `poly_const`
- Theorems: `RING_POLYNOMIAL_CONST`, `QinC_ring_clauses`


---

## poly_const_QinC_poly_const_complex

### Name of formal statement
poly_const_QinC_poly_const_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_const_QinC_poly_const_complex = prove(`
  !c.
  poly_const QinC_ring c
  = poly_const complex_ring c:(V->num)->complex
`,
  qed[poly_const_subring;subring_complex_QinC]
);;
```
### Informal statement
For all constants `c`, the polynomial constant function `poly_const` applied to the ring `QinC_ring` with the constant `c` is equal to the polynomial constant function `poly_const` applied to the complex ring `complex_ring` with the constant `c`, where the type of the latter is `(V->num)->complex`.

### Informal sketch
- The proof starts by using the theorem `poly_const_subring`, which states that if a ring `R` is a subring of a ring `S`, then `poly_const R c = poly_const S c` for any constant `c`.
- Then, it applies the theorem `subring_complex_QinC`, which establishes that the ring `QinC_ring` is a subring of the ring `complex_ring`. Thus, the equality holds by transitivity.

### Mathematical insight
This theorem bridges the gap between polynomials over the rational numbers extended with the imaginary unit (`QinC`) and polynomials over the complex numbers. The `poly_const` function constructs a constant polynomial. The theorem essentially states that constructing a polynomial as a constant over `QinC` gives the same result as constructing the polynomial over the complex numbers, as long as the constant value is interpreted as a complex number. This is useful because `QinC` is a subring of complex numbers and any calculation within it can be viewed within the setting of complex numbers.

### Dependencies
- Theorems:
  - `poly_const_subring`
  - `subring_complex_QinC`


---

## poly_mul_QinC_poly_mul_complex

### Name of formal statement
poly_mul_QinC_poly_mul_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_mul_QinC_poly_mul_complex = prove(`
  !(p:(1->num)->complex) (q:(1->num)->complex).
  ring_powerseries QinC_ring p ==>
  ring_powerseries QinC_ring q ==>
  poly_mul QinC_ring p q
  = poly_mul complex_ring p q
`,
  qed[poly_mul_subring;subring_complex_QinC]
);;
```
### Informal statement
For all `p` and `q`, both functions from natural numbers to complex numbers, if `p` and `q` are ring powerseries in the complex numbers when considered as elements of the field `QinC_ring`, then the polynomial multiplication of `p` and `q` with respect to `QinC_ring` is equal to the polynomial multiplication of `p` and `q` with respect to the standard complex number ring `complex_ring`.

### Informal sketch
The proof demonstrates that polynomial multiplication is preserved when moving from the `QinC_ring` representation of complex numbers to the standard `complex_ring`.

- The proof leverages `poly_mul_subring`, a theorem stating that polynomial multiplication in a subring coincides with the multiplication in the larger ring, given that the power series are rings over both.
- It uses `subring_complex_QinC`, which asserts that the complex numbers are a subring of `QinC_ring`.
- Therefore, since the `QinC_ring` includes complex numbers as a subring, polynomial multiplication via `QinC_ring` agrees with that of the `complex_ring`.

### Mathematical insight
This theorem highlights the consistency of polynomial multiplication across different representations of complex numbers. It shows that the abstract `QinC_ring` representation does not alter the result of polynomial multiplication compared to the standard complex number field. This is important for ensuring that computations and reasoning performed within the `QinC_ring` framework are sound and align with standard complex analysis. Effectively, even if we represent complex numbers differently, their algebraic properties, such as polynomial multiplication, remain consistent.

### Dependencies
- Theorems:
  - `poly_mul_subring`
  - `subring_complex_QinC`


---

## x_poly_ZinC_denominator_is_QinC_v2_lemma2

### Name of formal statement
x_poly_ZinC_denominator_is_QinC_v2_lemma2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_ZinC_denominator_is_QinC_v2_lemma2 = prove(`
  !(p:(1->num)->complex) e.
  ring_powerseries QinC_ring p ==>
  series_from_coeffs (\n. (coeff n p) / Cx(&e))
  = poly_mul QinC_ring (poly_const QinC_ring (Cx(&1) / Cx(&e))) p
`,
  intro THEN
  have `Cx(&1) / Cx(&e) IN QinC` [num_over_num_in_QinC] THEN
  have `ring_powerseries QinC_ring (poly_const QinC_ring (Cx(&1) / Cx(&e)):(1->num)->complex)` [RING_POWERSERIES_CONST;QinC_ring_clauses] THEN
  simp[poly_mul_QinC_poly_mul_complex] THEN
  simp[poly_const_QinC_poly_const_complex] THEN
  qed[x_poly_ZinC_denominator_is_QinC_v2_lemma]
);;
```
### Informal statement
For all `p` which is a function from `1->num` to complex numbers, and for all `e`, if `p` is a ring powerseries in `QinC`, then the series formed from the coefficients of `p` divided by `Cx(&e)` is equal to the polynomial multiplication in `QinC` of the polynomial constant `Cx(&1) / Cx(&e)` and `p`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a ring powerseries in `QinC`
- Show that `Cx(&1) / Cx(&e)` is in `QinC` using `num_over_num_in_QinC`.
- Show that the polynomial constant `Cx(&1) / Cx(&e)` is a ring powerseries in `QinC` using `RING_POWERSERIES_CONST` and facts about `QinC`.
- Simplify using `poly_mul_QinC_poly_mul_complex`.
- Simplify using `poly_const_QinC_poly_const_complex`.

### Mathematical insight
This lemma establishes a relationship between dividing a ring powerseries by a constant and multiplying by a polynomial constant in the context of `QinC`, representing rational complex numbers. It's important when manipulating ring powerseries, allowing coefficients to be scaled by multiplying by a constant polynomial.

### Dependencies
- Theorems:
  - `num_over_num_in_QinC`
  - `RING_POWERSERIES_CONST`
- Definitions/Theorems about `QinC` ring structure:
  - `QinC_ring_clauses`
- Simplification Rules
  - `poly_mul_QinC_poly_mul_complex`
  - `poly_const_QinC_poly_const_complex`
- Lemma:
  - `x_poly_ZinC_denominator_is_QinC_v2_lemma`


---

## x_poly_ZinC_denominator_is_QinC_v2

### Name of formal statement
x_poly_ZinC_denominator_is_QinC_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_ZinC_denominator_is_QinC_v2 = prove(`
  !(p:(1->num)->complex) e.
  ring_polynomial ZinC_ring p ==>
  ~(e = 0) ==>
  ring_polynomial QinC_ring
    (poly_mul QinC_ring (poly_const QinC_ring (Cx(&1) / Cx(&e))) p)
`,
  intro THEN
  have `ring_powerseries ZinC_ring (p:(1->num)->complex)` [ring_polynomial] THEN
  have `ring_powerseries QinC_ring (p:(1->num)->complex)` [series_QinC_if_series_ZinC] THEN
  qed[x_poly_ZinC_denominator_is_QinC;x_poly_ZinC_denominator_is_QinC_v2_lemma2]
);;
```
### Informal statement
For every complex-valued polynomial `p` indexed by natural numbers, if `p` is a ring polynomial over the ring `ZinC_ring` and `e` is not equal to 0, then the polynomial resulting from multiplying `p` by the constant polynomial `Cx(&1) / Cx(&e)` over the ring `QinC_ring` is a ring polynomial over the ring `QinC_ring`.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is a ring polynomial over the ring `ZinC_ring` and `e` is not zero.
- Show that since `p` is a ring polynomial in `ZinC_ring`, it is a ring power series in `ZinC_ring`.
- Show that since `p` is a ring power series in `ZinC_ring`, it is a ring power series in `QinC_ring`.
- Conclude that the given polynomial is a ring polynomial over `QinC_ring`.
The proof uses `intro` to introduce the assumptions and `qed` along with the specified lemmas.

### Mathematical insight
This theorem shows that if you have a polynomial whose coefficients are complex numbers of the form `x + iy` where `x` and `y` are integers, and you multiply it by a constant complex number of the form `1/e` where `e` is a real number (converted to a complex number), then the resulting polynomial has coefficients which are complex numbers of the form `x + iy` where `x` and `y` are rational numbers. This is important because it allows us to work with polynomials over the rational complex numbers `QinC_ring` when we start with polynomials over the integer complex numbers `ZinC_ring`, as long as we perform a scaling by a rational constant.

### Dependencies
- `ZinC_ring`
- `QinC_ring`
- `ring_polynomial`
- `poly_mul`
- `poly_const`
- `Cx`
- `ring_powerseries`
- `series_QinC_if_series_ZinC`
- `x_poly_ZinC_denominator_is_QinC`
- `x_poly_ZinC_denominator_is_QinC_v2_lemma2`

### Porting notes (optional)
The main challenge in porting this result will likely be the representation of complex numbers and polynomials in the target proof assistant. The definitions of `ZinC_ring` and `QinC_ring` will need to be carefully considered, and `ring_polynomial`, `poly_mul`, and `poly_const` must be properly defined in the target system. Additionally, the interaction between ring polynomials and ring power series may require some additional work.


---

## x_poly_QinC_is_ZinC_denominator

### Name of formal statement
x_poly_QinC_is_ZinC_denominator

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_QinC_is_ZinC_denominator = prove(`
  !p:(1->num)->complex.
  ring_polynomial QinC_ring p ==>
  ?e. (~(e = 0) /\
       ring_polynomial ZinC_ring
         (series_from_coeffs (\n. Cx(&e) * coeff n p))
      )
`,
  intro THEN
  witness `nproduct (0..poly_deg QinC_ring p) (\n. @d. ~(d = 0) /\ Cx(&d) * coeff n p IN ZinC)` THEN
  conjunction THENL [
    rw[NPRODUCT_EQ_0_NUMSEG] THEN
    qed[coeff_poly_in_ring;QinC_ring_clauses;QinC_to_ZinC]
  ;
    rw[poly_series_from_coeffs] THEN
    intro THENL [
      case `d <= poly_deg QinC_ring(p:(1->num)->complex)` THENL [
        have `d IN (0..poly_deg QinC_ring(p:(1->num)->complex))` [IN_NUMSEG_0] THEN
        have `FINITE (0..poly_deg QinC_ring(p:(1->num)->complex))` [FINITE_NUMSEG] THEN
        specialize[`\n. @d. ~(d = 0) /\ Cx (&d) * coeff n p IN ZinC`;`0..poly_deg QinC_ring(p:(1->num)->complex)`;`d:num`](GSYM NPRODUCT_DELETE) THEN
        simp[] THEN
        once_rw[MULT_SYM] THEN
        simp[prove(`&(m*n):real = &m * &n`,qed[REAL_OF_NUM_CLAUSES])] THEN
        rw[CX_MUL;GSYM COMPLEX_MUL_ASSOC] THEN
        have `(Cx (&(@u:num. ~(u = 0) /\ Cx (&u) * coeff d p IN ZinC))) * coeff d p IN ZinC` [coeff_poly_in_ring;QinC_ring_clauses;QinC_to_ZinC] THEN
        qed[mul_in_ZinC;ZinC_ring_clauses;num_in_ZinC]
      ;
        have `coeff d p = ring_0 QinC_ring` [coeff_le_deg] THEN
        have `ring_0 QinC_ring = Cx(&0)` [QinC_ring_clauses] THEN
        simp[COMPLEX_MUL_RZERO;ZinC_ring_clauses] THEN
        qed[ZinC_0]
      ]
    ;
      specialize[`QinC_ring`;`p:(1->num)->complex`]finite_coeff THEN
      subgoal `{d | ~(Cx (&(nproduct (0..poly_deg QinC_ring p) (\n. @d. ~(d = 0) /\ Cx (&d) * coeff n p IN ZinC))) * coeff d p = ring_0 ZinC_ring)} SUBSET {d | ~(coeff d p = ring_0 QinC_ring)}` THENL [
        rw[SUBSET;IN_ELIM_THM] THEN
        rw[ZinC_ring_clauses;QinC_ring_clauses] THEN
        qed[COMPLEX_MUL_RZERO]
      ;
        qed[FINITE_SUBSET]
      ]
    ]
  ]
);;
```
### Informal statement
For any polynomial `p` over the ring of complex numbers where the coefficients are rational numbers (`QinC`), there exists a non-zero natural number `e` such that the polynomial whose coefficients are obtained by multiplying each coefficient of `p` by `e` is a polynomial over the ring of complex numbers where the coefficients are integers (`ZinC`). The coefficients of the new polynomial are obtained by applying `series_from_coeffs` to a function that maps each natural number `n` to `Cx(&e) * coeff n p`, where `Cx` maps a real number to a complex number and `coeff n p` gives the `n`-th coefficient of `p`.

### Informal sketch
The proof proceeds as follows:

- Introduce the polynomial `p`.
- Instantiate the existential quantifier with `nproduct (0..poly_deg QinC_ring p) (\n. @d. ~(d = 0) /\ Cx(&d) * coeff n p IN ZinC)`. This term represents the product of denominators required to scale coefficients of p into ZinC.
- Split the goal into two subgoals: proving that the chosen witness is not zero, and proving that the scaled polynomial has coefficients in `ZinC`.

  - For the first subgoal, prove that the product is non-zero by showing that none of the terms in the product are zero. This relies on `NPRODUCT_EQ_0_NUMSEG` and the fact that each `d` such that `Cx (&d) * coeff n p IN ZinC` must be nonzero.
  - For the second subgoal, prove that the coefficients of the scaled polynomial `series_from_coeffs (\n. Cx(&e) * coeff n p)` are in `ZinC`. This leverages `poly_series_from_coeffs`.
    - Case split on whether `d <= poly_deg QinC_ring p`.
      - If `d <= poly_deg QinC_ring p`, then `d IN (0..poly_deg QinC_ring(p))`. Since `@(u:num). ~(u = 0) /\ Cx (&u) * coeff d p IN ZinC` is non-empty, take its witness `u`. Then `Cx (&u) * coeff d p IN ZinC`. It follows that `(Cx (&(@u. ~(u = 0) /\ Cx (&u) * coeff d p IN ZinC))) * coeff d p IN ZinC`. Hence, the coefficients of the new polynomial are in `ZinC` using `mul_in_ZinC` and properties of `ZinC_ring`.
      - If `~(d <= poly_deg QinC_ring p)`, then `coeff d p = ring_0 QinC_ring`. Since `ring_0 QinC_ring = Cx(&0)`, we have `Cx(&0) * Cx(&(...)) = Cx(&0)`, which is in `ZinC`.
    - Show the set of coefficients that are not `ring_0 ZinC_ring` is a subset of the coefficients that are not `ring_0 QinC_ring`.
    - Conclude using the finiteness property `finite_coeff`.
### Mathematical insight
The theorem states that a polynomial with rational complex coefficients can be converted into a polynomial with integer complex coefficients by multiplying by a common denominator. This is a fundamental result when working with polynomials, since it allows us to reduce problems about rational polynomials to problems about polynomials. The proof constructs a suitable denominator by taking the product of the denominators of all coefficients of the polynomial.

### Dependencies
- `NPRODUCT_EQ_0_NUMSEG`
- `coeff_poly_in_ring`
- `QinC_ring_clauses`
- `QinC_to_ZinC`
- `poly_series_from_coeffs`
- `REAL_OF_NUM_CLAUSES`
- `CX_MUL`
- `COMPLEX_MUL_ASSOC`
- `mul_in_ZinC`
- `ZinC_ring_clauses`
- `num_in_ZinC`
- `coeff_le_deg`
- `COMPLEX_MUL_RZERO`
- `ZinC_0`
- `SUBSET`
- `IN_ELIM_THM`
- `finite_coeff`
- `FINITE_SUBSET`

### Porting notes (optional)
- Recreating the tactic-based proof in other proof assistants such as Isabelle or Coq will require translating HOL Light-specific tactics (e.g., `intro`, `witness`, `rw`, `simp`, `qed`) into equivalent proof commands. The `auto` tactic in Isabelle and the `auto`/`easy` tactics in Coq are often helpful for automating simple reasoning steps. Lean's `simp` and rewrite machinery is quite powerful for equational reasoning.
- The `nproduct` function could be replaced with other implementations of product over finite sets, for example through folds, product operators, or inductive definitions. The choice will depend on the target proof assistant.
- The handling of complex numbers and their integer/rational subtypes may require adjustments depending on the target system's library. Ensure that analogous definitions for types like `QinC` and `ZinC` exist or can be readily created.


---

## x_poly_QinC_is_ZinC_denominator_v2_lemma

### Name of formal statement
x_poly_QinC_is_ZinC_denominator_v2_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_QinC_is_ZinC_denominator_v2_lemma = prove(`
  !(p:(1->num)->complex) e.
  series_from_coeffs (\n. Cx(&e) * coeff n p)
  = poly_mul complex_ring (poly_const complex_ring (Cx(&e))) p
`,
  intro THEN
  have `ring_powerseries complex_ring (p:(1->num)->complex)` [series_complex] THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_series_from_coeffs] THEN
  have `Cx(&e) IN ring_carrier complex_ring` [in_complex_ring] THEN
  simp[coeff_poly_const_times] THEN
  rw[complex_ring_clauses]
);;
```
### Informal statement
For any function `p` from `1->num` to complex numbers and any number `e`, the series generated from the coefficients defined by multiplying `Cx(&e)` with the coefficients of `p` is equal to the polynomial multiplication of the polynomial constant `Cx(&e)` with the polynomial `p`, within the complex ring structure.

### Informal sketch
The proof proceeds as follows:
- Introduce the variables `p` and `e`.
- Utilize the fact that `p` is a `ring_powerseries` in the `complex_ring`.
- Reduce the problem to proving the equality of coefficients on both sides of the equation.
- Introduce a variable `n` representing the coefficient index.
- Rewrite the left-hand side using the definition of `coeff_series_from_coeffs`.
- Show that `Cx(&e)` is an element of the carrier of the `complex_ring`
- Simplify the right-hand side using `coeff_poly_const_times`.
- Apply the `complex_ring_clauses` to complete the proof.

### Mathematical insight
This theorem essentially states that multiplying a polynomial by a constant `e` (represented as a complex number `Cx(&e)`) is equivalent to scaling each coefficient of the polynomial by `e` when considering the power series representation. This is a fundamental property used in polynomial algebra and is crucial for manipulating and simplifying polynomial expressions within the context of complex numbers.

### Dependencies
- Theorems:
  - `ring_powerseries`
- Definitions:
  - `series_from_coeffs`
  - `poly_mul`
  - `poly_const`
  - `Cx`
  - `coeff`
  - `coeff_series_from_coeffs`
  - `coeff_poly_const_times`
  - `complex_ring_clauses`

### Porting notes (optional)
- Ensure that the target proof assistant has a well-defined notion of power series, polynomials, and complex numbers.
- The `complex_ring` structure and its properties will need to be represented in the target system.
- The definitions of `series_from_coeffs`, `poly_mul`, `poly_const`, and `coeff` should be carefully translated to match the HOL Light semantics.
- Pay close attention to the handling of coefficients and polynomial multiplication in the target proof assistant.


---

## x_poly_QinC_is_ZinC_denominator_v2_lemma2

### Name of formal statement
x_poly_QinC_is_ZinC_denominator_v2_lemma2

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(p:(1->num)->complex) e.
  ring_powerseries QinC_ring p ==>
  series_from_coeffs (\n. Cx(&e) * coeff n p)
  = poly_mul QinC_ring (poly_const QinC_ring (Cx(&e))) p
```

### Informal statement
For all `p` which is a power series in `QinC_ring` and for all `e`, if `p` is a ring power series over the ring `QinC_ring`, then the formal power series obtained from the coefficients `Cx(&e) * coeff n p` is equal to the term `poly_mul QinC_ring (poly_const QinC_ring (Cx(&e))) p`. In other words, the formal power series whose nth coefficient is `Cx(&e)` times the nth coefficient of `p` is equal to the polynomial `poly_mul QinC_ring (poly_const QinC_ring (Cx(&e))) p`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions and variable `p` and `e`.
- Prove `Cx(&e) IN QinC` using `num_in_QinC`.
- Prove that `poly_const QinC_ring (Cx(&e))` is a ring power series over `QinC_ring` using `RING_POWERSERIES_CONST` and `QinC_ring_clauses`.
- Simplify using the definition of `poly_mul QinC_ring` with `poly_mul_QinC_poly_mul_complex`.
- Simplify with `poly_const_QinC_poly_const_complex`.
- Conclude.

### Mathematical insight
This lemma states that multiplication of a power series `p` by a constant `Cx(&e)` can be expressed as multiplication by a constant polynomial. It connects scalar multiplication of a power series with polynomial multiplication within the context of the `QinC_ring`.

### Dependencies
- `num_in_QinC`
- `RING_POWERSERIES_CONST`
- `QinC_ring_clauses`
- `poly_mul_QinC_poly_mul_complex`
- `poly_const_QinC_poly_const_complex`
- `x_poly_QinC_is_ZinC_denominator_v2_lemma`


---

## x_poly_QinC_is_ZinC_denominator_v2

### Name of formal statement
x_poly_QinC_is_ZinC_denominator_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let x_poly_QinC_is_ZinC_denominator_v2 = prove(`
  !p:(1->num)->complex.
  ring_polynomial QinC_ring p ==>
  ?e. (~(e = 0) /\
       ring_polynomial ZinC_ring
         (poly_mul QinC_ring (poly_const QinC_ring (Cx(&e))) p)
      )
`,
  intro THEN
  have `ring_powerseries QinC_ring (p:(1->num)->complex)` [ring_polynomial] THEN
  simp[GSYM x_poly_QinC_is_ZinC_denominator_v2_lemma2] THEN
  qed[x_poly_QinC_is_ZinC_denominator]
);;
```
### Informal statement
For all `p` of type `(1->num)->complex`, if `p` is a ring polynomial over the ring of rational complex numbers `QinC_ring`, then there exists a non-zero natural number `e` such that the polynomial obtained by multiplying `p` by the constant polynomial `Cx(&e)` (where `Cx` injects a real number into the complex numbers) is a ring polynomial over the ring of integer complex numbers `ZinC_ring`.

### Informal sketch
The proof proceeds as follows:
- The initial assumption is that `p` is a ring polynomial over `QinC_ring`.
- It is shown that `p` is a ring power series over `QinC_ring`, using a theorem about ring polynomials.
- Apply a lemma `x_poly_QinC_is_ZinC_denominator_v2_lemma2` and `x_poly_QinC_is_ZinC_denominator` to complete the proof. These lemmas likely relate `QinC_ring` and `ZinC_ring` and show that we can scale a polynomial over `QinC_ring` by some constant to obtain a polynomial over `ZinC_ring`.

### Mathematical insight
The theorem states that if `p` is a polynomial with complex rational coefficients `(QinC_ring)`, one can always find a nonzero integer `e` such that `e * p` has complex integer coefficients `(ZinC_ring)`. In other words, every polynomial with rational complex coefficients has an integer multiple that has integer complex coefficients. This is a fundamental result when working with polynomials over rings and is useful for converting problems involving rationals to problems involving integers, which are often easier to handle.

### Dependencies
- Theorems:
  - `x_poly_QinC_is_ZinC_denominator_v2_lemma2`
  - `x_poly_QinC_is_ZinC_denominator`
- Definitions:
  - `ring_polynomial`
  - `QinC_ring`
  - `ZinC_ring`
  - `poly_mul`
  - `poly_const`
  - `Cx`
  - `ring_powerseries`

### Porting notes (optional)
The main potential difficulty lies in the definitions of `QinC_ring` and `ZinC_ring`, and the associated `ring_polynomial` definition/property. Recreating these rings and their properties in another proof assistant, along with corresponding polynomial constructions and definitions is where the most work will be required. You will want to ensure your target proof assistant provides similar ring and polynomial theories. Also, `x_poly_QinC_is_ZinC_denominator_v2_lemma2` and `x_poly_QinC_is_ZinC_denominator` will need to be ported, and potentially their proofs as well.


---

## ring_hasQ_subring_series_complex

### Name of formal statement
ring_hasQ_subring_series_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_hasQ_subring_series_complex = prove(`
  ring_hasQ (
    subring_generated (
      x_series complex_ring
    ) (
      ring_carrier (x_series QinC_ring)
    )
  )
`,
  rw[ring_hasQ] THEN
  intro THENL [
    rw[RING_CHAR_SUBRING_GENERATED] THEN
    rw[ring_char_x_series] THEN
    rw[ring_char_complex]
  ;
    rw[ring_unit] THEN
    intro THENL [
      qed[RING_OF_NUM]
    ;
      witness `poly_const QinC_ring (Cx(&1) / Cx(&n)):(1->num)->complex` THEN
      intro THENL [
        have `Cx(&1) / Cx(&n) IN QinC` [num_over_num_in_QinC] THEN
        have `Cx(&1) / Cx(&n) IN ring_carrier(QinC_ring)` [QinC_ring_clauses] THEN
        have `poly_const QinC_ring (Cx(&1) / Cx(&n)) IN ring_carrier(x_series QinC_ring)` [x_series_use;RING_POWERSERIES_CONST] THEN
        have `ring_carrier(x_series QinC_ring) SUBSET ring_carrier(x_series complex_ring)` [x_series_use;series_complex_if_series_QinC;SUBSET] THEN
        have `ring_carrier(x_series QinC_ring) SUBSET ring_carrier (subring_generated (x_series complex_ring) (ring_carrier(x_series QinC_ring)))` [SUBSET_CARRIER_SUBRING_GENERATED;SUBSET_REFL] THEN
        qed[SUBSET]
      ;
        rw[RING_OF_NUM_SUBRING_GENERATED] THEN
        rw[SUBRING_GENERATED] THEN
        rw[ring_of_num_x_series] THEN
        rw[GSYM x_series_use] THEN
        rw[poly_const_QinC_poly_const_complex] THEN
        rw[ring_of_num_complex;complex_of_num] THEN
        simp[GSYM POLY_CONST_MUL;in_complex_ring] THEN
        rw[complex_ring_clauses;poly_1] THEN
        have `~(&n = &0:real)` [REAL_OF_NUM_EQ] THEN
        have `~(Cx(&n) = Cx(&0))` [CX_INJ] THEN
        complex_field_fact `~(Cx(&n) = Cx(&0)) ==> Cx (&n) * Cx (&1) / Cx (&n) = Cx(&1)` THEN
        qed[]
      ]
    ]
  ]
);;
```
### Informal statement
The ring `x_series complex_ring` has a subring with characteristic zero, namely the subring generated by the carrier of the ring of Cauchy rationals `x_series QinC_ring`.

### Informal sketch
The proof demonstrates that the characteristic of the subring generated by the ring carrier of `x_series QinC_ring` within `x_series complex_ring` is zero. This is shown by demonstrating both that the ring `x_series complex_ring` has characteristic zero and that `x_series QinC_ring` contains a multiplicative unit of `x_series complex_ring`.

- Show the characteristic of `subring_generated (x_series complex_ring) (ring_carrier (x_series QinC_ring))` is zero by showing:
	- The characteristic of `complex_ring` is zero.
	- A unit can be found in `ring_carrier (x_series QinC_ring)`.

- To show a unit exists in `x_series QinC_ring`, the constructive witness `poly_const QinC_ring (Cx(&1) / Cx(&n))` is used to show that `poly_const QinC_ring (Cx(&1) / Cx(&n))` is an element of the `x_series QinC_ring`. It is shown by:
	- Showing `Cx(&1) / Cx(&n)` is in `QinC` using `num_over_num_in_QinC`.
	- Showing `Cx(&1) / Cx(&n)` is in the ring carrier of `QinC_ring`.
	- Showing `poly_const QinC_ring (Cx(&1) / Cx(&n))` is in the carrier of `x_series QinC_ring` using `RING_POWERSERIES_CONST`. Because the carrier of `x_series QinC_ring` is a subset of the carrier of the subring being considered, this shows `poly_const QinC_ring (Cx(&1) / Cx(&n))` is in the subring.
	- Proving that `poly_const QinC_ring (Cx(&1) / Cx(&n))` is a multiplicative unit in `x_series complex_ring`.

- Because it is a unit in `x_series complex_ring` it is a unit in a subring. The `complex_field_fact` is used to prove the unit is 1.

### Mathematical insight
This theorem states a relationship between the ring of complex power series and the ring of rational Cauchy sequence power series. It says that the subring of complex power series generated by rational Cauchy power series has characteristic zero. This is important when considering algebraic properties of these rings, because rings with characteristic zero have different properties than rings with non-zero characteristic.

### Dependencies
- `ring_hasQ`
- `RING_CHAR_SUBRING_GENERATED`
- `ring_char_x_series`
- `ring_char_complex`
- `ring_unit`
- `RING_OF_NUM`
- `num_over_num_in_QinC`
- `QinC_ring_clauses`
- `x_series_use`
- `RING_POWERSERIES_CONST`
- `series_complex_if_series_QinC`
- `SUBSET`
- `SUBSET_CARRIER_SUBRING_GENERATED`
- `SUBSET_REFL`
- `RING_OF_NUM_SUBRING_GENERATED`
- `SUBRING_GENERATED`
- `ring_of_num_x_series`
- `poly_const_QinC_poly_const_complex`
- `ring_of_num_complex`
- `complex_of_num`
- `POLY_CONST_MUL`
- `complex_ring_clauses`
- `poly_1`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `in_complex_ring`

### Porting notes (optional)
- The proof makes heavy use of rewriting using `rw`. Translating such proofs to other systems often benefits from using similar rewriting tactics or their equivalents.
- The proof contains several uses of `have` to introduce intermediate lemmas. This is a common pattern in HOL Light that directly translates to similar proof structures in other systems (e.g., using `assert` in Coq or `have` is Isabelle).


---

## algebraic_number

### Name of formal statement
algebraic_number

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let algebraic_number = new_definition `
  algebraic_number (z:complex)
  <=> ?p. (ring_polynomial ZinC_ring p
           /\ ~(p = poly_0 ZinC_ring)
           /\ poly_eval complex_ring p z = Cx(&0)
          )
`;;
```
### Informal statement
A complex number `z` is defined to be an algebraic number if and only if there exists a polynomial `p` with coefficients in the complex numbers viewed as a ring (`ring_polynomial ZinC_ring p`), such that `p` is not the zero polynomial (`~(p = poly_0 ZinC_ring)`), and the evaluation of `p` at `z` in the complex ring is equal to the complex number 0 (`poly_eval complex_ring p z = Cx(&0)`).

### Informal sketch
The definition `algebraic_number` introduces the concept of an algebraic number. The right-hand side of the definition asserts the existence of a non-zero polynomial `p` with coefficients in the ring of complex numbers (`ZinC_ring`), such that `p` evaluates to zero at the given complex number `z`.

*   The logical structure of the definition is a straightforward equivalence (`<=>`).
*   The definition relies on existing definitions for polynomials over a ring (`ring_polynomial`), the zero polynomial (`poly_0`), and polynomial evaluation (`poly_eval`).
*   The condition `~(p = poly_0 ZinC_ring)` ensures that the polynomial is not identically zero, preventing trivial solutions.

### Mathematical insight
This definition captures the standard mathematical notion of an algebraic number. A complex number is algebraic if it is a root of a non-zero polynomial with complex (or equivalently, rational) coefficients. The definition is important as it provides a formal way to reason about algebraic numbers within HOL Light. It forms the basis for proving properties about algebraic numbers and their relationships to other mathematical concepts.

### Dependencies
- Definitions: `ring_polynomial`, `ZinC_ring`, `poly_0`, `poly_eval`, `complex_ring`


---

## algebraic_number_ZinC_explicit

### Name of formal statement
algebraic_number_ZinC_explicit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_ZinC_explicit = prove(`
  !z.
  z IN ZinC ==> (
    ring_polynomial ZinC_ring (x_minus_const ZinC_ring z) /\
    ~((x_minus_const ZinC_ring z) = poly_0 ZinC_ring) /\
    poly_eval complex_ring (x_minus_const ZinC_ring z) z = Cx(&0)
  )
`,
  intro_gendisch THEN
  have `z IN ring_carrier(ZinC_ring)` [ZinC_ring_clauses] THEN
  intro THENL [
    qed[x_minus_const_poly]
  ;
    have `coeff 1 (x_minus_const ZinC_ring z) = ring_1 ZinC_ring` [coeff_x_minus_const] THEN
    have `coeff 1 (poly_0 ZinC_ring) = ring_0 ZinC_ring` [coeff_poly_0] THEN
    have `ring_1 ZinC_ring = Cx(&1)` [ZinC_ring_clauses] THEN
    have `ring_0 ZinC_ring = Cx(&0)` [ZinC_ring_clauses] THEN
    have `Cx(&1) = Cx(&0)` [] THEN
    qed[CX_INJ;REAL_ARITH `~(&1 = &0:real)`]
  ;
    have `ZinC subring_of complex_ring` [ZinC_subring_complex] THEN
    have `z IN ring_carrier(ZinC_ring)` [ZinC_ring_clauses] THEN
    have `ring_powerseries(subring_generated complex_ring ZinC) (x_minus_const ZinC_ring z)` [x_minus_const_series;subring_complex_ZinC] THEN
    specialize[`complex_ring`;`ZinC`;`x_minus_const ZinC_ring z`;`z:complex`]poly_eval_subring THEN
    simp[] THEN
    qed[eval_x_minus_const_refl;subring_complex_ZinC;ZinC_0;ZinC_ring_clauses]
  ]
);;
```

### Informal statement
For all complex numbers `z`, if `z` is an element of `ZinC` (the subring of complex numbers generated by the integers), then:
1.  `x_minus_const ZinC_ring z` is a polynomial with coefficients in the ring `ZinC_ring`.
2.  `x_minus_const ZinC_ring z` is not the zero polynomial in the ring `ZinC_ring`.
3.  Evaluating the polynomial `x_minus_const ZinC_ring z` at `z` in the complex ring `complex_ring` yields the complex number `0`.

### Informal sketch
The proof proceeds by considering an arbitrary complex number `z` and showing that if `z` is in `ZinC`, then all three conditions hold.

- The first condition, that `x_minus_const ZinC_ring z` is a polynomial with coefficients in `ZinC_ring`, follows directly from the definition of `x_minus_const`.

- The second condition, that `x_minus_const ZinC_ring z` is not the zero polynomial, is proven by contradiction. We show that the coefficient of `x` in `x_minus_const ZinC_ring z` is `1` (using `coeff_x_minus_const`), while the coefficient of `x` in the zero polynomial is `0` (using `coeff_poly_0`).  Then we use `ZinC_ring_clauses` where `ring_1 ZinC_ring` is `Cx(&1)` and `ring_0 ZinC_ring` is `Cx(&0)`. Then `CX_INJ` along with `REAL_ARITH` shows that `1` is not `0`.

- The third condition, that evaluating `x_minus_const ZinC_ring z` at `z` results in `0`, uses the facts that `ZinC` is a subring of the complex numbers (`ZinC subring_of complex_ring`, `subring_complex_ZinC`) and that `z` is in `ZinC_ring`. We then specialize `poly_eval_subring` for `complex_ring`, `ZinC`, `x_minus_const ZinC_ring z`, and `z`, and simplify using `eval_x_minus_const_refl`, `subring_complex_ZinC`, `ZinC_0`, and `ZinC_ring_clauses`.

### Mathematical insight
This theorem states that if a complex number `z` is in `ZinC`, then `z` is a root of the polynomial `x - z`. This is a specific case of the more general result that elements of a ring are roots of polynomials over that ring.  The construction `ZinC` being the smallest subring of `complex_ring` generated by `INT` is a common and useful one in abstract algebra.

### Dependencies
- `ZinC_ring_clauses`
- `coeff_x_minus_const`
- `coeff_poly_0`
- `CX_INJ`
- `ZinC_subring_complex`
- `x_minus_const_series`
- `subring_complex_ZinC`
- `poly_eval_subring`
- `eval_x_minus_const_refl`
- `ZinC_0`

### Porting notes (optional)
- The tactic `REAL_ARITH` is a HOL Light specific tactic, any port will need to recreate the functionality directly, and likely is just using standard real number properties. `CX_INJ` refers to the injectivity of embedding real numbers into complex numbers.


---

## algebraic_number_ZinC

### Name of formal statement
algebraic_number_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_ZinC = prove(`
  !z.
  z IN ZinC ==> algebraic_number z
`,
  rw[algebraic_number] THEN
  qed[algebraic_number_ZinC_explicit]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is an element of `ZinC` (the set of complex numbers with integer real and imaginary parts), then `z` is an algebraic number.

### Informal sketch
- Goal: Prove that if a complex number `z` belongs to the set `ZinC` then `z` is an `algebraic_number`.
- Expand definition: Rewrite the goal using the definition of `algebraic_number`. This essentially means proving that there exists a non-zero polynomial with integer coefficients such that evaluating the polynomial at `z` results in zero.
- Proof completion: The proof is completed by an explicit construction of the polynomial, witnessed by the theorem `algebraic_number_ZinC_explicit`.

### Mathematical insight
This theorem establishes that any complex number with integer real and imaginary parts (i.e., a Gaussian integer) is an algebraic number. This is an important result because it connects a specific class of complex numbers (`ZinC`) to a more general notion of algebraic numbers.

### Dependencies
- Definitions: `algebraic_number`
- Theorems: `algebraic_number_ZinC_explicit`


---

## algebraic_number_ii

### Name of formal statement
algebraic_number_ii

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_ii = prove(`
  algebraic_number ii
`,
  rw[algebraic_number] THEN
  intro THEN
  witness `poly_add ZinC_ring (x_pow ZinC_ring 2) (x_pow ZinC_ring 0)` THEN
  intro THENL [
    qed[x_pow_poly;RING_POLYNOMIAL_ADD]
  ;
    have `coeff 0 (x_pow ZinC_ring 2) = ring_0 ZinC_ring` [coeff_x_pow;ARITH_RULE `~(2 = 0)`] THEN
    have `coeff 0 (x_pow ZinC_ring 0) = ring_1 ZinC_ring` [coeff_x_pow] THEN
    have `coeff 0 (poly_add ZinC_ring (x_pow ZinC_ring 2) (x_pow ZinC_ring 0)) = ring_add ZinC_ring (ring_0 ZinC_ring) (ring_1 ZinC_ring)` [coeff_poly_add] THEN
    have `coeff 0 (poly_add ZinC_ring (x_pow ZinC_ring 2) (x_pow ZinC_ring 0)) = ring_1 ZinC_ring` [RING_ADD_LZERO;RING_1] THEN
    have `coeff 0 (poly_0 ZinC_ring) = ring_0 ZinC_ring` [coeff_poly_0] THEN
    have `ring_1 ZinC_ring = Cx(&1)` [ZinC_ring_clauses] THEN
    have `ring_0 ZinC_ring = Cx(&0)` [ZinC_ring_clauses] THEN
    have `Cx(&1) = Cx(&0)` [] THEN
    qed[CX_INJ;REAL_ARITH `~(&1 = &0:real)`]
  ; pass
  ] THEN
  have `x_pow ZinC_ring 2 = x_pow complex_ring 2` [subring_x_pow;subring_complex_empty] THEN
  have `x_pow ZinC_ring 0 = x_pow complex_ring 0` [subring_x_pow;subring_complex_empty] THEN
  simp[poly_add_subring;GSYM subring_complex_empty] THEN
  have `ii IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `poly_deg complex_ring (x_pow complex_ring 2) <= 2` [deg_x_pow_le] THEN
  have `poly_deg complex_ring (x_pow complex_ring 0) <= 2` [deg_x_pow_le;ARITH_RULE `d <= 0 ==> d <= 2`] THEN
  have `ring_polynomial complex_ring (x_pow complex_ring 2)` [x_pow_poly] THEN
  have `ring_polynomial complex_ring (x_pow complex_ring 0)` [x_pow_poly] THEN
  have `ring_polynomial complex_ring (poly_add complex_ring (x_pow complex_ring 2) (x_pow complex_ring 0))` [RING_POLYNOMIAL_ADD] THEN
  have `poly_deg complex_ring (poly_add complex_ring (x_pow complex_ring 2) (x_pow complex_ring 0)) <= MAX (poly_deg complex_ring (x_pow complex_ring 2)) (poly_deg complex_ring (x_pow complex_ring 0))` [POLY_DEG_ADD_LE] THEN
  have `poly_deg complex_ring (poly_add complex_ring (x_pow complex_ring 2) (x_pow complex_ring 0)) <= 2` [ARITH_RULE `d <= 2 /\ e <= 2 /\ c <= MAX d e ==> c <= 2`] THEN
  specialize[`complex_ring`;`poly_add complex_ring (x_pow complex_ring 2) (x_pow complex_ring 0)`;`ii`;`2`]poly_eval_expand_coeff THEN
  simp[] THEN
  rw[coeff_poly_add;coeff_x_pow] THEN
  simp[RING_SUM_CLAUSES_RIGHT;
    ARITH_RULE `0 < 2 /\ 0 <= 2`;ARITH_RULE `2 - 1 = 1`;ARITH_RULE `~(2 = 0)`;
    ARITH_RULE `0 < 1 /\ 0 <= 1`;ARITH_RULE `1 - 1 = 0`;ARITH_RULE `~(1 = 2)`;ARITH_RULE `~(1 = 0)`;
    RING_CLAUSES] THEN
  once_rw[RING_SUM_CLAUSES_NUMSEG] THEN
  simp[ARITH_RULE `~(0 = 2)`;ARITH_RULE `~(0 = 1)`;
    RING_ADD_LZERO;RING_ADD_RZERO;RING_MUL_LID;RING_MUL_LZERO;
    RING_CLAUSES] THEN
  rw[ring_pow_complex;complex_ring_clauses] THEN
  simp[COMPLEX_POW_II_2;complex_pow] THEN
  CONV_TAC COMPLEX_FIELD
);;
```
### Informal statement
The imaginary unit `ii` is an algebraic number.

### Informal sketch
The proof proceeds as follows:
- It starts by rewriting `algebraic_number ii` with its definition, requiring a witness polynomial in `ZinC_ring` and proving two conditions: the polynomial is non-zero, and `ii` is a root of the polynomial when evaluated in the complex field.
- The witness polynomial is chosen to be `x^2 + 1` in `ZinC_ring` (polynomial addition of `(x^2)` and `1`).
- The proof demonstrates that `x^2 + 1` is non-zero in `ZinC_ring` using `coeff 0` and the injection properties of `Cx`. This splits into proving both conditions.
  - One condition required us to show that the 0th coefficient of the witness polynomial is not equal to 0 in `ZinC_ring`. The 0th coefficient evaluates to 1 (via `coeff_poly_add` and `coeff_x_pow`). If `poly_0 ZinC_ring` (which is just 0) was equal to `poly_add`, then stripping `Cx` would result in `1 = 0`, which is a trivial contradiction.
- The proof shows that `ii` is a root of `x^2 + 1` when evaluated in the complex field.
  - It equates `x^2` and `1` in `ZinC_ring` with their counterparts in `complex_ring` using subring properties.
  - It utilizes `poly_eval_expand_coeff` which expands polynomial evaluation in terms of coefficients. Then simplifies the expression `ii^2 + 1` to 0 using identities related to `ii` (`ii^2 = -1`).

### Mathematical insight
The theorem asserts that the imaginary unit `ii` satisfies the definition of an algebraic number. This is demonstrated by exhibiting a polynomial with integer coefficients, namely `x^2 + 1`, that has `ii` as one of its roots. This polynomial is a standard example in algebra.

### Dependencies
- Definitions: `algebraic_number`
- Theorems: `x_pow_poly`, `RING_POLYNOMIAL_ADD`, `coeff_x_pow`, `coeff_poly_add`, `RING_ADD_LZERO`, `RING_1`, `coeff_poly_0`, `ZinC_ring_clauses`, `CX_INJ`, `subring_x_pow`, `subring_complex_empty`, `in_complex_ring`, `deg_x_pow_le`, `POLY_DEG_ADD_LE`, `poly_eval_expand_coeff`, `RING_SUM_CLAUSES_RIGHT`, `RING_SUM_CLAUSES_NUMSEG`, `RING_ADD_LZERO`, `RING_ADD_RZERO`, `RING_MUL_LID`, `RING_MUL_LZERO`, `RING_CLAUSES`, `ring_pow_complex`, `complex_ring_clauses`, `COMPLEX_POW_II_2`, `complex_pow`
- Tactics: `COMPLEX_FIELD`

### Porting notes (optional)
- In proof assistants like Lean or Coq, one would need to define the complex numbers, polynomials, and the concept of algebraic numbers first.
- The subring coercions between `ZinC_ring` and `complex_ring` would require careful treatment in systems with different coercion mechanisms.
- The tactic `COMPLEX_FIELD` is likely a field tactic that utilizes properties of complex field, which would need to be replicated by similar automation in the target proof assistant.


---

## algebraic_number_half

### Name of formal statement
 algebraic_number_half

### Type of the formal statement
 theorem

### Formal Content
```ocaml
let algebraic_number_half = prove(`
  algebraic_number (Cx(&1 / &2))
`,
  rw[algebraic_number] THEN
  intro THEN
  witness `poly_sub ZinC_ring (const_x_pow ZinC_ring (Cx(&2)) 1) (x_pow ZinC_ring 0)` THEN
  intro THENL [
    have `Cx(&2) IN ring_carrier ZinC_ring` [complex_of_num;RING_OF_NUM;ring_of_num_ZinC] THEN
    qed[x_pow_poly;const_x_pow_poly;RING_POLYNOMIAL_SUB]
  ;
    have `coeff 0 (const_x_pow ZinC_ring (Cx(&2)) 1) = ring_0 ZinC_ring` [coeff_const_x_pow;ARITH_RULE `~(1 = 0)`] THEN
    have `coeff 0 (x_pow ZinC_ring 0) = ring_1 ZinC_ring` [coeff_x_pow] THEN
    have `coeff 0 (poly_sub ZinC_ring (const_x_pow ZinC_ring (Cx(&2)) 1) (x_pow ZinC_ring 0)) = ring_sub ZinC_ring (ring_0 ZinC_ring) (ring_1 ZinC_ring)` [coeff_poly_sub] THEN
    have `coeff 0 (poly_sub ZinC_ring (const_x_pow ZinC_ring (Cx(&2)) 1) (x_pow ZinC_ring 0)) = ring_neg ZinC_ring (ring_1 ZinC_ring)` [RING_SUB_LZERO;RING_1] THEN
    have `coeff 0 (poly_0 ZinC_ring) = ring_0 ZinC_ring` [coeff_poly_0] THEN
    have `ring_1 ZinC_ring = Cx(&1)` [ZinC_ring_clauses] THEN
    have `ring_0 ZinC_ring = Cx(&0)` [ZinC_ring_clauses] THEN
    have `ring_neg ZinC_ring = ( -- )` [ZinC_ring_clauses] THEN
    have `-- Cx(&1) = Cx(&0)` [] THEN
    have `Cx(&0) + Cx(&1) = Cx(&0)` [COMPLEX_LNEG_UNIQ] THEN
    have `Cx(&0 + &1) = Cx(&0)` [CX_ADD] THEN
    qed[CX_INJ;REAL_ARITH `~(&0 + &1 = &0:real)`]
  ; pass
  ] THEN
  have `const_x_pow ZinC_ring (Cx(&2)) 1 = const_x_pow complex_ring (Cx(&2)) 1` [subring_const_x_pow;subring_complex_empty] THEN
  have `x_pow ZinC_ring 0 = x_pow complex_ring 0` [subring_x_pow;subring_complex_empty] THEN
  simp[poly_sub_subring;GSYM subring_complex_empty] THEN
  have `Cx(&1 / &2) IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `Cx(&2) IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `poly_deg complex_ring (const_x_pow complex_ring (Cx(&2)) 1) <= 1` [deg_const_x_pow_le] THEN
  have `poly_deg complex_ring (x_pow complex_ring 0) <= 1` [deg_x_pow_le;ARITH_RULE `d <= 0 ==> d <= 1`] THEN
  have `ring_polynomial complex_ring (const_x_pow complex_ring (Cx(&2)) 1)` [const_x_pow_poly] THEN
  have `ring_polynomial complex_ring (x_pow complex_ring 0)` [x_pow_poly] THEN
  have `ring_polynomial complex_ring (poly_sub complex_ring (const_x_pow complex_ring (Cx(&2)) 1) (x_pow complex_ring 0))` [RING_POLYNOMIAL_SUB] THEN
  have `poly_deg complex_ring (poly_sub complex_ring (const_x_pow complex_ring (Cx(&2)) 1) (x_pow complex_ring 0)) <= 1` [POLY_DEG_SUB_LE;ARITH_RULE `d <= 1 /\ e <= 1 /\ c <= MAX d e ==> c <= 1`] THEN
  specialize[`complex_ring`;`poly_sub complex_ring (const_x_pow complex_ring (Cx(&2)) 1) (x_pow complex_ring 0)`;`Cx(&1 / &2)`;`1`]poly_eval_expand_coeff THEN
  simp[] THEN
  rw[coeff_poly_sub;coeff_const_x_pow;coeff_x_pow] THEN
  simp[RING_SUM_CLAUSES_RIGHT;
    ARITH_RULE `0 < 1 /\ 0 <= 1`;ARITH_RULE `1 - 1 = 0`;ARITH_RULE `~(1 = 0)`;
    RING_CLAUSES] THEN
  once_rw[RING_SUM_CLAUSES_NUMSEG] THEN
  simp[ARITH_RULE `~(0 = 1)`;
    RING_ADD_LZERO;RING_ADD_RZERO;RING_MUL_LID;RING_MUL_LZERO;
    RING_CLAUSES] THEN
  rw[ring_pow_complex;complex_ring_clauses;ring_sub_complex] THEN
  simp[complex_pow;COMPLEX_POW_1] THEN
  CONV_TAC COMPLEX_FIELD
);;
```

### Informal statement
The complex number 1/2 is an algebraic number.

### Informal sketch
The proof demonstrates that `Cx(&1 / &2)` is an algebraic number by exhibiting a polynomial with coefficients in the ring of complex integers (`ZinC_ring`) that has `Cx(&1 / &2)` as a root.

- The proof starts by unfolding the definition of `algebraic_number`.
- A suitable polynomial `p` is chosen as `poly_sub ZinC_ring (const_x_pow ZinC_ring (Cx(&2)) 1) (x_pow ZinC_ring 0)`, equivalent to `2x - 1`.
- It is shown that the coefficients of the polynomial lie in complex integers, and that the leading coefficient is nonzero (non-triviality). This is a consequence of `coeff 0 (poly_sub ZinC_ring (const_x_pow ZinC_ring (Cx(&2)) 1) (x_pow ZinC_ring 0)) = ring_neg ZinC_ring (ring_1 ZinC_ring)`.
- It is then shown that `p(Cx(&1 / &2)) = 0`.
- The evaluation `poly_eval complex_ring p (Cx(&1 / &2))` is simplified using polynomial arithmetic rules to `Cx(&0)`, where `p` is `poly_sub complex_ring (const_x_pow complex_ring (Cx(&2)) 1) (x_pow complex_ring 0)`.
- The final step consists in invoking `CONV_TAC COMPLEX_FIELD`, which simplifies this to zero by utilizing field operations in complex numbers.

### Mathematical insight
The theorem demonstrates a concrete instance of an algebraic number, showcasing that simple rational numbers in their complex form, such as 1/2, satisfy the definition of algebraic numbers. This serves as a basic example and provides intuition for more complex algebraic number proofs.

### Dependencies
- `algebraic_number`
- `ZinC_ring_clauses`
- `coeff_poly_sub`
- `coeff_const_x_pow`
- `coeff_x_pow`
- `complex_ring_clauses`

### Porting notes (optional)
- The tactic `CONV_TAC COMPLEX_FIELD` performs field arithmetic simplification; this may need to be reproduced using field tactic or lemmas in other proof assistants.
- The `subring_*` lemmas are used to transfer properties between `ZinC_ring` and `complex_ring`. These dependency names may need to adjusted based on established theories in target system.


---

## algebraic_number_if_monic_vanishing_at

### Name of formal statement
algebraic_number_if_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_if_monic_vanishing_at = prove(`
  !S (c:X->complex) s.
  FINITE S ==>
  ring_polynomial ZinC_ring (monic_vanishing_at complex_ring S c) ==>
  s IN S ==>
  algebraic_number (c s)
`,
  rw[algebraic_number] THEN
  intro THEN
  witness `monic_vanishing_at complex_ring S (c:X->complex)` THEN
  intro THENL [
    qed[]
  ;
    have `!s:X. s IN S ==> c s IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `monic complex_ring (monic_vanishing_at complex_ring (S:X->bool) c)` [monic_vanishing_at_monic] THEN
    have `monic complex_ring (poly_0 ZinC_ring)` [] THEN
    have `monic complex_ring (poly_0 complex_ring)` [poly_0_ZinC_eq_poly_0_complex] THEN
    have `ring_1 complex_ring = ring_0 complex_ring` [monic_poly_0] THEN
    qed[field_complex;field]
  ;
    have `!s:X. s IN S ==> c s IN ring_carrier complex_ring` [in_complex_ring] THEN
    simp[eval_monic_vanishing_at_refl] THEN
    rw[complex_ring_clauses]
  ]
);;
```
### Informal statement
For all sets `S` and functions `c` from `X` to the complex numbers, if `S` is finite, and the ring polynomial `monic_vanishing_at complex_ring S c` over `ZinC_ring` is a ring polynomial, then for all `s` in `S`, `c s` is an algebraic number.

### Informal sketch
The proof proceeds as follows:

- Unfold the definition of `algebraic_number`.
- Introduce the set `S` and function `c`.
- Assume that `S` is finite and that `monic_vanishing_at complex_ring S c` is a ring polynomial over `ZinC_ring`.
- Introduce `s` such that `s` is in `S`.
- Show that `c s` is an algebraic number by exhibiting the polynomial `monic_vanishing_at complex_ring S (c:X->complex)`:
  - The conditions to check are:
    - `monic_vanishing_at complex_ring S (c:X->complex)` is not zero. This is shown by proving `monic complex_ring (monic_vanishing_at complex_ring (S:X->bool) c)` which is shown because it is a monic vanishing at with specific conditions.
    - `monic_vanishing_at complex_ring S (c:X->complex)` evaluated at `c s` is zero. This follows from the definition of `monic_vanishing_at` and the assumption that `s IN S`.

### Mathematical insight
This theorem establishes that if we have a finite set `S` and a function `c` mapping elements of `S` to complex numbers, and if the polynomial `monic_vanishing_at` (specifically constructed to vanish on the images of `S` under `c`) is a ring polynomial (i.e. suitable for algebraic number theory), then the images of elements of `S` under `c` are algebraic numbers. In other words, the roots of the polynomial `monic_vanishing_at` are algebraic numbers.

### Dependencies
- `algebraic_number`
- `monic_vanishing_at`
- `ZinC_ring`
- `complex_ring`
- `FINITE`
- `field_complex`
- `field`
- `in_complex_ring`
- `monic_vanishing_at_monic`
- `monic_poly_0`
- `poly_0_ZinC_eq_poly_0_complex`
- `eval_monic_vanishing_at_refl`
- `complex_ring_clauses`


---

## algebraic_number_root_QinC_poly

### Name of formal statement
algebraic_number_root_QinC_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_root_QinC_poly = prove(`
  !z:complex.
  algebraic_number z
  <=> ?p. (ring_polynomial QinC_ring p
           /\ ~(p = poly_0 QinC_ring)
           /\ poly_eval complex_ring p z = Cx(&0)
          )
`,
  rw[algebraic_number] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    witness `p:(1->num)->complex` THEN
    qed[poly_QinC_if_poly_ZinC;poly_0_ZinC_eq_poly_0_QinC]
  ;
    intro THEN
    choose `e:num` `~(e = 0) /\ ring_polynomial ZinC_ring (poly_mul QinC_ring (poly_const QinC_ring (Cx (&e))) (p:(1->num)->complex))` [x_poly_QinC_is_ZinC_denominator_v2] THEN
    witness `poly_mul QinC_ring (poly_const QinC_ring (Cx (&e))) (p:(1->num)->complex)` THEN
    rw[poly_0_ZinC_eq_poly_0_QinC] THEN
    intro THENL [
      simp[]
    ;
      have `Cx(&e) IN QinC` [num_in_QinC] THEN
      have `ring_polynomial QinC_ring (poly_const QinC_ring (Cx(&e)):(1->num)->complex)` [poly_const_QinC] THEN
      have `(poly_const QinC_ring (Cx(&e)):(1->num)->complex) = poly_0 QinC_ring` [x_poly_mul_in_QinC_eq_0] THEN
      have `Cx(&e) = ring_0 QinC_ring` [poly_0;POLY_CONST_EQ] THEN
      have `Cx(&e) = Cx(&0)` [QinC_ring_clauses] THEN
      have `&e = &0:real` [CX_INJ] THEN
      qed[REAL_OF_NUM_EQ]
    ;
      have `Cx(&e) IN QinC` [num_in_QinC] THEN
      have `ring_polynomial QinC_ring (poly_const QinC_ring (Cx(&e)):(1->num)->complex)` [poly_const_QinC] THEN
      have `ring_powerseries QinC_ring (poly_const QinC_ring (Cx(&e)):(1->num)->complex)` [ring_polynomial] THEN
      have `ring_powerseries QinC_ring (p:(1->num)->complex)` [ring_polynomial] THEN
      simp[poly_mul_QinC_poly_mul_complex] THEN
      have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
      have `ring_polynomial complex_ring (poly_const QinC_ring (Cx(&e)):(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
      have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
      simp[POLY_EVAL_MUL;complex_ring_clauses] THEN
      qed[COMPLEX_MUL_RZERO;POLY_EVAL]
    ]
  ]
);;
```
### Informal statement
For all complex numbers `z`, `z` is an algebraic number if and only if there exists a polynomial `p` with coefficients in the field of complex rational numbers such that `p` is not the zero polynomial and the evaluation of `p` at `z` is equal to the complex number 0.

### Informal sketch
The proof demonstrates the equivalence between the definition of an algebraic number (`algebraic_number`) and the existence of a non-zero polynomial with complex rational coefficients that has the algebraic number as a root.

*   The proof starts by rewriting the definition of `algebraic_number`.
*   The implication from `algebraic_number z` to the existence of a polynomial `p` is shown by witnessing a suitable `p` leveraging the theorem `poly_QinC_if_poly_ZinC` which likely means that if a polynomial with complex integer coefficients is given, a polynomial with complex rational coefficients can be produced which has the same roots. The fact that constants can be converted from the integers to rationals is likely handled by `poly_0_ZinC_eq_poly_0_QinC`.
*   The reverse implication, from the existence of such a `p` to `algebraic_number z`, is proven by choosing a non-zero denominator `e`. It appears that `x_poly_QinC_is_ZinC_denominator_v2` is used to obtain this `e`. Then the polynomial `p` is multiplied by `Cx(&e)` where `Cx` converts a real to a complex number. Several facts about polynomials are proved (`num_in_QinC`, `poly_const_QinC`, `x_poly_mul_in_QinC_eq_0`, `poly_0`, `POLY_CONST_EQ`, `QinC_ring_clauses`, `CX_INJ`, `REAL_OF_NUM_EQ`). It is shown that `poly_mul QinC_ring (poly_const QinC_ring (Cx (&e))) (p:(1->num)->complex)` is a polynomial with integer coefficients, which means that `z` must be algebraic.

### Mathematical insight
This theorem provides an alternative characterization of algebraic numbers, defining them as roots of non-zero polynomials with coefficients in the field of complex rational numbers. This equivalence is fundamental in algebraic number theory.

### Dependencies
*   `algebraic_number`
*   `poly_QinC_if_poly_ZinC`
*   `poly_0_ZinC_eq_poly_0_QinC`
*   `x_poly_QinC_is_ZinC_denominator_v2`
*   `num_in_QinC`
*   `poly_const_QinC`
*   `x_poly_mul_in_QinC_eq_0`
*   `poly_0`
*   `POLY_CONST_EQ`
*   `QinC_ring_clauses`
*   `CX_INJ`
*   `REAL_OF_NUM_EQ`
*   `in_complex_ring`
*   `poly_complex_if_poly_QinC`
*   `POLY_EVAL_MUL`
*   `complex_ring_clauses`
*   `COMPLEX_MUL_RZERO`
*   `POLY_EVAL`

### Porting notes (optional)
*   The most challenging aspect of porting is likely the handling of polynomials, especially the details of complex rational coefficients (`QinC`). Check how the target proof assistant represents polynomials and coefficient rings.
*   The use of tactics like `splitiff` and witnesses might require adaptation depending on the automation available in the target system.
*   The proof relies on properties of the rings `ZinC_ring` and `QinC_ring`. Ensure that the target system has equivalent structures and theorems.


---

## algebraic_number_if_monic_vanishing_at_QinC

### Name of formal statement
algebraic_number_if_monic_vanishing_at_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_if_monic_vanishing_at_QinC = prove(`
  !S (c:X->complex) s.
  FINITE S ==>
  ring_polynomial QinC_ring (monic_vanishing_at complex_ring S c) ==>
  s IN S ==>
  algebraic_number (c s)
`,
  rw[algebraic_number_root_QinC_poly] THEN
  intro THEN
  witness `monic_vanishing_at complex_ring S (c:X->complex)` THEN
  intro THENL [
    qed[]
  ;
    have `!s:X. s IN S ==> c s IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `monic complex_ring (monic_vanishing_at complex_ring (S:X->bool) c)` [monic_vanishing_at_monic] THEN
    have `monic complex_ring (poly_0 QinC_ring)` [] THEN
    have `monic complex_ring (poly_0 complex_ring)` [poly_0_QinC_eq_poly_0_complex] THEN
    have `ring_1 complex_ring = ring_0 complex_ring` [monic_poly_0] THEN
    qed[field_complex;field]
  ;
    have `!s:X. s IN S ==> c s IN ring_carrier complex_ring` [in_complex_ring] THEN
    simp[eval_monic_vanishing_at_refl] THEN
    rw[complex_ring_clauses]
  ]
);;
```
### Informal statement
For all sets `S` and functions `c` from a type `X` to the complex numbers, if `S` is finite and the polynomial `monic_vanishing_at complex_ring S c` is a polynomial in `QinC_ring`, then for all `s` in `S`, `c s` is an algebraic number.

### Informal sketch
The proof proceeds as follows:
- Apply `algebraic_number_root_QinC_poly`, which states that roots of polynomials in `QinC_ring` are algebraic numbers.
- Introduce the assumptions using `intro`.
- Provide a witness `monic_vanishing_at complex_ring S (c:X->complex)`.
- The proof splits into two subgoals:
  - The first subgoal requires showing that the polynomial `monic_vanishing_at complex_ring S c` is not `poly_0`. To establish this, we first obtain `in_complex_ring` to show that elements in `S` map to values in `ring_carrier complex_ring`. Then demonstrate that `monic complex_ring (monic_vanishing_at complex_ring S c)` is monic, leverage the fact that `monic complex_ring (poly_0 QinC_ring)` and employ `poly_0_QinC_eq_poly_0_complex`. We show that `ring_1 complex_ring = ring_0 complex_ring` using `monic_poly_0`, leading to a contradiction using `field_complex` and `field`.
  - The second subgoal requires showing that if `s IN S` then evaluating `monic_vanishing_at complex_ring S c` at `c s` equals 0. We first obtain `in_complex_ring` again. Then, the proposition reduces using `eval_monic_vanishing_at_refl`, and is solved using the clauses in `complex_ring_clauses`.

### Mathematical insight
This theorem states that if a complex number is an element of a finite set `S`, and the polynomial that vanishes on `S` (i.e., has `S` as its roots) with leading coefficient 1 is representable within the `QinC` ring, then the complex number is an algebraic number. The significance lies in connecting the concept of finding roots of polynomials in the `QinC` ring with the notion of algebraic numbers, which are complex numbers satisfying polynomial equations with rational coefficients. In other words, any complex number that is a root of a monic polynomial over the ring QinC is an algebraic number.

### Dependencies
- `algebraic_number_root_QinC_poly`
- `complex_ring_clauses`
- `field_complex`
- `field`
- `poly_0_QinC_eq_poly_0_complex`
- `monic_poly_0`
- `eval_monic_vanishing_at_refl`

### Porting notes (optional)
When porting to other proof assistants, special attention might be needed to the handling of ring and field structures including the `QinC` ring and the associated polynomial rings. Ensure the target system has appropriate libraries for complex numbers, polynomials, and algebraic numbers, and that notions like "monic polynomial" and "evaluation" are clearly defined and match the HOL Light semantics. Specifically, ensure the target system can express the notion of `monic_vanishing_at` and reason about its properties.


---

## algebraic_number_if_root_irreducible_QinC_poly

### Name of formal statement
algebraic_number_if_root_irreducible_QinC_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_if_root_irreducible_QinC_poly = prove(`
  !z:complex.
  (?p. (ring_polynomial QinC_ring p
        /\ ring_irreducible(x_poly QinC_ring) p
        /\ poly_eval complex_ring p z = Cx(&0)
       )
  ) ==> algebraic_number z
`,
  rw[algebraic_number_root_QinC_poly] THEN
  intro THEN
  witness `p:(1->num)->complex` THEN
  have `~(p = ring_0(x_poly QinC_ring))` [ring_irreducible] THEN
  qed[x_poly_use]
);;
```
### Informal statement
For all complex numbers `z`, if there exists a polynomial `p` with coefficients in the complex rational numbers (`QinC_ring`) such that `p` is irreducible in the ring of polynomials over `QinC_ring`, and `p(z) = 0`, then `z` is an algebraic number.

### Informal sketch
The proof proceeds as follows:
- Start by rewriting with `algebraic_number_root_QinC_poly`, reducing the goal to showing there exists some non-zero polynomial with coefficients in `QinC_ring` that evaluates to zero at `z`.
- Assume that there exists a ring polynomial `p` with coefficients in `QinC_ring` such that it is irreducible over `QinC_ring` and `p(z)` is zero.
- Witness polynomial `p`. This is already assumed in the hypothesis.
- We need to show that `p` is not the zero polynomial which we obtain `p = ring_0(x_poly QinC_ring)` from `ring_irreducible` assumption over `p`.
- Finally apply `x_poly_use` to finish the proof.

### Mathematical insight
This theorem provides a sufficient condition for a complex number to be algebraic. Specifically, if a complex number is a root of an irreducible polynomial with coefficients in the complex rational numbers, then it is algebraic. This connects the algebraic properties of numbers with the properties of polynomials. Knowing that one can find a suitable polynomial that verifies its algebraic nature.

### Dependencies
- Definitions:
  - `algebraic_number`
  - `ring_polynomial`
  - `ring_irreducible`
  - `x_poly`
  - `QinC_ring`
  - `poly_eval`
  - `complex_ring`
  - `Cx`
- Theorems:
  - `algebraic_number_root_QinC_poly`

### Porting notes (optional)
- Porting largely depends on the target system's library for polynomials and complex numbers. Particular attention should be given to how polynomial irreducibility is defined and verified.
- The handling of `ring_polynomial`, `ring_irreducible`, and `poly_eval` in the target system is crucial.
- Ensure the target system has a notion of algebraic numbers aligned with HOL Light.


---

## algebraic_number_is_root_irreducible_QinC_poly

### Name of formal statement
algebraic_number_is_root_irreducible_QinC_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_is_root_irreducible_QinC_poly = prove(`
  !z:complex.
  algebraic_number z
  ==> ?p. (ring_polynomial QinC_ring p
           /\ ~(p = poly_0 QinC_ring)
           /\ ring_irreducible(x_poly QinC_ring) p
           /\ poly_eval complex_ring p z = Cx(&0)
          )
`,
  rw[algebraic_number_root_QinC_poly] THEN
  intro THEN
  have `UFD(x_poly QinC_ring)` [UFD_x_poly_QinC] THEN
  have `p IN ring_carrier(x_poly QinC_ring)` [x_poly_use] THEN
  have `~(p = ring_0(x_poly QinC_ring))` [x_poly_use] THEN
  choose2 `n:num` `q:num->(1->num)->complex` `(!i. 1 <= i /\ i <= n ==> ring_prime(x_poly QinC_ring) (q i)) /\ ring_associates(x_poly QinC_ring) (ring_product(x_poly QinC_ring) (1..n) q) p` [UFD_EQ_PRIMEFACT] THEN
  def `qprod:(1->num)->complex` `(ring_product(x_poly QinC_ring) (1..n) q)` THEN
  have `ring_divides(x_poly QinC_ring) p qprod` [ring_associates] THEN
  choose `c:(1->num)->complex` `c IN ring_carrier(x_poly QinC_ring) /\ qprod = ring_mul(x_poly QinC_ring) p c` [ring_divides] THEN
  have `(qprod:(1->num)->complex) = poly_mul QinC_ring p c` [x_poly;POLY_RING_CLAUSES] THEN
  have `ring_powerseries QinC_ring (p:(1->num)->complex)` [ring_polynomial] THEN
  have `p IN ring_carrier(x_poly QinC_ring)` [ring_divides] THEN
  have `qprod IN ring_carrier(x_poly QinC_ring)` [RING_MUL] THEN
  have `ring_polynomial QinC_ring (qprod:(1->num)->complex)` [x_poly_use] THEN
  have `ring_powerseries QinC_ring (qprod:(1->num)->complex)` [ring_polynomial] THEN
  have `c IN ring_carrier(x_poly QinC_ring)` [ring_divides] THEN
  have `ring_polynomial QinC_ring (c:(1->num)->complex)` [x_poly_use] THEN
  have `ring_powerseries QinC_ring (c:(1->num)->complex)` [ring_polynomial] THEN
  have `(qprod:(1->num)->complex) = poly_mul complex_ring p c` [poly_mul_QinC_poly_mul_complex] THEN
  have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (c:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `poly_eval complex_ring qprod z = ring_mul complex_ring (poly_eval complex_ring p z) (poly_eval complex_ring c z)` [POLY_EVAL_MUL] THEN
  have `poly_eval complex_ring qprod z = ring_mul complex_ring (ring_0 complex_ring) (poly_eval complex_ring c z)` [complex_ring_clauses] THEN
  have `poly_eval complex_ring qprod z = ring_0 complex_ring` [RING_MUL_LZERO;POLY_EVAL] THEN
  have `poly_eval complex_ring qprod z = Cx(&0)` [complex_ring_clauses] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  have `!i. i IN 1..n ==> 1 <= i /\ i <= n` [IN_NUMSEG] THEN
  have `!i. i IN 1..n ==> q i IN ring_carrier(x_poly QinC_ring)` [ring_prime] THEN
  have `!i. i IN 1..n ==> ring_polynomial QinC_ring (q i:(1->num)->complex)` [x_poly_use] THEN
  have `!i. i IN 1..n ==> ring_polynomial complex_ring (q i:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `!i. i IN 1..n ==> ring_powerseries QinC_ring (q i:(1->num)->complex)` [ring_polynomial] THEN
  have `!i. i IN 1..n ==> ring_powerseries (subring_generated complex_ring QinC) (q i:(1->num)->complex)` [subring_complex_QinC] THEN
  specialize[`complex_ring`;`q:num->(1->num)->complex`;`z:complex`;`1..n`]eval_poly_product THEN
  have `qprod = poly_product QinC_ring (1..n) q` [poly_product_ring_product_x_poly] THEN
  specialize[`complex_ring`;`QinC`;`q:num->(1->num)->complex`;`1..n`]poly_product_subring THEN
  have `qprod = poly_product complex_ring (1..n) q` [subring_complex_QinC] THEN
  have `ring_product complex_ring (1..n) (\i. poly_eval complex_ring (q i) z) = ring_0 complex_ring` [] THEN
  have `integral_domain complex_ring` [integral_domain_complex] THEN
  specialize[`complex_ring`;`1..n`;`\i. poly_eval complex_ring (q(i:num)) z`]INTEGRAL_DOMAIN_PRODUCT_EQ_0 THEN
  choose `i:num` `i IN 1..n /\ poly_eval complex_ring (q i) z = ring_0 complex_ring` [] THEN
  witness `q(i:num):(1->num)->complex` THEN
  have `integral_domain(x_poly QinC_ring)` [integral_domain_x_poly_QinC] THEN
  have `ring_irreducible(x_poly QinC_ring) (q(i:num))` [INTEGRAL_DOMAIN_PRIME_IMP_IRREDUCIBLE] THEN
  have `(q(i:num)) IN ring_carrier(x_poly QinC_ring)` [ring_irreducible] THEN
  have `ring_polynomial(QinC_ring) (q(i:num):(1->num)->complex)` [x_poly_use] THEN
  have `~((q(i:num):(1->num)->complex) = ring_0(x_poly QinC_ring))` [ring_irreducible] THEN
  have `~((q(i:num):(1->num)->complex) = poly_0 QinC_ring)` [x_poly_use] THEN
  qed[]
);;
```

### Informal statement
For all complex numbers `z`, if `z` is an algebraic number, then there exists a polynomial `p` over the ring `QinC_ring` (polynomials with coefficients in the field of complex rationals) such that `p` is not the zero polynomial, `p` is irreducible in the ring `x_poly QinC_ring` (polynomials over `QinC_ring`), and `p(z) = 0` where `p(z)` is the evaluation of `p` at `z` in the complex ring.

### Informal sketch
The proof proceeds as follows:
- Start with the definition `algebraic_number_root_QinC_poly` which states that if a complex number is algebraic then there exists a non-zero polynomial `p` in `QinC_ring` such that `p(z) = 0`.
- State that `x_poly QinC_ring` is a unique factorization domain (`UFD(x_poly QinC_ring)`).
- Obtain the prime factorization of `p` in `x_poly QinC_ring`. This gives `p = c * q_1 * ... * q_n` (up to associates), where each `q_i` is a prime polynomial in `x_poly QinC_ring` and `c` is a unit.
- The polynomial `qprod` denotes `q_1 * ... * q_n`, the product of the prime factors.
- Since `p(z) = 0`, it follows that `qprod(z) = 0`. Therefore the product `q_1(z) * ... * q_n(z) = 0` and since the complex numbers are an integral domain, that means that at least one of `q_i(z)` must be `0`.
- Choose one such `q_i` and show that it satisfies the desired properties: it is a polynomial in `QinC_ring`, it is irreducible, and it evaluates to `0` at `z`.

### Mathematical insight
This theorem states that every algebraic number is a root of an irreducible polynomial with coefficients in the field of complex rationals. This is a standard result in field theory and is crucial for characterizing algebraic numbers and their minimal polynomials. The theorem relies on the unique factorization of polynomials over a field.

### Dependencies
- `algebraic_number_root_QinC_poly`
- `UFD_x_poly_QinC`
- `integral_domain_x_poly_QinC`
- `integral_domain_complex`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `INTEGRAL_DOMAIN_PRIME_IMP_IRREDUCIBLE`
- `FINITE_NUMSEG`
- `IN_NUMSEG`
- `poly_product_ring_product_x_poly`
- `subring_complex_QinC`

### Porting notes (optional)
- The proof uses the `UFD` property of polynomial rings. This might require a suitable `UFD` library to be available in the target proof assistant.
- The tactic `choose2` is used to introduce multiple variables at once, based on existence. This might have to be achieved by multiple applications of the `choose` tactic in other systems.


---

## algebraic_number_root_irreducible_QinC_poly

### Name of formal statement
algebraic_number_root_irreducible_QinC_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_root_irreducible_QinC_poly = prove(`
  !z:complex.
  algebraic_number z
  <=> ?p. (ring_polynomial QinC_ring p
           /\ ~(p = poly_0 QinC_ring)
           /\ ring_irreducible(x_poly QinC_ring) p
           /\ poly_eval complex_ring p z = Cx(&0)
          )
`,
  qed[
    algebraic_number_if_root_irreducible_QinC_poly;
    algebraic_number_is_root_irreducible_QinC_poly
  ]
);;
```
### Informal statement
For all complex numbers `z`, `z` is an algebraic number if and only if there exists a polynomial `p` over the ring `QinC_ring` such that `p` is not equal to the zero polynomial, `p` is irreducible in the ring `QinC_ring`extended with a variable `x`, and the evaluation of `p` at `z` in the complex ring is equal to the complex number 0.

### Informal sketch
The theorem states the equivalence between a complex number being algebraic and being a root of an irreducible polynomial over the ring `QinC_ring`, meaning polynomials with rational coefficients.

*   The forward direction (algebraic number implies root of irreducible polynomial) is proved by `algebraic_number_is_root_irreducible_QinC_poly`. It likely constructs the minimal polynomial of the algebraic number and shows that it is irreducible.
*   The reverse direction (root of irreducible polynomial implies algebraic number) is proved by `algebraic_number_if_root_irreducible_QinC_poly`. This direction likely uses the property that if a complex number is the root of a polynomial, then it's algebraic; the irreducibility condition could guarantee the polynomial coefficients are rational, fitting the `QinC_ring`.

### Mathematical insight
This theorem provides a characterization of algebraic numbers in terms of irreducible polynomials with rational coefficients. It formalizes the fundamental concept that algebraic numbers are precisely those numbers that are roots of non-zero polynomials with rational coefficients, with a stronger condition on the polynomial: that it should be irreducible. This provides a canonical representation since there is only one irreducible polynomial that generates the algebraic number.

### Dependencies
*   `algebraic_number_if_root_irreducible_QinC_poly`
*   `algebraic_number_is_root_irreducible_QinC_poly`


---

## algebraic_number_is_root_monic_irreducible_QinC_poly

### Name of formal statement
algebraic_number_is_root_monic_irreducible_QinC_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_is_root_monic_irreducible_QinC_poly = prove(`
  !z:complex.
  algebraic_number z
  ==> ?p. (ring_polynomial QinC_ring p
           /\ ~(p = poly_0 QinC_ring)
           /\ monic QinC_ring p
           /\ ring_irreducible(x_poly QinC_ring) p
           /\ poly_eval complex_ring p z = Cx(&0)
          )
`,
  rw[algebraic_number_root_irreducible_QinC_poly] THEN
  intro THEN
  have `field QinC_ring` [field_QinC] THEN
  choose `q:(1->num)->complex` `ring_polynomial QinC_ring q /\ monic QinC_ring (q:(1->num)->complex) /\ ring_associates(x_poly QinC_ring) p q` [x_poly_field_monic_associate] THEN
  witness `q:(1->num)->complex` THEN
  have `~((q:(1->num)->complex) = poly_0 QinC_ring)` [monic_poly_0;field] THEN
  have `integral_domain(x_poly QinC_ring)` [integral_domain_x_poly_QinC] THEN
  have `ring_irreducible (x_poly QinC_ring) q` [RING_ASSOCIATES_IRREDUCIBLE] THEN
  choose `w:(1->num)->complex` `w IN ring_carrier(x_poly QinC_ring) /\ q = ring_mul(x_poly QinC_ring) p w` [ring_associates;ring_divides] THEN
  have `(q:(1->num)->complex) = poly_mul QinC_ring p w` [x_poly_use] THEN
  have `ring_polynomial QinC_ring (w:(1->num)->complex)` [x_poly_use] THEN
  have `(q:(1->num)->complex) = poly_mul complex_ring p w` [poly_mul_subring;subring_complex_QinC;ring_polynomial] THEN
  have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (w:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  specialize[`complex_ring`;`p:(1->num)->complex`;`w:(1->num)->complex`;`z:complex`]POLY_EVAL_MUL THEN
  qed[COMPLEX_MUL_LZERO;complex_ring_clauses]
);;
```

### Informal statement
For all complex numbers `z`, if `z` is an algebraic number, then there exists a polynomial `p` with coefficients in the quotient field of integers in the complex numbers (`QinC_ring`) such that: `p` is not the zero polynomial, `p` is monic, `p` is irreducible with respect to the polynomial ring with coefficients from the field of fractions of integers in the complex numbers, and `z` is a root of `p` (i.e., evaluating `p` at `z` yields 0).

### Informal sketch
The proof proceeds as follows:
- It starts by rewriting using `algebraic_number_root_irreducible_QinC_poly` and introducing the variable `z`.
- It then asserts that `QinC_ring` is a field.
- It chooses a polynomial `q` with coefficients in `QinC_ring` such that `q` is monic and `p` and `q` are associates. The existence of `q` is guaranteed by `x_poly_field_monic_associate`.
- It shows that `q` is not the zero polynomial, since it is monic.
- It shows that `x_poly QinC_ring` is an integral domain.
- It shows that `q` is irreducible by using the fact that associates of irreducible polynomials are irreducible.
- It chooses a `w` in the ring carrier of `x_poly QinC_ring` such that `q = p * w` using `ring_associates` and `ring_divides`.
- It proves `q = poly_mul QinC_ring p w` by applying `x_poly_use`.
- It states that `w` is a polynomial by applying `x_poly_use`.
- It converts the polynomial multiplication to `q = poly_mul complex_ring p w` using `poly_mul_subring`, `subring_complex_QinC` and `ring_polynomial`.
- It states that `z` is in the ring carrier of `complex_ring`.
- It states that `p` and `w` are polynomials over the complex numbers, using `poly_complex_if_poly_QinC`.
- It specialize the theorem `POLY_EVAL_MUL` for the `complex_ring`,`p: (1 -> num) -> complex`, `w: (1 -> num) -> complex` and `z: complex`.
- Finally, the proof concludes, most likely by relying on the properties of zero multiplication.

### Mathematical insight
This theorem states that an algebraic number (a complex number that is a root of a non-zero polynomial with integer coefficients) is also a root of a monic irreducible polynomial with coefficients in the field of fractions of integers in the complex numbers. This is an important result in algebraic number theory because it characterizes algebraic numbers in terms of monic irreducible polynomials, which have unique factorization properties. The theorem bridges the gap between polynomials with integer coefficients and polynomials with coefficients in a field, which is crucial for studying algebraic number fields.

### Dependencies
- Theorems:
  - `algebraic_number_root_irreducible_QinC_poly`
  - `x_poly_field_monic_associate`
  - `monic_poly_0`
  - `integral_domain_x_poly_QinC`
  - `RING_ASSOCIATES_IRREDUCIBLE`
  - `POLY_EVAL_MUL`
- Definitions:
  - `ring_associates`
  - `ring_divides`
  - `x_poly_use`
  - `poly_mul_subring`
  - `subring_complex_QinC`
  - `poly_complex_if_poly_QinC`
  - `in_complex_ring`
- Other:
  - `field_QinC`
  - `COMPLEX_MUL_LZERO`
  - `complex_ring_clauses`

### Porting notes (optional)
- The theorem relies heavily on ring theory, polynomial algebra, and the specific representation of complex numbers and polynomials in HOL Light.
- When porting to other proof assistants, ensure that the corresponding definitions of rings, fields, polynomials, irreducibility, monic polynomials, and evaluation are compatible.
- The `ring_associates` and `ring_divides` relations are important and require careful translation.
- The tactic `choose` to introduce witnesses in the form `q:(1->num)->complex` and `w:(1->num)->complex` should be translated to the corresponding mechanism (e.g., `exists` introduction followed by assignment via `let` or `destruct`).


---

## coprimes_sharing_root

### Name of formal statement
coprimes_sharing_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coprimes_sharing_root = prove(`
  !(r:R ring) s G p q z.
  s = subring_generated r G ==>
  field s ==>
  ring_polynomial s p ==>
  ring_polynomial s q ==>
  ~(p = poly_0 s) ==>
  ~(q = poly_0 s) ==>
  ring_irreducible(x_poly s) p ==>
  ring_irreducible(x_poly s) q ==>
  z IN ring_carrier r ==>
  poly_eval r p z = ring_0 r ==>
  poly_eval r q z = ring_0 r ==>
  ring_associates(x_poly s) p q
`,
  intro THEN
  def `g:(1->num)->R` `ring_gcd(x_poly(s:R ring)) (p,q)` THEN
  case `ring_unit(x_poly(s:R ring)) g` THENL [
    have `g IN ring_carrier(x_poly(s:R ring))` [RING_GCD] THEN
    choose `ginv:(1->num)->R` `ginv IN ring_carrier(x_poly(s:R ring)) /\ ring_mul(x_poly s) g ginv = ring_1(x_poly s)` [ring_unit] THEN
    have `ring_polynomial(s:R ring) (ginv:(1->num)->R)` [x_poly_use] THEN
    have `ring_polynomial(s:R ring) (g:(1->num)->R)` [x_poly_use] THEN
    specialize[`s:R ring`;`p:(1->num)->R`;`q:(1->num)->R`]gcd_poly_linear_combination THEN
    choose2 `u:(1->num)->R` `v:(1->num)->R` `ring_polynomial s u /\ ring_polynomial s v /\ poly_add s (poly_mul s p u) (poly_mul s q v) = g:(1->num)->R` [] THEN
    have `ring_polynomial(s:R ring) (poly_mul s (p:(1->num)->R) (u:(1->num)->R))` [RING_POLYNOMIAL_MUL] THEN
    have `ring_polynomial(s:R ring) (poly_mul s (q:(1->num)->R) (v:(1->num)->R))` [RING_POLYNOMIAL_MUL] THEN
    have `ring_polynomial(r:R ring) (g:(1->num)->R)` [ring_polynomial_if_subring] THEN
    have `ring_polynomial(r:R ring) (ginv:(1->num)->R)` [ring_polynomial_if_subring] THEN
    have `ring_polynomial(r:R ring) (p:(1->num)->R)` [ring_polynomial_if_subring] THEN
    have `ring_polynomial(r:R ring) (q:(1->num)->R)` [ring_polynomial_if_subring] THEN
    have `ring_polynomial(r:R ring) (u:(1->num)->R)` [ring_polynomial_if_subring] THEN
    have `ring_polynomial(r:R ring) (v:(1->num)->R)` [ring_polynomial_if_subring] THEN
    have `poly_mul(s:R ring) g ginv:(1->num)->R = poly_1 s` [x_poly_use] THEN
    have `poly_mul(r:R ring) g ginv:(1->num)->R = poly_1 r` [poly_mul_subring;ring_polynomial;poly_1_subring] THEN
    specialize[`r:R ring`;`g:(1->num)->R`;`ginv:(1->num)->R`;`z:R`]POLY_EVAL_MUL THEN
    specialize[`r:R ring`;`p:(1->num)->R`;`u:(1->num)->R`;`z:R`]POLY_EVAL_MUL THEN
    specialize[`r:R ring`;`q:(1->num)->R`;`v:(1->num)->R`;`z:R`]POLY_EVAL_MUL THEN
    have `ring_mul(r:R ring) (poly_eval r g z) (poly_eval r ginv z) = ring_1 r` [POLY_EVAL_1] THEN
    have `poly_eval(r:R ring) (poly_mul r p u) z = ring_0 r` [RING_MUL_LZERO;POLY_EVAL] THEN
    have `poly_eval(r:R ring) (poly_mul r q v) z = ring_0 r` [RING_MUL_LZERO;POLY_EVAL] THEN
    have `poly_mul(r:R ring) p u:(1->num)->R = poly_mul s p u` [poly_mul_subring;ring_polynomial] THEN
    have `poly_mul(r:R ring) q v:(1->num)->R = poly_mul s q v` [poly_mul_subring;ring_polynomial] THEN
    have `ring_polynomial(r:R ring) (poly_mul r (p:(1->num)->R) (u:(1->num)->R))` [ring_polynomial_if_subring] THEN
    have `ring_polynomial(r:R ring) (poly_mul r (q:(1->num)->R) (v:(1->num)->R))` [ring_polynomial_if_subring] THEN
    have `poly_add(r:R ring) (poly_mul r p u) (poly_mul r q v:(1->num)->R) = poly_add s (poly_mul s p u) (poly_mul s q v)` [poly_add_subring;ring_polynomial] THEN
    have `poly_add(r:R ring) (poly_mul r p u) (poly_mul r q v:(1->num)->R) = g` [] THEN
    specialize[`r:R ring`;`poly_mul r (p:(1->num)->R) (u:(1->num)->R)`;`poly_mul r (q:(1->num)->R) (v:(1->num)->R)`;`z:R`]POLY_EVAL_ADD THEN
    have `poly_eval(r:R ring) g z = ring_add r (ring_0 r) (ring_0 r)` [] THEN
    have `poly_eval(r:R ring) g z = ring_0 r` [RING_ADD_LZERO;RING_0] THEN
    have `poly_eval(r:R ring) (poly_1 r) z = ring_mul r (ring_0 r) (poly_eval r ginv z)` [] THEN
    have `ring_1(r:R ring) = ring_0 r` [POLY_EVAL_1;RING_MUL_LZERO;POLY_EVAL] THEN
    have `ring_1(s:R ring) = ring_0 s` [SUBRING_GENERATED] THEN
    qed[field]
  ; pass
  ] THEN
  have `ring_divides(x_poly s) (g:(1->num)->R) p` [RING_GCD_DIVIDES;x_poly_use] THEN
  have `ring_divides(x_poly s) (g:(1->num)->R) q` [RING_GCD_DIVIDES;x_poly_use] THEN
  have `ring_associates(x_poly s) (g:(1->num)->R) p` [RING_NONUNIT_DIVIDES_IRREDUCIBLE] THEN
  have `ring_associates(x_poly s) (g:(1->num)->R) q` [RING_NONUNIT_DIVIDES_IRREDUCIBLE] THEN
  qed[RING_ASSOCIATES_SYM;RING_ASSOCIATES_TRANS]
);;
```

### Informal statement
Let `r` be a ring, `s` be a subring of `r` generated by the set `G`, `p` and `q` be polynomials over `s` that are not zero, and irreducible over `s[x]`.
Also, let `z` be an element of `r` such that `p(z) = 0` and `q(z) = 0`. Then polynomials `p` and `q` are associates in `s[x]`.

### Informal sketch
The proof establishes that two irreducible polynomials `p` and `q` over a subring `s` of a ring `r` sharing a root `z` in `r` must be associates. The proof proceeds by contradiction:

- Assume `p` and `q` are not associates.
- Define `g` as the greatest common divisor (GCD) of `p` and `q` in the ring of polynomials `s[x]` using the `ring_gcd` function.
- Case split on whether the GCD `g` is a unit in `s[x]`.
  - If `g` is a unit, then there exists a `ginv` such that `g * ginv = 1`.
    - By `gcd_poly_linear_combination`, find polynomials `u` and `v` in `s[x]` such that `p * u + q * v = g`.
    - Evaluate the polynomials `p(z)`, `q(z)`, `g(z)`, `u(z)`, `v(z)` at `z` and use the fact that `p(z) = 0` and `q(z) = 0` to conclude that `g(z) = 0`.
    - Also since `g` is a unit, `g * ginv = 1`, so `g(z) * ginv(z) = 1`, therefore `1 = 0`, contradicting the premise that `s` is a field.
  - If `g` is not a unit, then `g` divides both `p` and `q`, and because `p` and `q` are irreducible, it implies that `g` is associate to both `p` and `q`. Consequently, `p` and `q` are associates, which contradicts the assumption.
- Therefore `p` and `q` must be associates.

### Mathematical insight
The theorem demonstrates a fundamental property of irreducible polynomials. If two irreducible polynomials share a root, they must be associates. This is important in algebraic number theory and field theory. The condition that `s` is a field and a subring generated by set `G` is crucial to ensure that the greatest common divisor exists and has the required properties.

### Dependencies
- `ring_gcd`
- `gcd_poly_linear_combination`
- `RING_POLYNOMIAL_MUL`
- `POLY_EVAL_MUL`
- `RING_MUL_LZERO`
- `POLY_EVAL_ADD`
- `RING_ADD_LZERO`
- `RING_0`
- `POLY_EVAL_1`
- `RING_ASSOCIATES_SYM`
- `RING_ASSOCIATES_TRANS`
- `RING_GCD_DIVIDES`
- `RING_NONUNIT_DIVIDES_IRREDUCIBLE`
- `poly_add_subring`
- `poly_mul_subring`
- `ring_polynomial_if_subring`
- `poly_1_subring`
- `SUBRING_GENERATED`
- `RING_MUL_LZERO`
### Porting notes (optional)
- The proof relies on properties of GCDs in rings, which may need to be explicitly defined or imported in other proof assistants.
- The `x_poly` constructor may have an equivalent representation that needs to be used instead.
- The `field s` statement will likely need to map to an equivalent typeclass or property stating that `s` is a field.


---

## algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma

### Name of formal statement
algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma = prove(`
  !(z:complex) p q.
  ring_polynomial QinC_ring p
  /\ ring_polynomial QinC_ring q
  /\ ~(p = poly_0 QinC_ring)
  /\ ~(q = poly_0 QinC_ring)
  /\ ring_irreducible(x_poly QinC_ring) p
  /\ ring_irreducible(x_poly QinC_ring) q
  /\ poly_eval complex_ring p z = Cx(&0)
  /\ poly_eval complex_ring q z = Cx(&0)
  ==> ring_associates(x_poly QinC_ring) p q
`,
  intro THEN
  have `QinC_ring = subring_generated complex_ring QinC` [subring_complex_QinC] THEN
  have `field QinC_ring` [field_QinC] THEN
  have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `poly_eval complex_ring p z = ring_0 complex_ring` [complex_ring_clauses] THEN
  have `poly_eval complex_ring q z = ring_0 complex_ring` [complex_ring_clauses] THEN
  specialize[`complex_ring`;`QinC_ring`;`QinC`;`p:(1->num)->complex`;`q:(1->num)->complex`;`z:complex`]coprimes_sharing_root THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `z` and polynomials `p` and `q` over the ring `QinC_ring` (polynomials with coefficients in the subring of complex numbers generated by `QinC`), if `p` and `q` are non-zero, irreducible polynomials in `x_poly QinC_ring` (the polynomial ring over `QinC_ring` generated by `x`), and `z` is a root of both `p` and `q` when evaluated in the complex numbers, then `p` and `q` are associates in the polynomial ring over `QinC_ring`.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent: `z` is a complex number, `p` and `q` are polynomials over `QinC_ring`, `p` and `q` are non-zero, `p` and `q` are irreducible, and `z` is a root of both `p` and `q`.
- Show that `QinC_ring` is the subring generated by `QinC`.
- Show that `QinC_ring` is a field.
- Show that `z` is in the carrier of the complex ring.
- Show that evaluating polynomial `p` at `z` in complex ring equals to zero of complex ring.
- Show that evaluating polynomial `q` at `z` in complex ring equals to zero of complex ring.
- Apply the theorem `coprimes_sharing_root`, instantiating with `complex_ring`, `QinC_ring`, `QinC`, `p`, `q`, and `z`. This theorem implies that if two non-zero polynomials `p` and `q` with coefficients in a field share a common root `z` and are irreducible, then they must be associates.

### Mathematical insight
The lemma states that if two irreducible polynomials with coefficients in the field `QinC_ring` have a common root in the complex numbers, then they are associates. This is a strong result related to the uniqueness of minimal polynomials in field theory, and it's useful because it shows that if two irreducible polynomials share a root, they are essentially the same polynomial up to a constant factor.

### Dependencies
- `subring_complex_QinC`
- `field_QinC`
- `in_complex_ring`
- `complex_ring_clauses`
- `coprimes_sharing_root`


---

## algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple

### Name of formal statement
algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple = prove(`
  !(z:complex) p q.
  ring_polynomial QinC_ring p
  /\ ring_polynomial QinC_ring q
  /\ ~(p = poly_0 QinC_ring)
  /\ ~(q = poly_0 QinC_ring)
  /\ monic QinC_ring p
  /\ monic QinC_ring q
  /\ ring_irreducible(x_poly QinC_ring) p
  /\ ring_irreducible(x_poly QinC_ring) q
  /\ poly_eval complex_ring p z = Cx(&0)
  /\ poly_eval complex_ring q z = Cx(&0)
  ==> p = q
`,
  intro THEN
  have `ring_associates(x_poly QinC_ring) p q` [algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma] THEN
  qed[monic_associates;field_QinC]
);;
```
### Informal statement
For all complex numbers `z` and polynomials `p` and `q` over the ring of rationals extended with the imaginary unit (`QinC_ring`), if `p` and `q` are non-zero polynomials, monic polynomials, irreducible polynomials over `QinC_ring`, and `z` is a root of both `p` and `q` (i.e., evaluating `p` at `z` and `q` at `z` yields 0), then `p` and `q` are equal.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent conditions: `p` and `q` are polynomials over `QinC_ring`, both are non-zero and monic, both are irreducible, and `z` is a root of both `p` and `q`.
- Apply the lemma `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma` to show that `p` and `q` are associates (i.e., `ring_associates(x_poly QinC_ring) p q`).
- Since `p` and `q` are monic and associates, instantiate and use `monic_associates` to conclude that `p = q`.
- Field `field_QinC` is also used.

### Mathematical insight
The theorem states that if two monic irreducible polynomials over the field extension `QinC_ring` share a root in the complex numbers, then they must be the same polynomial. This is a standard uniqueness result in field theory, particularly in the context of minimal polynomials of algebraic numbers. The fact that `p` and `q` are monic is important to ensure uniqueness here.

### Dependencies
- Theorems: `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma`, `monic_associates`
- Definitions: `ring_polynomial`, `poly_0`, `monic`, `ring_irreducible`, `poly_eval`
- Constants: `Cx`, `x_poly`, `QinC_ring`, `complex_ring`
- Fields: `field_QinC`

### Porting notes (optional)
This theorem and its proof rely on algebraic concepts such as polynomial rings, irreducibility, and the notion of associates. Porting it to another proof assistant requires ensuring that these algebraic structures and their properties are defined appropriately within that system. The lemma `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_lemma` encapsulates much of the algebraic reasoning, so its counterpart in the target system needs careful consideration.


---

## algebraic_number_is_root_unique_monic_irreducible_QinC_poly

### Name of formal statement
algebraic_number_is_root_unique_monic_irreducible_QinC_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_is_root_unique_monic_irreducible_QinC_poly = prove(`
  !z:complex.
  algebraic_number z
  ==> ?!p. (ring_polynomial QinC_ring p
            /\ ~(p = poly_0 QinC_ring)
            /\ monic QinC_ring p
            /\ ring_irreducible(x_poly QinC_ring) p
            /\ poly_eval complex_ring p z = Cx(&0)
           )
`,
  qed[EXISTS_UNIQUE_THM;
    algebraic_number_is_root_monic_irreducible_QinC_poly;
    algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple
  ]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is an algebraic number, then there exists a unique polynomial `p` with coefficients in the ring `QinC_ring` (polynomials with rational complex coefficients) such that `p` is not the zero polynomial, `p` is monic with respect to the ring `QinC_ring`, `p` is irreducible in the ring of polynomials `x_poly QinC_ring` and evaluating `p` at `z` in the complex ring equals the complex number 0.

### Informal sketch
The proof demonstrates that every algebraic number is the root of a unique monic irreducible polynomial in `QinC_ring[X]`.

- The proof refers to the theorem `EXISTS_UNIQUE_THM` to show the existence of a unique such polynomial. This handles the general logic of proving unique existence.
- It reuses the theorem `algebraic_number_is_root_monic_irreducible_QinC_poly`, which presumably proves the existence of a monic irreducible polynomial.
- It utilizes `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple`, which presumably proves the uniqueness aspect once the existence of a monic irreducible polynomial has been established.

### Mathematical insight
This theorem establishes a fundamental connection between algebraic numbers and polynomials. It states that each algebraic number corresponds to exactly one monic irreducible polynomial with coefficients in `QinC_ring`, of which it is a root. This unique polynomial is often referred to as the minimal polynomial of the algebraic number. The importance of this theorem lies in its ability to characterize and distinguish algebraic numbers based on their minimal polynomials. It is a cornerstone for studying field extensions and algebraic number theory.

### Dependencies
- Theorem: `EXISTS_UNIQUE_THM`
- Theorem: `algebraic_number_is_root_monic_irreducible_QinC_poly`
- Theorem: `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple`


---

## algebraic_number_QinC_explicit

### Name of formal statement
algebraic_number_QinC_explicit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_QinC_explicit = prove(`
  !z.
  z IN QinC ==> (
    ring_polynomial QinC_ring (x_minus_const QinC_ring z) /\
    ~((x_minus_const QinC_ring z) = poly_0 QinC_ring) /\
    monic QinC_ring (x_minus_const QinC_ring z) /\
    ring_irreducible (x_poly QinC_ring) (x_minus_const QinC_ring z) /\
    poly_eval complex_ring (x_minus_const QinC_ring z) z = Cx(&0)
  )
`,
  intro_gendisch THEN
  have `z IN ring_carrier(QinC_ring)` [QinC_ring_clauses] THEN
  intro THENL [
    qed[x_minus_const_poly]
  ;
    have `coeff 1 (x_minus_const QinC_ring z) = ring_1 QinC_ring` [coeff_x_minus_const] THEN
    have `coeff 1 (poly_0 QinC_ring) = ring_0 QinC_ring` [coeff_poly_0] THEN
    have `ring_1 QinC_ring = Cx(&1)` [QinC_ring_clauses] THEN
    have `ring_0 QinC_ring = Cx(&0)` [QinC_ring_clauses] THEN
    have `Cx(&1) = Cx(&0)` [] THEN
    qed[CX_INJ;REAL_ARITH `~(&1 = &0:real)`]
  ;
    qed[monic_x_minus_const]
  ;
    qed[irred_x_minus_const;field_QinC]
  ;
    have `QinC subring_of complex_ring` [QinC_subring_complex] THEN
    have `z IN ring_carrier(QinC_ring)` [QinC_ring_clauses] THEN
    have `ring_powerseries(subring_generated complex_ring QinC) (x_minus_const QinC_ring z)` [x_minus_const_series;subring_complex_QinC] THEN
    specialize[`complex_ring`;`QinC`;`x_minus_const QinC_ring z`;`z:complex`]poly_eval_subring THEN
    simp[] THEN
    qed[eval_x_minus_const_refl;subring_complex_QinC;QinC_0;QinC_ring_clauses]
  ]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is in `QinC` (the algebraic closure of `Q` in `C`), then the following conditions hold:
1.  `x_minus_const QinC_ring z` (the polynomial `x - z` represented in the `QinC_ring`) is a polynomial in `QinC_ring`.
2.  `x_minus_const QinC_ring z` is not the zero polynomial in `QinC_ring`.
3.  `x_minus_const QinC_ring z` is monic in `QinC_ring`.
4.  `x_minus_const QinC_ring z` is irreducible in the polynomial ring `x_poly QinC_ring`.
5.  Evaluating the polynomial `x_minus_const QinC_ring z` at `z` in the complex number ring `complex_ring` results in `0`.

### Informal sketch
The proof proceeds by assuming that `z` is an element of `QinC` and then proving each of the five conditions separately.
- The first condition, that `x_minus_const QinC_ring z` is a polynomial in `QinC_ring`, is shown directly using `x_minus_const_poly`.
- The second condition, that `x_minus_const QinC_ring z` is not the zero polynomial, is proved by contradiction. We assume that `x_minus_const QinC_ring z` equals `poly_0 QinC_ring`. Then by considering the coefficients on x^1, the left hand side equals `ring_1 QinC_ring` and the right hand side is `ring_0 QinC_ring`. Then it can be shown that `Cx(&1) = Cx(&0)`, which is contradictory.
- The third condition, that `x_minus_const QinC_ring z` is monic, is shown using `monic_x_minus_const`.
- The fourth condition, that `x_minus_const QinC_ring z` is irreducible, is shown using `irred_x_minus_const` and `field_QinC`.
- The fifth condition, that `poly_eval complex_ring (x_minus_const QinC_ring z) z = Cx(&0)`, is shown by using the evaluation function `poly_eval_subring` and rewriting according to `eval_x_minus_const_refl`, `subring_complex_QinC`, `QinC_0`, `QinC_ring_clauses`.

### Mathematical insight
This theorem establishes that for any element `z` in `QinC` (the algebraic closure of rationals in complex numbers), the polynomial `x - z` (represented within the ring structure `QinC_ring`) is a monic, irreducible polynomial in `QinC_ring` which evaluates to zero when evaluated at `z`. This is a fundamental property used when working with algebraic numbers and their minimal polynomials. It underlines the relation between an algebraic number and its defining polynomial.

### Dependencies
- `QinC_ring_clauses`
- `x_minus_const_poly`
- `coeff_x_minus_const`
- `coeff_poly_0`
- `monic_x_minus_const`
- `irred_x_minus_const`
- `field_QinC`
- `QinC_subring_complex`
- `x_minus_const_series`
- `subring_complex_QinC`
- `poly_eval_subring`
- `eval_x_minus_const_refl`
- `QinC_0`
- `CX_INJ`

### Porting notes (optional)
- The major challenge will be setting up the correct ring and subring structures and adapting the reasoning about `complex_ring` and `QinC`.
- The tactic `REAL_ARITH` may require the most adaption, because it is an automatic tactic for solving inequalities which relies on some specific decision procedure implemented in HOL Light.


---

## algebraic_number_QinC

### Name of formal statement
algebraic_number_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_QinC = prove(`
  !z.
  z IN QinC ==> algebraic_number z
`,
  rw[algebraic_number_root_QinC_poly] THEN
  qed[algebraic_number_QinC_explicit]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is an element of `QinC` (the field of constructible complex numbers), then `z` is an algebraic number.

### Informal sketch
The proof proceeds by applying `algebraic_number_root_QinC_poly` and then using `qed[algebraic_number_QinC_explicit]`.

- The theorem `algebraic_number_root_QinC_poly` states that if a complex number `z` is a root of a polynomial with coefficients in the field of constructible reals `QinR`, then `z` is an algebraic number. We aim to prove `!z. z IN QinC ==> algebraic_number z`.
- The `algebraic_number_QinC` tactic uses the pre-proved result `algebraic_number_root_QinC_poly.` The usage of `qed[algebraic_number_QinC_explicit]` signifies that this theorem is considered obvious enough after the preceding steps that it can be automatically discharged.

### Mathematical insight
This theorem establishes that constructible complex numbers are a subset of algebraic numbers. In other words, any complex number that can be constructed using a compass and straightedge is the root of some polynomial with rational coefficients. This result connects geometric constructibility with algebraic properties. The use of `QinC` highlights the field of constructible complex numbers, emphasizing their algebraic closure.

### Dependencies
- Theorems:
  - `algebraic_number_root_QinC_poly`

### Porting notes (optional)
When porting this theorem, ensure the corresponding definitions of `QinC` (constructible complex numbers), `algebraic_number`, and the required polynomial representations are available. The main task is to ensure that `algebraic_number_root_QinC_poly` has been properly proven and is accessible during the proof of `algebraic_number_QinC`. The `qed` step may require the proof assistant's automation to be configured or extended to handle the trivial discharge after the application of `algebraic_number_root_QinC_poly`.


---

## minimal_polynomial

### Name of formal statement
`minimal_polynomial`

### Type of the formal statement
`new_definition`

### Formal Content
```ocaml
let minimal_polynomial = new_definition `
  minimal_polynomial (z:complex) =
  if algebraic_number z
  then (@p. (ring_polynomial QinC_ring p
             /\ ~(p = poly_0 QinC_ring)
             /\ monic QinC_ring p
             /\ ring_irreducible(x_poly QinC_ring) p
             /\ poly_eval complex_ring p z = Cx(&0)
            ))
  else poly_0 QinC_ring
`;;
```

### Informal statement
The `minimal_polynomial` of a complex number `z` is defined as follows: if `z` is an algebraic number, then it is the unique polynomial `p` such that `p` is a polynomial over the complex numbers with rational coefficients, `p` is not the zero polynomial, `p` is monic, `p` is irreducible in the ring of polynomials with rational coefficients, and `p` evaluated at `z` is equal to 0. If `z` is not an algebraic number, then the `minimal_polynomial` of `z` is the zero polynomial over the complex numbers with rational coefficients.

### Informal sketch
- The definition distinguishes between algebraic and transcendental numbers. If the input `z` is not an algebraic number (checked by `algebraic_number z`), then the minimal polynomial is defined to be the zero polynomial `poly_0 QinC_ring` in the polynomial ring with rational coefficients.

- If `z` is algebraic, the definition returns a polynomial `p` satisfying the following conditions:
    - `ring_polynomial QinC_ring p`: `p` is a polynomial with coefficients in the rational complex numbers.
    - `~(p = poly_0 QinC_ring)`: `p` is not the zero polynomial.
    - `monic QinC_ring p`: `p` is a monic polynomial i.e. its leading coefficient is 1.
    - `ring_irreducible(x_poly QinC_ring) p`: `p` is irreducible, meaning it cannot be factored into two non-constant polynomials with rational coefficients. `x_poly QinC_ring` specifies the polynomial ring `QinC_ring` for irreducibility.
    - `poly_eval complex_ring p z = Cx(&0)`: `p` evaluates to zero at `z`; where `poly_eval complex_ring p z` evaluates the polynomial `p` at the complex number `z` using the evaluation function for the complex ring, and `Cx(&0)` represents the complex number 0, converted from the real number 0.

- The definition uses Hilbert's choice operator `@` to select *a* polynomial satisfying the stated properties; the existence of such a polynomial is guaranteed for algebraic numbers. The polynomial is also unique based upon being irreducible and monic.

### Mathematical insight
The `minimal_polynomial` definition provides a way to associate a unique polynomial to each algebraic number.  The polynomial is the monic irreducible polynomial with rational coefficients that has the given algebraic number as a root. For transcendental numbers, it defaults to the zero polynomial. This definition is a foundational step on the path to further reasoning about algebraic numbers and their polynomial relationships.

### Dependencies
- Definitions:
    - `algebraic_number`
    - `ring_polynomial`
    - `poly_0`
    - `monic`
    - `ring_irreducible`
    - `x_poly`
    - `poly_eval`

### Porting notes (optional)
When porting to other proof assistants:
- Ensure that the concepts of "algebraic number," "monic polynomial," and "irreducible polynomial" are defined appropriately in the target system.
- The handling of rings and polynomial rings may vary across systems. Pay close attention to the ring structures assumed.
- The Hilbert choice operator `@` may need to be replaced by an equivalent construct that selects an element satisfying a given condition. Some systems might require proving the existence of such an element beforehand.


---

## algebraic_has_minimal_polynomial

### Name of formal statement
algebraic_has_minimal_polynomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_has_minimal_polynomial = prove(`
  !z:complex.
  algebraic_number z ==>
  ring_polynomial QinC_ring (minimal_polynomial z)
  /\ ~((minimal_polynomial z) = poly_0 QinC_ring)
  /\ monic QinC_ring (minimal_polynomial z)
  /\ ring_irreducible(x_poly QinC_ring) (minimal_polynomial z)
  /\ poly_eval complex_ring (minimal_polynomial z) z = Cx(&0)
`,
  qed[minimal_polynomial;algebraic_number_is_root_unique_monic_irreducible_QinC_poly]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is an algebraic number, then the `minimal_polynomial` of `z` is a polynomial in the ring of polynomials over complex numbers, and the `minimal_polynomial` of `z` is not the zero polynomial in the ring of polynomials over complex numbers, and the `minimal_polynomial` of `z` is monic in the ring of polynomials over complex numbers, and the `minimal_polynomial` of `z` is irreducible in the ring of polynomials over complex numbers, and evaluating the `minimal_polynomial` of `z` at `z` in the complex ring equals the complex number 0.

### Informal sketch
The proof demonstrates that if a complex number `z` is algebraic, its `minimal_polynomial` satisfies several key properties.

- First it shows that the `minimal_polynomial` is a polynomial over complex numbers through usage of `QinC_ring` a ring of polynomials over the complex numbers.
- It establishes that the `minimal_polynomial` is non-zero by definition.
- It proves that the polynomial is monic.
- It demonstrates that the polynomial is irreducible.
- Finally, it validates that evaluating this polynomial at `z` equals zero, meaning `z` is a root of the `minimal_polynomial`.
- The proof is dispatched by `qed[minimal_polynomial;algebraic_number_is_root_unique_monic_irreducible_QinC_poly]`.

### Mathematical insight
This theorem establishes that the `minimal_polynomial` of an algebraic number over the complex numbers is indeed a polynomial over the complex numbers, non-zero, monic, irreducible, and has the algebraic number as a root. It essentially confirms that the `minimal_polynomial`, as constructed, satisfies the necessary criteria to be a minimal polynomial. The minimality of this polynomial makes it a fundamental object for characterising algebraic numbers.

### Dependencies
- Definition: `minimal_polynomial`
- Theorem: `algebraic_number_is_root_unique_monic_irreducible_QinC_poly`


---

## maybe_algebraic_minimal_polynomial

### Name of formal statement
maybe_algebraic_minimal_polynomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let maybe_algebraic_minimal_polynomial = prove(`
  !z:complex.
  ring_polynomial QinC_ring (minimal_polynomial z)
  /\ poly_eval complex_ring (minimal_polynomial z) z = Cx(&0)
`,
  intro THEN
  case `algebraic_number z` THENL [
    qed[algebraic_has_minimal_polynomial]
  ;
    have `minimal_polynomial z = poly_0 QinC_ring` [minimal_polynomial] THEN
    qed[RING_POLYNOMIAL_0]
  ;
    qed[algebraic_has_minimal_polynomial]
  ;
    have `minimal_polynomial z = poly_0 QinC_ring` [minimal_polynomial] THEN
    qed[POLY_EVAL_0;complex_ring_clauses;poly_0_QinC_eq_poly_0_complex]
  ]
);;
```
### Informal statement
For all complex numbers `z`, `minimal_polynomial z` is a ring polynomial in the ring of complex numbers `QinC_ring`, and the evaluation of the polynomial `minimal_polynomial z` at `z` in the complex ring `complex_ring` is equal to the complex number `0`.

### Informal sketch
The proof proceeds by case analysis on whether `z` is an algebraic number.
- Case 1: `z` is algebraic. In this case, the minimal polynomial is used by the theorem `algebraic_has_minimal_polynomial`
- Case 2: `z` is not algebraic.
  - It is shown using `minimal_polynomial` that `minimal_polynomial z = poly_0 QinC_ring`.
  - The goal is then broken into two parts: showing that `poly_0 QinC_ring` is a ring polynomial and that evaluating it at `z` yields `Cx(&0)`.
  - The first part follows from `RING_POLYNOMIAL_0`
  - The fact that `poly_eval complex_ring (poly_0 QinC_ring) z = Cx(&0)` is proven by using the theorems `POLY_EVAL_0`, `complex_ring_clauses` along with the theorem `poly_0_QinC_eq_poly_0_complex` which translates `poly_0 QinC_ring` to `poly_0 complex_ring`.

### Mathematical insight
The theorem `maybe_algebraic_minimal_polynomial` establishes a key property of the minimal polynomial of a complex number `z`. It states that regardless of whether `z` is algebraic or transcendental, its minimal polynomial (as defined in HOL Light) is always a ring polynomial and evaluates to zero at `z`. This is a fundamental requirement for `minimal_polynomial` to function as expected in further algebraic manipulations and reasoning. When `z` is not algebraic, the `minimal_polynomial` returns the zero polynomial.

### Dependencies
- Theorems:
  - `algebraic_has_minimal_polynomial`
  - `RING_POLYNOMIAL_0`
  - `POLY_EVAL_0`
  - `complex_ring_clauses`
  - `poly_0_QinC_eq_poly_0_complex`
- Definitions:
  - `minimal_polynomial`

### Porting notes (optional)
- The definition `minimal_polynomial` is likely to be present with slight name variation. Ensure that the `poly_0_QinC_eq_poly_0_complex` theorem exists or that the notion of the `0` polynomial is the same on the two rings, otherwise, a similar theorem might have to be crafted.


---

## minimal_polynomial_QinC

### Name of formal statement
minimal_polynomial_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let minimal_polynomial_QinC = prove(`
  !z:complex.
  z IN QinC ==>
  minimal_polynomial z = x_minus_const QinC_ring z
`,
  intro THEN
  rw[minimal_polynomial] THEN
  simp[algebraic_number_QinC] THEN
  specialize[`z:complex`]algebraic_number_QinC_explicit THEN
  sufficesby SELECT_UNIQUE THEN
  qed[algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple]
);;
```
### Informal statement
For all complex numbers `z`, if `z` is in `QinC` (the complex algebraic numbers), then the `minimal_polynomial` of `z` is `x_minus_const QinC_ring z`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumption that `z` is in `QinC`.
- Rewrite using the definition of `minimal_polynomial`.
- Simplify using the definition of `algebraic_number_QinC`.
- Specialize the theorem `algebraic_number_QinC_explicit` with `z:complex`.
- Conclude by selecting the unique element satisfying the conditions using `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple`.

### Mathematical insight
This theorem states that, for elements in `QinC` (algebraic complex numbers), the `minimal_polynomial` is given by `x_minus_const QinC_ring z`, where `x_minus_const` represents the polynomial `x - z` over the ring `QinC_ring`. This is a straightforward result once one has proven that `QinC` is algebraically closed; then every element in Qbar has a minimal polynomial of degree 1, which is `x - z`.

### Dependencies
- Definitions: `minimal_polynomial`, `algebraic_number_QinC`, `x_minus_const`, `QinC_ring`
- Theorems: `algebraic_number_QinC_explicit`, `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple`


---

## poly_eval_vsum_lemma

### Name of formal statement
poly_eval_vsum_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_eval_vsum_lemma = prove(`
  !(p:(1->num)->complex) z n.
  vsum (0..n) (\i. coeff i p * z pow i)
  = ring_sum complex_ring (0..n)
      (\d. ring_mul complex_ring (coeff d p) (ring_pow complex_ring z d))
`,
  intro THEN
  have `FINITE (0..n)` [FINITE_NUMSEG] THEN
  simp[vsum_ring_sum_complex] THEN
  sufficesby RING_SUM_EQ THEN
  intro THEN
  rw[BETA_THM] THEN
  rw[complex_ring_clauses;ring_pow_complex]
);;
```
### Informal statement
For any `p` which is a function from natural numbers to complex numbers, for any complex number `z`, and for any natural number `n`, the sum of `coeff i p * z pow i` from `i = 0` to `n` is equal to the ring sum, in the complex ring, of `coeff d p * z pow d` from `d = 0` to `n`.

### Informal sketch
The proof proceeds as follows:
- Introduce the variables `p`, `z`, and `n`.
- Prove that the set `{0..n}` is finite using `FINITE_NUMSEG`.
- Simplify the goal using the theorem `vsum_ring_sum_complex` which equates vector sums to ring sums in the complex number ring.
- Reduce the goal by showing that the indexed terms are equal using `RING_SUM_EQ`.
- Introduce a variable `d` which represents dummy variable for summations from `0` to `n`.
- Rewrite using `BETA_THM` to evaluate the lambda abstraction.
- Rewrite using `complex_ring_clauses` and `ring_pow_complex` to align the exponentiation functions.

### Mathematical insight
This lemma establishes the equivalence between the vector sum and ring sum representations of polynomial evaluation, where the polynomial is defined by its coefficients. This equivalence is crucial for reasoning about polynomials in both algebraic and analytical contexts within HOL Light. The `vsum` represents a sum from a vector space, while `ring_sum` is a more general notion defined for rings. Since Complex numbers form a ring (with appropriate operations), and can be viewed as a vector space we can equate them and this lemma precisely allows one to change representations inside of HOL Light.

### Dependencies
- `FINITE_NUMSEG`
- `vsum_ring_sum_complex`
- `BETA_THM`
- `complex_ring_clauses`
- `ring_pow_complex`

---

## poly_eval_vsum

### Name of formal statement
poly_eval_vsum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_eval_vsum = prove(`
  !(p:(1->num)->complex) z n.
  ring_polynomial complex_ring p ==>
  poly_deg complex_ring p <= n ==>
  vsum (0..n) (\i. coeff i p * z pow i)
  = poly_eval complex_ring p z
`,
  have `!y. y IN ring_carrier complex_ring` [in_complex_ring] THEN
  simp[poly_eval_expand_coeff] THEN
  qed[poly_eval_vsum_lemma]
);;
```
### Informal statement
For any function `p` from natural numbers to complex numbers, any complex number `z`, and any natural number `n`, if `p` is a ring polynomial over the complex numbers and the degree of `p` is less than or equal to `n`, then the sum from `i = 0` to `n` of the coefficients of `p` at `i` times `z` raised to the power of `i` is equal to the evaluation of the polynomial `p` at `z` with respect to the complex ring.

### Informal sketch
The proof proceeds as follows:

- Assume `y` is in the carrier of the complex ring `complex_ring`. This is established by the theorem `in_complex_ring`.
- Expand the definition of `poly_eval` using the expansion of the coefficients `poly_eval_expand_coeff`.
- The desired equality follows directly.

### Mathematical insight
This theorem states that evaluating a polynomial at a point `z` gives the same result as summing the terms of the polynomial up to a certain degree `n`, provided the actual degree of the polynomial is less than or equal to `n`. This is a fundamental property linking the evaluation of a polynomial to the summation of its terms and can be seen as a formalization of Horner's method when `n` is exactly the degree of `p`.

### Dependencies
- Theorems:
  - `in_complex_ring`
- Definitions:
  - `poly_eval_expand_coeff`


---

## nonconstant_complex_root

### Name of formal statement
nonconstant_complex_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonconstant_complex_root = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  1 <= poly_deg complex_ring p ==>
  ?z. poly_eval complex_ring p z = Cx(&0)
`,
  intro THEN
  def `n:num` `poly_deg complex_ring (p:(1->num)->complex)` THEN
  subgoal `~(!i. i IN 1..n ==> coeff i p = Cx(&0))` THENL [
    rw[NOT_FORALL_THM] THEN
    witness `n:num` THEN
    have `n IN 1..n` [IN_NUMSEG;ARITH_RULE `n <= n:num`] THEN
    have `~(p = poly_0 complex_ring:(1->num)->complex)` [POLY_DEG_0;ARITH_RULE `~(1 <= 0)`] THEN
    have `~(coeff n p = ring_0 complex_ring)` [topcoeff_nonzero] THEN
    qed[complex_ring_clauses]
  ;
    specialize_assuming[`\i. coeff i p:complex`;`n:num`]FTA THEN
    choose `z:complex` `vsum(0..n) (\i. coeff i p * z pow i) = Cx(&0)` [] THEN
    witness `z:complex` THEN
    qed[poly_eval_vsum;ARITH_RULE `n <= n:num`]
  ]
);;
```

### Informal statement
For any polynomial `p` from numbers to complex numbers, if `p` is a ring polynomial over the complex ring and the degree of `p` is greater than or equal to 1, then there exists a complex number `z` such that evaluating `p` at `z` yields the complex number 0.

### Informal sketch
The proof demonstrates that a non-constant polynomial over the complex numbers has a root by using the Fundamental Theorem of Algebra.

- First, the goal is introduced. Then we introduce `n`, the degree of the polynomial `p`.
- Next, we aim to show that not all coefficients of the polynomial `p` are zero. This is proved by contradiction.
   - Assume for contradiction that all coefficients `i` of `p` where `i` ranges from `1` to `n` are zero
   - Show that `n` is in the range `1..n`
   - Use `POLY_DEG_0` to show that `p` is not the zero polynomial.  Then we obtain a contradiction.
   - Show that `coeff n p` is not the ring zero in the complex ring using `topcoeff_nonzero`.
   - Finally, obtain the desired result by rewriting with the defined complex ring clauses `complex_ring_clauses`.
- Specialize the Fundamental Theorem of Algebra (`FTA`) with our polynomial `p` and the degree `n`. This gives us a complex number `z` which is a root of the polynomial (i.e the vsum equals zero).
  - Choose such `z` for which `vsum(0..n) (\i. coeff i p * z pow i) = Cx(&0)`.
   - Instantiate `z` with our chosen `z` and finally discharge assumption by rewriting with `poly_eval_vsum`.

### Mathematical insight
This theorem formally states the existence of a complex root for any non-constant polynomial with complex coefficients, a result known as the Fundamental Theorem of Algebra. It plays a crucial role in complex analysis and algebra, guaranteeing that every non-constant polynomial equation has at least one solution in the complex numbers.

### Dependencies
- `ring_polynomial`
- `complex_ring`
- `poly_deg`
- `poly_eval`
- `Cx`
- `poly_0`
- `coeff`
- `ring_0`
- `vsum`
- `pow`

Theorems:
- `NOT_FORALL_THM`
- `POLY_DEG_0`
- `topcoeff_nonzero`
- `FTA`
- `poly_eval_vsum`

Rules: `IN_NUMSEG`, `ARITH_RULE`

Definitions:
- `def`

### Porting notes (optional)
- A direct translation of the FTA is required.
- The definition of 'ring_polynomial' and the complex ring structure `complex_ring` must be available.
- Ensure that the `poly_eval_vsum` rewrite rule correctly connects polynomial evaluation with summation of coefficients.


---

## nonconstant_complex_x_minus_root

### Name of formal statement
nonconstant_complex_x_minus_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonconstant_complex_x_minus_root = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  1 <= poly_deg complex_ring p ==>
  ?z q. ring_polynomial complex_ring q /\ p = poly_mul complex_ring (x_minus_const complex_ring z) q
`,
  intro THEN
  choose `z:complex` `poly_eval complex_ring p z = Cx(&0)` [nonconstant_complex_root] THEN
  have `poly_eval complex_ring p z = ring_0 complex_ring` [complex_ring_clauses] THEN
  have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `p IN ring_carrier(poly_ring complex_ring (:1))` [x_poly;x_poly_use] THEN
  specialize[`complex_ring`;`z:complex`;`p:(1->num)->complex`]POLY_DIVIDES_X_MINUS_ROOT THEN
  have `poly_sub complex_ring (poly_var complex_ring one) (poly_const complex_ring z) = x_minus_const complex_ring z` [x_minus_const;x_pow_1] THEN
  have `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) p` [x_poly] THEN
  choose `q:(1->num)->complex` `q IN ring_carrier(x_poly complex_ring) /\ (p:(1->num)->complex) = ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) q` [ring_divides] THEN
  witness `z:complex` THEN
  witness `q:(1->num)->complex` THEN
  qed[x_poly_use]
);;
```
### Informal statement
For all polynomials `p` over the complex numbers, represented as functions from natural numbers to complex numbers, if `p` is a ring polynomial in the complex ring and the degree of `p` is greater than or equal to 1, then there exist a complex number `z` and a polynomial `q` over the complex numbers, also a ring polynomial in the complex ring, such that `p` is equal to the product of the polynomial `x - z` and `q` in the complex ring.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumption that `p` is a complex ring polynomial with degree greater than or equal to 1.
- Choose a complex number `z` such that `poly_eval complex_ring p z = Cx(&0)` using the theorem `nonconstant_complex_root`. This means we find a root `z` of the polynomial `p` in the complex numbers.
- Show that `poly_eval complex_ring p z = ring_0 complex_ring` using `complex_ring_clauses`, confirming that `z` is a root.
- Show `z IN ring_carrier complex_ring` using `in_complex_ring`, which proves `z` is a member of the ring.
- Show `p IN ring_carrier(poly_ring complex_ring (:1))` using rewrite rules `x_poly` and `x_poly_use`.
- Specialize the theorem `POLY_DIVIDES_X_MINUS_ROOT` with the complex ring, `z`, and `p`.
- Derive the equivalence of `poly_sub complex_ring (poly_var complex_ring one) (poly_const complex_ring z)` and `x_minus_const complex_ring z`, using rewrite rules `x_minus_const` and `x_pow_1`.
- Show that `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) p` using rewrite rule `x_poly`. It means that `x - z` divides `p`.
- Choose a polynomial `q` over the complex numbers such that `q IN ring_carrier(x_poly complex_ring) /\ (p:(1->num)->complex) = ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) q` using the theorem `ring_divides`. This means that `q` is a ring polynomial and `p = (x - z) * q`.
- Witness `z` and `q` to prove the existential quantifiers.
- Close the proof.

### Mathematical insight
This theorem formalizes the fundamental fact that a non-constant polynomial over the complex numbers has a complex root, and thus can be factored into `(x - z)` times another polynomial `q`. This is a direct consequence of the fundamental theorem of algebra. The theorem constructs `q` by division.

### Dependencies
- `complex_ring_clauses`
- `POLY_DIVIDES_X_MINUS_ROOT`
- `nonconstant_complex_root`
- `in_complex_ring`
- `ring_divides`
- `x_minus_const`
- `x_poly`
- `x_poly_use`
- `x_pow_1`


---

## associates_monic_vanishing_at_if_complex_lemma

### Name of formal statement
associates_monic_vanishing_at_if_complex_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let associates_monic_vanishing_at_if_complex_lemma = prove(`
  !n (p:(1->num)->complex).
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  poly_deg complex_ring p = n ==>
  ?c. ring_associates(x_poly complex_ring)
        p
        (monic_vanishing_at complex_ring {i:num | i < n} c)
`,
  INDUCT_TAC THENL [
    intro THEN
    witness `\i:num. Cx(&0)` THEN
    rw[NUMSEG_LT] THEN
    rw[monic_vanishing_at_empty] THEN
    choose `c:complex` `c IN ring_carrier complex_ring /\ p = poly_const complex_ring c:(1->num)->complex` [POLY_DEG_EQ_0] THEN
    have `~(c = ring_0 complex_ring)` [poly_0] THEN
    have `field complex_ring` [field_complex] THEN
    have `ring_unit complex_ring c` [FIELD_UNIT] THEN
    have `ring_unit(x_poly complex_ring) p` [RING_UNIT_POLY_CONST;x_poly] THEN
    have `ring_associates(x_poly complex_ring) p (ring_1(x_poly complex_ring))` [RING_ASSOCIATES_1] THEN
    qed[x_poly_use]
  ;
    intro THEN
    num_linear_fact `poly_deg complex_ring (p:(1->num)->complex) = SUC n ==> 1 <= poly_deg complex_ring p` THEN
    choose2 `z:complex` `q:(1->num)->complex` `ring_polynomial complex_ring q /\ p = poly_mul complex_ring (x_minus_const complex_ring z) q` [nonconstant_complex_x_minus_root] THEN
    have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly] THEN
    have `integral_domain complex_ring` [integral_domain_complex] THEN
    have `~(x_minus_const complex_ring z = poly_0 complex_ring)` [x_minus_const_nonzero;integral_domain] THEN
    have `~(q = poly_0 complex_ring:(1->num)->complex)` [POLY_MUL_0;x_poly_use;x_minus_const_poly] THEN
    specialize_assuming[`complex_ring`;`x_minus_const complex_ring z`;`q:(1->num)->complex`]POLY_DEG_MUL THEN
    have `poly_deg complex_ring (p:(1->num)->complex) = poly_deg complex_ring (x_minus_const complex_ring z) + poly_deg complex_ring (q:(1->num)->complex)` [integral_domain_complex;x_poly_use] THEN
    have `SUC n = 1 + poly_deg complex_ring (q:(1->num)->complex)` [deg_x_minus_const;integral_domain] THEN
    num_linear_fact `SUC n = 1 + poly_deg complex_ring (q:(1->num)->complex) ==> poly_deg complex_ring q = n` THEN
    have `x_minus_const complex_ring z IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
    choose `d:num->complex` `ring_associates(x_poly complex_ring) q (monic_vanishing_at complex_ring {i:num | i < n} d)` [] THEN
    def `c:num->complex` `\i:num. if i = n then z:complex else d i` THEN
    have `c(n:num) IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `monic_vanishing_at complex_ring {i:num | i < n+1} c = poly_mul complex_ring (x_minus_const complex_ring (c n)) (monic_vanishing_at complex_ring {i:num | i < n} c)` [monic_vanishing_at_plus1] THEN
    set_fact_using `!i:num. i IN {i | i < n} ==> ~(i = n)` [ARITH_RULE `~(n < n:num)`] THEN
    have `!i:num. i IN {i | i < n} ==> c i = d i:complex` [] THEN
    have `monic_vanishing_at complex_ring {i:num | i < n} c = monic_vanishing_at complex_ring {i:num | i < n} d` [monic_vanishing_at_eq] THEN
    have `ring_associates(x_poly complex_ring) (x_minus_const complex_ring z) (x_minus_const complex_ring z)` [RING_ASSOCIATES_REFL;x_minus_const_poly;x_poly_use] THEN
    have `ring_associates(x_poly complex_ring) (ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) q) (ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) (monic_vanishing_at complex_ring {i:num | i < n} d))` [RING_ASSOCIATES_MUL] THEN
    have `ring_associates(x_poly complex_ring) (poly_mul complex_ring (x_minus_const complex_ring z) q) (poly_mul complex_ring (x_minus_const complex_ring z) (monic_vanishing_at complex_ring {i:num | i < n} d))` [x_poly_use] THEN
    have `ring_associates(x_poly complex_ring) p (poly_mul complex_ring (x_minus_const complex_ring z) (monic_vanishing_at complex_ring {i:num | i < n} d))` [RING_ASSOCIATES_MUL;x_poly_use] THEN
    have `ring_associates(x_poly complex_ring) p (poly_mul complex_ring (x_minus_const complex_ring z) (monic_vanishing_at complex_ring {i:num | i < n} c))` [] THEN
    have `ring_associates(x_poly complex_ring) p (monic_vanishing_at complex_ring {i:num | i < n+1} c)` [] THEN
    witness `c:num->complex` THEN
    qed[ARITH_RULE `SUC n = n+1`]
  ]
);;
```

### Informal statement
For all natural numbers `n` and all ring polynomials `p` over the complex numbers, if `p` is not the zero polynomial and the degree of `p` is `n`, then there exists a function `c` from natural numbers to complex numbers such that `p` is an associate of the monic vanishing polynomial at the set `{i : num | i < n}` with coefficients `c` in the ring of polynomials over the complex numbers.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case (n = 0):
  - We need to show that if the degree of `p` is 0, then `p` is an associate of `monic_vanishing_at complex_ring {} c`, where `{}` is the empty set.
  - We choose `c` to be a constant function that always returns the complex number 0.
  - Then `monic_vanishing_at complex_ring {} c` is equal to `ring_1(x_poly complex_ring)`. `monic_vanishing_at_empty` is used to prove this.
  - Since `p` has degree 0 and is non-zero, `p` is a constant polynomial, so `p = poly_const complex_ring c` for some complex number `c`. We show `c` is a ring unit. Thus `p` is a unit in the polynomial ring. Any two units are associates, so `p` is an associate of `ring_1(x_poly complex_ring)`.
- Inductive step:
  - Assume the theorem holds for `n`. We need to show that if the degree of `p` is `SUC n`, then there exists a function `c` such that `p` is an associate of `monic_vanishing_at complex_ring {i | i < SUC n} c`.
  - Since `poly_deg complex_ring p = SUC n`, we know that `1 <= poly_deg complex_ring p`.
  - By `nonconstant_complex_x_minus_root`, we can write `p` as `poly_mul complex_ring (x_minus_const complex_ring z) q`, where `z` is a complex number and `q` is a polynomial.
  - We have `poly_deg complex_ring p = poly_deg complex_ring (x_minus_const complex_ring z) + poly_deg complex_ring q`.
  - Since `poly_deg complex_ring (x_minus_const complex_ring z) = 1`, we have `poly_deg complex_ring q = n`.
  - By the inductive hypothesis, there exists a function `d` such that `q` is an associate of `monic_vanishing_at complex_ring {i | i < n} d`.
  - We define a new function `c` such that `c i = d i` for `i < n` and `c n = z`.
  - Then `monic_vanishing_at complex_ring {i | i < SUC n} c = poly_mul complex_ring (x_minus_const complex_ring z) (monic_vanishing_at complex_ring {i | i < n} c)`.
  - Thus, `p = poly_mul complex_ring (x_minus_const complex_ring z) q` is an associate of `poly_mul complex_ring (x_minus_const complex_ring z) (monic_vanishing_at complex_ring {i | i < n} d)`, which is equal to `monic_vanishing_at complex_ring {i | i < SUC n} c`.  Here, the properties of `ring_associates` are used.

### Mathematical insight
The statement provides a fundamental connection between polynomials and their roots. Specifically, it implies that a polynomial of degree `n` is always an associate of a polynomial that vanishes on a set of `n` values. In the complex field, it is equivalent to saying that polynomials are determined by their roots, up to a constant factor. In other words, monic vanishing polynomials are canonical representatives of their equivalence class under the `ring_associates` relation.

### Dependencies
#### Theorems
- `field_complex`
- `RING_UNIT_POLY_CONST`
- `RING_ASSOCIATES_1`
- `nonconstant_complex_x_minus_root`
- `deg_x_minus_const`
- `RING_ASSOCIATES_REFL`
- `RING_ASSOCIATES_MUL`

#### Definitions
- `ring_polynomial`
- `poly_0`
- `poly_deg`
- `ring_associates`
- `x_poly`
- `monic_vanishing_at`
- `poly_const`
- `ring_unit`
- `x_minus_const`
- `poly_mul`
- `ring_carrier`
- `integral_domain`

#### Other
- `NUMSEG_LT`
- `POLY_DEG_EQ_0`
- `POLY_MUL_0`
- `ARITH_RULE`
- `integral_domain_complex`

### Porting notes (optional)
- The proof relies heavily on the properties of polynomial rings over complex numbers. Care must be taken to ensure that the target proof assistant has similar infrastructure for dealing with polynomials and complex numbers.
- The use of `ring_associates` suggests that the target proof assistant must also have a notion of associates in a ring.
- The `choose` tactic is heavily used within the proof, so the target proof assistant must offer similar functionality for existentially quantified variables and assumptions.


---

## associates_monic_vanishing_at_if_complex

### Name of formal statement
associates_monic_vanishing_at_if_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let associates_monic_vanishing_at_if_complex = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  ?c. ring_associates(x_poly complex_ring)
        p
        (monic_vanishing_at complex_ring {i:num | i < poly_deg complex_ring p} c)
`,
  intro THEN
  specialize[`poly_deg complex_ring (p:(1->num)->complex)`;`p:(1->num)->complex`]associates_monic_vanishing_at_if_complex_lemma THEN
  qed[]
);;
```
### Informal statement
For any polynomial `p` from numbers to complex numbers, if `p` is a ring polynomial over the complex ring and `p` is not the zero polynomial over the complex ring, then there exists a complex number `c` such that the ring associate of `x_poly complex_ring` and `p` is equal to the monic polynomial vanishing at the set of numbers `i` such that `i` is less than the polynomial degree of `p` over the complex ring evaluated at `c`.

### Informal sketch
The proof proceeds as follows:
- Introduce the antecedent of the implication.
- Apply a lemma called `associates_monic_vanishing_at_if_complex_lemma`, specializing it to the polynomial `p`.
- Conclude the proof.

### Mathematical insight
This theorem states that any non-zero ring polynomial over the complex numbers is associated with a monic polynomial that vanishes at a specific set of points determined by the degree of the polynomial. This is significant because it connects the concept of ring associates to monic polynomials, which are fundamental in polynomial algebra, particularly in the context of complex polynomials. The `associates` relation implies that the polynomials differ only by a unit factor, and the `monic_vanishing_at` represents a polynomial that has specific roots.

### Dependencies
- Theorems: `associates_monic_vanishing_at_if_complex_lemma`


---

## monic_vanishing_at_if_monic_complex

### Name of formal statement
monic_vanishing_at_if_monic_complex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_if_monic_complex = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  monic complex_ring p ==>
  ?c. p = monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c
`,
  intro THEN
  have `~(p:(1->num)->complex = poly_0 complex_ring)` [monic_poly_0;field_complex;field] THEN
  specialize[`p:(1->num)->complex`]associates_monic_vanishing_at_if_complex THEN
  choose `c:num->complex` `ring_associates (x_poly complex_ring) p (monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c)` [] THEN
  have `!i. i IN {i | i < poly_deg complex_ring (p:(1->num)->complex)} ==> c i IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`poly_deg complex_ring (p:(1->num)->complex)`]FINITE_NUMSEG_LT THEN
  have `monic complex_ring (monic_vanishing_at complex_ring {i | i < poly_deg complex_ring (p:(1->num)->complex)} c)` [monic_vanishing_at_monic] THEN
  qed[monic_associates;field_complex]
);;
```
### Informal statement
For any `p` which is a polynomial over the complex numbers (represented as functions from natural numbers to complex numbers) in the complex ring (`complex_ring`), if `p` is monic in the complex ring, then there exists a function `c` from natural numbers to complex numbers such that `p` is equal to the `monic_vanishing_at` polynomial of the complex ring, evaluated at `c` over the set `{i | i < poly_deg complex_ring p}`, which is the set of natural numbers `i` less than the degree of the polynomial `p` in the complex ring.

### Informal sketch
The proof proceeds as follows:

- We start by assuming that `p` is a polynomial in the complex ring and is monic.
- We then prove `~(p = poly_0 complex_ring)` by using `monic_poly_0;field_complex;field`
- Using `associates_monic_vanishing_at_if_complex` with specialization of `p`, we have the existence of a function `c` such that `ring_associates (x_poly complex_ring) p (monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c)`.
- Using `in_complex_ring` with universal quantification over `i`, we prove that if `i` is in the set `{i | i < poly_deg complex_ring (p:(1->num)->complex)}`, then `c i` is in the carrier of the complex ring.
- Applying `FINITE_NUMSEG_LT` to `poly_deg complex_ring (p:(1->num)->complex)`, it can be shown that the set `{i | i < poly_deg complex_ring (p:(1->num)->complex)}` is finite.
- Applying `monic_vanishing_at_monic` to the `monic_vanishing_at` polynomial, we prove `monic complex_ring (monic_vanishing_at complex_ring {i | i < poly_deg complex_ring (p:(1->num)->complex)} c)`.
- Finally, conclude with `monic_associates` and `field_complex` to prove that `p = monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c`.

### Mathematical insight
The theorem states that any monic polynomial over the complex numbers can be represented as a `monic_vanishing_at` polynomial, where `monic_vanishing_at` is a canonical form that encodes the roots of the polynomial. The `monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c` polynomial has degree equal to `poly_deg complex_ring p` and has roots `c i` for `i < poly_deg complex_ring p`. `associates_monic_vanishing_at_if_complex` decomposes `p` into its leading coefficient (which is 1 since `p` is monic) and the canonical representation `monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c`.

### Dependencies
- Theorems: `monic_poly_0`, `associates_monic_vanishing_at_if_complex`, `FINITE_NUMSEG_LT`, `monic_vanishing_at_monic`, `monic_associates`
- Definitions: `field_complex`, `field`, `in_complex_ring`


---

## monic_QinC_squarefree_complex_squarefree_lemma

### Name of formal statement
monic_QinC_squarefree_complex_squarefree_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_QinC_squarefree_complex_squarefree_lemma = prove(`
  !(r:R ring) C p qpd qp'd D:(1->num)->R.
  ring_polynomial r C ==>
  ring_polynomial r p ==>
  ring_polynomial r qpd ==>
  ring_polynomial r qp'd ==>
  ring_polynomial r D ==>
  p = poly_mul r C qpd ==>
  poly_mul r C qp'd = poly_add r qpd (poly_mul r C D) ==>
  p = poly_mul r (poly_mul r C C) (poly_sub r qp'd D)
`,
  rw[x_poly_use;x_poly_sub_use] THEN
  intro THEN
  specialize[`x_poly(r:R ring)`
    ;`C:(1->num)->R`
    ;`D:(1->num)->R`
    ;`p:(1->num)->R`
    ;`qp'd:(1->num)->R`
    ;`qpd:(1->num)->R`](
    GENL[`r:R ring`;`C:R`;`D:R`;`p:R`;`qp'd:R`;`qpd:R`](
      RING_RULE `
        p = ring_mul(r:R ring) C qpd ==>
        ring_mul r C qp'd = ring_add r qpd (ring_mul r C D) ==>
        p = ring_mul r (ring_mul r C C) (ring_sub r qp'd D)
      `
    )) THEN
  qed[]
);;
```
### Informal statement
For all rings `r` and for all polynomials `C`, `p`, `qpd`, `qp'd`, and `D` over `r`, if `C`, `p`, `qpd`, `qp'd`, and `D` are ring polynomials and `p` is equal to the polynomial multiplication of `C` and `qpd`, and the polynomial multiplication of `C` and `qp'd` is equal to the polynomial addition of `qpd` and the polynomial multiplication of `C` and `D`, then `p` is equal to the polynomial multiplication of `C` multiplied by `C`, and the result is multiplied by the polynomial subtraction of `qp'd` and `D`.

### Informal sketch
The proof proceeds by rewriting using `x_poly_use` and `x_poly_sub_use` to convert polynomial operations to ring operations. The goal is:
`p = poly_mul r C qpd ==> poly_mul r C qp'd = poly_add r qpd (poly_mul r C D) ==> p = poly_mul r (poly_mul r C C) (poly_sub r qp'd D)`.

- After introduction and specialization, we have the assumptions `p = ring_mul C qpd` and `ring_mul C qp'd = ring_add qpd (ring_mul C D)`.
- The conclusion we need to prove is `p = ring_mul (ring_mul C C) (ring_sub qp'd D)`.
- The proof applies `RING_RULE` to show `p = ring_mul C qpd ==> ring_mul C qp'd = ring_add qpd (ring_mul C D) ==> p = ring_mul (ring_mul C C) (ring_sub qp'd D)`.
- The concluding tactic, `qed[]`, closes the proof.

### Mathematical insight
The lemma establishes a relationship between polynomials `p`, `C`, `qpd`, `qp'd`, and `D` under polynomial multiplication, addition, and subtraction given the initial conditions. The key idea is that if `p = C * qpd` and `C * qp'd = qpd + C * D`, then `p = C^2 * (qp'd - D)`. This reveals how `p` can be expressed involving `C^2` and `qp'd - D`.

### Dependencies
- Theorems: `x_poly_use`, `x_poly_sub_use`

### Porting notes (optional)
The `RING_RULE` tactic in HOL Light automatically performs ring-theoretic reasoning to prove the goal from assumptions. In other proof assistants (e.g., Lean, Coq), you may need to manually apply ring simplification tactics or use a ring tactic specifically designed for that system (e.g., `ring_nf` in Coq).


---

## monic_QinC_squarefree_complex_squarefree

### Name of formal statement
monic_QinC_squarefree_complex_squarefree

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_QinC_squarefree_complex_squarefree = prove(`
  !p:(1->num)->complex.
  ring_polynomial QinC_ring p ==>
  monic QinC_ring p ==>
  (ring_squarefree(x_poly QinC_ring) p <=>
   ring_squarefree(x_poly complex_ring) p)
`,
  intro THEN
  recall subring_complex_QinC THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `monic complex_ring (p:(1->num)->complex)` [monic_subring] THEN
  splitiff THENL [
    intro THEN
    recall field_QinC THEN
    recall ring_char_QinC THEN
    have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;field] THEN
    specialize[`QinC_ring`;`p:(1->num)->complex`]coprime_derivative_if_squarefree THEN
    specialize[`QinC_ring`;`p:(1->num)->complex`;`x_derivative QinC_ring p`]linear_combination_if_coprime_poly THEN
    choose2 `x:(1->num)->complex` `y:(1->num)->complex` `ring_polynomial QinC_ring x /\ ring_polynomial QinC_ring y /\ poly_add QinC_ring (poly_mul QinC_ring p x) (poly_mul QinC_ring (x_derivative QinC_ring p) y) = poly_1 QinC_ring` [] THEN
    have `poly_mul QinC_ring p x = poly_mul complex_ring p x:(1->num)->complex` [poly_mul_subring;ring_polynomial] THEN
    have `ring_polynomial QinC_ring (x_derivative QinC_ring p)` [x_derivative_polynomial] THEN
    have `poly_mul QinC_ring (x_derivative QinC_ring p) y = poly_mul complex_ring (x_derivative QinC_ring p) y:(1->num)->complex` [poly_mul_subring;ring_polynomial] THEN
    have `poly_add QinC_ring (poly_mul complex_ring p x) (poly_mul complex_ring (x_derivative QinC_ring p) y) = poly_1 complex_ring` [poly_1_subring] THEN
    have `poly_add complex_ring (poly_mul complex_ring p x) (poly_mul complex_ring (x_derivative QinC_ring p) y) = poly_1 complex_ring` [poly_add_subring] THEN
    have `poly_add complex_ring (poly_mul complex_ring p x) (poly_mul complex_ring (x_derivative complex_ring p) y) = poly_1 complex_ring` [x_derivative_subring] THEN
    specialize_assuming[`complex_ring`;`p:(1->num)->complex`;`x_derivative complex_ring p:(1->num)->complex`;`x:(1->num)->complex`;`y:(1->num)->complex`]coprime_poly_if_linear_combination THEN
    have `ring_polynomial complex_ring (p:(1->num)->complex)` [ring_polynomial_if_subring] THEN
    have `ring_powerseries complex_ring (p:(1->num)->complex)` [series_complex] THEN
    have `ring_polynomial complex_ring (x_derivative complex_ring (p:(1->num)->complex))` [x_derivative_polynomial] THEN
    have `ring_polynomial complex_ring (x:(1->num)->complex)` [ring_polynomial_if_subring] THEN
    have `ring_polynomial complex_ring (y:(1->num)->complex)` [ring_polynomial_if_subring] THEN
    have `ring_coprime (x_poly complex_ring) (p,x_derivative complex_ring p)` [] THEN
    qed[squarefree_if_coprime_derivative;field_complex]
  ;
    intro THEN
    proven_if `ring_coprime(x_poly QinC_ring) (p,x_derivative QinC_ring p)` [squarefree_if_coprime_derivative;field_QinC] THEN
    have `p IN ring_carrier(x_poly QinC_ring)` [x_poly_use] THEN
    have `x_derivative QinC_ring p IN ring_carrier(x_poly QinC_ring)` [x_derivative_polynomial;x_poly_use] THEN
    choose `d:(1->num)->complex` `ring_divides(x_poly QinC_ring) d p /\ ring_divides(x_poly QinC_ring) d (x_derivative QinC_ring p) /\ ~(ring_unit(x_poly QinC_ring) d)` [ring_coprime] THEN
    case `poly_deg QinC_ring (d:(1->num)->complex) = 0` THENL [
      have `ring_polynomial QinC_ring (d:(1->num)->complex)` [ring_divides;x_poly_use] THEN
      choose `c:complex` `c IN ring_carrier(QinC_ring) /\ d = poly_const QinC_ring c:(1->num)->complex` [POLY_DEG_EQ_0] THEN
      case `c = ring_0 QinC_ring` THENL [
        have `d = poly_0 QinC_ring:(1->num)->complex` [poly_0] THEN
        have `p = poly_0 QinC_ring:(1->num)->complex` [x_poly_use;RING_DIVIDES_ZERO] THEN
        qed[monic_poly_0;field;field_QinC]
      ;
        have `c IN QinC` [QinC_ring_clauses] THEN
        choose `d:complex` `d IN ring_carrier QinC_ring /\ ring_mul QinC_ring c d = ring_1 QinC_ring` [field;field_QinC] THEN
        have `ring_unit QinC_ring c` [ring_unit] THEN
        qed[RING_UNIT_POLY_CONST;x_poly]
      ]
    ; pass
    ] THEN
    num_linear_fact `~(poly_deg QinC_ring (d:(1->num)->complex) = 0) ==> 1 <= poly_deg QinC_ring (d:(1->num)->complex)` THEN
    have `1 <= poly_deg complex_ring (d:(1->num)->complex)` [POLY_DEG_SUBRING_GENERATED] THEN
    have `d IN ring_carrier(x_poly QinC_ring)` [ring_divides] THEN
    have `ring_polynomial QinC_ring (d:(1->num)->complex)` [x_poly_use] THEN
    have `ring_polynomial complex_ring (d:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
    have `ring_powerseries QinC_ring (d:(1->num)->complex)` [ring_polynomial] THEN
    have `d IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
    choose2 `z:complex` `q:(1->num)->complex` `ring_polynomial complex_ring q /\ d = poly_mul complex_ring (x_minus_const complex_ring z) q` [nonconstant_complex_x_minus_root] THEN
    have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly] THEN
    have `ring_powerseries complex_ring (x_minus_const complex_ring z)` [series_complex] THEN
    have `ring_polynomial complex_ring (q:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
    have `ring_powerseries complex_ring (q:(1->num)->complex)` [series_complex] THEN
    have `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) d` [x_poly_use;ring_divides] THEN
    have `p IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
    choose `pd:(1->num)->complex` `pd IN ring_carrier(x_poly QinC_ring) /\ p = ring_mul(x_poly QinC_ring) d pd` [ring_divides] THEN
    have `p = poly_mul QinC_ring d pd:(1->num)->complex` [x_poly_use] THEN
    have `ring_polynomial QinC_ring (pd:(1->num)->complex)` [x_poly_use] THEN
    have `ring_powerseries QinC_ring (pd:(1->num)->complex)` [ring_polynomial] THEN
    have `ring_polynomial complex_ring (pd:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
    have `ring_powerseries complex_ring (pd:(1->num)->complex)` [series_complex] THEN
    specialize_assuming[`complex_ring`;`QinC`;`d:(1->num)->complex`;`pd:(1->num)->complex`]poly_mul_subring THEN
    have `p = poly_mul complex_ring d pd:(1->num)->complex` [ring_polynomial] THEN
    def `qpd:(1->num)->complex` `poly_mul complex_ring q pd:(1->num)->complex` THEN
    have `ring_polynomial complex_ring (qpd:(1->num)->complex)` [RING_POLYNOMIAL_MUL] THEN
    have `ring_powerseries complex_ring (qpd:(1->num)->complex)` [series_complex] THEN
    have `ring_polynomial complex_ring (x_derivative complex_ring qpd)` [x_derivative_polynomial] THEN
    have `p = poly_mul complex_ring (x_minus_const complex_ring z) qpd` [POLY_MUL_ASSOC;ring_polynomial;RING_MUL] THEN
    have `x_derivative complex_ring p = poly_add complex_ring (poly_mul complex_ring (x_derivative complex_ring (x_minus_const complex_ring z)) qpd) (poly_mul complex_ring (x_minus_const complex_ring z) (x_derivative complex_ring qpd))` [x_derivative_mul] THEN
    choose `p'd:(1->num)->complex` `p'd IN ring_carrier(x_poly QinC_ring) /\ x_derivative QinC_ring p = ring_mul(x_poly QinC_ring) d p'd` [ring_divides] THEN
    have `p'd IN ring_carrier(x_poly complex_ring)` [poly_complex_if_poly_QinC;x_poly_use] THEN
    have `x_derivative complex_ring p = x_derivative QinC_ring p` [x_derivative_subring] THEN
    have `x_derivative complex_ring p = ring_mul(x_poly QinC_ring) d p'd` [] THEN
    have `x_derivative complex_ring p = poly_mul QinC_ring d p'd` [x_poly_use] THEN
    have `ring_polynomial complex_ring (p'd:(1->num)->complex)` [x_poly_use] THEN
    have `ring_powerseries complex_ring (p'd:(1->num)->complex)` [series_complex] THEN
    have `ring_powerseries QinC_ring (p'd:(1->num)->complex)` [x_poly_use;ring_polynomial] THEN
    have `x_derivative complex_ring p = poly_mul complex_ring d p'd` [poly_mul_subring] THEN
    def `qp'd:(1->num)->complex` `poly_mul complex_ring q p'd:(1->num)->complex` THEN
    have `ring_polynomial complex_ring (qp'd:(1->num)->complex)` [RING_POLYNOMIAL_MUL] THEN
    have `ring_powerseries complex_ring (qp'd:(1->num)->complex)` [series_complex] THEN
    have `x_derivative complex_ring p = poly_mul complex_ring (x_minus_const complex_ring z) qp'd` [POLY_MUL_ASSOC;ring_polynomial;RING_MUL] THEN
    have `poly_mul complex_ring (x_minus_const complex_ring z) qp'd = poly_add complex_ring (poly_mul complex_ring (x_derivative complex_ring (x_minus_const complex_ring z)) qpd) (poly_mul complex_ring (x_minus_const complex_ring z) (x_derivative complex_ring qpd))` [] THEN
    have `poly_mul complex_ring (x_minus_const complex_ring z) qp'd = poly_add complex_ring (poly_mul complex_ring (poly_1 complex_ring) qpd) (poly_mul complex_ring (x_minus_const complex_ring z) (x_derivative complex_ring qpd))` [x_derivative_x_minus_const] THEN
    have `poly_mul complex_ring (x_minus_const complex_ring z) qp'd = poly_add complex_ring qpd (poly_mul complex_ring (x_minus_const complex_ring z) (x_derivative complex_ring qpd))` [POLY_MUL_LID] THEN
    specialize[`complex_ring`;`x_minus_const complex_ring z`;`p:(1->num)->complex`;`qpd:(1->num)->complex`;`qp'd:(1->num)->complex`;`x_derivative complex_ring qpd:(1->num)->complex`]monic_QinC_squarefree_complex_squarefree_lemma THEN
    have `pd IN ring_carrier(x_poly complex_ring)` [poly_complex_if_poly_QinC;x_poly_use] THEN
    have `p = ring_mul(x_poly complex_ring) d pd` [ring_polynomial;x_poly_use;poly_mul_subring] THEN
    have `ring_divides(x_poly complex_ring) d p` [ring_divides] THEN
    have `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) p` [RING_DIVIDES_TRANS] THEN
    have `x_derivative QinC_ring p IN ring_carrier(x_poly complex_ring)` [poly_complex_if_poly_QinC;x_poly_use] THEN
    have `x_derivative QinC_ring p = ring_mul(x_poly complex_ring) d p'd` [ring_polynomial;x_poly_use;poly_mul_subring] THEN
    have `ring_divides(x_poly complex_ring) d (x_derivative QinC_ring p)` [ring_divides] THEN
    have `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) (x_derivative QinC_ring p)` [RING_DIVIDES_TRANS] THEN
    have `integral_domain(x_poly complex_ring)` [integral_domain_x_poly_field;field_complex] THEN
    have `~(monic complex_ring (poly_0 complex_ring))` [monic_poly_0;field;field_complex] THEN
    have `~(p = ring_0(x_poly complex_ring))` [x_poly_use] THEN
    have `x_minus_const complex_ring z IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
    have  `~ring_unit(x_poly complex_ring) (x_minus_const complex_ring z)` [x_minus_const_not_unit;integral_domain_complex] THEN
    specialize_assuming[`x_poly complex_ring`;`p:(1->num)->complex`;`x_minus_const complex_ring z:(1->num)->complex`]not_squarefree_if_divisible_by_square THEN
    have `p = ring_mul(x_poly complex_ring) (poly_mul complex_ring (x_minus_const complex_ring z) (x_minus_const complex_ring z)) (poly_sub complex_ring qp'd (x_derivative complex_ring qpd))` [x_poly_use] THEN
    have `p = ring_mul(x_poly complex_ring) (ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) (x_minus_const complex_ring z)) (poly_sub complex_ring qp'd (x_derivative complex_ring qpd))` [x_poly_use] THEN
    have `p = ring_mul(x_poly complex_ring) (ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) (x_minus_const complex_ring z)) (ring_sub(x_poly complex_ring) qp'd (x_derivative complex_ring qpd))` [x_poly_sub_use] THEN
    subgoal `ring_divides (x_poly complex_ring) (ring_mul (x_poly complex_ring) (x_minus_const complex_ring z) (x_minus_const complex_ring z)) p` THENL [
      rw[ring_divides] THEN
      intro THENL [
        qed[RING_MUL;x_minus_const_poly;x_poly_use]
      ;
        qed[]
      ;
        witness `ring_sub (x_poly complex_ring) qp'd (x_derivative complex_ring qpd)` THEN
        qed[RING_SUB;x_poly_use]
      ]
      ;
        qed[]
    ]
  ]
);;
```
### Informal statement
For any polynomial `p` from numbers to complex numbers, if `p` is a polynomial over the subring `QinC` of complex numbers, and `p` is monic over `QinC`, then `p` is squarefree in the ring of polynomials over `QinC` if and only if `p` is squarefree in the ring of polynomials over the complex numbers.

### Informal sketch
The proof proceeds by showing the equivalence of `ring_squarefree` for a polynomial `p` over the subring `QinC` and the complex numbers, given that `p` is a polynomial over `QinC` and is monic. The proof is structured as follows:
- An introduction is performed, followed by recalling the `subring_complex_QinC` theorem.
- It is proven that `ring_polynomial complex_ring p` holds assuming ring_polynomial QinC_ring p, using the poly_complex_if_poly_QinC theorem.
- It is proven that `monic complex_ring p` holds using the `monic_subring` theorem.
- The proof is split into two directions using `splitiff`:
  - From `squarefree(QinC)` to `squarefree(complex)`:
    - Assuming `ring_squarefree(x_poly QinC_ring) p`, the goal is to show that `ring_squarefree(x_poly complex_ring) p`.
    - Use `field_QinC` and `ring_char_QinC`.
    - Apply `coprime_derivative_if_squarefree`, `linear_combination_if_coprime_poly` theorems.
    - Choose polynomials `x` and `y` in `QinC` such that `p*x + p'*y = 1` in `QinC`.
    - Show that `p*x + p'*y = 1` in `complex_ring` using subring properties.
    - Apply `coprime_poly_if_linear_combination` to show that `p` and `p'` are coprime in `complex`.
    - Use `squarefree_if_coprime_derivative` to conclude that `p` is squarefree in `complex`.
  - From `squarefree(complex)` to `squarefree(QinC)`:
    - Assume `ring_squarefree(x_poly complex_ring) p`.
    - Apply `squarefree_if_coprime_derivative` to show that `p` and `p'` are coprime in `QinC`.
    - Choose a common divisor `d` of `p` and `p'` in `QinC`.
    - Case split on whether `deg(d) = 0`.
        - If `deg(d) = 0`, then either `d` is zero which implies p is zero, or `d` is a unit in `QinC`.
        - Otherwise, `1 <= deg(d)`.
    - Let `z` be a root of `d` in `complex`. This exists since complex is algebraically closed.
    - Show that `(x - z)` divides `p` and `p'` in `complex`.
    - Apply a lemma stating that if `(x - z)` divides both `p` and `p'`, then `(x - z)^2` divides `p`.
    - Thus, `p` cannot be squarefree, leading to contradiction of the initial assumption.

### Mathematical insight
This theorem states that for monic polynomials over `QinC`, squarefreeness is preserved when moving from the polynomial ring over `QinC` to the polynomial ring over complex numbers. This is useful because often it is simpler to check for squarefreeness in the complex field.

### Dependencies
- `subring_complex_QinC`
- `poly_complex_if_poly_QinC`
- `monic_subring`
- `field_QinC`
- `ring_char_QinC`
- `monic_poly_0`
- `coprime_derivative_if_squarefree`
- `linear_combination_if_coprime_poly`
- `poly_mul_subring`
- `x_derivative_polynomial`
- `poly_add_subring`
- `poly_1_subring`
- `x_derivative_subring`
- `coprime_poly_if_linear_combination`
- `ring_polynomial_if_subring`
- `ring_coprime`
- `squarefree_if_coprime_derivative`
- `ring_polynomial`
- `series_complex`
- `field_complex`
- `squarefree_if_coprime_derivative`
- `RING_DIVIDES_ZERO`
- `RING_UNIT_POLY_CONST`
- `POLY_DEG_EQ_0`
- `POLY_DEG_SUBRING_GENERATED`
- `nonconstant_complex_x_minus_root`
- `poly_complex_if_poly_QinC`
- `ring_divides`
- `x_minus_const_poly`
- `poly_mul_subring`
- `POLY_MUL_ASSOC`
- `x_derivative_mul`
- `x_derivative_x_minus_const`
- `POLY_MUL_LID`
- `monic_QinC_squarefree_complex_squarefree_lemma`
- `integral_domain_x_poly_field`
- `x_minus_const_not_unit`
- `field_complex`
- `monic_poly_0`
- `not_squarefree_if_divisible_by_square`
- `x_poly_sub_use`
-` ring_divides`

### Porting notes (optional)
The proof relies heavily on the algebraic properties of polynomial rings and field extensions.  A key challenge will be ensuring definitions of `squarefree`, `monic`, `ring_polynomial`, etc., are compatible across different formal systems. The numerous subring lemmas used here may need to be recreated.


---

## monic_squarefree_complex_roots

### Name of formal statement
monic_squarefree_complex_roots

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_squarefree_complex_roots = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  ring_squarefree(x_poly complex_ring) p ==>
  monic complex_ring p ==>
  ?S. FINITE S /\ p = monic_vanishing_at complex_ring S I
`,
  intro THEN
  choose `c:num->complex` `p = monic_vanishing_at complex_ring {i | i < poly_deg complex_ring p} c` [monic_vanishing_at_if_monic_complex] THEN
  def `S:num->bool` `{i | i < poly_deg complex_ring (p:(1->num)->complex)}` THEN
  have `p = monic_vanishing_at complex_ring (S:num->bool) c` [] THEN
  witness `IMAGE (c:num->complex) S` THEN
  subgoal `!e f:num. e IN S ==> f IN S ==> c e = (c f:complex) ==> e = f` THENL [
    intro THEN
    def `d:num->(1->num)->complex` `\j:num. if j = e then x_minus_const complex_ring (c e) else if j = f then x_minus_const complex_ring (c e) else ring_1(x_poly complex_ring)` THEN
    specialize[`poly_deg complex_ring (p:(1->num)->complex)`]FINITE_NUMSEG_LT THEN
    have `FINITE (S:num->bool)` [] THEN
    have `c(e:num) IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `x_minus_const complex_ring (c(e:num)) IN ring_carrier(x_poly complex_ring)` [x_poly_use;x_minus_const_poly] THEN
    specialize[`x_poly complex_ring`;`S:num->bool`;`e:num`;`f:num`;`x_minus_const complex_ring (c(e:num))`;`x_minus_const complex_ring (c(e:num))`]ring_product_delta_delta THEN
    have `ring_product (x_poly complex_ring) (S:num->bool) d = (if e = f:num then x_minus_const complex_ring (c e) else ring_mul (x_poly complex_ring) (x_minus_const complex_ring (c e)) (x_minus_const complex_ring (c e)))` [] THEN
    subgoal `!s:num. s IN S ==> ring_divides(x_poly complex_ring) (d s) (x_minus_const complex_ring (c s))` THENL [
      intro THEN
      have `c(s:num) IN ring_carrier complex_ring` [in_complex_ring] THEN
      have `ring_polynomial complex_ring (x_minus_const complex_ring (c(s:num)))` [x_minus_const_poly] THEN
      have `x_minus_const complex_ring (c(s:num)) IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
      case `s = e:num \/ s = f:num` THENL [
        have `d(s:num) = x_minus_const complex_ring (c s)` [] THEN
        specialize[`x_poly complex_ring`;`x_minus_const complex_ring (c(s:num))`]RING_DIVIDES_REFL THEN
        qed[]
      ; pass
      ] THEN
      have `d(s:num) = ring_1(x_poly complex_ring)` [] THEN
      specialize[`x_poly complex_ring`;`x_minus_const complex_ring (c(s:num))`]RING_DIVIDES_1 THEN
      qed[]
    ; pass
    ] THEN
    specialize[`x_poly complex_ring`;`d:num->(1->num)->complex`;`\i:num. x_minus_const complex_ring (c i):(1->num)->complex`;`S:num->bool`]ring_product_divides_factor_by_factor THEN
    have `integral_domain(x_poly complex_ring)` [integral_domain_x_poly_field;field_complex] THEN
    have `~(monic complex_ring (poly_0 complex_ring))` [monic_poly_0;field;field_complex] THEN
    have `~(p = ring_0(x_poly complex_ring))` [x_poly_use] THEN
    have `~ring_unit(x_poly complex_ring) (x_minus_const complex_ring (c(e:num)))` [x_minus_const_not_unit;integral_domain_complex] THEN
    proven_if `e = f:num` [] THEN
    have `ring_product (x_poly complex_ring) (S:num->bool) d = ring_mul (x_poly complex_ring) (x_minus_const complex_ring (c e)) (x_minus_const complex_ring (c(e:num)))` [] THEN
    have `!s:num. s IN S ==> c s IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `!s:num. s IN S ==> ring_polynomial complex_ring (x_minus_const complex_ring (c s))` [x_minus_const_poly] THEN
    specialize[`complex_ring`;`\i:num. x_minus_const complex_ring (c i)`;`S:num->bool`]poly_product_ring_product_x_poly THEN
    specialize_assuming[`S:num->bool`;`complex_ring`;`c:num->complex`]monic_vanishing_at THEN
    have `p = poly_product complex_ring S (\s:num. x_minus_const complex_ring (c s))` [] THEN
    have `ring_product (x_poly complex_ring) (S:num->bool) (\i. x_minus_const complex_ring (c i)) = p` [monic_vanishing_at] THEN
    have `ring_divides(x_poly complex_ring) (ring_mul (x_poly complex_ring) (x_minus_const complex_ring (c e)) (x_minus_const complex_ring (c(e:num)))) p` [] THEN
    specialize[`x_poly complex_ring`;`p:(1->num)->complex`;`x_minus_const complex_ring (c(e:num))`]not_squarefree_if_divisible_by_square THEN
    qed[]
  ; pass
  ] THEN
  specialize[`poly_deg complex_ring (p:(1->num)->complex)`]FINITE_NUMSEG_LT THEN
  have `FINITE (S:num->bool)` [] THEN
  have `FINITE (IMAGE (c:num->complex) S)` [FINITE_IMAGE] THEN
  specialize[`complex_ring`;`S:num->bool`;`c:num->complex`;`I:complex->complex`]monic_vanishing_at_image THEN
  qed[monic_vanishing_at_image;I_O_ID]
);;
```

### Informal statement
For any polynomial `p` from numbers to complex numbers, if `p` is a ring polynomial in the complex ring, `p` is squarefree in the complex ring, and `p` is monic in the complex ring, then there exists a set `S` of complex numbers such that `S` is finite and `p` is equal to the monic vanishing polynomial at `S` under the identity mapping `I`.

### Informal sketch
The proof establishes the existence of a finite set `S` of complex numbers such that a monic squarefree polynomial `p` over the complex numbers is equal to the monic vanishing polynomial at `S` under the identity mapping.
- First, assuming that `p` is a ring polynomial, squarefree, and monic in the complex ring, it introduces a function `c` that maps numbers to complex numbers such that `p` equals the monic vanishing polynomial at `{i | i < poly_deg complex_ring p}` over `c`.
- Then, defines a set `S` as `{i | i < poly_deg complex_ring p}` where `p` is viewed as a polynomial mapping numbers to complex numbers.
- It shows that `p` is equal to the monic vanishing polynomial at `S` over `c`.
- It demonstrates the existence of such a set by choosing `IMAGE (c:num->complex) S` as a witness.
- A key step involves proving that the function `c` is injective on `S`. To show injectivity, we introduce a function `d` and use the fact that `p` is squarefree to show that for every `e` and `f` in `S`, if `c e = c f`, then `e = f`. Suppose `e` and `f` are elements of `S` and `c e = c f`. Let `d` be a function such that if `j = e` or `j = f` then `d j = x_minus_const complex_ring (c e)` else `d j = ring_1(x_poly complex_ring)`. By `ring_product_delta_delta` we have `ring_product (x_poly complex_ring) S d = (if e = f:num then x_minus_const complex_ring (c e) else ring_mul (x_poly complex_ring) (x_minus_const complex_ring (c e)) (x_minus_const complex_ring (c e)))`. By `ring_product_divides_factor_by_factor` we have that `ring_product (x_poly complex_ring) S d ring_divides p`.
- Because p is monic, ring_polynomial and squarefree, by `not_squarefree_if_divisible_by_square` then `e= f`.
- Finally, it proves that `IMAGE (c:num->complex) S` is finite, and using `monic_vanishing_at_image;I_O_ID` that `p` is equal to the monic vanishing polynomial at `IMAGE (c:num->complex) S` with the identity mapping.

### Mathematical insight
The theorem states that a monic and squarefree polynomial over the complex numbers is uniquely determined by its roots. It leverages the fact that a squarefree polynomial has distinct roots, and monic vanishing polynomials are constructed from the roots with multiplicity one. The theorem essentially asserts that you can construct the polynomial given the set of its roots (without multiplicity). This is a fundamental property in field theory, especially for polynomials over algebraically closed fields like the complex numbers.

### Dependencies
- `ring_polynomial`
- `ring_squarefree`
- `monic`
- `FINITE`
- `monic_vanishing_at`
- `in_complex_ring`
- `x_poly_use`
- `x_minus_const_poly`
- `ring_product_delta_delta`
- `RING_DIVIDES_REFL`
- `RING_DIVIDES_1`
- `ring_product_divides_factor_by_factor`
- `integral_domain_x_poly_field`
- `field_complex`
- `monic_poly_0`
- `x_minus_const_not_unit`
- `integral_domain_complex`
- `poly_product_ring_product_x_poly`
- `monic_vanishing_at`
- `not_squarefree_if_divisible_by_square`
- `FINITE_IMAGE`
- `monic_vanishing_at_image`
- `I_O_ID`
- `FINITE_NUMSEG_LT`

### Porting notes (optional)
- The theorem relies heavily on algebraic properties specific to polynomial rings and fields, particularly the complex numbers. Ensure the target proof assistant has similar infrastructure or be prepared to develop it. The `monic_vanishing_at` definition and associated lemmas are crucial and must be ported accurately.
- In proof assistants with strong automation, such as Lean, many of the intermediate steps may be handled automatically. However, the core injectivity argument, which uses the squarefree premise, may require explicit guidance.


---

## QinC_monic_irreducible_complex_roots

### Name of formal statement
QinC_monic_irreducible_complex_roots

### Type of the formal statement
theorem

### Formal Content
```ocaml
let QinC_monic_irreducible_complex_roots = prove(`
  !p:(1->num)->complex.
  ring_polynomial QinC_ring p ==>
  ring_irreducible(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  ?S. FINITE S /\ p = monic_vanishing_at complex_ring S I
`,
  intro THEN
  have `UFD(x_poly QinC_ring)` [UFD_x_poly_QinC] THEN
  have `ring_prime(x_poly QinC_ring) p` [UFD_IRREDUCIBLE_EQ_PRIME] THEN
  have `ring_squarefree(x_poly QinC_ring) p` [ring_squarefree_if_prime] THEN
  have `ring_squarefree(x_poly complex_ring) p` [monic_QinC_squarefree_complex_squarefree] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `monic complex_ring (p:(1->num)->complex)` [monic_subring;subring_complex_QinC] THEN
  qed[monic_squarefree_complex_roots]
);;
```

### Informal statement
For every polynomial `p` from number to complex, if `p` is a polynomial over the QinC ring, `p` is irreducible with respect to the polynomial ring over the QinC ring, and `p` is monic with respect to the QinC ring, then there exists a finite set `S` of complex numbers such that `p` is equal to the monic polynomial that vanishes on `S` in the complex ring.

### Informal sketch
The proof shows that an irreducible monic polynomial `p` over the `QinC` ring is the monic vanishing polynomial of its roots in the complex numbers.
- First, we establish that the polynomial ring over `QinC` is a unique factorization domain (`UFD`).
- Since `p` is irreducible over `QinC`, it is also prime.
- Then, we show that `p` is squarefree over `QinC`.
- Since `p` is squarefree over `QinC` and monic, we show that it is also squarefree over the complex numbers.
- We also show that `p` is a polynomial over the complex ring.
- Because `p` is monic over the `QinC` ring, it remains monic over the complex ring.
- Finally, since `p` is monic and squarefree over the complex ring, it is the monic vanishing polynomial of its roots.

### Mathematical insight
This theorem connects abstract algebraic properties of polynomials (irreducibility, being monic) over the QinC numbers to their concrete behavior over the complex numbers, namely that they are determined by their roots. It leverages the fact that monic irreducible polynomials generate finite sets of roots in the complex numbers.

### Dependencies
- `UFD_x_poly_QinC`
- `UFD_IRREDUCIBLE_EQ_PRIME`
- `ring_squarefree_if_prime`
- `monic_QinC_squarefree_complex_squarefree`
- `poly_complex_if_poly_QinC`
- `monic_subring`
- `subring_complex_QinC`
- `monic_squarefree_complex_roots`


---

## complex_root

### Name of formal statement
- complex_root

### Type of the formal statement
- new_definition

### Formal Content
```ocaml
let complex_root = new_definition `
  complex_root p (z:complex)
  <=> poly_eval complex_ring p z = Cx(&0)
`;;
```
### Informal statement
- The complex number `z` is a complex root of the complex polynomial `p` if and only if the evaluation of the polynomial `p` over the complex ring at `z` is equal to the complex number 0.

### Informal sketch
- The definition `complex_root` introduces the concept of a complex root of a complex polynomial. It defines `complex_root p z` as equivalent to the evaluation of the polynomial `p` at the complex number `z` being equal to the complex zero `Cx(&0)`.
- No proof is required because it's a definition.

### Mathematical insight
- This definition formally defines the notion of a root of a complex polynomial. It connects the algebraic concept of a polynomial root with the evaluation of the polynomial in the complex ring. This is a fundamental concept in algebra and complex analysis.

### Dependencies
- Definitions:
  - `poly_eval`
  - `complex_ring`


---

## complex_root_ring

### Name of formal statement
complex_root_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_ring = prove(`
  !p z.
  complex_root p z
  <=> poly_eval complex_ring p z = ring_0 complex_ring
`,
  qed[complex_root;complex_ring_clauses]
);;
```
### Informal statement
For all polynomials `p` over the complex ring and for all complex numbers `z`, `z` is a complex root of `p` if and only if the evaluation of the polynomial `p` at `z` with respect to the complex ring operations is equal to the zero element of the complex ring.

### Informal sketch
The proof establishes the equivalence between the predicate `complex_root p z` and the equation `poly_eval complex_ring p z = ring_0 complex_ring`. `complex_root` likely unfolds to the definition of a root of a polynomial and then the proof uses clauses (`complex_ring_clauses`) related to the evaluation of polynomials over the complex ring (`poly_eval complex_ring p z`) and characterization of the zero element in the ring (`ring_0 complex_ring`).

### Mathematical insight
This theorem formally connects the algebraic definition of a root of a polynomial (a value that, when substituted into the polynomial, yields zero) with its evaluation within the framework of the complex ring. The theorem essentially states that a complex number, when evaluated in a polynomial using complex number arithmetic, equals zero if and only if the number is a root of the polynomial. This is a foundational result in algebra.

### Dependencies
- Definitions: `complex_root`, `poly_eval`, `ring_0`
- Theorems: `complex_ring_clauses`


---

## complex_root_divides

### Name of formal statement
- complex_root_divides

### Type of the formal statement
- theorem

### Formal Content
- Placeholder: 
```ocaml
let complex_root_divides = prove(`
  !p q.
  ring_divides(x_poly complex_ring) p q
  ==> complex_root p SUBSET complex_root q
`,
  rw[SUBSET;IN;complex_root_ring] THEN
  intro THEN
  choose `u:(1->num)->complex` `u IN ring_carrier(x_poly complex_ring) /\ q = ring_mul(x_poly complex_ring) p u` [ring_divides] THEN
  have `p IN ring_carrier(x_poly complex_ring)` [ring_divides] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [x_poly_use] THEN
  have `ring_polynomial complex_ring (u:(1->num)->complex)` [x_poly_use] THEN
  have `x IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`p:(1->num)->complex`;`u:(1->num)->complex`;`x:complex`]POLY_EVAL_MUL THEN
  simp[] THEN
  rw[GSYM x_poly_use] THEN
  simp[] THEN
  qed[RING_MUL_LZERO;POLY_EVAL]
);;
```

### Informal statement
- For all polynomials `p` and `q` with complex coefficients, `p` ring-divides `q` in the polynomial ring over the complex numbers if and only if the set of complex roots of `p` is a subset of the set of complex roots of `q`.

### Informal sketch
- The proof begins by expanding the definitions of `SUBSET` and `IN` and `complex_root_ring`.
- Assume that `p` ring-divides `q` in the polynomial ring over the complex numbers.
- By definition of ring divides, we chose a witness `u`, such that `u` is in the polynomial ring over the complex numbers and `q = p * u`.
- We have the hypothesis that `p` is in the carrier of the polynomial ring over the complex numbers.
- Deduce that `p` and `u` are ring polynomials over the complex numbers.
- Consider an arbitrary `x` such that `x` is in the carrier of complex ring
- Specialize the theorem `POLY_EVAL_MUL` with the hypothesis that `complex_ring`, `p`, `u` and `x` respectively.
- Simplify using `GSYM x_poly_use` and the fact that the polynomial evaluation of the zero polynomial is always zero `RING_MUL_LZERO`, and `POLY_EVAL`.
- Thus, the proof is complete.

### Mathematical insight
- This theorem states a fundamental relationship between polynomial division and the roots of polynomials in the complex numbers. It asserts that if one polynomial divides another, then the roots of the divisor must be a subset of the roots of the dividend. This is a crucial result in polynomial algebra and is used extensively in various areas of mathematics.

### Dependencies
- Definitions:
  - `SUBSET`
  - `IN`
  - `complex_root_ring`
  - `ring_divides`
  - `ring_carrier`
  - `ring_mul`
  - `x_poly`
  - `complex_ring`
  - `ring_polynomial`
- Theorems:
  - `x_poly_use`
  - `in_complex_ring`
  - `POLY_EVAL_MUL`
  - `RING_MUL_LZERO`
  - `POLY_EVAL`


---

## complex_root_associates

### Name of formal statement
complex_root_associates

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_associates = prove(`
  !p q.
  ring_associates(x_poly complex_ring) p q
  ==> complex_root p = complex_root q
`,
  qed[ring_associates;complex_root_divides;SUBSET_ANTISYM]
);;
```
### Informal statement
For all polynomials `p` and `q`, if `p` and `q` are associates in the ring of polynomials over the complex numbers, then the set of complex roots of `p` is equal to the set of complex roots of `q`.

### Informal sketch
- The proof shows that if two polynomials `p` and `q` are associates in the ring of polynomials over the complex numbers, implying `ring_associates(x_poly complex_ring) p q`, then they have the same complex roots, i.e., `complex_root p = complex_root q`.
- This involves demonstrating mutual inclusion, leveraging the definition of `ring_associates` and properties of polynomial division. Namely, if `p` and `q` are associates, then `p | q` and `q | p`.
- This implies, `complex_root_divides`, that `complex_root p SUBSET complex_root q` and `complex_root q SUBSET complex_root p`.
- Finally, `SUBSET_ANTISYM` is used to establish the equality of `complex_root p` and `complex_root q`.

### Mathematical insight
The theorem `complex_root_associates` states that if two polynomials are associates over the complex numbers, they have the same roots. Being associates means that each polynomial divides the other. This is a fundamental property in polynomial algebra, ensuring that polynomials that differ only by a multiplicative unit (a constant in the case of complex polynomials) share the same roots. This result is important because it allows us to simplify polynomial analysis by considering only one representative from each class of associated polynomials when studying roots.

### Dependencies
- Theorem: `ring_associates`
- Theorem: `complex_root_divides`
- Theorem: `SUBSET_ANTISYM`


---

## complex_root_le_deg

### Name of formal statement
complex_root_le_deg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_le_deg = prove(`
  !p.
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  (FINITE(complex_root p)
   /\ CARD(complex_root p) <= poly_deg complex_ring p
  )
`,
  GEN_TAC THEN REPEAT DISCH_TAC THEN
  recall integral_domain_complex THEN
  have `p IN ring_carrier(poly_ring complex_ring (:1))` [x_poly_use;x_poly] THEN
  have `~(p = ring_0(poly_ring complex_ring (:1)))` [x_poly_use;x_poly] THEN
  specialize[`complex_ring`;`p:(1->num)->complex`]POLY_ROOT_BOUND THEN
  subgoal `complex_root p = { x | x IN ring_carrier complex_ring /\ poly_eval complex_ring p x = ring_0 complex_ring}` THENL [
    rw[EXTENSION;IN;IN_ELIM_THM;complex_root_ring] THEN
    qed[complex_ring_clauses;UNIV]
  ; qed[]
  ]
);;
```

### Informal statement
For all `p`, if `p` is a ring polynomial over the complex numbers and `p` is not the zero polynomial, then the set of complex roots of `p` is finite and the cardinality of the set of complex roots of `p` is less than or equal to the degree of `p`.

### Informal sketch
The proof proceeds as follows:

- Assume `p` is a ring polynomial over the complex numbers and `p` is not the zero polynomial.
- Instantiate the theorem `POLY_ROOT_BOUND` (which states that the number of roots of a polynomial is bounded by its degree) with the complex numbers as the ring and `p` as the polynomial.
- To apply `POLY_ROOT_BOUND`, it is necessary to show that `complex_root p` is the set of roots of `p` in the `complex_ring`, which follows by rewriting the definition of `complex_root`.

### Mathematical insight
This theorem formalizes the fundamental algebraic fact that a polynomial over the complex numbers has at most as many roots as its degree. This is a key result in algebra and is essential for reasoning about the solutions of polynomial equations. The bound holds in any integral domain as demonstrated by the more general theorem `POLY_ROOT_BOUND`, but is here specialised to the field of complex numbers.

### Dependencies
- Theorems: `POLY_ROOT_BOUND`, `EXTENSION`, `IN`, `IN_ELIM_THM`
- Definitions: `complex_root_ring`, `complex_ring`
### Porting notes (optional)
This theorem depends on a suitable formalization of polynomials and abstract algebra including the notions of rings and integral domains. Ensure that the target proof assistant has libraries that formalize polynomials over a ring. In some systems, the `FINITE` and `CARD` predicates may be defined differently, or finiteness may be implicit in the definition of the root set. The key is to establish the appropriate bound on the size of the root set.


---

## complex_root_monic_vanishing_at

### Name of formal statement
complex_root_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_monic_vanishing_at = prove(`
  !S.
  FINITE S ==>
  complex_root (monic_vanishing_at complex_ring S I) = S
`,
  rw[FUN_EQ_THM] THEN
  rw[complex_root_ring] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    have `x IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `!s. s IN S ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[`complex_ring`;`S:complex->bool`;`I:complex->complex`;`x:complex`]eval_monic_vanishing_at THEN
    recall integral_domain_complex THEN
    have `ring_product complex_ring S (\s. ring_sub complex_ring x (I s)) = ring_0 complex_ring` [] THEN
    choose `s:complex` `s IN S /\ ring_sub complex_ring x (I s) = ring_0 complex_ring` [INTEGRAL_DOMAIN_PRODUCT_EQ_0] THEN
    have `x = I s:complex` [RING_SUB_EQ_0;in_complex_ring] THEN
    qed[IN;I_DEF]
  ; pass
  ] THEN
  intro THEN
  have `x:complex IN S` [IN] THEN
  have `!s. s IN S ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`S:complex->bool`;`I:complex->complex`;`x:complex`]eval_monic_vanishing_at_refl THEN
  qed[I_DEF]
);;
```
### Informal statement
For any set `S` of complex numbers, if `S` is finite, then the set of complex roots of the monic polynomial `monic_vanishing_at complex_ring S I` is equal to `S`, where `I` is a function mapping a complex number to itself.

### Informal sketch
The proof shows that the complex roots of the monic vanishing polynomial at S are exactly the elements of S.

*   The proof starts by rewriting using `FUN_EQ_THM` and `complex_root_ring`.
*   Then it proves that if `x` is a member of `S`, then `x` is a root of the polynomial `monic_vanishing_at complex_ring S I` and conversely if `x` is a root it must be in `S`. The proof splits to handle both directions of set equality.
*   First, assuming `x` is a root of `monic_vanishing_at complex_ring S I` it is shown that `x` must be in `S`.
    *   It specializes `eval_monic_vanishing_at` and uses the fact that the complex numbers form an integral domain, and consequently, the product of ring elements is zero only when one of the elements is zero. Thus there exists an `s` in `S` such that `x = I s : complex`. Given the definition of `I`, it is then shown that `x` is in `S`.
*   The second direction proves that any element in `S` is a root of the polynomial, using `IN`, `I_DEF`, and `eval_monic_vanishing_at_refl`.

### Mathematical insight
The theorem provides a fundamental connection between a finite set of complex numbers and a monic polynomial whose roots are exactly those numbers. The `monic_vanishing_at` polynomial is constructed in such a way that it vanishes precisely at elements of the given set `S`. This is important in algebraic number theory.

### Dependencies
- `FUN_EQ_THM`
- `complex_root_ring`
- `eval_monic_vanishing_at`
- `integral_domain_complex`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `RING_SUB_EQ_0`
- `eval_monic_vanishing_at_refl`
- `I_DEF`
- `IN`


---

## monic_vanishing_at_complex_root

### Name of formal statement
monic_vanishing_at_complex_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_vanishing_at_complex_root = prove(`
  !p.
  ring_polynomial complex_ring p ==>
  ring_squarefree(x_poly complex_ring) p ==>
  monic complex_ring p ==>
  monic_vanishing_at complex_ring (complex_root p) I = p
`,
  intro THEN
  choose `S:complex->bool` `FINITE S /\ p = monic_vanishing_at complex_ring S I` [monic_squarefree_complex_roots] THEN
  qed[complex_root_monic_vanishing_at]
);;
```
### Informal statement
For all polynomials `p`, if `p` is a polynomial over the complex numbers, `p` is squarefree when considered as a polynomial over the ring generated by `x` using operations from the complex numbers, and `p` is monic over the complex numbers, then `monic_vanishing_at complex_ring (complex_root p) I` is equal to `p`.

### Informal sketch
The proof proceeds as follows:

- Assume `p` is a ring polynomial over the complex numbers, `ring_squarefree(x_poly complex_ring) p` holds, and `p` is monic over the complex numbers.
- Choose a set `S` of complex numbers such that `FINITE S` and `p = monic_vanishing_at complex_ring S I`, using the theorem `monic_squarefree_complex_roots`.  In particular, `S` is the set of roots of `p`.
- The theorem `complex_root_monic_vanishing_at` is then applied to conclude the proof. This likely shows that the roots of `p`, represented as `complex_root p`, are the same set as `S`, thus implying the equality.

### Mathematical insight
This theorem states that for a monic, squarefree polynomial `p` over the complex numbers, the polynomial constructed by `monic_vanishing_at` using the ideal generated by `I` (likely representing `x`) and the roots of `p` is equal to the original polynomial `p`. This highlights the relationship between a polynomial and its roots in the context of complex numbers and ideals. It formalizes the idea that a monic, squarefree polynomial is uniquely determined by its roots.

### Dependencies
- Definitions: `ring_polynomial`, `ring_squarefree`, `monic`, `monic_vanishing_at`, `complex_ring`, `complex_root`, `x_poly`
- Theorems: `monic_squarefree_complex_roots`, `complex_root_monic_vanishing_at`


---

## complex_root_if_x_minus_const_divides

### Name of formal statement
complex_root_if_x_minus_const_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_if_x_minus_const_divides = prove(`
  !p z.
  ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) p ==>
  complex_root p z
`,
  intro THEN
  have `p IN ring_carrier(x_poly complex_ring)` [ring_divides] THEN
  choose `q:(1->num)->complex` `q IN ring_carrier(x_poly complex_ring) /\ p = ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) q` [ring_divides] THEN
  have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly;in_complex_ring] THEN
  have `ring_polynomial complex_ring (q:(1->num)->complex)` [x_poly_use] THEN
  specialize_assuming[`complex_ring`;`x_minus_const complex_ring z`;`q:(1->num)->complex`;`z:complex`]POLY_EVAL_MUL THEN
  have `poly_eval complex_ring p z = ring_mul complex_ring (poly_eval complex_ring (x_minus_const complex_ring z) z) (poly_eval complex_ring q z)` [in_complex_ring;x_poly_use] THEN
  simp[complex_root] THEN
  simp[eval_x_minus_const_refl;in_complex_ring] THEN
  simp[RING_MUL_LZERO;POLY_EVAL] THEN
  qed[complex_ring_clauses]
);;
```
### Informal statement
For all polynomials `p` over the complex numbers, and for all complex numbers `z`, if the polynomial `x - z` divides `p`, then `z` is a root of `p`.

### Informal sketch
The proof proceeds as follows:

- Assume `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) p`.
- From the assumption that `x - z` divides `p`, infer that there exists a polynomial `q` such that `p = (x - z) * q`.
- Show that `poly_eval complex_ring p z = ring_mul complex_ring (poly_eval complex_ring (x_minus_const complex_ring z) z) (poly_eval complex_ring q z)`.  This involves using the fact that polynomial evaluation is a ring homomorphism.
- Simplify the expression using the fact that `poly_eval complex_ring (x_minus_const complex_ring z) z = 0`.
- Consequently, `poly_eval complex_ring p z = 0`, which means `complex_root p z` holds, completing the proof.

### Mathematical insight
This theorem formalizes a fundamental result in complex analysis and algebra: if a polynomial `p` has a root `z`, then `x - z` is a factor of `p`. This result is crucial for understanding the relationship between roots and factors of polynomials, and it's a cornerstone for various polynomial factorization and root-finding algorithms.

### Dependencies
- Definitions:
  - `complex_root`
  - `ring_divides`
  - `x_poly`
  - `x_minus_const`
  - `ring_mul`
  - `poly_eval`
- Theorems:
  - `x_minus_const_poly`
  - `in_complex_ring`
  - `POLY_EVAL_MUL`
  - `eval_x_minus_const_refl`
  - `RING_MUL_LZERO`
  - `POLY_EVAL`
  - `complex_ring_clauses`


---

## complex_root_x_pow

### Name of formal statement
complex_root_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_x_pow = prove(`
  !n.
  complex_root(x_pow QinC_ring n)
  = if n = 0 then {} else {Cx(&0)}
`,
  intro THEN
  rw[x_pow_QinC_eq_x_pow_complex] THEN
  case `n = 0` THENL [
    simp[EXTENSION;EMPTY;IN_ELIM_THM;IN;complex_root] THEN
    simp[eval_x_pow;in_complex_ring;RING_POW_0] THEN
    qed[ring_1_0_complex;complex_ring_clauses]
  ; pass
  ] THEN
  simp[EXTENSION;IN_SING] THEN
  simp[IN;complex_root] THEN
  intro THEN
  simp[eval_x_pow;in_complex_ring] THEN
  qed[COMPLEX_POW_EQ_0;ring_pow_complex]
);;
```
### Informal statement
For all natural numbers `n`, the set of complex roots of the polynomial `x^n` (where `x` is in the complex numbers) is equal to the empty set if `n` is 0, otherwise it's the singleton set containing the complex number 0.

### Informal sketch
The proof proceeds by induction on `n`.
- **Base Case (n = 0):**
  - Simplify the definition of `complex_root`.
  - Reduce `x^0` to 1 in the complex ring.
  - Show that the set of roots of 1 is the empty set, since 1 is never equal to 0 in the complex numbers.
- **Inductive Step (n > 0):**
  - Simplify the definition of `complex_root`.
  - Reduce the problem of finding complex roots of `x^n` to checking when `x^n` equals 0 in the complex ring.
  - Apply the theorem `COMPLEX_POW_EQ_0` and `ring_pow_complex` to show that x^n = 0 if and only if x = 0.
  - Therefore, the roots of `x^n` when `n > 0` are just {0}.

### Mathematical insight
This theorem characterizes the solutions of the polynomial equation `x^n = 0` in the complex field. When `n` is zero, the equation becomes `1 = 0`, which has no solution. When `n` is a positive integer, the only complex solution to `x^n = 0` is `x = 0`. This is a fundamental result in complex analysis and algebra.

### Dependencies
- Definitions: `complex_root`, `x_pow`, `QinC_ring`
- Theorems: `x_pow_QinC_eq_x_pow_complex`, `EXTENSION`, `EMPTY`, `IN_ELIM_THM`, `IN`, `eval_x_pow`, `in_complex_ring`, `RING_POW_0`, `ring_1_0_complex`, `complex_ring_clauses`, `IN_SING`, `COMPLEX_POW_EQ_0`, `ring_pow_complex`

### Porting notes (optional)
- The tactics `case` and `THENL` are used for case splitting.
- The simplifications rely on the ring structure of complex numbers. Ensure the target system has similar ring simplification capabilities or rewrite rules.
- `COMPLEX_POW_EQ_0` is crucial for the inductive step and should be ported or proven in the target system.


---

## complex_root_x_minus_const

### Name of formal statement
complex_root_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_x_minus_const = prove(`
  !c.
  complex_root(x_minus_const complex_ring c)
  = {c}
`,
  intro THEN
  rw[EXTENSION;IN_SING;IN;complex_root] THEN
  intro THEN
  simp[eval_x_minus_const;in_complex_ring;complex_ring_clauses;ring_sub_complex] THEN
  CONV_TAC COMPLEX_FIELD
);;
```

### Informal statement
For any complex number `c`, the set of complex roots of the polynomial `x - c` (considered as a polynomial with coefficients in the complex numbers) is equal to the singleton set containing `c`.

### Informal sketch
The proof demonstrates that the set of complex roots of the polynomial `x - c` is `{c}`.

- First, introduce the variable `c`.
- Then, rewrite the statement using the definitions of `EXTENSION`, `IN_SING`, `IN`, and `complex_root`, which expands the definition of roots and set membership.
- Introduce a variable representing a complex number, say `z`.
- Simplify using the definition of `eval_x_minus_const`, the ring properties encapsulated within `in_complex_ring`, `complex_ring_clauses`, and `ring_sub_complex`. This will reduce the root condition to `z - c = 0`.
- Finally, apply a field tactic `COMPLEX_FIELD` to solve `z - c = 0` for `z`, which simplifies to `z = c`.

### Mathematical insight
This theorem states that the only root of the linear polynomial `x - c` is `c` itself. This is a fundamental result in polynomial algebra, especially when working with complex numbers, as the field of complex numbers is algebraically closed.

### Dependencies
- Definitions: `complex_root`, `x_minus_const`, `complex_ring`, `in_complex_ring`, `ring_sub_complex`, `eval_x_minus_const`
- Theorems/Definitions used implicitly through tactics: `EXTENSION`, `IN_SING`, `IN`

### Porting notes (optional)
- The tactic `CONV_TAC COMPLEX_FIELD` is specific to HOL Light, and it performs field simplification. When porting, the corresponding field decision procedure of the target proof assistant should be applied. Alternatively, one can manually apply the field axioms to achieve the same result.


---

## not_coprime_QinC_if_shared_complex_root

### Name of formal statement
not_coprime_QinC_if_shared_complex_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let not_coprime_QinC_if_shared_complex_root = prove(`
  !z:complex p q.
  complex_root p z ==>
  complex_root q z ==>
  ~(ring_coprime(x_poly QinC_ring) (p,q))
`,
  intro THEN
  have `PID(x_poly QinC_ring)` [PID_x_poly_QinC] THEN
  have `bezout_ring(x_poly QinC_ring)` [PID_IMP_BEZOUT_RING] THEN
  choose2 `x:(1->num)->complex` `y:(1->num)->complex` `x IN ring_carrier(x_poly QinC_ring) /\ y IN ring_carrier(x_poly QinC_ring) /\ ring_add(x_poly QinC_ring) (ring_mul(x_poly QinC_ring) p x) (ring_mul(x_poly QinC_ring) q y) = ring_1(x_poly QinC_ring)` [BEZOUT_RING_COPRIME] THEN
  have `ring_polynomial QinC_ring (x:(1->num)->complex)` [x_poly_use] THEN
  have `ring_polynomial QinC_ring (y:(1->num)->complex)` [x_poly_use] THEN
  have `ring_polynomial QinC_ring (p:(1->num)->complex)` [ring_coprime;x_poly_use] THEN
  have `ring_polynomial QinC_ring (q:(1->num)->complex)` [ring_coprime;x_poly_use] THEN
  have `ring_polynomial complex_ring (x:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (y:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (q:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring p x:(1->num)->complex)` [RING_POLYNOMIAL_MUL] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring q y:(1->num)->complex)` [RING_POLYNOMIAL_MUL] THEN
  have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[
    `complex_ring`;
    `p:(1->num)->complex`;
    `x:(1->num)->complex`;
    `z:complex`
  ]POLY_EVAL_MUL THEN
  have `poly_eval complex_ring (poly_mul complex_ring p x) z = Cx(&0)` [complex_root;complex_ring_clauses;COMPLEX_MUL_LZERO] THEN
  specialize[
    `complex_ring`;
    `q:(1->num)->complex`;
    `y:(1->num)->complex`;
    `z:complex`
  ]POLY_EVAL_MUL THEN
  have `poly_eval complex_ring (poly_mul complex_ring q y) z = Cx(&0)` [complex_root;complex_ring_clauses;COMPLEX_MUL_LZERO] THEN
  specialize[
    `complex_ring`;
    `poly_mul complex_ring p x:(1->num)->complex`;
    `poly_mul complex_ring q y:(1->num)->complex`;
    `z:complex`
  ]POLY_EVAL_ADD THEN
  have `poly_eval complex_ring (poly_add complex_ring (poly_mul complex_ring p x) (poly_mul complex_ring q y)) z = Cx(&0)` [COMPLEX_ADD_LID;complex_ring_clauses] THEN
  have `poly_mul complex_ring p x = poly_mul QinC_ring p x:(1->num)->complex` [poly_mul_subring;subring_complex_QinC;ring_polynomial] THEN
  have `poly_mul complex_ring q y = poly_mul QinC_ring q y:(1->num)->complex` [poly_mul_subring;subring_complex_QinC;ring_polynomial] THEN
  have `poly_add complex_ring (poly_mul complex_ring p x) (poly_mul complex_ring q y) = poly_add QinC_ring (poly_mul QinC_ring p x) (poly_mul QinC_ring q y):(1->num)->complex` [poly_add_subring;subring_complex_QinC;ring_polynomial] THEN
  subgoal `poly_add QinC_ring (poly_mul QinC_ring p x) (poly_mul QinC_ring q y):(1->num)->complex = poly_1 complex_ring` THENL [
    rw[GSYM poly_1_QinC_eq_poly_1_complex] THEN
    rw[x_poly_use] THEN
    qed[]
  ; pass
  ] THEN
  have `poly_eval complex_ring (poly_1 complex_ring) z = Cx(&0)` [] THEN
  have `poly_eval complex_ring (poly_1 complex_ring) z = Cx(&1)` [POLY_EVAL_1;complex_ring_clauses] THEN
  complex_field_fact `~(Cx(&0) = Cx(&1))` THEN
  qed[]
);;
```

### Informal statement
For all complex numbers `z` and polynomials `p` and `q` with coefficients in the rational complex numbers, if `z` is a root of `p` and `z` is a root of `q`, then `p` and `q` are not coprime in the ring of polynomials with coefficients in the rational complex numbers.

### Informal sketch
The proof proceeds by contradiction.
- Assume that `p` and `q` are coprime.
- Since the ring of polynomials with rational complex coefficients (denoted `x_poly QinC_ring`) is a PID (`PID(x_poly QinC_ring)`), it is also a Bezout ring (`bezout_ring(x_poly QinC_ring)`).
- From the Bezout property, we can choose polynomials `x` and `y` in `x_poly QinC_ring` such that `p * x + q * y = 1` in `x_poly QinC_ring`.
- Since `p` and `q` are polynomials with coefficients in `QinC`, also `x` and `y` are polynomials with coefficients in `QinC`. Then `x`, `y`, `p`, `q` are polynomials with coefficients in Complex numbers.
- Evaluate `p * x + q * y` at `z`.  Since `z` is a root of both `p` and `q`, `p(z) = 0` and `q(z) = 0`. Thus, `(p * x)(z) = 0` and `(q * y)(z) = 0`, so `(p * x + q * y)(z) = 0 + 0 = 0`.
- But `p * x + q * y = 1`, so `(p * x + q * y)(z) = 1(z) = 1`.
- Then `0 = 1` in the complex field, which is a contradiction. This relies on `poly_1_QinC_eq_poly_1_complex` which states a polynomial that is 1 in `QinC` is also 1 in the complex numbers.

### Mathematical insight
This theorem states that if two polynomials share a common root, they cannot be coprime. This is a fundamental property in polynomial algebra.  The fact that polynomials with coefficients in QinC (complex rationals) form a PID is used in the proof.

### Dependencies
- `PID(x_poly QinC_ring)`
- `bezout_ring(x_poly QinC_ring)`
- `BEZOUT_RING_COPRIME`
- `ring_polynomial QinC_ring (x:(1->num)->complex)`
- `ring_polynomial QinC_ring (y:(1->num)->complex)`
- `ring_polynomial QinC_ring (p:(1->num)->complex)`
- `ring_polynomial QinC_ring (q:(1->num)->complex)`
- `ring_polynomial complex_ring (x:(1->num)->complex)`
- `ring_polynomial complex_ring (y:(1->num)->complex)`
- `ring_polynomial complex_ring (p:(1->num)->complex)`
- `ring_polynomial complex_ring (q:(1->num)->complex)`
- `RING_POLYNOMIAL_MUL`
- `in_complex_ring`
- `POLY_EVAL_MUL`
- `complex_root`
- `COMPLEX_MUL_LZERO`
- `POLY_EVAL_ADD`
- `COMPLEX_ADD_LID`
- `poly_mul_subring`
- `subring_complex_QinC`
- `ring_polynomial`
- `poly_add_subring`
- `GSYM poly_1_QinC_eq_poly_1_complex`
- `POLY_EVAL_1`
- `complex_field_fact`


---

## complex_root_minimal_polynomial_refl

### Name of formal statement
complex_root_minimal_polynomial_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_minimal_polynomial_refl = prove(`
  !z:complex.
  complex_root (minimal_polynomial z) z
`,
  rw[complex_root] THEN
  qed[maybe_algebraic_minimal_polynomial]
);;
```

### Informal statement
For all complex numbers `z`, `z` is a complex root of its minimal polynomial.

### Informal sketch
The proof proceeds as follows:
- Unfold `complex_root` by rewriting the definition.
- This leaves us to prove `(minimal_polynomial z) z = &0`.
- Apply/conclude using the theorem `maybe_algebraic_minimal_polynomial`. This theorem states that if `z` is an algebraic complex number, its minimal polynomial evaluated at `z` yields 0.

### Mathematical insight
The theorem states a fundamental property of the minimal polynomial of a complex number: it vanishes at the number itself. The minimal polynomial is the unique monic polynomial of smallest degree that has the number as a root. This is a key property when studying field extensions and algebraic numbers.

### Dependencies
- Definitions:
  - `complex_root`
- Theorems:
  - `maybe_algebraic_minimal_polynomial`


---

## minimal_polynomial_divides

### Name of formal statement
minimal_polynomial_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let minimal_polynomial_divides = prove(`
  !z:complex p:(1->num)->complex.
  algebraic_number z ==>
  ring_polynomial QinC_ring p ==>
  ( ring_divides(x_poly QinC_ring) (minimal_polynomial z) p
    <=> complex_root p z
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    specialize[
      `minimal_polynomial z`;
      `p:(1->num)->complex`
    ]ring_divides_poly_complex_if_ring_divides_poly_QinC THEN
    have `complex_root (minimal_polynomial z) SUBSET complex_root p` [complex_root_divides] THEN
    qed[SUBSET;IN;complex_root_minimal_polynomial_refl]
  ;
    intro THEN
    have `ring_polynomial QinC_ring (minimal_polynomial z) /\ ~((minimal_polynomial z) = poly_0 QinC_ring) /\ monic QinC_ring (minimal_polynomial z) /\ ring_irreducible (x_poly QinC_ring) (minimal_polynomial z) /\ poly_eval complex_ring (minimal_polynomial z) z = Cx (&0)` [algebraic_has_minimal_polynomial] THEN
    have `~ring_coprime (x_poly QinC_ring) (minimal_polynomial z,p)` [not_coprime_QinC_if_shared_complex_root;complex_root] THEN
    recall integral_domain_x_poly_QinC THEN
    have `minimal_polynomial z IN ring_carrier(x_poly QinC_ring)` [x_poly_use] THEN
    have `p IN ring_carrier(x_poly QinC_ring)` [x_poly_use] THEN
    have `ring_prime(x_poly QinC_ring) (minimal_polynomial z)` [prime_iff_irreducible_over_field;field_QinC] THEN
    specialize[
      `x_poly QinC_ring`;
      `minimal_polynomial z`;
      `p:(1->num)->complex`
    ]INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME THEN
    qed[]
  ]
);;
```
### Informal statement
For all complex numbers `z` and polynomials `p` over the complex numbers, if `z` is an algebraic number, and `p` is a polynomial in the ring of polynomials QinC, then `p` is divisible by the minimal polynomial of `z` in the ring of polynomials QinC if and only if `z` is a complex root of `p`.

### Informal sketch
The proof proceeds by proving the equivalence as two implications.

*   **Forward implication:** Assuming `algebraic_number z` and `ring_polynomial QinC_ring p`, and that `ring_divides (x_poly QinC_ring) (minimal_polynomial z) p` holds, show that `complex_root p z`.
    *   Use `ring_divides_poly_complex_if_ring_divides_poly_QinC` to deduce that `complex_root (minimal_polynomial z) SUBSET complex_root p`.
    *   From `algebraic_number z` and the definition of `minimal_polynomial`, we have that `complex_root (minimal_polynomial z) z`.
    *   Conclude that `complex_root p z`.

*   **Backward implication:** Assuming `algebraic_number z` and `ring_polynomial QinC_ring p`, and that `complex_root p z` holds, show that `ring_divides (x_poly QinC_ring) (minimal_polynomial z) p`.
    *   Establish that `minimal_polynomial z` is a non-zero, monic, irreducible polynomial in the ring of polynomials QinC, and that `poly_eval complex_ring (minimal_polynomial z) z = Cx (&0)` using `algebraic_has_minimal_polynomial`.
    *   Show that `minimal_polynomial z` and `p` share a root, `z` hence they are not coprime using `not_coprime_QinC_if_shared_complex_root`.
    *   Recall that `x_poly QinC_ring`, the polynomial ring over QinC, forms an integral domain.
    *   Note that both `minimal_polynomial z` and `p` are in the carrier of `x_poly QinC_ring`.
    *   Establish `ring_prime(x_poly QinC_ring) (minimal_polynomial z)` using `prime_iff_irreducible_over_field` and the fact that `field_QinC`.
    *   Apply `INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME` to conclude that `ring_divides (x_poly QinC_ring) (minimal_polynomial z) p`.

### Mathematical insight
This theorem states a fundamental property of the minimal polynomial of an algebraic number: it divides any polynomial that has the algebraic number as a root. The equivalence between these two conditions provides an important characterization of the minimal polynomial.

### Dependencies
*   `algebraic_number`
*   `ring_polynomial`
*   `ring_divides`
*   `x_poly`
*   `minimal_polynomial`
*   `complex_root`
*   `ring_divides_poly_complex_if_ring_divides_poly_QinC`
*   `complex_root_minimal_polynomial_refl`
*   `algebraic_has_minimal_polynomial`
*   `not_coprime_QinC_if_shared_complex_root`
*   `INTEGRAL_DOMAIN_PRIME_DIVIDES_OR_COPRIME`
*   `prime_iff_irreducible_over_field`
*   `field_QinC`
*   `integral_domain_x_poly_QinC`

**Ring Theory:**
*   `x_poly_use`

### Porting notes (optional)
*   Ensure that the target proof assistant has a well-developed theory of polynomial rings and algebraic numbers.
*   The tactic `splitiff` is used for splitting the iff statement into two implications. Proof assistants like Lean provides `iff.intro` or similar tactics to achieve these implications separately.
*   The handling of polynomial rings and their properties may vary between proof assistants, requiring careful adaptation of the HOL Light definitions and theorems. For instance, ensure irreducibility, coprimality and division in polynomial rings are correctly translated.


---

## complex_root_powersums

### Name of formal statement
complex_root_powersums

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let complex_root_powersums = new_definition `
  complex_root_powersums p n
  = ring_sum complex_ring (complex_root p) (\z. z pow n)
`;;
```
### Informal statement
The function `complex_root_powersums` takes a complex polynomial `p` and a natural number `n` as input, and it returns the sum, in the complex ring, of the `n`-th powers of the complex roots of the polynomial `p`. More formally, it computes the ring sum over the roots `z` of `p` (i.e., such that `p(z) = 0`) of the complex numbers `z` raised to the power of `n`.

### Informal sketch
The definition introduces `complex_root_powersums` as a direct application of `ring_sum`.
- `complex_root p` represents the set of complex roots of polynomial `p`.
- The function `\z. z pow n` takes a complex number `z` and returns `z` raised to the power of `n`.
- `ring_sum complex_ring (complex_root p) (\z. z pow n)` then sums the `n`-th powers of the roots of the polynomial `p` in the `complex_ring`.

### Mathematical insight
This definition introduces a function to compute the sum of the `n`-th powers of the roots of a complex polynomial. This is a fundamental quantity in the study of polynomials and their roots, related to Vieta's formulas and Newton's identities. It is often used in algebraic manipulation and root-finding algorithms.

### Dependencies
- **Definitions**: `complex_ring`, `complex_root`, `ring_sum`, `pow`


---

## complex_root_powersums_ring

### Name of formal statement
complex_root_powersums_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_powersums_ring = prove(`
  !p n.
  complex_root_powersums p n
  = ring_sum complex_ring (complex_root p) (\z. ring_pow complex_ring z n)
`,
  rw[complex_root_powersums;ring_pow_complex]
);;
```
### Informal statement
For all polynomials `p` over the complex numbers and for all natural numbers `n`, the power sum of order `n` of the roots of `p` is equal to the ring sum, over the complex numbers, of `z^n` where `z` ranges over the roots of `p`.

### Informal sketch
The proof proceeds by rewriting the formula using the definitions of `complex_root_powersums` and `ring_pow_complex`.

### Mathematical insight
This theorem relates two ways of mathematically expressing the power sums of roots of polynomials. `complex_root_powersums` is the function that directly computes the power sum as the sum of the n-th power of roots of `p`, while the right-hand-side explicitly expresses a ring sum within the field of complex numbers. The relationship helps to reason about and manipulate expressions involving these power sums within the algebraic framework of complex numbers.

### Dependencies
- Definitions: `complex_root_powersums`, `ring_pow_complex`


---

## complex_root_powersums_QinC_monic_irreducible_QinC

### Name of formal statement
complex_root_powersums_QinC_monic_irreducible_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_powersums_QinC_monic_irreducible_QinC = prove(`
  !(p:(1->num)->complex) n.
  ring_polynomial QinC_ring p ==>
  ring_irreducible(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  complex_root_powersums p n IN QinC
`,
  rw[complex_root_powersums_ring] THEN
  intro THEN
  recall subring_complex_QinC THEN
  have `!n. coeff n p IN ring_carrier(QinC_ring)` [coeff_poly_in_ring] THEN
  choose `S:complex->bool` `FINITE S /\ p = monic_vanishing_at complex_ring S I` [QinC_monic_irreducible_complex_roots] THEN
  have `complex_root p = S` [complex_root_monic_vanishing_at] THEN
  have `FINITE (complex_root p)` [] THEN
  have `!s. s IN complex_root p ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `!n. coeff n (monic_vanishing_at complex_ring (complex_root p) I) IN ring_carrier(subring_generated complex_ring QinC)` [coeff_poly_in_ring] THEN
  specialize[`complex_ring`;`QinC`;`complex_root p`;`I:complex->complex`;`n:num`]powersums_subring_if_poly_subring THEN
  have `!z. z IN complex_root p ==> ring_pow complex_ring z n = ring_pow complex_ring (I z) n` [I_DEF] THEN
  specialize[`complex_ring`;`\z. ring_pow complex_ring z n`;`\z. ring_pow complex_ring (I z) n`;`complex_root p`]RING_SUM_EQ THEN
  qed[QinC_ring_clauses]
);;
```
### Informal statement
For all polynomials `p` from numbers to complex numbers and all natural numbers `n`, if `p` is a ring polynomial over the field of rationals extended with `i` (denoted `QinC`), `p` is irreducible as a polynomial over `QinC`, and `p` is monic as a polynomial over `QinC`, then the `n`-th power sum of the complex roots of `p` is in `QinC`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `complex_root_powersums_ring` to reduce the goal to showing that `complex_root_powersums p n` is in `ring_carrier(subring_generated complex_ring QinC)`.
- Introduce the assumptions.
- Recall that `QinC` is a subring of the complex numbers using `subring_complex_QinC`.
- State that if `p` is in `ring_polynomial QinC_ring`, then for all `n`, the coefficient `n` of `p` is in `ring_carrier(QinC_ring)` by `coeff_poly_in_ring`.
- Choose a set `S : complex -> bool` of roots to make `p` equal to `monic_vanishing_at complex_ring S I` using `QinC_monic_irreducible_complex_roots`. This uses the crucial fact that since `p` is irreducible over `QinC`, it splits completely into linear factors in the complex numbers.
- Deduce that `complex_root p = S` with `complex_root_monic_vanishing_at`.
- Deduce that `S` is finite
- Show each `s` in `complex_root p` implies `I s` is in the carrier of `complex_ring` using `in_complex_ring`.
- Show that for all `n`, the coefficient of `n` of `monic_vanishing_at complex_ring (complex_root p) I` is in `ring_carrier(subring_generated complex_ring QinC)` using `coeff_poly_in_ring`.
- Specialize the theorem `powersums_subring_if_poly_subring` to the case of `complex_ring`, `QinC`, `complex_root_p`, `I`, and `n`.
- Show that for all `z` in `complex_root p`, `ring_pow complex_ring z n = ring_pow complex_ring (I z) n` by `I_DEF`.
- Specialize `RING_SUM_EQ`
- QED.

### Mathematical insight
The theorem states that if a polynomial `p` with coefficients in `QinC` is monic and irreducible over `QinC`, then the power sums of the complex roots of `p` are also in `QinC`. This is a significant result in algebraic number theory. It exploits the Galois symmetry of the roots in an essential way: since the Galois group of `QinC` is isomorphic to `Z/2Z`, and is generated by the complex conjugation `I`, the invariants of `I` are real. The power sums of the roots generate a subfield of a Galois extension; if the polynomial is irreducible then the power sums are invariant under action of the Galois group. In our case, the Galois group only contains complex conjugation, and so if the polynomial is invariant under complex conjugation, then it is real.

### Dependencies
- `complex_root_powersums_ring`
- `subring_complex_QinC`
- `QinC_monic_irreducible_complex_roots`
- `complex_root_monic_vanishing_at`
- `in_complex_ring`
- `powersums_subring_if_poly_subring`
- `I_DEF`
- `RING_SUM_EQ`
- `QinC_ring_clauses`
- `coeff_poly_in_ring`

### Porting notes (optional)
This theorem relies heavily on the algebraic structure of complex numbers and polynomials over rings. The `QinC` type represents `Q(i)`, which is the field extension of the rational numbers by the imaginary unit `i`. Porting to another proof assistant will require defining this field and its ring structure, as well as the concept of irreducibility and monic polynomials within that ring. The main challenge will be to prove `QinC_monic_irreducible_complex_roots` that decomposes a `QinC` irreducible polynomial into linear factors over the complex numbers.


---

## complex_root_powersums_QinC_monic_irreducible_ZinC

### Name of formal statement
complex_root_powersums_QinC_monic_irreducible_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let complex_root_powersums_QinC_monic_irreducible_ZinC = prove(`
  !(p:(1->num)->complex) D n.
  ring_polynomial QinC_ring p ==>
  ring_irreducible(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  (!i. D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  D pow n * complex_root_powersums p n IN ZinC
`,
  rw[complex_root_powersums_ring] THEN
  intro THEN
  recall subring_complex_empty THEN
  choose `S:complex->bool` `FINITE S /\ p = monic_vanishing_at complex_ring S I` [QinC_monic_irreducible_complex_roots] THEN
  have `complex_root p = S` [complex_root_monic_vanishing_at] THEN
  have `~(ring_1 complex_ring = ring_0 complex_ring)` [field_complex;field] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  recall subring_complex_QinC THEN
  have `monic complex_ring (p:(1->num)->complex)` [monic_subring] THEN
  have `~(p:(1->num)->complex = poly_0 complex_ring)` [monic_poly_0;field_complex;field] THEN
  have `FINITE (complex_root p)` [complex_root_le_deg] THEN
  have `poly_deg complex_ring (p:(1->num)->complex) = CARD(S:complex->bool)` [deg_monic_vanishing_at;in_complex_ring] THEN
  have `!s. s IN complex_root p ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
  subgoal `!n. ring_mul complex_ring (ring_pow complex_ring D n) (coeff (CARD(complex_root p) - n) (monic_vanishing_at complex_ring (complex_root p) I)) IN ring_carrier(subring_generated complex_ring {})` THENL [
    simp[complex_ring_clauses;ring_pow_complex;ZinC_ring_clauses] THEN
    qed[]
  ; pass
  ] THEN
  have `D IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`{}:complex->bool`;`complex_root p`;`I:complex->complex`;`D:complex`;`n:num`]powersums_subring_if_poly_subring_denominators THEN
  have `(D pow n) * (ring_sum complex_ring (complex_root p) (\s. ring_pow complex_ring (I s) n)) IN ring_carrier (subring_generated complex_ring {})` [complex_ring_clauses;ring_pow_complex] THEN
  have `(D pow n) * (ring_sum complex_ring (complex_root p) (\s. ring_pow complex_ring (I s) n)) IN ZinC` [ZinC_ring_clauses] THEN
  have `!s. ring_pow complex_ring (I s) n = ring_pow complex_ring s n` [I_DEF;ring_pow_complex] THEN
  qed[RING_SUM_EQ]
);;
```
### Informal statement
For all `p`, `D`, and `n`, where `p` is a polynomial over the subring of complexes that are rational on the imaginary part (QinC_ring), `p` is irreducible over this subring, `p` is monic over this subring; and for all `i`, the `i`-th power of `D` multiplied by the coefficient of `x^(deg(p) - i)` in `p` belongs to ZinC; then the `n`-th power of `D` multiplied by the `n`-th power sum of the complex roots of `p` belongs to ZinC.

### Informal sketch
*   The proof starts by rewriting `complex_root_powersums p n` using `complex_root_powersums_ring`.
*   Then the structure of the goal is simplified using `intro`.
*   The subring `complex` is recalled to be non-empty by using `subring_complex_empty`. Then we choose a finite set `S` such that `p` is equal to a `monic_vanishing_at complex_ring S I`, where `I s` is the complex number obtained putting `s` on the imaginary part.
*   The next step proves that the complex roots of `p` equal `S` by using `complex_root_monic_vanishing_at`.
*   Then we proceed by proving that `complex_ring` is a non-trivial ring by using `field_complex;field`.
*   Then, that `p` is a polynomial over the ring of complexes by using `poly_complex_if_poly_QinC`.
*   Then, recall that `complex_ring` contains `QinC_ring` by using `subring_complex_QinC`.
*   Then, prove that polynomial `p` is monic over the ring of complexes by using `monic_subring`.
*   Then, prove that `p` is non-zero by using `monic_poly_0;field_complex;field`.
*   Then, prove that the set of complex roots of `p` is finite by using `complex_root_le_deg`.
*   Then, prove that the degree of `p` is equal to the cardinality of the set `S` by using `deg_monic_vanishing_at;in_complex_ring`.
*   Then, show that `I s` belong to the carrier set of the ring of complex numbers by using `in_complex_ring`.
*   Then, show that `(D pow n) * (coeff (CARD(complex_root p) - n) (monic_vanishing_at complex_ring (complex_root p) I))` belongs to `ZinC` using `simp[complex_ring_clauses;ring_pow_complex;ZinC_ring_clauses]`.
*   Then, show that `D` belongs to the carrier set of the ring of complexes by using `in_complex_ring`.
*   Then we prove `powersums_subring_if_poly_subring_denominators`.
*   Then, show that `(D pow n) * (ring_sum complex_ring (complex_root p) (\s. ring_pow complex_ring (I s) n))` belongs to `ZinC` by using `complex_ring_clauses;ring_pow_complex`.
*   The equivalence between `ring_pow complex_ring (I s) n` and `ring_pow complex_ring s n` is shown using `I_DEF;ring_pow_complex`.
*   Use `RING_SUM_EQ` to close the goal.

### Mathematical insight
This theorem establishes that if a monic polynomial `p` with coefficients related to scaled integer coefficients is irreducible over QinC, then a scaled power sum of its complex roots also belongs to the integers.

### Dependencies
*   `complex_root_powersums_ring`
*   `subring_complex_empty`
*   `QinC_monic_irreducible_complex_roots`
*   `complex_root_monic_vanishing_at`
*   `field_complex`
*   `field`
*   `poly_complex_if_poly_QinC`
*   `subring_complex_QinC`
*   `monic_subring`
*   `monic_poly_0`
*   `complex_root_le_deg`
*   `deg_monic_vanishing_at`
*   `in_complex_ring`
*   `complex_ring_clauses`
*   `ring_pow_complex`
*   `ZinC_ring_clauses`
*   `powersums_subring_if_poly_subring_denominators`
*   `I_DEF`
*   `RING_SUM_EQ`


---

## denominator_if_monic_QinC

### Name of formal statement
denominator_if_monic_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let denominator_if_monic_QinC = prove(`
  !(p:(1->num)->complex).
  ring_polynomial QinC_ring p ==>
  monic QinC_ring p ==>
  ?D. D IN ZinC /\
      ~(D = Cx(&0)) /\
      (!i. D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC)
`,
  intro THEN
  def `n:num` `poly_deg complex_ring (p:(1->num)->complex)` THEN
  have `FINITE (0..n)` [FINITE_NUMSEG] THEN
  have `!i. i IN 0..n ==> coeff (n-i) p IN QinC` [coeff_poly_in_ring;QinC_ring_clauses] THEN
  specialize[`0..n`;`\i. coeff (n-i) p:complex`]multi_QinC_to_ZinC THEN
  choose `d:num` `~(d = 0) /\ !i. i IN 0..n ==> Cx(&d) * (coeff (n-i) p) IN ZinC` [] THEN
  witness `Cx(&d)` THEN
  have `Cx(&d) IN ZinC` [num_in_ZinC] THEN
  intro THENL [
    qed[]
  ;
    have `~(&d = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&d) = Cx(&0))` [CX_INJ] THEN
    qed[]
  ; pass
  ] THEN
  case `i = 0` THENL [
    simp[complex_pow;COMPLEX_MUL_LID;ARITH_RULE `d - 0 = d`] THEN
    recall subring_complex_QinC THEN
    have `monic complex_ring (p:(1->num)->complex)` [monic_subring] THEN
    have `coeff (poly_deg complex_ring p) p = ring_1 complex_ring` [monic] THEN
    qed[complex_ring_clauses;ZinC_1]
  ; pass
  ] THEN
  num_linear_fact `~(i = 0) ==> (i-1)+1 = i` THEN
  have `Cx(&d) pow i = Cx(&d) pow (i-1) * Cx(&d)` [COMPLEX_POW_ADD;COMPLEX_POW_1] THEN
  simp[GSYM COMPLEX_MUL_ASSOC] THEN
  have `Cx(&d) pow (i-1) IN ZinC` [ring_pow_ZinC;RING_POW;ring_pow_complex;ZinC_ring_clauses] THEN
  subgoal `Cx(&d) * coeff(n-i) p IN ZinC` THENL [
    proven_if `i <= n:num` [IN_NUMSEG_0] THEN
    num_linear_fact `~(i <= n) ==> n - i = n - n:num` THEN
    num_linear_fact `n <= n:num` THEN
    have `n IN 0..n` [IN_NUMSEG_0] THEN
    qed[]
  ; pass
  ] THEN
  qed[ZinC_ring_clauses;RING_MUL;complex_ring_clauses]
);;
```
### Informal statement
For any polynomial `p` from numbers to complex numbers, if `p` is a ring polynomial over the field of rational complex numbers and `p` is monic over the field of rational complex numbers, then there exists a complex number `D` that is a member of the field of integer complex numbers, such that `D` is not equal to the complex number zero, and for all `i`, `D` raised to the power of `i` multiplied by the coefficient of `p` at degree `poly_deg complex_ring p - i` is a member of the field of integer complex numbers.

### Informal sketch
The proof demonstrates that a monic polynomial `p` with coefficients in the field of rational complex numbers (`QinC`) has a denominator `D` in the field of integer complex numbers (`ZinC`) such that `D` is non-zero and `D^i * p_(deg p - i)` is in `ZinC` for all `i`.

- The proof starts by introducing the degree of the polynomial `n`.
- It uses the fact that coefficients of the polynomial `p` are in `QinC` from `coeff_poly_in_ring` and `QinC_ring_clauses`.
- Then, it applies `multi_QinC_to_ZinC` to find a common denominator `d` for the coefficients.
- It witnesses the existence of `D` with `Cx(&d)`, which is the complex number constructed from `d`.
- It splits into three subgoals: proving that `Cx(&d)` is in `ZinC`, that `Cx(&d)` is not zero, and finally the main goal to show that `Cx(&d)^i * coeff (poly_deg complex_ring p - i) p` is in `ZinC`.
- The main goal is split into two cases `i = 0`, and `i != 0`.
  - In the case where `i = 0`, simplification reveals that the expression reduces to the leading coefficient which is `1` since `p` is monic. Since `1` is in complex integers, the goal is proven.
  - In the case where `i != 0`, we use the following reasoning:
    - `Cx(&d)^i = Cx(&d)^(i-1) * Cx(&d)`.
    - Show that `Cx(&d)^(i-1)` is in `ZinC` using `ring_pow_ZinC`
    - Show that `Cx(&d) * coeff (poly_deg complex_ring p - i) p` is in `ZinC` using the fact that `Cx(&d)` is a common denominator for the coefficients.
    - By `ZinC_ring_clauses`, `Cx(&d)^(i-1) * (Cx(&d) * coeff (poly_deg complex_ring p - i) p)` is in `ZinC`.

### Mathematical insight
This theorem essentially shows that if we have a monic polynomial with rational complex coefficients, we can find an integer complex number that serves as a common denominator for all the coefficients when multiplied by appropriate powers. This result is relevant in algebraic number theory, especially when dealing with algebraic integers. It demonstrates a connection between monic polynomials and algebraic integers (the roots of the polynomial). The comment in HOL Light gives the intuition: `Dz` is an algebraic integer for each root `z`.

### Dependencies
- `FINITE_NUMSEG`
- `coeff_poly_in_ring`
- `QinC_ring_clauses`
- `num_in_ZinC`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `complex_pow`
- `COMPLEX_MUL_LID`
- `ARITH_RULE`
- `subring_complex_QinC`
- `monic_subring`
- `monic`
- `complex_ring_clauses`
- `ZinC_1`
- `COMPLEX_POW_ADD`
- `COMPLEX_POW_1`
- `GSYM`
- `COMPLEX_MUL_ASSOC`
- `ring_pow_ZinC`
- `RING_POW`
- `ring_pow_complex`
- `ZinC_ring_clauses`
- `IN_NUMSEG_0`
- `RING_MUL`

### Porting notes (optional)
- The theorem relies heavily on the properties of complex numbers and polynomials in HOL Light. A porter should ensure that the target proof assistant has similar definitions and theorems for the complex numbers, polynomials, rings, and subrings.
- The tactic `intro THENL [...]` is crucial for introducing assumptions and splitting goals in HOL Light. The porter must appropriately deal with these proof structures.
- `num_linear_fact` performs arithmetic reasoning, which might need equivalent automation in the target system.
- The theorem also uses a bit of arithmetic reasoning on natural numbers, so the target system needs to have similar reasoning capabilities.


---

## denominator_reverse

### Name of formal statement
denominator_reverse

### Type of the formal statement
theorem

### Formal Content
```ocaml
let denominator_reverse = prove(`
  !(p:(1->num)->complex).
  ring_polynomial QinC_ring p ==>
  monic QinC_ring p ==>
  (!i. D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  (!i. D pow i * (coeff i (x_truncreverse QinC_ring (poly_deg complex_ring p) p)) IN ZinC)
`,
  intro THEN
  rw[coeff_x_truncreverse] THEN
  qed[QinC_ring_clauses;COMPLEX_MUL_RZERO;ZinC_0]
);;
```
### Informal statement
For all `p` of type `(1->num)->complex`, if `p` is a ring polynomial over the quotient ring of integers in the complex numbers (`QinC_ring`), and `p` is monic, and for all `i`, `D` raised to the power of `i` multiplied by the coefficient of the term with degree (`poly_deg complex_ring p - i`) in `p` is an element of the quotient ring of integers in the complex numbers (`ZinC`), then for all `i`, `D` raised to the power of `i` multiplied by the coefficient of the term with degree `i` in the reversed polynomial `x_truncreverse QinC_ring (poly_deg complex_ring p) p` is an element of the quotient ring of integers in the complex numbers (`ZinC`).

### Informal sketch
The proof proceeds by:

- Introduction.
- Rewriting using the definition of `coeff_x_truncreverse`.
- Applying the theorems `QinC_ring_clauses`, `COMPLEX_MUL_RZERO`, and `ZinC_0` to complete the proof.

### Mathematical insight
This theorem states that reversing a monic polynomial (represented as `p`) with certain integrality conditions (coefficients scaled by powers of `D` being in `ZinC`) preserves those integrality conditions on the coefficients of each degree, after reversing the order of coefficients using `x_truncreverse`. The assumptions related to the coefficients of the polynomial, along with the rewriting by `coeff_x_truncreverse`, allows inferring the integrality condition for the transformed polynomial.

### Dependencies
- Definitions: `QinC_ring`, `monic`, `poly_deg`, `complex_ring`, `coeff`, `x_truncreverse`, `ZinC`
- Theorems: `QinC_ring_clauses`, `COMPLEX_MUL_RZERO`, `ZinC_0`, `coeff_x_truncreverse`


---

## denominator_reverse_mul

### Name of formal statement
denominator_reverse_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let denominator_reverse_mul = prove(`
  !(p:(1->num)->complex) q D.
  ring_powerseries QinC_ring p ==>
  ring_powerseries QinC_ring q ==>
  D IN ZinC ==>
  (!i. D pow i * (coeff i p) IN ZinC) ==>
  (!i. D pow i * (coeff i q) IN ZinC) ==>
  (!i. D pow i * (coeff i (poly_mul QinC_ring p q)) IN ZinC)
`,
  intro THEN
  rw[coeff_poly_mul_oneindex] THEN
  have `D pow i IN ZinC` [RING_POW;ring_pow_ZinC;ZinC_ring_clauses] THEN
  have `D pow i IN QinC` [ZinC_in_QinC] THEN
  have `D pow i IN ring_carrier QinC_ring` [QinC_ring_clauses] THEN
  have `FINITE (0..i)` [FINITE_NUMSEG] THEN
  have `!a. a IN 0..i ==> ring_mul QinC_ring (coeff a p) (coeff (i - a) q) IN ring_carrier QinC_ring` [coeff_series_in_ring;RING_MUL] THEN
  specialize[`QinC_ring`;`(\a. ring_mul QinC_ring (coeff a p) (coeff (i - a) q))`;`(D:complex) pow i`;`0..i`](GSYM RING_SUM_LMUL) THEN
  simp[GSYM QinC_ring_clauses] THEN
  subgoal `!s. s IN 0..i ==> ring_mul QinC_ring (D pow i) (ring_mul QinC_ring (coeff s p) (coeff (i - s) q)) IN ring_carrier (subring_generated QinC_ring {})` THENL [
    intro THEN
    rw[subring_QinC_empty;QinC_ring_clauses;ZinC_ring_clauses] THEN
    have `s <= i:num` [IN_NUMSEG_0] THEN
    num_linear_fact `s <= i:num ==> i = s + (i-s)` THEN
    have `(D:complex) pow i = D pow s * D pow (i-s)` [COMPLEX_POW_ADD] THEN
    complex_field_fact `((D:complex) pow s * D pow (i-s)) * coeff s p * coeff (i - s) q = (D pow s * coeff s p) * (D pow (i-s) * coeff (i-s) q)` THEN
    qed[mul_in_ZinC]
  ; pass
  ] THEN
  specialize[`QinC_ring`;`{}:complex->bool`;`0..i`;`\x. ring_mul QinC_ring (D pow i) (ring_mul QinC_ring (coeff x p) (coeff (i - x) q))`]ring_sum_in_subring THEN
  qed[subring_QinC_empty;ZinC_ring_clauses]
);;
```

### Informal statement
For all power series `p` and `q` over the ring of rationals with coefficients `QinC_ring`, and for all `D` in the integers `ZinC`, if `p` and `q` are ring power series, and for all `i`, `D^i * (coeff i p)` is in `ZinC` and `D^i * (coeff i q)` is in `ZinC`, then for all `i`, `D^i * (coeff i (poly_mul QinC_ring p q))` is in `ZinC`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Rewrite the coefficient of the product using `coeff_poly_mul_oneindex`: `coeff i (poly_mul QinC_ring p q) = ring_sum QinC_ring (0..i) (\s. ring_mul QinC_ring (coeff s p) (coeff (i - s) q))`.
- Show that `D pow i IN ZinC` using `RING_POW`, `ring_pow_ZinC` and `ZinC_ring_clauses`. Then conclude `D pow i IN QinC` using `ZinC_in_QinC`.
- Prove that `D pow i IN ring_carrier QinC_ring` with rewrite rules associated with the construction of `QinC_ring`.
- Use `FINITE_NUMSEG` to get the fact that `FINITE (0..i)`.
- Show that for all `a`, if `a IN 0..i` then `ring_mul QinC_ring (coeff a p) (coeff (i - a) q) IN ring_carrier QinC_ring` using `coeff_series_in_ring` and `RING_MUL`.
- Use `RING_SUM_LMUL` to move `D pow i` inside the sum.
- Simplify using `QinC_ring_clauses`.
- The main goal is to show that for all `s`, if `s IN 0..i`, then `ring_mul QinC_ring (D pow i) (ring_mul QinC_ring (coeff s p) (coeff (i - s) q)) IN ring_carrier (subring_generated QinC_ring {})`.
  - We introduce the assumption `s IN 0..i`.
  - Rewrite using `subring_QinC_empty`, `QinC_ring_clauses` and `ZinC_ring_clauses` to show the carrier is `ZinC`.
  - Use `IN_NUMSEG_0` to get `s <= i:num`.
  - Use `num_linear_fact` to show `s <= i:num ==> i = s + (i-s:num)`.
  - Use `COMPLEX_POW_ADD` to rewrite `(D:complex) pow i` as `D pow s * D pow (i-s)`.
  - Use `complex_field_fact` to rearrange the multiplication.
  - Use `mul_in_ZinC` to show the product is in `ZinC`.
- Use `ring_sum_in_subring` to show that the sum is in the subring.
- Apply simplification rules that are associated with `subring_QinC_empty` and `ZinC_ring_clauses` to conclude.

### Mathematical insight
This theorem states that if the coefficients of two power series, when multiplied by a suitable power of a common denominator `D`, are integers, then the coefficients of their product also have this property. This is important when working with power series whose coefficients are rational numbers, as it allows one to transform them into power series with integer coefficients (up to a power of `D`) via multiplication by an appropriate power of the "common denominator".

### Dependencies
- Theorems: `coeff_poly_mul_oneindex`, `RING_POW`, `ring_pow_ZinC`, `ZinC_ring_clauses`, `ZinC_in_QinC`, `QinC_ring_clauses`, `FINITE_NUMSEG`, `coeff_series_in_ring`, `RING_MUL`, `RING_SUM_LMUL`, `subring_QinC_empty`, `IN_NUMSEG_0`, `COMPLEX_POW_ADD`, `mul_in_ZinC`, `ring_sum_in_subring`
- Definitions: `QinC_ring`,	`ZinC`, `poly_mul`,	`coeff`, `ring_powerseries`

### Porting notes (optional)
- The proof relies heavily on rewriting and equational reasoning within the field of complex numbers and the manipulation of power series coefficients. Ensure that the target proof assistant has suitable libraries and automation for these tasks.
- The use of `num_linear_fact` suggests a need for some external arithmetic reasoning, which might require explicit invocation of an arithmetic solver or tactic in other systems.
- The tactic `complex_field_fact` is used to rearrange the order of multiplication in complex field. The target system needs similar tactics to handle this fact.


---

## denominator_reverse_product

### Name of formal statement
denominator_reverse_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let denominator_reverse_product = prove(`
  !p D (S:X->bool).
  FINITE S ==>
  (!s. s IN S ==> ring_powerseries QinC_ring (p s)) ==>
  D IN ZinC ==>
  (!s i. s IN S ==> D pow i * (coeff i (p s)) IN ZinC) ==>
  (!i. D pow i * (coeff i (poly_product QinC_ring S p)) IN ZinC)
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty] THEN
    rw[coeff_poly_1] THEN
    rw[QinC_ring_clauses] THEN
    have `D pow i * Cx(&1) IN ZinC` [COMPLEX_MUL_RID;RING_POW;ring_pow_ZinC;ZinC_ring_clauses] THEN
    have `D pow i * Cx(&0) IN ZinC` [COMPLEX_MUL_RZERO;ZinC_0] THEN
    qed[]
  ;
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    simp[poly_product_insert] THEN
    have `ring_powerseries QinC_ring (p(x:X):(1->num)->complex)` [] THEN
    have `ring_powerseries QinC_ring (poly_product QinC_ring (S:X->bool) p)` [poly_product_series] THEN
    have `!i. D pow i * coeff i (p(x:X)) IN ZinC` [] THEN
    have `!s:X. s IN S ==> ring_powerseries QinC_ring (p s:(1->num)->complex)` [] THEN
    have `!s:X i. s IN S ==> D pow i * coeff i (p s) IN ZinC` [] THEN
    have `!i. D pow i * coeff i (poly_product QinC_ring (S:X->bool) p) IN ZinC` [] THEN
    specialize[`p(x:X):(1->num)->complex`;`poly_product QinC_ring (S:X->bool) p`;`D:complex`]denominator_reverse_mul THEN
    qed[]
  ]
);;
```
### Informal statement
For any type `X`, for any function `p` from `X` to formal power series over the field of complex numbers with coefficients in `QinC_ring` (rationals + i*rationals), for any set `S` of type `X`, if `S` is finite and for all `s` in `S`, `p s` is a formal power series with coefficients in `QinC_ring`, and `D` is in `ZinC` (Gaussian integers), and for all `s` in `S` and for all natural numbers `i`, `D` to the power of `i` times the `i`-th coefficient of `p s` is in `ZinC`, then for all natural numbers `i`, `D` to the power of `i` times the `i`-th coefficient of the product of `p s` over `S` (using `QinC_ring`'s multiplication) is in `ZinC`.

### Informal sketch
The theorem is proved by strong induction on the finiteness of the set `S`.

- Base case: `S` is empty. The product is then the constant formal power series `1`. The `i`-th coefficient of `1` is `&1` when `i` is `0` and `&0` otherwise. We need to show that `D pow i * &1 IN ZinC` and `D pow i * &0 IN ZinC`. This follows from the properties of `ZinC` being a ring with `1`.
- Inductive step: Assume the theorem holds for all subsets of `S`. We want to prove it for `x INSERT S`.
  - First rewrite `poly_product QinC_ring (x INSERT S) p` to `p x * poly_product QinC_ring S p`.
  - Obtain series properties of `p x` and `poly_product QinC_ring S p`.
  - Instantiate a previously proven theorem `denominator_reverse_mul` with, `p x`, `poly_product QinC_ring S p`, and `D`.

### Mathematical insight
This theorem essentially states that if we have a finite product of formal power series whose coefficients can be made Gaussian integers upon multiplication by a suitable power of some Gaussian integer `D`, then the coefficients of the product series can also be made Gaussian integers upon multiplication by a suitable power of `D`. This relates to denominator bounds in power series.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_product_empty`
- `coeff_poly_1`
- `QinC_ring_clauses`
- `COMPLEX_MUL_RID`
- `RING_POW`
- `ring_pow_ZinC`
- `ZinC_ring_clauses`
- `COMPLEX_MUL_RZERO`
- `ZinC_0`
- `poly_product_insert`
- `poly_product_series`
- `denominator_reverse_mul`


---

## denominator_reverse_pow

### Name of formal statement
denominator_reverse_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let denominator_reverse_pow = prove(`
  !p D n.
  ring_powerseries QinC_ring p ==>
  D IN ZinC ==>
  (!i. D pow i * (coeff i p) IN ZinC) ==>
  (!i. D pow i * (coeff i (poly_pow QinC_ring p n)) IN ZinC)
`,
  intro THEN
  simp[poly_pow_is_product] THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  specialize_assuming[`\i:num. p:(1->num)->complex`;`D:complex`;`1..n`]denominator_reverse_product THEN
  qed[]
);;
```
### Informal statement
For all power series `p`, and all `D`, and `n`, if `p` is a powerseries over the ring `QinC_ring`, and `D` is an element of `ZinC`, and for all `i`, `D` raised to the power of `i` multiplied by the coefficient of `i` in `p` is in `ZinC`, then for all `i`, `D` raised to the power of `i` multiplied by the coefficient of `i` in `p` raised to the power of `n` (using the ring power operation `poly_pow` over `QinC_ring`) is in `ZinC`.

### Informal sketch
The proof proceeds as follows:
- Introduce all variables.
- Simplify using the definition of `poly_pow_is_product`, which expresses exponentiation as repeated multiplication. This converts the powerseries raised to `n` into a product of n copies of the powerseries.
- Use the theorem `denominator_reverse_product` to show that under the given conditions, if the coefficients of the product of finitely many power series have the property that `D pow i * (coeff i p) IN ZinC`, then the same property holds for their product. `FINITE (1..n)` establishes the required finiteness, and the assumptions of the present theorem provide the other needed conditions to apply `denominator_reverse_product`.
- Conclude the proof.

### Mathematical insight
This theorem provides a condition under which exponentiating a power series preserves integrality properties of its coefficients. Specifically, if multiplying each coefficient of the original series by a suitable power of `D` makes it an integer, then the same is true for coefficients of the series raised to an integer power. This is significant in algebraic number theory or commutative algebra settings where one needs to control denominators in power series manipulations.

### Dependencies
- `ring_powerseries`
- `QinC_ring`
- `ZinC`
- `poly_pow_is_product`
- `FINITE_NUMSEG`
- `denominator_reverse_product`


---

## distinct_minpolys

### Name of formal statement
distinct_minpolys

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let distinct_minpolys = new_definition `
  distinct_minpolys P <=>
  !p. p IN P ==>
  (ring_polynomial QinC_ring p
   /\ ring_irreducible(x_poly QinC_ring) p
   /\ monic QinC_ring p
  )
`;;
```
### Informal statement
The set `P` of polynomials satisfies `distinct_minpolys P` if and only if for all polynomials `p` in the set `P`, `p` is a ring polynomial in the quotient ring `Qinc_ring`, `p` is ring irreducible with respect to `x_poly Qinc_ring`, and `p` is monic in `Qinc_ring`.

### Informal sketch
The definition `distinct_minpolys` defines a property of a set of polynomials `P`. The definition states that all polynomials in `P` must satisfy three conditions: be a ring polynomial, be irreducible, and be monic, all with respect to the quotient ring, `Qinc_ring`.

### Mathematical insight
This definition is expected to capture the notion of a set of distinct minimal polynomials, where each polynomial is irreducible and monic within the given ring. The `Qinc_ring` likely refers to a ring of complex numbers. The minimal polynomials should be distinct to guarantee desired properties in later constructions.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `ring_irreducible`
  - `monic`
  - `x_poly`
  - `Qinc_ring`


---

## polynomial_product_distinct_minpolys

### Name of formal statement
polynomial_product_distinct_minpolys

### Type of the formal statement
theorem

### Formal Content
```ocaml
let polynomial_product_distinct_minpolys = prove(`
  !P.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_polynomial QinC_ring (poly_product QinC_ring P I)
`,
  rw[distinct_minpolys] THEN
  intro THEN
  have `!p. p IN P ==> ring_polynomial QinC_ring (I p:(1->num)->complex)` [I_DEF] THEN
  qed[poly_product_poly]
);;
```
### Informal statement
For all sets `P` of functions from a type to complex numbers, if `P` is finite and the minimal polynomials of the elements of `P` are distinct, then the product of the minimal polynomials of the elements of `P`, as a polynomial over the rational complex numbers (`QinC_ring`), is a polynomial over the rational complex numbers.

### Informal sketch
- The proof starts by rewriting with the definition of `distinct_minpolys`.
- Then, it introduces a variable `P`.
- We establish that for every `p` in `P`, `ring_polynomial QinC_ring (I p:(1->num)->complex)` holds, this step is justified because we are given that minimal polynomials exist (because of the assumption `distinct_minpolys P`, and the `I_DEF` which must be the definition of the minimal polynomial `I`).
- Finally, the conclusion that `ring_polynomial QinC_ring (poly_product QinC_ring P I)` is obtained directly by using the theorem `poly_product_poly`` which says that the product of polynomials over `QinC_ring` is a polynomial over `QinC_ring` if the elements of the product are polynomials over `QinC_ring`.

### Mathematical insight
This theorem establishes that if we have a finite set of functions with distinct minimal polynomials, then the product of these minimal polynomials remains a polynomial over the base ring `QinC_ring` (complex rationals). This result is essential for understanding the algebraic closure of constructible numbers and is a step toward showing that certain operations preserve the property of being a polynomial over the rational complex numbers.

### Dependencies
Definitions:
- `distinct_minpolys`
- `poly_product`
- `QinC_ring`
- `ring_polynomial`

Theorems:
- `poly_product_poly`


---

## monic_product_distinct_minpolys

### Name of formal statement
monic_product_distinct_minpolys

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_product_distinct_minpolys = prove(`
  !P.
  FINITE P ==>
  distinct_minpolys P ==>
  monic QinC_ring (poly_product QinC_ring P I)
`,
  rw[distinct_minpolys] THEN
  intro THEN
  have `!p. p IN P ==> ring_polynomial QinC_ring (I p:(1->num)->complex)` [I_DEF] THEN
  have `!p. p IN P ==> monic QinC_ring (I p)` [I_DEF] THEN
  qed[monic_poly_product]
);;
```
### Informal statement
For any set `P` of polynomials, if `P` is finite and the minimal polynomials in `P` are distinct, then the product of the polynomials `I p`, where `I` is a function from polynomials to polynomials that associates each polynomial `p` in `P` with a complex-valued polynomial, is monic.

### Informal sketch
*   The proof starts by rewriting with the definition of `distinct_minpolys`, then introduces the assumption `P` is finite.
*   It is shown that for all `p` in `P`, `I p` is a ring polynomial, which essentially states that the coefficients are in the ring of complex numbers since `I` maps polynomials to complex polynomials.
*   Next, it is shown that for all `p` in `P`, `I p` is monic.
*   Finally, the proof concludes using the theorem `monic_poly_product`, which states that a product of monic polynomials is monic.

### Mathematical insight
This theorem states that if we have a finite set of polynomials with distinct minimal polynomials, then a product formed by taking a complex-valued polynomial associated with each polynomial in the set is monic. This result is useful because it provides a condition under which a product of polynomials is guaranteed to be monic, a property that is valuable in various algebraic manipulations and polynomial factorization arguments.

### Dependencies
*   Definitions: `distinct_minpolys`
*   Theorems: `monic_poly_product`


---

## distinct_minpolys_nonzero

### Name of formal statement
distinct_minpolys_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_nonzero = prove(`
  !P p.
  distinct_minpolys P ==>
  p IN P ==>
  ~(p = poly_0 QinC_ring)
`,
  qed[distinct_minpolys;monic_poly_0;field_QinC;field]
);;
```
### Informal statement
For all sets of polynomials `P` and for all polynomials `p`, if `P` is a set of polynomials with distinct minimal polynomials and `p` is an element of `P`, then `p` is not equal to the zero polynomial `poly_0` defined over `QinC_ring`.

### Informal sketch
*   The proof proceeds by contradiction. Assume `P` is a set of polynomials with distinct minimal polynomials, `p` is in `P`, and `p` is the zero polynomial `poly_0` over `QinC_ring`.
*   By the definition of `distinct_minpolys`, all elements in the set `P` are monic and have minimal polynomials. Hence if `p` is in `P` then `p` is monic (by `distinct_minpolys`).
*   The tactic `monic_poly_0` states that the zero polynomial `poly_0` is not monic.
*   This creates a contradiction and the assumption `p = poly_0 QinC_ring` is false using basic field axioms `field_QinC` and `field` facts.

### Mathematical insight
The theorem states that if we have a set of polynomials with distinct minimal polynomials as defined by `distinct_minpolys`, then none of the polynomials in that set can be the zero polynomial. This makes sense because minimal polynomials are monic (leading coefficient is 1) and the zero polynomial cannot be monic. It contributes towards establishing properties of algebraic extensions.

### Dependencies
- `distinct_minpolys`
- `monic_poly_0`
- `field_QinC`
- `field`


---

## distinct_minpolys_reverse_nonzero

### Name of formal statement
distinct_minpolys_reverse_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_reverse_nonzero = prove(`
  !P p.
  distinct_minpolys P ==>
  p IN P ==>
  ~(x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_0 complex_ring)
`,
  intro THEN
  recall integral_domain_QinC THEN
  have `~(ring_1 QinC_ring = ring_0 QinC_ring)` [integral_domain] THEN
  have `monic QinC_ring p` [distinct_minpolys] THEN
  have `poly_deg QinC_ring (p:(1->num)->complex) = poly_deg complex_ring p` [poly_deg_subring;subring_complex_QinC] THEN
  have `x_truncreverse QinC_ring (poly_deg QinC_ring p) p = poly_0 QinC_ring` [poly_0_QinC_eq_poly_0_complex] THEN
  qed[nonzero_if_x_truncreverse_monic;integral_domain]
);;
```
### Informal statement
For all sets of polynomials `P` and polynomials `p`, if `P` is a set of distinct minimal polynomials and `p` is an element of `P`, then the truncation-reverse of `p` (with respect to the degree of `p` in the quotient ring `QinC_ring`) is not the zero polynomial in the quotient ring `QinC_ring`.

### Informal sketch
The proof proceeds as follows:

- Assume `P` is a set of distinct minimal polynomials and `p` is an element of `P`.
- Use `integral_domain_QinC` to show that the ring unit and zero elements are distinct in `QinC_ring`.
- By the assumption that `distinct_minpolys P`, the polynomial `p` is monic in the `QinC_ring`.
- Show that the degree of the polynomial `p` in `QinC_ring` is equal to its degree as a polynomial in `complex_ring`, using `poly_deg_subring` and `subring_complex_QinC`.
- Assume `x_truncreverse QinC_ring (poly_deg QinC_ring p) p = poly_0 QinC_ring` and rewrite using `poly_0_QinC_eq_poly_0_complex`.
- Obtain a contradiction via `nonzero_if_x_truncreverse_monic` and `integral_domain`, implying that `x_truncreverse QinC_ring (poly_deg complex_ring p) p` is not the zero polynomial.

### Mathematical insight
This theorem states that the truncation-reverse of a minimal polynomial (from a set of distinct minimal polynomials) cannot be the zero polynomial. This is likely used in the context of algebraic number theory to show properties of minimal polynomials or their roots. Reversing a polynomial is related to inverting the coefficients. This result is useful because we want to show something about the properties of minimal polynomials (and their coefficients) so it is useful to know that the truncated reverse is non-zero.

### Dependencies
- `distinct_minpolys`
- `integral_domain_QinC`
- `poly_deg_subring`
- `subring_complex_QinC`
- `poly_0_QinC_eq_poly_0_complex`
- `nonzero_if_x_truncreverse_monic`

### Porting notes (optional)
The main challenge in porting this theorem likely lies in reproducing the specific definitions and properties related to polynomials, quotient rings, and algebraic number theory that are available in HOL Light. Particular attention should be paid to the definitions of subrings and minimal polynomials. Handling for coercion between types such as `complex` and `QinC_ring` may vary between proof assistants.


---

## distinct_minpolys_total_deg

### Name of formal statement
distinct_minpolys_total_deg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_total_deg = prove(`
  !P.
  FINITE P ==>
  distinct_minpolys P ==>
  (P = {}
   <=> nsum P (\p. poly_deg complex_ring p) = 0)
`,
  intro THEN
  splitiff THENL [
    simp[NSUM_CLAUSES]
  ;
    rw[EXTENSION;EMPTY;IN_ELIM_THM] THEN
    intro THEN
    have `poly_deg complex_ring (x:(1->num)->complex) = 0` [NSUM_EQ_0_IFF] THEN
    have `poly_deg QinC_ring (x:(1->num)->complex) = 0` [poly_deg_subring;subring_complex_QinC] THEN
    recall field_QinC THEN
    have `~(ring_prime(x_poly QinC_ring) x)` [deg_prime] THEN
    have `~(ring_irreducible(x_poly QinC_ring) x)` [prime_iff_irreducible_over_field] THEN
    qed[distinct_minpolys]
  ]
);;
```

### Informal statement
For all sets `P` of polynomials from complex numbers to complex numbers, if `P` is finite, then if the polynomials in `P` are distinct minimal polynomials, then `P` is empty if and only if the sum over `P` of the degrees of the polynomials is 0.

### Informal sketch
The proof proceeds by splitting the equivalence into two implications:

*   First, if `P` is empty, then the sum of the degrees is 0. This direction follows directly from the definition of `nsum` using `NSUM_CLAUSES`.

*   Second, if the sum of the degrees is 0, then `P` is empty. This is proved by contradiction. Assume `P` is non-empty. Then there exists an element `x` in `P`. Since `P` contains distinct minimal polynomials, `x` is a minimal polynomial. Thus the polynomial degree `poly_deg complex_ring x` is not 0. It follows that `poly_deg QinC_ring x` is also nonzero, this uses `poly_deg_subring` and `subring_complex_QinC`. Finally we use the fact that since `x` is irreducible over `QinC` then it can not be zero. `deg_prime` is used.

### Mathematical insight
This theorem connects the emptiness of a finite set of polynomials which are distinct minimal polynomials with the sum of their degrees being 0. The theorem formalizes the intuitive notion that if a set of polynomials contains no element, then the sum of their degrees should be 0. The converse is also true if the polynomials meet certain conditions, i.e., are irreducible and distinct.

### Dependencies

*   Theorems:
    *   `NSUM_CLAUSES`
    *   `EXTENSION`
    *   `EMPTY`
    *   `IN_ELIM_THM`
    *   `NSUM_EQ_0_IFF`
    *   `poly_deg_subring`
    *   `subring_complex_QinC`
    *   `deg_prime`
    *   `prime_iff_irreducible_over_field`
    *   `distinct_minpolys`
*   Definitions:
    *   `nsum`

*   Axioms
    *   `field_QinC`


---

## distinct_minpolys_monic_vanishing_at_simple

### Name of formal statement
distinct_minpolys_monic_vanishing_at_simple

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_monic_vanishing_at_simple = prove(`
  !p.
  ring_polynomial QinC_ring p ==>
  monic QinC_ring p ==>
  ring_irreducible(x_poly QinC_ring) p ==>
  monic_vanishing_at complex_ring (complex_root p) I = p
`,
  intro THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  recall subring_complex_QinC THEN
  have `monic complex_ring (p:(1->num)->complex)` [monic_subring] THEN
  have `ring_squarefree(x_poly QinC_ring) p` [squarefree_if_irreducible_over_field;field_QinC] THEN
  have `ring_squarefree(x_poly complex_ring) p` [monic_QinC_squarefree_complex_squarefree] THEN
  qed[monic_vanishing_at_complex_root]
);;
```

### Informal statement
For all polynomials `p` over the quotient ring of integers `QinC_ring`, if `p` is a ring polynomial, `p` is monic, and `p` is irreducible over the quotient ring of integers with respect to the `x_poly` morphism, then the monic polynomial vanishing at a complex root of `p` over the complex numbers with respect to the identity function `I` is equal to `p`.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is a polynomial over `QinC_ring`, monic, and irreducible with respect to the `x_poly` morphism.
- Show that `p` is a polynomial over the complex numbers. This follows since if `p` is a polynomial over the quotient ring of integers `QinC_ring`, then `p` is also a polynomial over the complex numbers with the help of `poly_complex_if_poly_QinC`. Also recall `subring_complex_QinC`.
- Show that `p` is monic over the complex numbers. This follows from the fact that `p` is monic over the quotient ring of integers `QinC_ring`, and `monic_subring`.
- Show that `p` is squarefree over the quotient ring of integers `QinC_ring` using `squarefree_if_irreducible_over_field` and `field_QinC`. This holds because when `p` is irreducible over the quotient ring of integers, then it is squarefree because `QinC_ring` is a field.
- Show that `p` is squarefree over the complex numbers using `monic_QinC_squarefree_complex_squarefree`.
- Use the theorem `monic_vanishing_at_complex_root`, which states that if `p` is monic and squarefree over the complex numbers, then the monic polynomial vanishing at a complex root of `p` with respect to the identity function is equal to `p`.

### Mathematical insight
This theorem connects the irreducibility and monic properties of a polynomial $p$ over the quotient ring of integers with the uniqueness of the monic polynomial vanishing at a complex root of $p$. Specifically, if a polynomial is monic, irreducible over $\mathbb{Q}[i]$, then the minimal polynomial of its complex root is the polynomial itself.

### Dependencies
- `ring_polynomial`
- `QinC_ring`
- `monic`
- `ring_irreducible`
- `x_poly`
- `monic_vanishing_at`
- `complex_ring`
- `complex_root`
- `I`
- `poly_complex_if_poly_QinC`
- `subring_complex_QinC`
- `monic_subring`
- `squarefree_if_irreducible_over_field`
- `field_QinC`
- `ring_squarefree`
- `monic_QinC_squarefree_complex_squarefree`
- `monic_vanishing_at_complex_root`


---

## distinct_minpolys_monic_vanishing_at

### Name of formal statement
distinct_minpolys_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_monic_vanishing_at = prove(`
  !P p.
  distinct_minpolys P ==>
  p IN P ==>
  monic_vanishing_at complex_ring (complex_root p) I = p
`,
  qed[distinct_minpolys;distinct_minpolys_monic_vanishing_at_simple]
);;
```
### Informal statement
For all sets `P` of polynomials and for all polynomials `p`, if `P` is a set of distinct minimal polynomials and `p` is in `P`, then the monic polynomial that vanishes at the complex root of `p` over the ring of complex numbers `complex_ring` in the ideal `I` is equal to `p`.

### Informal sketch
The theorem states that if we have a set of distinct minimal polynomials, and we pick one of them, then the minimal polynomial that vanishes at a root of that polynomial must be the original polynomial itself.
- Start with the assumptions `distinct_minpolys P` and `p IN P`.
- The goal is to show `monic_vanishing_at complex_ring (complex_root p) I = p`.
- The proof likely proceeds by using the property that if `P` is a set of distinct minimal polynomials then the monic vanishing polynomial at a root of a polynomial `p` in `P`, is indeed `p`. This ties into the uniqueness of minimal polynomials.
- The tactic `distinct_minpolys_monic_vanishing_at_simple` is likely used or proven first to set some simplification rules for dealing with `distinct_minpolys`

### Mathematical insight
The theorem formalizes the idea that the minimal polynomial of a root is unique within a specific context (here, the property relates to the minimal polynomials of complex roots). It connects the concept of a set of `distinct_minpolys` with the `monic_vanishing_at` operation, effectively saying that if we start with a minimal polynomial, take a root, and compute the minimal polynomial of that root, we get back the original polynomial. This provides an essential characterization for working with minimal polynomials and their roots.

### Dependencies
- `distinct_minpolys`
- `distinct_minpolys_monic_vanishing_at_simple`


---

## distinct_minpolys_deg_nonzero

### Name of formal statement
distinct_minpolys_deg_nonzero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_deg_nonzero = prove(`
  !P p.
  distinct_minpolys P ==>
  p IN P ==>
  ~(poly_deg complex_ring p = 0)
`,
  intro THEN
  have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_irreducible(x_poly QinC_ring) (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_prime(x_poly QinC_ring) (p:(1->num)->complex)` [prime_iff_irreducible_over_field;field_QinC] THEN
  have `~(poly_deg QinC_ring (p:(1->num)->complex) = 0)` [deg_prime;field_QinC] THEN
  qed[poly_deg_subring;subring_complex_QinC]
);;
```
### Informal statement
For all sets `P` of polynomials (over the complex numbers) and for all polynomials `p`, if `P` consists of distinct minimal polynomials and `p` is in `P`, then the degree of `p` is not equal to 0.

### Informal sketch
The proof proceeds as follows:
- Assume that `P` is a set of distinct minimal polynomials.
- Assume `p` is an element of `P`.
- Show that `p` has non-zero degree.
  - Since `p` is a minimal polynomial, `p` is irreducible in `QinC_ring` (polynomials over complex numbers).
  - Since `p` is irreducible in `QinC_ring`, it is prime in `QinC_ring` because in a field, irreducible elements are prime.
  - Because `p` is prime, it must have a non-zero degree via the theorem `deg_prime`.
  - The theorem `poly_deg_subring` is used, along with the fact that complex numbers are a subring, to establish that properties about polynomial degrees hold in `QinC_ring` because the standard polynomials are a subring.

### Mathematical insight
The statement asserts that any polynomial within a set of distinct minimal polynomials must have a non-zero degree. This is intuitive because a polynomial of degree 0 is a constant, and a minimal polynomial cannot be constant (otherwise it would be further reducible). Minimal polynomials are key in algebraic field extensions, especially in Galois theory. They specify the irreducible polynomial of an element in a field extension.

### Dependencies
- Definitions: `distinct_minpolys`
- Theorems: `prime_iff_irreducible_over_field`, `deg_prime`, `poly_deg_subring`
- Facts: `field_QinC`, `subring_complex_QinC`


---

## distinct_minpolys_finite_root_simple

### Name of formal statement
distinct_minpolys_finite_root_simple

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_finite_root_simple = prove(`
  !p.
  ring_polynomial QinC_ring p ==>
  monic QinC_ring p ==>
  ring_irreducible(x_poly QinC_ring) p ==>
  FINITE(complex_root p)
`,
  intro THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p:(1->num)->complex = poly_0 QinC_ring)` [monic_poly_0;field_QinC;field] THEN
  recall subring_complex_QinC THEN
  have `~(p:(1->num)->complex = poly_0 complex_ring)` [poly_0_subring] THEN
  qed[complex_root_le_deg]
);;
```
### Informal statement
For any `p`, if `p` is a ring polynomial over the complex rational ring (`QinC_ring`), `p` is monic over `QinC_ring`, and `p` is irreducible over `QinC_ring` viewed as a polynomial over itself, then the set of complex roots of `p` is finite.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is a ring polynomial over the complex rational ring (`QinC_ring`), `p` is monic over `QinC_ring`, and `p` is irreducible over `QinC_ring` viewed as polynomial over itself.
- Show that `p`, when considered as a polynomial over the complex numbers, is also a `ring_polynomial` over the complex numbers. This follows directly since `p` is a ring polynomial over `QinC_ring`, and the complex numbers are a subring of themselves, thus it is also a ring polynomial over complex numbers.
- Since `p` is irreducible, it is not equal to the zero polynomial (`poly_0`). We first apply `monic_poly_0` using the assumption that the polynomial `p` is monic. Since `QinC_ring` is a field due to `field_QinC` and general field, the given statement becomes `~(p = poly_0 QinC_ring)`.
- Show that `p` is not the zero polynomial over the complex numbers. This follows from the fact that it is not the zero polynomial over the complex rational ring (`QinC_ring`), which is a subring of the complex numbers, we derive `~(p = poly_0 complex_ring)` by `poly_0_subring`.
- Conclude that the set of complex roots of `p` is finite by recalling `complex_root_le_deg`.

### Mathematical insight
This theorem establishes that for a monic and irreducible polynomial `p` over the complex rational ring, the number of complex roots of `p` is finite. This is a consequence of the fact that any non-zero polynomial has a number of roots bounded by its degree, and irreducibility together with the fact that the polynomial is non-zero, guarantees that the polynomial has finite roots.

### Dependencies
- Definitions: `ring_polynomial`, `monic`, `ring_irreducible`, `FINITE`, `complex_root`.
- Theorems: `poly_complex_if_poly_QinC`, `monic_poly_0`, `field_QinC`, `field`, `subring_complex_QinC`, `poly_0_subring`, `complex_root_le_deg`.

---

## distinct_minpolys_finite_root

### Name of formal statement
distinct_minpolys_finite_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_finite_root = prove(`
  !P p.
  distinct_minpolys P ==>
  p IN P ==>
  FINITE(complex_root p)
`,
  qed[distinct_minpolys;distinct_minpolys_finite_root_simple]
);;
```
### Informal statement
For all sets `P` of polynomials, and for all polynomials `p`, if `P` is a set of distinct minimal polynomials, and `p` belongs to `P`, then the set of complex roots of `p` is finite.

### Informal sketch
*   The proof proceeds by assuming `distinct_minpolys P` and `p IN P`.
*   The goal is to show that `FINITE(complex_root p)`.
*   The proof relies on two key theorems: `distinct_minpolys` which asserts the distinctness and irreducibility properties of minimal polynomials, and `distinct_minpolys_finite_root_simple` which is presumably a simpler result stating the argument for a single minimal polynomial.

### Mathematical insight
The theorem states that the set of complex roots of a polynomial that is a member of a set of distinct minimal polynomials is finite. This is a consequence of the fact that any polynomial has a finite number of roots, and minimal polynomials are still polynomials. The importance of this theorem lies in the fact that it combines two notions: the concept of "minimal" polynomials and the finiteness of their roots

### Dependencies
- Theorems: `distinct_minpolys`, `distinct_minpolys_finite_root_simple`


---

## distinct_minpolys_card_root

### Name of formal statement
distinct_minpolys_card_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_card_root = prove(`
  !P p.
  distinct_minpolys P ==>
  p IN P ==>
  CARD(complex_root p) = poly_deg complex_ring p
`,
  intro THEN
  have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p:(1->num)->complex = poly_0 QinC_ring)` [distinct_minpolys_nonzero] THEN
  recall subring_complex_QinC THEN
  have `~(p:(1->num)->complex = poly_0 complex_ring)` [poly_0_subring] THEN
  have `monic_vanishing_at complex_ring (complex_root p) I = p` [distinct_minpolys_monic_vanishing_at] THEN
  have `!c. c IN complex_root p ==> I c IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `FINITE (complex_root p)` [distinct_minpolys_finite_root] THEN
  specialize[`complex_ring`;`I:complex->complex`;`complex_root p`]deg_monic_vanishing_at THEN
  qed[deg_monic_vanishing_at;field_complex;field]
);;
```
### Informal statement
For every set `P` of polynomials and every polynomial `p`, if `P` satisfies `distinct_minpolys` and `p` is in `P`, then the cardinality of the set of complex roots of `p` is equal to the degree of `p` in the complex ring.

### Informal sketch
The proof proceeds as follows:
- Assume `distinct_minpolys P` and `p IN P`.
- Show that `p` is a polynomial over a subring of complex numbers (`QinC_ring`), and subsequently `p` is a polynomial over the complex field (`complex_ring`). This relies on `poly_complex_if_poly_QinC`.
- Show that `p` is not the zero polynomial (`poly_0`) in the complex ring because `distinct_minpolys` implies `distinct_minpolys_nonzero`.
- Use `distinct_minpolys_monic_vanishing_at` to show that `monic_vanishing_at complex_ring (complex_root p) I = p`. This states that `p` is the monic polynomial vanishing on its complex roots, `complex_root p`.
- Show that if `c IN complex_root p`, then `I c` is in the carrier set of the complex ring, using the theorem `in_complex_ring`.
- `FINITE (complex_root p)` since `distinct_minpolys_finite_root` asserts that the set of complex roots of `p` is finite.
- Specialize the theorem `deg_monic_vanishing_at` for `complex_ring`, the identity function `I`, and the set `complex_root p`.
- Finally, derive the result using `deg_monic_vanishing_at`, `field_complex`, and `field`.

### Mathematical insight
The theorem connects the cardinality of the complex roots of a polynomial `p` with the polynomial's degree, given that `p` belongs to a set `P` of polynomials satisfying the `distinct_minpolys` condition (minimal polynomials). It demonstrates a fundamental property of polynomials and algebraic closures.

### Dependencies
- `distinct_minpolys`
- `ring_polynomial`
- `poly_complex_if_poly_QinC`
- `distinct_minpolys_nonzero`
- `subring_complex_QinC`
- `poly_0_subring`
- `distinct_minpolys_monic_vanishing_at`
- `in_complex_ring`
- `distinct_minpolys_finite_root`
- `deg_monic_vanishing_at`
- `field_complex`
- `field`

### Porting notes (optional)
When porting to other proof assistants, ensure that the definitions and properties of polynomial rings, subrings, and fields are correctly translated. Ensure that the concept of `distinct_minpolys`, which likely captures properties related to minimal polynomials and algebraic independence, are faithfully represented in the target system. The handling of complex numbers and their embedding in algebraic structures is also crucial.


---

## distinct_minpolys_denominator

### Name of formal statement
distinct_minpolys_denominator

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_denominator = prove(`
  !P.
  FINITE P ==>
  distinct_minpolys P ==>
  ?D. D IN ZinC /\
      ~(D = Cx(&0)) /\
      (!p. p IN P ==>
           !i. D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC
      )
`,
  rw[distinct_minpolys] THEN
  intro THEN
  def `denom:((1->num)->complex)->complex` `\p. @d. d IN ZinC /\ ~(d = Cx(&0)) /\ (!i. d pow i * (coeff(poly_deg complex_ring p - i) p) IN ZinC)` THEN
  subgoal `!p:(1->num)->complex. p IN P ==> denom p IN ZinC /\ ~(denom p = Cx(&0)) /\ (!i. (denom p) pow i * (coeff(poly_deg complex_ring p - i) p) IN ZinC)` THENL [
    intro THEN
    have `ring_polynomial QinC_ring (p:(1->num)->complex)` [] THEN
    have `monic QinC_ring (p:(1->num)->complex)` [] THEN
    specialize[`p:(1->num)->complex`]denominator_if_monic_QinC THEN
    qed[]
  ; pass
  ] THEN
  def `D:complex` `ring_product ZinC_ring P (denom:((1->num)->complex)->complex)` THEN
  have `D IN ZinC` [RING_PRODUCT;ZinC_ring_clauses] THEN
  witness `D:complex` THEN
  intro THENL [
    qed[]
  ;
    qed[INTEGRAL_DOMAIN_PRODUCT_EQ_0;integral_domain_ZinC;ZinC_ring_clauses]
  ; pass
  ] THEN
  def `q:complex` `ring_product ZinC_ring (P DELETE (p:(1->num)->complex)) denom` THEN
  have `denom (p:(1->num)->complex) IN ring_carrier ZinC_ring` [ZinC_ring_clauses] THEN
  specialize[`ZinC_ring`;`P:((1->num)->complex)->bool`;`p:(1->num)->complex`;`denom:((1->num)->complex)->complex`]ring_product_delete THEN
  have `D = (denom (p:(1->num)->complex)) * q:complex` [ZinC_ring_clauses] THEN
  have `D pow i = (denom (p:(1->num)->complex) pow i) * (q pow i):complex` [COMPLEX_POW_MUL] THEN
  have `q pow i IN ZinC` [RING_PRODUCT;RING_POW;ZinC_ring_clauses;ring_pow_ZinC] THEN
  have `q pow i * denom p pow i * coeff (poly_deg complex_ring p - i) p IN ZinC` [RING_MUL;ZinC_ring_clauses] THEN
  have `(q pow i * denom p pow i) * coeff (poly_deg complex_ring p - i) p IN ZinC` [COMPLEX_MUL_ASSOC] THEN
  have `(denom p pow i * q pow i) * coeff (poly_deg complex_ring p - i) p IN ZinC` [COMPLEX_MUL_SYM] THEN
  qed[]
);;
```
### Informal statement
For any set `P` of complex polynomials, if `P` is finite and contains polynomials with distinct minimal polynomials, then there exists a non-zero element `D` in ZinC (the ring of integer complex numbers) such that for all polynomials `p` in `P` and for all `i`, `D` raised to the power of `i` multiplied by the coefficient of `p` at degree (degree of `p` minus `i`) is in `ZinC`.

### Informal sketch
*   The proof starts by rewriting `distinct_minpolys`.
*   It introduces the definition `denom` which maps polynomial `p` in `P` to `d`, where `d` is an element in `ZinC` such that `d` is nonzero, and for all `i`, `d` raised to the power of `i` multiplied by the coefficient of `p` at degree (`poly_deg complex_ring p - i`) is in `ZinC`.
*   The goal is to prove that `denom p IN ZinC /\ ~(denom p = Cx(&0)) /\ (!i. (denom p) pow i * (coeff(poly_deg complex_ring p - i) p) IN ZinC)`.
    *   It is shown that `p` is a ring polynomial in `QinC_ring` and is monic.
    *   Then, the theorem `denominator_if_monic_QinC` is specialized and applied.
*   The proof defines `D` as the ring product of `denom p` for all `p` in `P`, using the ring `ZinC_ring`.
*   It's shown that `D IN ZinC`.
*   It is shown that `D` is not equal to zero.
*   Then `q` is defined as the ring product of `denom` for all polynomials in `P` except for `p`.
*   It's shown that `denom p` is an element of the carrier of the ring `ZinC_ring`.
*   The theorem `ring_product_delete` is specialized to `ZinC_ring`, `P`, `p`, and `denom`.
*   It is shown that `D = (denom p) * q`.
*   It's proved that `D pow i = (denom p pow i) * (q pow i)`.
*   It's then shown that `q pow i IN ZinC`.
*   Using the fact that the product of terms in `ZinC` is in `ZinC`, show that `q pow i * denom p pow i * coeff (poly_deg complex_ring p - i) p IN ZinC`.
*   Use associativity and symmetry to rearrangement to obtain the desired result.

### Mathematical insight
The theorem states that given a finite set of complex polynomials with distinct minimal polynomials, there exists a common denominator `D` in `ZinC` such that multiplying the coefficients of each polynomial `p` in the set by appropriate powers of `D` results in coefficients that are also in `ZinC`. This implies that the roots of these polynomials are algebraic integers after scaled by `D`. This is a key step in proving properties about algebraic integers and their minimal polynomials.

### Dependencies
- Definitions:
  - `denom:((1->num)->complex)->complex`
  - `D:complex`
  - `q:complex`
- Theorems:
  - `distinct_minpolys`
  - `denominator_if_monic_QinC`
  - `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
  - `integral_domain_ZinC`
  - `ZinC_ring_clauses`
  - `COMPLEX_POW_MUL`
  - `COMPLEX_MUL_ASSOC`
  - `COMPLEX_MUL_SYM`
- Other:
  - `RING_PRODUCT`
  - `RING_POW`
  - `RING_MUL`
  - `ring_polynomial`
  - `monic`
  - `ZinC_ring_clauses`
  - `ring_pow_ZinC`
  - `ring_product_delete`

### Porting notes (optional)
- The `ring_product` term will need to be carefully translated, ensuring correct behavior in the target proof assistant, pay close attention to the ring structure used.
- The handling of dependent types and implicit coercions (e.g., between integers and complex numbers) may differ across systems, so explicit conversions might be needed.
- Ensure the target system has a notion of "algebraic integers", or adapt this theorem appropriately to fit the system's definitions.


---

## weighted_powersums_distinct_minpolys

### Name of formal statement
weighted_powersums_distinct_minpolys

### Type of the formal statement
theorem

### Formal Content
```ocaml
let weighted_powersums_distinct_minpolys = prove(`
  !P D B n.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  D pow n *
  (ring_sum complex_ring P
     (\p. (complex_of_int(B p)) * complex_root_powersums p n))
  IN ZinC
`,
  intro THEN
  subgoal `!p. p IN P ==> D pow n * complex_root_powersums p n IN ZinC` THENL [
    intro THEN
    have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
    have `ring_irreducible(x_poly QinC_ring) p` [distinct_minpolys] THEN
    have `monic QinC_ring p` [distinct_minpolys] THEN
    have `!i. D pow i * coeff(poly_deg complex_ring p - i) p IN ZinC` [] THEN
    specialize[`p:(1->num)->complex`;`D:complex`;`n:num`]complex_root_powersums_QinC_monic_irreducible_ZinC THEN
    qed[]
  ; pass
  ] THEN
  have `!p. p IN P ==> (complex_of_int(B p)) * (D pow n * complex_root_powersums p n) IN ZinC` [ZinC_ring_clauses;int_in_ZinC;RING_MUL] THEN
  have `!p. p IN P ==> ((complex_of_int(B p)) * D pow n) * complex_root_powersums p n IN ZinC` [COMPLEX_MUL_ASSOC] THEN
  have `!p. p IN P ==> (D pow n * (complex_of_int(B p))) * complex_root_powersums p n IN ZinC` [COMPLEX_MUL_SYM] THEN
  have `!p. p IN P ==> D pow n * ((complex_of_int(B p)) * complex_root_powersums p n) IN ZinC` [COMPLEX_MUL_ASSOC] THEN
  have `D pow n IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `!p. p IN P ==> (complex_of_int(B p)) * complex_root_powersums p n IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`\p. (complex_of_int(B p)) * complex_root_powersums p n`;`(D pow n):complex`;`P:((1->num)->complex)->bool`](GSYM RING_SUM_LMUL) THEN
  have `(D pow n) * (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n)) = ring_sum complex_ring P (\x. (D pow n) * ((complex_of_int(B x)) * complex_root_powersums x n))` [complex_ring_clauses;RING_SUM_EQ] THEN
  simp[] THEN
  recall subring_complex_empty THEN
  have `!p. p IN P ==> D pow n * (complex_of_int(B p)) * complex_root_powersums p n IN ring_carrier(subring_generated complex_ring {})` [ZinC_ring_clauses] THEN
  specialize[`complex_ring`;`{}:complex->bool`;`P:((1->num)->complex)->bool`;`\x. D pow n * (complex_of_int(B x)) * complex_root_powersums x n`]ring_sum_subring_generated_v2 THEN
  have `ring_sum complex_ring P (\x. D pow n * (complex_of_int(B x)) * complex_root_powersums x n) = ring_sum ZinC_ring P (\x. D pow n * (complex_of_int(B x)) * complex_root_powersums x n)` [] THEN
  qed[RING_SUM;ZinC_ring_clauses]
);;
```
### Informal statement
For all sets `P` of complex polynomials, all complex numbers `D`, all functions `B` from complex polynomials to integers, and all natural numbers `n`, if `P` is finite, all polynomials in `P` have distinct minimal polynomials, and for all polynomials `p` in `P` and natural numbers `i`, `D` to the power of `i` multiplied by the coefficient of `p` at `poly_deg complex_ring p - i` is in `ZinC` (the complex subring generated by the integers), then `D` to the power of `n` multiplied by the ring sum over `P` of the function mapping each polynomial `p` to `complex_of_int(B p)` times the `n`-th power sum of the complex roots of `p` is in `ZinC`.

### Informal sketch
The proof proceeds by induction and equational reasoning within the complex ring.

- The goal is to show that `D pow n * (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))` is in `ZinC`, given the hypotheses.
- First, it's shown for any polynomial `p` in `P` that `D pow n * complex_root_powersums p n` is in `ZinC`. This subgoal uses the theorem `complex_root_powersums_QinC_monic_irreducible_ZinC`, relying on the assumptions that polynomials in P are monic and irreducible which is implied by `distinct_minpolys`.
- Then, it is shown that `(complex_of_int(B p)) * (D pow n * complex_root_powersums p n)` is in `ZinC`, from the fact that `D pow n * complex_root_powersums p n` is in `ZinC` and integers are in `ZinC` using the properties of the `ZinC` ring.
- Next, `RING_SUM_LMUL` is applied to move `D pow n` outside the sum.
- Finally, `ring_sum_subring_generated_v2` proves that the ring sum over `complex_ring` is equal to the ring sum over `ZinC_ring`.

### Mathematical insight
This theorem establishes a condition under which a weighted sum of power sums of roots of polynomials lies in `ZinC`, which could be exploited to characterize algebraic integers. Crucially, the polynomials must have distinct minimal polynomials. The constant `D` is introduced and appears to be used as a scaling factor ensuring the coefficients are in `ZinC`. The more general subring `ZinC` is used instead of `Z` or `int`, presumably because this is a more general version allowing coefficients to also come from `Z[i]`.

### Dependencies
- Theorems:
  - `complex_root_powersums_QinC_monic_irreducible_ZinC`
  - `ZinC_ring_clauses`
  - `int_in_ZinC`
  - `RING_MUL`
  - `COMPLEX_MUL_ASSOC`
  - `COMPLEX_MUL_SYM`
  - `in_complex_ring`
  - `RING_SUM_LMUL`
  - `RING_SUM_EQ`
  - `GSYM RING_SUM_LMUL`
  - `subring_complex_empty`
  - `ring_sum_subring_generated_v2`
  - `RING_SUM`
- Definitions:
  - `FINITE`
  - `distinct_minpolys`
  - `coeff`
  - `poly_deg`
  - `ring_sum`
  - `complex_root_powersums`
  - `complex_of_int`
  - `ring_polynomial`
  - `ring_irreducible`
  - `x_poly`
  - `monic`
  - `ZinC`

### Porting notes (optional)
- Replace `ZinC` by the equivalent construct in the target system.
- Port `complex_root_powersums_QinC_monic_irreducible_ZinC first`.
- Make sure ring theory has a `ring_sum` with equivalent theorems to `RING_SUM_LMUL`, `RING_SUM_EQ` and `RING_SUM`.


---

## distinct_minpolys_distinct_roots

### Name of formal statement
distinct_minpolys_distinct_roots

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_distinct_roots = prove(`
  !P p q z.
  distinct_minpolys P ==>
  p IN P ==>
  q IN P ==>
  ~(p = q) ==>
  complex_root p z ==>
  ~(complex_root q z)
`,
  intro THEN
  have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_polynomial QinC_ring (q:(1->num)->complex)` [distinct_minpolys] THEN
  have `monic QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `monic QinC_ring (q:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_irreducible(x_poly QinC_ring) p` [distinct_minpolys] THEN
  have `ring_irreducible(x_poly QinC_ring) q` [distinct_minpolys] THEN
  have `~(p = poly_0 QinC_ring:(1->num)->complex)` [ring_irreducible;x_poly_use] THEN
  have `~(q = poly_0 QinC_ring:(1->num)->complex)` [ring_irreducible;x_poly_use] THEN
  have `ring_irreducible(x_poly QinC_ring) q` [distinct_minpolys] THEN
  have `poly_eval complex_ring p z = Cx(&0)` [complex_root] THEN
  have `poly_eval complex_ring q z = Cx(&0)` [complex_root] THEN
  qed[algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple]
);;
```
### Informal statement
For any set of polynomials `P`, and any polynomials `p` and `q`, and any complex number `z`, if `P` is a set of distinct minimal polynomials, and `p` is in `P`, and `q` is in `P`, and `p` and `q` are not equal, and `z` is a complex root of `p`, then `z` is not a complex root of `q`.

### Informal sketch
The proof proceeds as follows:
- Assume that `P` is a set of distinct minimal polynomials, `p` and `q` are in `P` and `p` and `q` are distinct. Also assume that `z` is a complex root of `p`.
- From `distinct_minpolys P`, deduce that the polynomials `p` and `q` are polynomials over the QinC ring of algebraic complex numbers and both are monic and irreducible polynomials.
- From the hypothesis that `z` is a complex root of `p`, we have `poly_eval complex_ring p z = Cx(&0)`.
- From the hypothesis that `z` is a complex root of `q`, we have `poly_eval complex_ring q z = Cx(&0)`.
- Apply the theorem `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple`, that states that an algebraic number has a unique minimal polynomial, to show that `p` and `q` must be equal, contradicting the hypothesis that `p` and `q ` are distinct. Hence, it is not possible that `z` is a complex root of `q`.

### Mathematical insight
This theorem formalizes the idea that distinct minimal polynomials over the algebraic complex numbers have distinct roots. This is a fundamental property used in algebraic number theory when working with minimal polynomials and algebraic numbers.

### Dependencies
- `distinct_minpolys`
- `ring_polynomial`
- `monic`
- `ring_irreducible`
- `x_poly_use`
- `poly_0`
- `poly_eval`
- `complex_root`
- `algebraic_number_is_root_unique_monic_irreducible_QinC_poly_simple`


---

## distinct_minpolys_zero_root

### Name of formal statement
distinct_minpolys_zero_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let distinct_minpolys_zero_root = prove(`
  !P q.
  distinct_minpolys P ==>
  q IN P ==>
  complex_root q (Cx(&0)) ==>
  q = x_pow QinC_ring 1
`,
  intro THEN
  def `S:((1->num)->complex)->bool` `\p. p = q \/ p = x_pow QinC_ring 1` THEN
  have `(q:(1->num)->complex) IN S` [IN] THEN
  have `x_pow QinC_ring 1 IN S` [IN] THEN
  subgoal `distinct_minpolys S` THENL [
    rw[distinct_minpolys] THEN
    GEN_TAC THEN DISCH_TAC THEN
    proven_if `p = q:(1->num)->complex` [distinct_minpolys] THEN
    have `p = x_pow QinC_ring 1` [IN] THEN
    have `ring_polynomial QinC_ring (p:(1->num)->complex)` [x_pow_poly] THEN
    have `poly_deg QinC_ring (x_pow QinC_ring 1) = 1` [deg_x_pow;ring_1_0_QinC] THEN
    have `ring_prime(x_poly QinC_ring) p` [prime_if_deg_1;field_QinC] THEN
    have `ring_irreducible(x_poly QinC_ring) p` [prime_iff_irreducible_over_field;field_QinC] THEN
    qed[monic_x_pow]
  ; pass
  ] THEN
  have `x_pow QinC_ring 1 = x_pow complex_ring 1` [x_pow_QinC_eq_x_pow_complex] THEN
  subgoal `complex_root (x_pow QinC_ring 1) (Cx(&0))` THENL [
    rw[complex_root] THEN
    simp[eval_x_pow;RING_POW_1;in_complex_ring]
  ; pass
  ] THEN
  qed[distinct_minpolys_distinct_roots]
);;
```

### Informal statement
For all sets of polynomials `P` and for all polynomials `q`, if `P` is a set of polynomials with distinct minimal polynomials, and `q` is in `P`, and `Cx(&0)` (the complex number 0) is a complex root of `q`, then `q` is equal to `x_pow QinC_ring 1` (the polynomial x in the ring of polynomials over the complex field).

### Informal sketch
The proof proceeds as follows:
- Assume `distinct_minpolys P` and `q IN P` and `complex_root q (Cx(&0))`.
- Define the set `S` as `{p | p = q \/ p = x_pow QinC_ring 1}`.
- Show that both `q` and `x_pow QinC_ring 1` are in `S`.
- Prove that `distinct_minpolys S`. This is done by considering two polynomials `p1` and `p2` in S and showing that either they're distinct or their minimal polynomials are distinct.
    - Case 1: `p = q`.  We need to show distinct_minpolys given this hypothesis.
    - Case 2: `p = x_pow QinC_ring 1`. Show that `ring_polynomial QinC_ring p`. Show `poly_deg QinC_ring (x_pow QinC_ring 1) = 1`. Show `ring_prime(x_poly QinC_ring) p` using `prime_if_deg_1` and `field_QinC`. Then show `ring_irreducible(x_poly QinC_ring) p` using `prime_iff_irreducible_over_field` and `field_QinC`, then `monic_x_pow`.
- Show that `x_pow QinC_ring 1 = x_pow complex_ring 1`.
- Prove that `complex_root (x_pow QinC_ring 1) (Cx(&0))`. This is established by rewriting with `complex_root`, then simplifying using the definition of `eval_x_pow`, `RING_POW_1`, and `in_complex_ring`.
- Finally, use `distinct_minpolys_distinct_roots` to conclude the proof.

### Mathematical insight
This theorem states that if we have a set of polynomials with distinct minimal polynomials, and one of those polynomials has a root at 0, then that polynomial must be `x`. This makes sense intuitively because `x` is the minimal polynomial with a root at 0. This makes use of the fact that minimal polynomials of distinct elements in a set are distinct.

### Dependencies
- `distinct_minpolys`
- `x_pow_poly`
- `deg_x_pow`
- `ring_1_0_QinC`
- `prime_if_deg_1`
- `field_QinC`
- `prime_iff_irreducible_over_field`
- `monic_x_pow`
- `x_pow_QinC_eq_x_pow_complex`
- `complex_root`
- `eval_x_pow`
- `RING_POW_1`
- `in_complex_ring`
- `distinct_minpolys_distinct_roots`


---

## monic_factorization_distinct_minpolys

### Name of formal statement
monic_factorization_distinct_minpolys

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_factorization_distinct_minpolys = prove(`
  !f.
  ring_polynomial QinC_ring f ==>
  monic QinC_ring f ==>
  ?P e. (
    FINITE P /\
    distinct_minpolys P /\
    (!p. p IN P ==> ~(e p = 0)) /\
    poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p)) = f
  )
`,
  intro THEN
  rw[distinct_minpolys] THEN
  recall field_QinC THEN
  specialize[`QinC_ring`;`f:(1->num)->complex`]monic_factorization_exponents THEN
  choose2 `P:((1->num)->complex)->bool` `e:((1->num)->complex)->num` `FINITE P /\ (!p. p IN P ==> ring_polynomial QinC_ring p) /\ (!p. p IN P ==> monic QinC_ring p) /\ (!p. p IN P ==> ring_irreducible (x_poly QinC_ring) p) /\ (!p. p IN P ==> ~(e p = 0)) /\ poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p)) = f` [] THEN
  witness `P:((1->num)->complex)->bool` THEN
  witness `e:((1->num)->complex)->num` THEN
  qed[]
);;
```
### Informal statement
For any polynomial `f` over the quotient field `Q\C` (where Q denotes the field of rational numbers, and C denotes the field of complex numbers) which is monic, there exist a finite set `P` of polynomials over `Q\C` and a function `e` from `P` to natural numbers such that:
  1. `P` is a finite set.
  2. The minimal polynomials in `P` are distinct.
  3. For every `p` in `P`, `e(p)` is not zero.
  4. The product of `p` raised to the power `e(p)` (for `p` in `P`) equals `f`.

### Informal sketch
The proof proceeds as follows:
- We start by introducing the assumption that the polynomial `f` is monic and a polynomial over the quotient field `Q\C`.
- We unfold the definition of `distinct_minpolys`.
- We recall the theorem `field_QinC`.
- We specialize a theorem `monic_factorization_exponents` where the ring is `QinC_ring` and `f` is a polynomial over `Q\C`, obtaining the sets `P` and `e` such that the desired conditions hold: `P` is finite, all `p` in `P` are polynomials over `Q\C`, monic, irreducible, such that `e(p)` is non-zero and the product of `p` to the power of `e(p)` equals `f`.
- We then conclude by providing the sets `P` and `e` as witnesses using the `witness` tactic.

### Mathematical insight
This theorem states that any monic polynomial `f` over the quotient field `Q\C` can be factored into a product of powers of distinct monic irreducible polynomials, where each exponent is non-zero. This is a fundamental result in field theory, related to the unique factorization of polynomials over fields. The minimal polynomials condition ensures that the factorization is canonical in some sense.

### Dependencies
- `distinct_minpolys`
- `field_QinC`
- `monic_factorization_exponents`


---

## multi_monic_factorization_distinct_minpolys

### Name of formal statement
multi_monic_factorization_distinct_minpolys

### Type of the formal statement
theorem

### Formal Content
```ocaml
let multi_monic_factorization_distinct_minpolys = prove(`
  !S f.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial QinC_ring (f s)) ==>
  (!s:X. s IN S ==> monic QinC_ring (f s)) ==>
  ?P e. (
    FINITE P /\
    distinct_minpolys P /\
    (!s. s IN S ==>
         poly_product QinC_ring P (\p. poly_pow QinC_ring p (e s p)) = f s
    )
  )
`,
  intro THEN
  subgoal `!s:X. s IN S ==> ?P e. FINITE P /\ distinct_minpolys P /\ (!p. p IN P ==> ~(e p = 0)) /\ poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p)) = f s` THENL [
    intro THEN
    specialize_assuming[`f(s:X):(1->num)->complex`]monic_factorization_distinct_minpolys THEN
    qed[]
  ; pass
  ] THEN
  def `Q:X->((1->num)->complex)->bool` `\s:X. @P. ?e. FINITE P /\ distinct_minpolys P /\ (!p. p IN P ==> ~(e p = 0)) /\ poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p)) = f s` THEN
  subgoal `!s:X. s IN S ==> ?d. FINITE (Q s) /\ distinct_minpolys (Q s) /\ (!p. p IN (Q s) ==> ~(d p = 0)) /\ poly_product QinC_ring (Q s) (\p. poly_pow QinC_ring p (d p)) = f s` THENL [
    specialize[
      `S:X->bool`;
      `\s:X P. (?d. FINITE P /\ distinct_minpolys P /\ (!p. p IN P ==> ~(d p = 0)) /\ poly_product QinC_ring P (\p. poly_pow QinC_ring p (d p)) = f s)`
    ]select_foreach THEN
    simp[]
  ; pass
  ] THEN
  have `!s:X. s IN S ==> FINITE (Q s:((1->num)->complex)->bool)` [] THEN
  have `!s:X. s IN S ==> distinct_minpolys (Q s:((1->num)->complex)->bool)` [] THEN
  def `P:((1->num)->complex)->bool` `UNIONS { Q s:((1->num)->complex)->bool| s:X IN S }` THEN
  subgoal `!s:X. s IN S ==> ?e. poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p)) = f s:(1->num)->complex` THENL [
    have `!s:X. s IN S ==> ?d. ((!p. p IN (Q s) ==> ~(d p = 0)) /\ poly_product QinC_ring (Q s) (\p. poly_pow QinC_ring p (d p)) = f s)` [] THEN
    specialize[
      `S:X->bool`;
      `\s:X d. (!p. p IN (Q s) ==> ~(d p = 0)) /\ poly_product QinC_ring (Q s) (\p. poly_pow QinC_ring p (d p)) = f s`
    ]select_foreach THEN
    intro THEN
    choose `d:((1->num)->complex)->num` `poly_product QinC_ring (Q s) (\p. poly_pow QinC_ring p (d p)) = f(s:X):(1->num)->complex` [] THEN
    witness `\p:(1->num)->complex. if p IN Q(s:X) then d p else 0` THEN
    rw[BETA_THM] THEN
    subgoal `poly_product QinC_ring P (\p. poly_pow QinC_ring p (if p IN Q(s:X) then d p else 0)) = poly_product QinC_ring P (\p. if p IN Q s then poly_pow QinC_ring p (d p) else poly_1 QinC_ring)` THENL [
      sufficesby poly_product_eq THEN
      qed[poly_pow_0]
    ; pass
    ] THEN
    rw[know `poly_product QinC_ring P (\p. poly_pow QinC_ring p (if p IN Q(s:X) then d p else 0)) = poly_product QinC_ring P (\p. if p IN Q s then poly_pow QinC_ring p (d p) else poly_1 QinC_ring)`] THEN
    set_fact_using `Q(s:X) SUBSET P:((1->num)->complex)->bool` [know `s:X IN S`;know `P = UNIONS {Q s:((1->num)->complex)->bool | s:X IN S}`] THEN
    specialize[
      `QinC_ring`;
      `Q(s:X):((1->num)->complex)->bool`;
      `P:((1->num)->complex)->bool`;
      `\p:(1->num)->complex. poly_pow QinC_ring p (d p)`
    ]poly_product_restrict_subset THEN
    qed[]
  ; pass
  ] THEN
  def `e:X->((1->num)->complex)->num` `\s:X. @d. poly_product QinC_ring P (\p. poly_pow QinC_ring p (d p)) = f s:(1->num)->complex` THEN
  witness `P:((1->num)->complex)->bool` THEN
  witness `e:X->((1->num)->complex)->num` THEN
  intro THENL [
    rw[know `P = UNIONS {Q s:((1->num)->complex)->bool | s:X IN S}`] THEN
    rw[FINITE_UNIONS;IN_ELIM_THM] THEN
    once_rw[SIMPLE_IMAGE_GEN] THEN
    rw[IN_GSPEC] THEN
    specialize[
      `Q:X->((1->num)->complex)->bool`;
      `S:X->bool`
    ]FINITE_IMAGE THEN
    qed[]
  ;
    rw[distinct_minpolys] THEN
    rw[know `P = UNIONS {Q s:((1->num)->complex)->bool | s:X IN S}`] THEN
    rw[IN_UNIONS;IN_ELIM_THM] THEN
    qed[distinct_minpolys]
  ;
    specialize[
      `S:X->bool`;
      `\s:X d. poly_product QinC_ring P (\p. poly_pow QinC_ring p (d p)) = f s`
    ]select_foreach THEN
    rw[know `e = (\s:X. @d. poly_product QinC_ring P (\p. poly_pow QinC_ring p (d p)) = f s)`] THEN
    qed[]
  ]
);;
```
### Informal statement
For all sets `S` and functions `f` from `X` to polynomials over the ring `QinC_ring` , if `S` is finite, and for all `s` in `S`, `f s` is a polynomial over the ring `QinC_ring`, and for all `s` in `S`, `f s` is monic over the ring `QinC_ring`, then there exist `P` and `e` such that `P` is finite, `P` consists of polynomials with distinct minimal polynomials, and for all `s` in `S`, the polynomial product over `P` of each `p` in `P` raised to the power `e s p` is equal to `f s`.

### Informal sketch
The proof demonstrates that a finite set of monic polynomials can be factored into a product of distinct minimal polynomials raised to certain powers.
- It leverages the existing theorem `monic_factorization_distinct_minpolys`, which establishes that any monic polynomial can be factored into a product of powers of distinct minimal polynomials.
- The main idea is to find the distinct minimal polynomial factors for each polynomial `f s` where `s` is in `S`, and then take the union of all these minimal polynomial factors.
- The function `Q` is defined such that `Q s` gives the set of distinct monic minimal polynomial factors of `f s`.
- The set `P` is then defined as the union of all `Q s` for `s` in `S`. This ensures that `P` is a finite set of distinct minimal polynomials since `S` is finite and each `Q s` is finite.
- A function `e` is defined such that `e s p` gives the exponent to which the minimal polynomial `p` is raised in the factorization of `f s`.
- Finally, it is shown that for all `s` in `S`, `f s` can be expressed as the product of elements of `P` raised to appropriate powers (given by `e`). This involves adjusting the exponents when dealing with the union of sets. The tactic `poly_product_restrict_subset` plays a part in this last step.

### Mathematical insight
This theorem extends the single monic polynomial factorization result to a finite set of monic polynomials. It shows that these polynomials can all be expressed using a common finite set of minimal polynomials `P`, with varying exponents for each polynomial in the set `S`. This result is essential when dealing with sets of monic polynomials, for example, to understand their divisibility properties within a ring of polynomials.

### Dependencies
- `monic_factorization_distinct_minpolys`
- `FINITE_UNIONS`
- `select_foreach`
- `poly_product_restrict_subset`
- `poly_pow_0`

### Porting notes (optional)
- The use of `@` for Hilbert choice in the definitions of `Q` and `e` might require care when porting to other proof assistants. Some systems have slightly different axioms, or require explicit proof of existence before applying choice.
- The `select_foreach` tactic is used to choose a dependent function within a quantified context. This pattern might need to be translated manually in other systems that don't have equivalent tactics.
- HOL Light relies on rewriting and equational reasoning. Ensure that the target proof assistant has similar capabilities for efficiently manipulating polynomial expressions.


---

## binom_coeff

### Name of formal statement
binom_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let binom_coeff = prove(`
  !n d.
  coeff d (
    poly_pow integer_ring (
      poly_add integer_ring
        (x_pow integer_ring 0)
        (x_pow integer_ring 1)
    ) n
  )
  = &(binom(n,d)):int
`,
  INDUCT_TAC THENL [
    rw[poly_pow_0] THEN
    rw[BINOM_0;coeff_poly_1] THEN
    rw[INTEGER_RING] THEN
    qed[]
  ;
    intro THEN
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    simp[poly_pow_add;RING_POWERSERIES_ADD;x_pow_series] THEN
    rw[coeff_poly_mul_oneindex] THEN
    simp[poly_pow_1;RING_POWERSERIES_ADD;x_pow_series] THEN
    rw[coeff_poly_add;coeff_x_pow] THEN
    subgoal `ring_sum integer_ring (0..d) (\a. ring_mul integer_ring (ring_add integer_ring (if a = 0 then ring_1 integer_ring else ring_0 integer_ring) (if a = 1 then ring_1 integer_ring else ring_0 integer_ring)) (&(binom (n,d - a)))) = ring_sum integer_ring (0..d) (\a. if a = 0 then &(binom(n,d)) else if a = 1 then &(binom(n,d-1)) else ring_0 integer_ring)` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      rw[BETA_THM] THEN
      case `a = 0` THENL [
        simp[ARITH_RULE `~(0 = 1)`] THEN
        simp[RING_ADD_RZERO;RING_1] THEN
        qed[RING_MUL_LID;RING_OF_NUM;INTEGER_RING_OF_NUM;ARITH_RULE `d - 0 = d`]
      ; pass
      ] THEN
      case `a = 1` THENL [
        simp[RING_ADD_LZERO;RING_1] THEN
        qed[RING_MUL_LID;RING_OF_NUM;INTEGER_RING_OF_NUM]
      ; pass
      ] THEN
      simp[RING_ADD_LZERO;RING_0] THEN
      qed[RING_MUL_LZERO;RING_OF_NUM;INTEGER_RING_OF_NUM]
    ; pass
    ] THEN
    simp[] THEN
    case `d = 0` THENL [
      subgoal `ring_sum integer_ring (0..d) (\a. if a = 0 then &(binom (n,d)) else if a = 1 then &(binom (n,d - 1)) else ring_0 integer_ring) = ring_sum integer_ring (0..d) (\a. if a = 0 then &(binom (n,d)) else ring_0 integer_ring)` THENL [
        sufficesby RING_SUM_EQ THEN
        intro THEN
        rw[BETA_THM] THEN
        have `a <= d:num` [IN_NUMSEG] THEN
        num_linear_fact `a <= d ==> d = 0 ==> ~(a = 1)` THEN
        qed[]
      ; pass
      ] THEN
      have `0 IN 0..0` [IN_NUMSEG_0;ARITH_RULE `0 <= 0`] THEN
      have `&(binom (n,0)) IN ring_carrier integer_ring` [RING_OF_NUM;INTEGER_RING_OF_NUM] THEN
      simp[RING_SUM_DELTA] THEN
      qed[binom]
    ; pass
    ] THEN
    num_linear_fact `0 <= d` THEN
    have `0 IN 0..d` [IN_NUMSEG_0] THEN
    num_linear_fact `~(d = 0) ==> 1 <= d` THEN
    have `FINITE (0..d)` [FINITE_NUMSEG] THEN
    have `1 IN 0..d` [IN_NUMSEG_0] THEN
    have `&(binom (n,d)) IN ring_carrier integer_ring` [RING_OF_NUM;INTEGER_RING_OF_NUM] THEN
    have `&(binom (n,d-1)) IN ring_carrier integer_ring` [RING_OF_NUM;INTEGER_RING_OF_NUM] THEN
    simp[ring_sum_delta_delta;ARITH_RULE `~(0 = 1)`] THEN
    rw[INTEGER_RING] THEN
    num_linear_fact `1+n = SUC n` THEN
    def `d1:num` `d-1` THEN
    num_linear_fact `~(d = 0) ==> d1 = d-1 ==> d = SUC d1` THEN
    rw[know `d = SUC d1`] THEN
    rw[know `1 + n = SUC n`] THEN
    rw[binom] THEN
    rw[ARITH_RULE `SUC d1 - 1 = d1`] THEN
    qed[INT_OF_NUM_ADD]
  ]
);;
```

### Informal statement
For all natural numbers `n` and `d`, the coefficient of `x^d` in the polynomial `(1 + x)^n` is equal to the integer representation of the binomial coefficient of `n` choose `d`.

### Informal sketch
The proof proceeds by induction on `n`.

- Base case (`n = 0`): Show that the coefficient of `x^d` in `(1 + x)^0 = 1` is equal to the integer representation of `binom(0, d)`. If `d = 0`, the coefficient is 1, which equals `binom(0, 0)`. If `d > 0`, the coefficient is 0, which equals `binom(0, d)`.

- Inductive step: Assume the theorem holds for `n`. We want to show it holds for `n+1`.
  - Rewrite `(1 + x)^(n+1)` as `(1 + x)^n * (1 + x)`.
  - Use the inductive hypothesis to express the coefficients of `(1 + x)^n` in terms of binomial coefficients.
  - Compute the coefficients of the product `(1 + x)^n * (1 + x)` using the formula for the coefficients of a product of polynomials, which involves a summation.
  - Simplify the summation using the fact that `(1+x) = x^0 + x^1`.
  - The summation then reduces to `binom(n, d) + binom(n, d-1)`.
  - Apply the identity `binom(n+1, d) = binom(n, d) + binom(n, d-1)` to complete the proof.
  - Several case splits on `d = 0` are used when simplifying sums with bounds related to `d`.  The identity `binom(n, SUC d1) = binom(SUC d1 + n, SUC d1)` which is the standard recursive defintion is unfolded after the main summation is simplified.

### Mathematical insight
This theorem connects the binomial coefficients, which are defined combinatorially, with the coefficients of the polynomial expansion of `(1 + x)^n`. This provides an algebraic interpretation of binomial coefficients and is fundamental for many combinatorial arguments and algebraic manipulations.

### Dependencies
- `poly_pow`
- `integer_ring`
- `poly_add`
- `x_pow`
- `coeff`
- `binom`
- `poly_pow_0`
- `BINOM_0`
- `coeff_poly_1`
- `INTEGER_RING`
- `poly_pow_add`
- `RING_POWERSERIES_ADD`
- `x_pow_series`
- `coeff_poly_mul_oneindex`
- `poly_pow_1`
- `coeff_poly_add`
- `coeff_x_pow`
- `RING_SUM_EQ`
- `BETA_THM`
- `RING_ADD_RZERO`
- `RING_1`
- `RING_MUL_LID`
- `RING_OF_NUM`
- `INTEGER_RING_OF_NUM`
- `RING_ADD_LZERO`
- `RING_MUL_LZERO`
- `RING_0`
- `RING_SUM_DELTA`
- `FINITE_NUMSEG`
- `ring_sum_delta_delta`
- `INT_OF_NUM_ADD`


---

## binom_sum

### Name of formal statement
binom_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let binom_sum = prove(`
  !m n d.
  binom(m+n,d) = nsum(0..d) (\i. binom(m,i) * binom(n,d-i))
`,
  intro THEN
  rw[GSYM INT_OF_NUM_EQ] THEN
  rw[GSYM binom_coeff] THEN
  simp[poly_pow_add;RING_POWERSERIES_ADD;x_pow_series] THEN
  rw[coeff_poly_mul_oneindex] THEN
  have `FINITE (0..d)` [FINITE_NUMSEG] THEN
  simp[int_of_num_sum] THEN
  simp[isum_integer_sum] THEN
  sufficesby RING_SUM_EQ THEN
  intro THEN
  rw[BETA_THM] THEN
  rw[GSYM INT_OF_NUM_MUL] THEN
  rw[GSYM binom_coeff] THEN
  rw[INTEGER_RING]
);;
```
### Informal statement
For all natural numbers `m`, `n`, and `d`, the binomial coefficient of `m+n` choose `d` is equal to the sum from `i = 0` to `d` of the product of the binomial coefficient of `m` choose `i` and the binomial coefficient of `n` choose `d-i`.

### Informal sketch
The proof proceeds as follows:
- Introduce the variables `m`, `n`, and `d`.
- Rewrite the goal by converting from natural numbers to integers.
- Rewrite the goal by replacing the `binom` function with `binom_coeff`.
- Simplify using rules such as `poly_pow_add`, `RING_POWERSERIES_ADD`, and `x_pow_series`.
- Rewrite using `coeff_poly_mul_oneindex`.
- Establish that the set `{0..d}` is finite using `FINITE_NUMSEG`.
- Simplify using rules about integer sums (`int_of_num_sum`, `isum_integer_sum`).
- Reduce the goal to proving an equality involving sums over a ring using `RING_SUM_EQ`.
- Introduce a variable.
- Rewrite and beta-reduce, then rewrite by distributing integer conversions across multiplication and revert to `binom_coeff`.
- Use the properties of the INTEGER_RING for the final simplification.

### Mathematical insight
This theorem expresses the convolution property of binomial coefficients. It states that the number of ways to choose `d` elements from the union of two disjoint sets of sizes `m` and `n` is the sum, over all possible sizes `i` of the subset chosen from the first set, of the product of the number of ways to choose `i` elements from the first set and the number of ways to choose `d-i` elements from the second set. This result relates to polynomial multiplication and is a fundamental identity in combinatorics.

### Dependencies
#### Theorems
- `INT_OF_NUM_EQ`
- `binom_coeff`
- `poly_pow_add`
- `RING_POWERSERIES_ADD`
- `x_pow_series`
- `coeff_poly_mul_oneindex`
- `FINITE_NUMSEG`
- `int_of_num_sum`
- `isum_integer_sum`
- `RING_SUM_EQ`
- `BETA_THM`
- `INT_OF_NUM_MUL`
- `INTEGER_RING`

#### Tactics
- `intro`
- `rw`
- `simp`
- `have`
- `sufficesby`


---

## binom_rowsum

### Name of formal statement
binom_rowsum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let binom_rowsum = prove(`
  !m.
  nsum(0..m) (\i. binom(m,i)) = 2 EXP m
`,
  intro THEN
  specialize[`m:num`;`1`;`1`]BINOMIAL_THEOREM THEN
  subgoal `nsum (0..m) (\k. binom (m,k) * 1 EXP k * 1 EXP (m - k)) = nsum (0..m) (\k. binom (m,k))` THENL [
    sufficesby NSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    rw[EXP_ONE] THEN
    rw[MULT_CLAUSES]
  ; pass
  ] THEN
  qed[ARITH_RULE `1+1 = 2`]
);;
```
### Informal statement
For all natural numbers `m`, the sum of the binomial coefficients `binom(m,i)` from `i=0` to `i=m` is equal to 2 raised to the power of `m`.

### Informal sketch
The proof proceeds as follows:
- Introduce `m`.
- Specialize the `BINOMIAL_THEOREM` with `m`, `1`, and `1`.
- Establish that `nsum (0..m) (\k. binom (m,k) * 1 EXP k * 1 EXP (m - k)) = nsum (0..m) (\k. binom (m,k))` by showing that the summands are equal.
  -  Use `NSUM_EQ` to prove the equality of the sums.
  - Introduce `k`.
  - Simplify the summand using `BETA_THM`, `EXP_ONE`, and `MULT_CLAUSES` to show the equality of the summands.
- Complete the proof by simplifying `(1+1) EXP m` to `2 EXP m` using the arithmetic rule `1+1 = 2`.

### Mathematical insight
This theorem states that the sum of the elements in the `m`-th row of Pascal's triangle equals `2^m`.  This is a fundamental property of binomial coefficients and can be seen as a special case of the binomial theorem where both terms are equal to 1.

### Dependencies
- Theorems: `BINOMIAL_THEOREM`, `BETA_THM`, `EXP_ONE`, `MULT_CLAUSES`
- Definitions: `binom`, `nsum`
- Rules: `ARITH_RULE`


---

## binom_rowsum_partial

### Name of formal statement
binom_rowsum_partial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let binom_rowsum_partial = prove(`
  !m k.
  nsum(0..k) (\i. binom(m,i)) <= 2 EXP m
`,
  intro THEN
  have `2 EXP m = nsum(0..m) (\i. binom(m,i))` [binom_rowsum] THEN
  case `k <= m:num` THENL [
    have `(0..k) SUBSET (0..m)` [SUBSET_NUMSEG;ARITH_RULE `0 <= 0`] THEN
    qed[NSUM_SUBSET_SIMPLE;FINITE_NUMSEG]
  ;
    simp[] THEN
    sufficesby NSUM_SUBSET THEN
    simp[FINITE_NUMSEG] THEN
    rw[IN_DIFF;IN_NUMSEG] THEN
    intro THEN
    num_linear_fact `~(0 <= x /\ x <= m) ==> m < x` THEN
    qed[BINOM_LT]
  ]
);;
```
### Informal statement
For all natural numbers `m` and `k`, the sum of the binomial coefficients `binom(m, i)` for `i` ranging from 0 to `k` is less than or equal to 2 raised to the power of `m`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions `m` and `k`.
- Establish that `2^m` is equal to the sum of `binom(m, i)` from `i = 0` to `m`. This relies on the theorem `binom_rowsum`.
- Perform a case split on whether `k <= m`.
  - Case 1: `k <= m`.
    - Show that the set `{0..k}` is a subset of `{0..m}` using `SUBSET_NUMSEG` and arithmetic reasoning.
    - Conclude that `nsum(0..k) (\i. binom(m,i)) <= nsum(0..m) (\i. binom(m,i))` using `NSUM_SUBSET_SIMPLE` and the finiteness of the set `{0..m}`.
  - Case 2: `~(k <= m)`.
    - Simplify the goal.
    - Reduce the goal to showing that `nsum(0..m) (\i. binom(m,i)) <= nsum(0..k) (\i. binom(m,i))` by `NSUM_SUBSET`
    - Simplify using the finiteness of the sets.
    - Rewrite the subset relation using `IN_DIFF` and `IN_NUMSEG`.
    - Introduce the assumption that `x` is in `0..m` but not in `0..k`.
    - Use a numeric linear fact to show that `~(0 <= x /\ x <= m)` implies `m < x`.
    - Conclude using the lemma `BINOM_LT`, which states that `binom(m, i) = 0` if `i > m`, and `m < x` ensures that `binom(m,x) = 0`.

### Mathematical insight
The theorem provides an upper bound for the partial sum of binomial coefficients in a row of Pascal's triangle. It leverages the fact that the sum of all binomial coefficients in a row is `2^m`, a well known binomial identity.

### Dependencies
- `binom_rowsum`
- `SUBSET_NUMSEG`
- `ARITH_RULE` (for `0 <= 0`)
- `NSUM_SUBSET_SIMPLE`
- `FINITE_NUMSEG`
- `IN_DIFF`
- `IN_NUMSEG`
- `BINOM_LT`
- `NSUM_SUBSET`

### Porting notes (optional)
The theorem relies on the properties of summation over finite sets of natural numbers. The `NSUM_SUBSET_SIMPLE` theorem expresses a monotonicity property. The `num_linear_fact` tactic is crucial for discharging arithmetic side conditions in the proof via linera arithmetic. `BINOM_LT` is critical for reasoning about values outside of the binomial definition's domain, i.e., is zero where `k > m`.


---

## coeff_root_bound_1

### Name of formal statement
coeff_root_bound_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_root_bound_1 = prove(`
  !A:real d.
  norm(coeff d (poly_1 complex_ring))
  <= A pow d * &(binom(0,d))
`,
  intro THEN
  rw[coeff_poly_1] THEN
  case `d = 0` THENL [
    simp[complex_ring_clauses] THEN
    rw[real_pow;binom;COMPLEX_NORM_CX] THEN
    real_field_fact `abs(&1) <= &1 * &1` THEN
    qed[]
  ; pass
  ] THEN
  simp[complex_ring_clauses] THEN
  rw[COMPLEX_NORM_CX] THEN
  num_linear_fact `~(d = 0) ==> 0 < d` THEN
  simp[BINOM_LT] THEN
  real_field_fact `abs(&0):real <= A pow d * &0` THEN
  qed[]
);;
```
### Informal statement
For all real numbers `A` and natural numbers `d`, the norm of the `d`-th coefficient of the polynomial `poly_1 complex_ring` is less than or equal to `A` raised to the power of `d` multiplied by the binomial coefficient of `(0, d)`.

### Informal sketch
The proof proceeds by induction on `d`.

- **Base Case (d = 0):**
  - Simplify the statement using `complex_ring_clauses` and `coeff_poly_1`.
  - Rewrite using `real_pow`, `binom`, and `COMPLEX_NORM_CX` to simplify norm of a complex number.
  - Apply a real field fact `abs(&1) <= &1 * &1` to complete the base case.
- **Inductive Step:**
  - Assume `d != 0`.
   - Simplify using `complex_ring_clauses`.
   - Rewrite using `COMPLEX_NORM_CX`.
  - Use the fact that `~(d = 0) ==> 0 < d`.
  - Simplify using `BINOM_LT`.
  - Apply the real field fact `abs(&0):real <= A pow d * &0` to complete the proof.

### Mathematical insight
This theorem provides a bound on the coefficients of a specific polynomial (`poly_1 complex_ring`) in terms of its roots. The `poly_1` is implicitly defined, where all its roots are 1 each, and it simplifies to coefficients being `&(binom(0, d)`. In this case, it establishes an upper bound of the d-th coefficient of that polynomial with all roots equal to 1.

### Dependencies
- `binom`
- `coeff_poly_1`
- `complex_ring_clauses`
- `COMPLEX_NORM_CX`
- `real_pow`
- `BINOM_LT`


---

## coeff_root_bound_one_minus_constx

### Name of formal statement
coeff_root_bound_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_root_bound_one_minus_constx = prove(`
  !c:complex A:real d:num.
  norm(c) <= A ==>
  norm(coeff d (one_minus_constx complex_ring c))
  <= A pow d * &(binom(1,d))
`,
  intro THEN
  simp[coeff_one_minus_constx;in_complex_ring] THEN
  case `d = 0` THENL [
    simp[complex_ring_clauses] THEN
    rw[real_pow;binom;COMPLEX_NORM_CX] THEN
    real_field_fact `abs(&1) <= &1 * &1` THEN
    qed[]
  ; pass
  ] THEN
  case `d = 1` THENL [
    simp[complex_ring_clauses] THEN
    rw[REAL_POW_1;BINOM_REFL;NORM_NEG] THEN
    real_field_fact `A = A * &1:real` THEN
    qed[]
  ; pass
  ] THEN
  simp[complex_ring_clauses] THEN
  rw[COMPLEX_NORM_CX] THEN
  num_linear_fact `~(d = 0) ==> ~(d = 1) ==> 1 < d` THEN
  simp[BINOM_LT] THEN
  real_field_fact `abs(&0):real <= A pow d * &0` THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `c`, real numbers `A`, and natural numbers `d`, if the norm of `c` is less than or equal to `A`, then the norm of the `d`-th coefficient of the power series expansion of `1 - c*x` in the `complex_ring` is less than or equal to `A` raised to the power of `d` times the binomial coefficient of `(1, d)`.

### Informal sketch
The proof proceeds by induction on `d`.

- The base cases `d = 0` and `d = 1` are handled separately.
  - When `d = 0`, the coefficient is `1`, so the norm is `1`, and the binomial coefficient is also `1`. The goal reduces to showing that `abs(&1) <= &1 * &1`, a field fact.
  - When `d = 1`, the coefficient is `-c`, so the norm is `norm(c)`, which is less than or equal to `A` by assumption. The binomial coefficient is `1` and reduces to `A = A * &1:real`, which is a field fact.

- For the case when  `d` is neither `0` nor `1`, `1 < d` can be proven by `num_linear_fact`.
  - In this case, the `(1, d)` entry of the binomial coefficient `<` `0` (proven by `BINOM_LT`), and since the absolute value/norm of a real zero term is always than or equal to `A pow d * &0`, via term rewriting and simplification the goal reduces to this trivial inequality and the goal is proven.

### Mathematical insight
This theorem provides a bound on the coefficients of the power series expansion of the function `1 - c*x`, where `c` is a complex number. This bound depends on the norm of `c` and the index `d` of the coefficient. The result can be used to estimate the convergence rate of the power series and to control the size of the coefficients.

### Dependencies
- `coeff_one_minus_constx`
- `in_complex_ring`
- `complex_ring_clauses`
- `real_pow`
- `binom`
- `COMPLEX_NORM_CX`
- `REAL_POW_1`
- `BINOM_REFL`
- `NORM_NEG`
- `BINOM_LT`


---

## coeff_root_bound_mul

### Name of formal statement
coeff_root_bound_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_root_bound_mul = prove(`
  !p q (A:real) m n.
  (!d. norm(coeff d p) <= A pow d * &(binom(m,d))) ==>
  (!d. norm(coeff d q) <= A pow d * &(binom(n,d))) ==>
  (!d. norm(coeff d (poly_mul complex_ring p q)) <= A pow d * &(binom(m+n,d)))
`,
  intro THEN
  rw[coeff_poly_mul_oneindex] THEN
  rw[complex_ring_clauses] THEN
  simp[GSYM vsum_ring_sum_complex;FINITE_NUMSEG] THEN
  subgoal `!a. a IN (0..d) ==> norm(coeff a p * coeff (d-a) q) <= A pow d * &(binom(m,a)*binom(n,d-a))` THENL [
    intro THEN
    rw[GSYM REAL_OF_NUM_MUL] THEN
    have `norm(coeff a (p:(1->num)->complex) * coeff (d-a) (q:(1->num)->complex)) = norm(coeff a p) * norm(coeff (d-a) q)` [COMPLEX_NORM_MUL] THEN
    have `norm(coeff a (p:(1->num)->complex)) * norm(coeff (d-a) (q:(1->num)->complex)) <= (A pow a * &(binom(m,a))) * (A pow (d-a) * &(binom(n,d-a)))` [REAL_LE_MUL2;NORM_POS_LE] THEN
    have `a <= d:num` [IN_NUMSEG] THEN
    num_linear_fact `a <= d:num ==> d = a + (d-a)` THEN
    have `(A:real) pow d = A pow a * A pow (d-a)` [REAL_POW_ADD] THEN
    real_linear_fact `((A:real) pow a * &(binom (m,a))) * A pow (d - a) * &(binom (n,d - a)) = (A pow a * A pow (d-a)) * &(binom (m,a)) * &(binom (n,d - a))` THEN
    qed[]
  ; pass
  ] THEN
  subgoal `norm(vsum(0..d) (\a. coeff a p * coeff (d - a) q)) <= sum(0..d) (\a. A pow d * &(binom (m,a) * binom (n,d - a)))` THENL [
    sufficesby VSUM_NORM_LE THEN
    qed[FINITE_NUMSEG]
  ; pass
  ] THEN
  specialize[`\a. &(binom (m,a) * binom (n,d - a)):real`;`(A:real) pow d`;`0..d`]SUM_LMUL THEN
  have `norm(vsum(0..d) (\a. coeff a p * coeff (d - a) q)) <= (A:real) pow d * sum(0..d) (\a. &(binom (m,a) * binom (n,d - a)))` [] THEN
  rw[binom_sum] THEN
  simp[REAL_OF_NUM_SUM;FINITE_NUMSEG]
);;
```

### Informal statement
For all polynomials `p` and `q` with complex coefficients, and for all real numbers `A`, and for all natural numbers `m` and `n`, if for all natural numbers `d`, the norm of the `d`-th coefficient of `p` is less than or equal to `A` raised to the power of `d` multiplied by the binomial coefficient of `m` and `d`, and if for all natural numbers `d`, the norm of the `d`-th coefficient of `q` is less than or equal to `A` raised to the power of `d` multiplied by the binomial coefficient of `n` and `d`, then for all natural numbers `d`, the norm of the `d`-th coefficient of the polynomial `poly_mul complex_ring p q` is less than or equal to `A` raised to the power of `d` multiplied by the binomial coefficient of `m+n` and `d`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions about `p`, `q`, `A`, `m`, and `n` using `intro`.
- Rewrite using `coeff_poly_mul_oneindex` and `complex_ring_clauses`. These steps expand the definition of the coefficient of the product of two polynomials and simplify expressions related to complex numbers.
- Simplify the expression involving a summation using `GSYM vsum_ring_sum_complex;FINITE_NUMSEG`.
- Establish the inequality `norm(coeff a p * coeff (d-a) q) <= A pow d * &(binom(m,a)*binom(n,d-a))` under the assumption that `a IN (0..d)`.
  - Introduce the assumption `a IN (0..d)`.
  - Rewrite using `GSYM REAL_OF_NUM_MUL`.
  - Show that `norm(coeff a p * coeff (d-a) q) = norm(coeff a p) * norm(coeff (d-a) q)` use `COMPLEX_NORM_MUL`.
  - Show that `norm(coeff a p) * norm(coeff (d-a) q) <= (A pow a * &(binom(m,a))) * (A pow (d-a) * &(binom(n,d-a)))` use `REAL_LE_MUL2;NORM_POS_LE`.
  - Show that `a <= d:num` use `IN_NUMSEG`.
  - Show that `d = a + (d-a)` use `num_linear_fact`.
  - Show that `(A:real) pow d = A pow a * A pow (d-a)` use `REAL_POW_ADD`.
  - Show that `((A:real) pow a * &(binom (m,a))) * A pow (d - a) * &(binom (n,d - a)) = (A pow a * A pow (d-a)) * &(binom (m,a)) * &(binom (n,d - a))` use `real_linear_fact`.
- Establish the inequality `norm(vsum(0..d) (\a. coeff a p * coeff (d - a) q)) <= sum(0..d) (\a. A pow d * &(binom (m,a) * binom (n,d - a)))`.
  - Prove `VSUM_NORM_LE` which states that the norm of a sum is less than or equal to the sum of the norms and show `FINITE_NUMSEG`.
- Specialize `SUM_LMUL` for `\a. &(binom (m,a) * binom (n,d - a)):real`, `(A:real) pow d` and `0..d`.
- Show that `norm(vsum(0..d) (\a. coeff a p * coeff (d - a) q)) <= (A:real) pow d * sum(0..d) (\a. &(binom (m,a) * binom (n,d - a)))`.
- Rewrite using `binom_sum` and simplify using `REAL_OF_NUM_SUM;FINITE_NUMSEG`.

### Mathematical insight
This theorem provides an upper bound on the coefficients of the product of two polynomials, given upper bounds on the coefficients of the individual polynomials. The bound involves powers of a real number `A` and binomial coefficients. This kind of bound is useful in various contexts, such as analyzing the growth of polynomial coefficients or estimating the roots of polynomials. The theorem essentially states that if the coefficients of two polynomials are bounded in a specific way involving binomial coefficients, then the coefficients of their product are also bounded in a similar way.

### Dependencies
-  `coeff_poly_mul_oneindex`
- `complex_ring_clauses`
- `vsum_ring_sum_complex`
- `FINITE_NUMSEG`
- `REAL_OF_NUM_MUL`
- `COMPLEX_NORM_MUL`
- `REAL_LE_MUL2`
- `NORM_POS_LE`
- `IN_NUMSEG`
- `REAL_POW_ADD`
- `VSUM_NORM_LE`
- `SUM_LMUL`
- `binom_sum`
- `REAL_OF_NUM_SUM`

### Porting notes (optional)
The main difficulty in porting this theorem to other proof assistants is likely to be the automation provided by HOL Light's tactic `num_linear_fact` and `real_linear_fact` for linear arithmetic over numerals and reals. These may need to be replaced by more explicit reasoning steps or calls to external solvers. Also, the handling of complex numbers and their norms may differ between proof assistants. The `vsum` operator might also need a proper translation into the target proof assistant's summation operator, along with ensuring that properties like `VSUM_NORM_LE` are available or provable.


---

## coeff_root_bound_product

### Name of formal statement
coeff_root_bound_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_root_bound_product = prove(`
  !p (A:real) m S.
  FINITE S ==>
  (!s:X d. s IN S ==> norm(coeff d (p s)) <= A pow d * &(binom(m s,d))) ==>
  (!d. norm(coeff d (poly_product complex_ring S p)) <= A pow d * &(binom(nsum S m,d)))
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;NSUM_CLAUSES] THEN
    qed[coeff_root_bound_1]
  ;
    have `(!s:X. s IN x INSERT S ==> ring_powerseries complex_ring (p s:(1->num)->complex))` [series_complex] THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    simp[poly_product_insert;NSUM_CLAUSES] THEN
    qed[coeff_root_bound_mul]
  ]
);;
```

### Informal statement
For any `p` of type `X -> (num -> complex)`, any real number `A`, any function `m` of type `X -> num`, and any finite set `S` of type `X`, if for every `s` in `S` and every natural number `d`, the norm of the `d`-th coefficient of `p s` is less than or equal to `A` raised to the power of `d` times the binomial coefficient of `m s` and `d`, then for every natural number `d`, the norm of the `d`-th coefficient of the product of the polynomials `p s` over the set `S` (where the product is defined with respect to the `complex_ring`) is less than or equal to `A` raised to the power of `d` times the binomial coefficient of the sum of `m s` over `S` and `d`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: When `S` is empty, the product of polynomials over `S` is 1, and the sum of `m s` over `S` is 0. Then `coeff_root_bound_1` is used.
- Inductive step: Assume the theorem holds for `S`. We need to prove it holds for `x INSERT S`. `poly_product_insert` is used to split the polynomial product into `p x` times the polynomial product over `S`. The inductive hypothesis and `coeff_root_bound_mul` are then applied.

### Mathematical insight
This theorem provides a bound on the coefficients of a product of polynomials, where the polynomials are indexed by a finite set. The bound is expressed in terms of a real number A, the degree-bounding function `m`, and the binomial coefficients. This is a core result in complex analysis.

### Dependencies
- `FINITE`
- `complex_ring`
- `NSUM_CLAUSES`
- `poly_product_empty`
- `coeff_root_bound_1`
- `poly_product_insert`
- `coeff_root_bound_mul`

### Porting notes (optional)
- The definitions of `FINITE`, `poly_product`, and `complex_ring` need to be available.
- The binomial coefficient function `binom` needs to be available.
- The `nsum` function should also be available or defined for the target proof assistant.


---

## coeff_root_bound_pow

### Name of formal statement
coeff_root_bound_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let coeff_root_bound_pow = prove(`
  !p (A:real) m n.
  ring_powerseries complex_ring p ==>
  (!d. norm(coeff d p) <= A pow d * &(binom(m,d))) ==>
  (!d. norm(coeff d (poly_pow complex_ring p n)) <= A pow d * &(binom(m*n,d)))
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0] THEN
    rw[ARITH_RULE `m * 0 = 0`] THEN
    qed[coeff_root_bound_1]
  ;
    intro THEN
    rw[ARITH_RULE `SUC n = n + 1`] THEN
    simp[poly_pow_add;poly_pow_1] THEN
    specialize_assuming[`poly_pow complex_ring (p:(1->num)->complex) n`;`p:(1->num)->complex`;`A:real`;`m*n:num`;`m:num`]coeff_root_bound_mul THEN
    qed[ARITH_RULE `m*n+m = m*(n+1)`]
  ]
);;
```

### Informal statement
For all power series `p` of complex numbers, real number `A`, and natural numbers `m` and `n`, if `p` is a ring powerseries in the complex ring, and for all natural numbers `d`, the norm of the d-th coefficient of `p` is less than or equal to `A` to the power of `d` times the binomial coefficient of `m` and `d`, then for all natural numbers `d`, the norm of the d-th coefficient of `p` raised to the power of `n` in the complex ring is less than or equal to `A` to the power of `d` times the binomial coefficient of `m*n` and `d`.

### Informal sketch
The proof proceeds by induction on `n`. 

- Base case: `n = 0`. We use `poly_pow_0` to show the power series is 1. We then apply `coeff_root_bound_1` to complete the proof.

- Inductive step: Assume the hypothesis holds for `n`. We want to show that it also holds for `n + 1`. We use `poly_pow_add` and `poly_pow_1` to rewrite `p` raised to `n + 1` as `p` raised to `n`, multiplied by `p`. Then we apply the theorem `coeff_root_bound_mul` along with the inductive hypothesis. Finally, a simplification step using `ARITH_RULE` on `m*n+m = m*(n+1)` concludes the proof.

### Mathematical insight
This theorem provides a bound on the coefficients of the power series `p^n`. Given the condition that the norm of the coefficients of `p` are bounded by `A^d * binom(m,d)`, the theorem establishes a similar bound `A^d * binom(m*n,d)` for the coefficients of `p^n`. The theorem is useful in complex analysis when dealing with power series expansions and their bounds.

### Dependencies
- `ring_powerseries`
- `coeff`
- `norm`
- `poly_pow`
- `binom`
- `poly_pow_0`
- `coeff_root_bound_1`
- `poly_pow_add`
- `poly_pow_1`
- `coeff_root_bound_mul`


---

## factorial_lower_bound

### Name of formal statement
factorial_lower_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let factorial_lower_bound = prove(`
  !n.
  (&n / exp(&1)) pow n <= &(FACT n)
`,
  INDUCT_TAC THENL [
    rw[FACT] THEN
    CONV_TAC REAL_FIELD
  ; pass
  ] THEN
  rw[FACT;real_pow] THEN
  rw[ARITH_RULE `SUC n = n+1`] THEN
  case `n = 0` THENL [
    simp[real_pow;ARITH_RULE `0+1 = 1`] THEN
    rw[FACT;ARITH_RULE `1*1 = 1`] THEN
    real_linear_fact `&0 <= &1:real` THEN
    have `exp(&0) <= exp(&1)` [REAL_EXP_MONO_LE] THEN
    have `&1 <= exp(&1)` [REAL_EXP_0] THEN
    have `inv(exp(&1)) <= &1` [REAL_INV_LE_1] THEN
    real_linear_fact `inv(exp(&1)) <= &1 ==> &1 / exp(&1) * &1 <= &1` THEN
    qed[]
  ; pass
  ] THEN
  have `&1 + &1 / &n <= exp(&1 / &n)` [REAL_EXP_LE_X] THEN
  have `~(&n = &0:real)` [REAL_OF_NUM_EQ] THEN
  real_field_fact `~(&n = &0) ==> (&n + &1) / &n:real = &1 + &1 / &n` THEN
  have `(&n + &1) / &n <= exp(&1 / &n)` [] THEN
  have `&0 <= &n:real` [REAL_OF_NUM_LE;ARITH_RULE `0 <= n`] THEN
  real_linear_fact `&0 <= &n:real ==> &0 <= &n + &1` THEN
  have `&0 <= (&n + &1) / &n` [REAL_LE_DIV] THEN
  have `&0 <= exp(&1)` [REAL_EXP_POS_LE] THEN
  have `((&n + &1) / &n) pow n <= exp(&1 / &n) pow n` [REAL_POW_LE2] THEN
  subgoal `exp(&1 / &n) pow n = exp(&1)` THENL [
    rw[GSYM REAL_EXP_N] THEN
    real_field_fact `~(&n = &0:real) ==> &n * &1 / &n = &1` THEN
    qed[]
  ; pass
  ] THEN
  have `((&n + &1) / &n) pow n <= exp(&1)` [] THEN
  have `&0 <= &n / exp(&1)` [REAL_LE_DIV] THEN
  subgoal `(&n / exp (&1)) pow n * ((&n + &1) / &n) pow n <= &(FACT n) * exp(&1)` THENL [
    have `&0 <= (&n / exp(&1)) pow n` [REAL_POW_LE] THEN
    have `&0 <= ((&n + &1) / &n) pow n` [REAL_POW_LE] THEN
    qed[REAL_LE_MUL2]
  ; pass
  ] THEN
  subgoal `(&n / exp (&1)) pow n * ((&n + &1) / &n) pow n = ((&n + &1) / exp(&1)) pow n` THENL [
    rw[GSYM REAL_POW_MUL] THEN
    real_field_fact `~(&n = &0:real) ==> (&n / exp (&1) * (&n + &1) / &n) = ((&n + &1) / exp (&1))` THEN
    qed[]
  ; pass
  ] THEN
  have `((&n + &1) / exp (&1)) pow n <= &(FACT n) * exp(&1)` [] THEN
  have `&0 <= (&n + &1) / exp(&1)` [REAL_LE_DIV] THEN
  have `(&n + &1) / exp (&1) * ((&n + &1) / exp (&1)) pow n <= (&n + &1) / exp (&1) * &(FACT n) * exp(&1)` [REAL_LE_LMUL] THEN
  have `&0 < exp(&1)` [REAL_EXP_POS_LT] THEN
  real_field_fact `&0 < exp(&1) ==> (&n + &1) / exp (&1) * &(FACT n) * exp (&1) = (&n + &1) * &(FACT n)` THEN
  have `(&n + &1) / exp (&1) * ((&n + &1) / exp (&1)) pow n <= (&n + &1) * &(FACT n)` [] THEN
  simp[GSYM REAL_OF_NUM_ADD;GSYM REAL_OF_NUM_MUL]
);;
```
### Informal statement
For all natural numbers `n`, it is the case that `(n / exp(1))^n` is less than or equal to the factorial of `n`.

### Informal sketch
The proof proceeds by mathematical induction on `n`.
- Base case (`n = 0`): We need to show that `(0 / exp(1))^0 <= 1`. Since `(0 / exp(1))^0` is `0^0`which equals `1`, and we have `1 <= 1`
- Inductive step: Assume that `(n / exp(1))^n <= FACT n` holds. We need to prove that `((n+1) / exp(1))^(n+1) <= FACT (n+1)`.
  - We use the fact that `(1 + 1/n) <= exp(1/n)`.
  - Thus, `((n + 1) / n)^n <= exp(1)`.
  - We also have `(n / exp(1))^n * ((n + 1) / n)^n <= FACT n * exp(1)` by applying the inductive hypothesis and leveraging inequalities, such as `REAL_LE_MUL2`
  - From this, we can show the equivalent `((n + 1) / exp(1))^n <= FACT n * exp(1)`.
  - Multiplying both sides of the inequality `((n + 1) / exp(1))^n <= FACT n * exp(1)` by `(n+1) / exp(1)` and doing algebraic manipulation, and using `FACT (SUC n) = SUC n * FACT n`, we have `((n+1) / exp(1))^(n+1) <= FACT (n+1)`.

### Mathematical insight
This theorem provides a lower bound for the factorial function using an exponential function. It's a basic version of Stirling's approximation which gives both an upper and lower bound and approximates the log factorial much more closely. The importance stems from providing means to estimate the growth of the factorial function, which appears in various mathematical contexts, including combinatorics and analysis.

### Dependencies
- `FACT` (factorial)
- `real_pow` (real number exponentiation)
- `REAL_EXP_MONO_LE`
- `REAL_EXP_0`
- `REAL_INV_LE_1`
- `REAL_EXP_LE_X`
- `REAL_OF_NUM_EQ`
- `REAL_OF_NUM_LE`
- `REAL_LE_DIV`
- `REAL_EXP_POS_LE`
- `REAL_POW_LE2`
- `REAL_EXP_N`
- `REAL_POW_LE`
- `REAL_LE_MUL2`
- `REAL_LE_LMUL`
- `REAL_EXP_POS_LT`

### Porting notes (optional)
- The proof relies heavily on real analysis lemmas. Ensure the target proof assistant or formal language has equivalent results available.
- The HOL Light tactics `CONV_TAC REAL_FIELD`, `real_linear_fact`, and `real_field_fact` are used for real number arithmetic simplification and can be complex to replicate directly. Ensure the target system has powerful arithmetic decision procedures.


---

## poly_ord

### Name of formal statement
poly_ord

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let poly_ord = new_definition `
  poly_ord (p:(1->num)->complex) (z:complex)
  = @e:num. (
      ?q:(1->num)->complex. (
        ring_polynomial complex_ring q /\
        ~(complex_root q z) /\
        p = poly_mul complex_ring (
          poly_pow complex_ring (
            x_minus_const complex_ring z
          ) e
        ) (
          q
        )
      )
    )
`;;
```
### Informal statement
The order of vanishing, `poly_ord`, of a polynomial `p` (a function from `num` to `complex`) at a complex number `z` is defined to be the number `e` such that there exists a polynomial `q` (a function from `num` to `complex`) satisfying the following conditions: `q` is a polynomial in the complex ring (i.e., `ring_polynomial complex_ring q`), `z` is not a root of `q` (i.e., `~(complex_root q z)`), and `p` is equal to the product of `(x_minus_const complex_ring z)` raised to the power of `e` and `q`, all within the complex ring (i.e., `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e) q`).

### Informal sketch
The definition of `poly_ord p z` aims to capture the exponent of `(x - z)` that divides the polynomial `p`.

- The definition searches for a natural number `e` which will be the order.
- It asserts the existence of a polynomial `q` that doesn't have `z` as a root.
- It requires `p` to be expressible as the product of `(x - z)^e` and `q`.

### Mathematical insight
This definition formalizes the notion of the multiplicity of a root of a polynomial. The order of vanishing of a polynomial `p` at a point `z` is the highest power to which `(x - z)` divides `p`. The condition that `q` is a polynomial that does not have `z` as a root ensures that `e` is the *exact* order.

### Dependencies
- `ring_polynomial`
- `complex_root`
- `poly_mul`
- `poly_pow`
- `x_minus_const`
- `complex_ring`


---

## poly_ord_exists_lemma

### Name of formal statement
poly_ord_exists_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_exists_lemma = prove(`
  !n p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  poly_deg complex_ring p = n ==>
  ?e:num q:(1->num)->complex. (
    ring_polynomial complex_ring q /\
    ~(complex_root q z) /\
    p = poly_mul complex_ring (
      poly_pow complex_ring (
        x_minus_const complex_ring z
      ) e
    ) (
      q
    )
  )
`,
  INDUCT_TAC THENL [
    intro THEN
    witness `0` THEN
    witness `p:(1->num)->complex` THEN
    rw[poly_pow_0] THEN
    simp[POLY_MUL_LID;series_complex] THEN
    choose `c:complex` `(p:(1->num)->complex) = poly_const complex_ring c` [POLY_DEG_EQ_0] THEN
    have `poly_eval complex_ring p z = c` [POLY_EVAL_CONST;in_complex_ring] THEN
    have `~(c = ring_0 complex_ring)` [poly_0] THEN
    have `~(c = Cx(&0))` [complex_ring_clauses] THEN
    qed[complex_root]
  ; pass
  ] THEN
  intro THEN
  case `~(complex_root p z)` THENL [
    witness `0` THEN
    witness `p:(1->num)->complex` THEN
    rw[poly_pow_0] THEN
    simp[POLY_MUL_LID;series_complex]
  ; pass
  ] THEN
  have `poly_eval complex_ring p z = ring_0 complex_ring` [complex_root;complex_ring_clauses] THEN
  have `z IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `p IN ring_carrier(poly_ring complex_ring (:1))` [x_poly;x_poly_use] THEN
  specialize[`complex_ring`;`z:complex`;`p:(1->num)->complex`]POLY_DIVIDES_X_MINUS_ROOT THEN
  have `poly_sub complex_ring (poly_var complex_ring one) (poly_const complex_ring z) = x_minus_const complex_ring z` [x_minus_const;x_pow_1] THEN
  have `ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) p` [x_poly] THEN
  choose `q:(1->num)->complex` `q IN ring_carrier(x_poly complex_ring) /\ (p:(1->num)->complex) = ring_mul(x_poly complex_ring) (x_minus_const complex_ring z) q` [ring_divides] THEN
  have `integral_domain complex_ring` [integral_domain_complex] THEN
  have `poly_deg complex_ring (x_minus_const complex_ring z) = 1` [deg_x_minus_const;integral_domain] THEN
  have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly] THEN
  have `ring_polynomial complex_ring (q:(1->num)->complex)` [x_poly_use] THEN
  have `p = poly_mul complex_ring (x_minus_const complex_ring z) q` [x_poly_use] THEN
  have `~(q = poly_0 complex_ring:(1->num)->complex)` [POLY_MUL_0] THEN
  have `~(x_minus_const complex_ring z = poly_0 complex_ring)` [POLY_DEG_0;ARITH_RULE `~(0 = 1)`] THEN
  have `(x_minus_const complex_ring z = poly_0 complex_ring) <=> (q = poly_0 complex_ring:(1->num)->complex)` [] THEN
  specialize[`complex_ring`;`x_minus_const complex_ring z`;`q:(1->num)->complex`]POLY_DEG_MUL THEN
  have `poly_deg complex_ring (p:(1->num)->complex) = poly_deg complex_ring (x_minus_const complex_ring z) + poly_deg complex_ring (q:(1->num)->complex)` [] THEN
  have `SUC n = 1 + poly_deg complex_ring (q:(1->num)->complex)` [] THEN
  num_linear_fact `SUC n = 1 + poly_deg complex_ring (q:(1->num)->complex) ==> poly_deg complex_ring q = n` THEN
  specialize[`q:(1->num)->complex`](know(`!p. ring_polynomial complex_ring p ==> ~(p = poly_0 complex_ring) ==> poly_deg complex_ring p = n ==> (?e q. ring_polynomial complex_ring q /\ ~complex_root q z /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e) q)`)) THEN
  choose2 `e:num` `r:(1->num)->complex` `ring_polynomial complex_ring r /\ ~complex_root r z /\ q = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e) r` [] THEN
  witness `1+e` THEN
  witness `r:(1->num)->complex` THEN
  SIMP_TAC[poly_pow_add;poly_pow_1;series_complex] THEN
  SIMP_TAC[GSYM POLY_MUL_ASSOC;series_complex] THEN
  qed[]
);;
```

### Informal statement
For any natural number `n` and any polynomial `p` over the complex numbers satisfying: the polynomial `p` is a ring polynomial, `p` is not the zero polynomial, and the degree of `p` is `n`, there exist a natural number `e` and a polynomial `q` over the complex numbers such that `q` is a ring polynomial, `z` is not a root of `q`, and `p` is equal to the product of the polynomial `(x - z)^e` and `q`.

### Informal sketch
The proof proceeds by induction on the degree `n` of the polynomial `p`.

- Base case: `n = 0`.  We need to show that if `p` is a constant polynomial `c` where `c` is not zero, then there exist `e` and `q` satisfying the stated conditions. We take `e = 0` and `q = p` and use the fact that `p` is not zero to conclude that `z` is not a root of `q`.
- Inductive step: Suppose `n = SUC n'` and assume the theorem holds for `n'`.
  - First, consider the case where `z` is not a root of `p`. Then we can take `e = 0` and `q = p` and we are done.
  - Otherwise, assume `z` is a root of `p`. Then `p(z) = 0`, so `(x - z)` divides `p`. Thus, there exists a polynomial `q` such that `p = (x - z) * q`.  Since `p` is not zero, neither is `q`. By considering the degrees, `deg(p) = deg(x - z) + deg(q)`, so `SUC n' = 1 + deg(q)`, which means `deg(q) = n'`. Now we can apply the inductive hypothesis to `q`.  So, there exist `e` and `r` such that `q = (x - z)^e * r`, where `r` is a ring polynomial and `z` is not a root of `r`.  Therefore, `p = (x - z) * q = (x - z) * ((x - z)^e * r) = (x - z)^(1 + e) * r`.  Let `e' = 1 + e` and `r` be the new polynomial. Thus, the theorem holds for `n = SUC n'`.

### Mathematical insight
The `poly_ord_exists_lemma` states that, given a polynomial `p` of degree `n` and a complex number `z`, if we know that `p(z) = 0` repeatedly, then we can factor out `(x - z)` a certain number of times (say, `e` times) and obtain a polynomial `q` such that `p(x) = (x - z)^e * q(x)` and `q(z) != 0`. This means the complex number `z` is not a `complex_root` of q.

### Dependencies
- `ring_polynomial`
- `complex_ring`
- `poly_0`
- `poly_deg`
- `poly_mul`
- `poly_pow`
- `x_minus_const`
- `complex_root`
- `POLY_MUL_LID`
- `series_complex`
- `POLY_EVAL_CONST`
- `in_complex_ring`
- `complex_ring_clauses`
- `deg_x_minus_const`
- `integral_domain`
- `integral_domain_complex`

### Porting notes (optional)
This theorem relies heavily on properties of polynomials over the complexes. When porting, make sure that the target proof assistant has similar infrastructure for polynomials over a ring. In particular, make sure that the definitions of `ring_polynomial`, `poly_0`, `poly_deg`, `poly_mul`, `poly_pow`, `x_minus_const`, and `complex_root` are available. The proof uses induction. The tactics can be translated as a case distinction. Automation for polynomials over rings might be needed.


---

## poly_ord_exists_lemma2

### Name of formal statement
poly_ord_exists_lemma2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_exists_lemma2 = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  ?e q:(1->num)->complex. (
    ring_polynomial complex_ring q /\
    ~(complex_root q z) /\
    p = poly_mul complex_ring (
      poly_pow complex_ring (
        x_minus_const complex_ring z
      ) e
    ) (
      q
    )
  )
`,
  intro THEN
  specialize[`poly_deg complex_ring (p:(1->num)->complex)`;`p:(1->num)->complex`]poly_ord_exists_lemma THEN
  qed[]
);;
```
### Informal statement
For all `p` which is a polynomial over the complex numbers, if `p` is a ring polynomial in the complex ring and `p` is not the zero polynomial in the complex ring, then there exist a natural number `e` and a polynomial `q` over the complex numbers such that `q` is a ring polynomial in the complex ring, `z` is not a complex root of `q`, and `p` is equal to the polynomial multiplication in the complex ring of `(x - z)^e` by `q`.

### Informal sketch
The proof proceeds as follows:
- Introduce the hypothesis.
- Specialize the theorem `poly_ord_exists_lemma` with `poly_deg complex_ring p` as the natural number and `p` as the polynomial.
- The result follows directly.

### Mathematical insight
This theorem states that for a ring polynomial over the complex numbers that is not the zero polynomial, one can always factor out `(x-z)^e`, where `z` is a complex number and `e` is a natural number representing the multiplicity of `z` as a root, such that the remaining polynomial `q` does not have `z` as a root. This essentially decomposes a polynomial into a factor determined by `z` and another polynomial that doesn't have `z` as a root.

### Dependencies
- Theorems: `poly_ord_exists_lemma`


---

## poly_ord_exists

### Name of formal statement
poly_ord_exists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_exists = prove(`
  !p:(1->num)->complex.
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  ?q:(1->num)->complex. (
    ring_polynomial complex_ring q /\
    ~(complex_root q z) /\
    p = poly_mul complex_ring (
      poly_pow complex_ring (
        x_minus_const complex_ring z
      ) (poly_ord p z)
    ) (
      q
    )
  )
`,
  rw[poly_ord] THEN
  qed[poly_ord_exists_lemma2]
);;
```
### Informal statement
For any polynomial `p` with coefficients in the complex numbers, if `p` is a ring polynomial, and `p` is not the zero polynomial, then there exists a polynomial `q` with coefficients in the complex numbers such that `q` is a ring polynomial, `z` is not a root of `q`, and `p` is equal to the polynomial multiplication of `(x - z)` raised to the power of the order of `p` at `z`, and `q`.

### Informal sketch
The proof proceeds as follows:
- Start by applying the `poly_ord` definition, which likely expands the definition of the polynomial order.
- Use `poly_ord_exists_lemma2` to complete the proof. This lemma is likely an intermediate result that helps establish the existence of the polynomial `q` with the desired properties.

### Mathematical insight
The theorem states that a non-zero polynomial `p` can be factored into `(x - z)^k * q`, where `k` is the order of the root `z` in `p`, and `q` is a polynomial that does not have `z` as a root. This is a standard result in polynomial algebra, showing that we can always factor out roots from a polynomial until the remaining polynomial doesn't have that root.

### Dependencies
- Definitions: `poly_ord`
- Theorems: `poly_ord_exists_lemma2`


---

## poly_ord_unique

### Name of formal statement
poly_ord_unique

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_unique = prove(`
  !p:(1->num)->complex q e.
  ring_polynomial complex_ring q ==>
  ~(complex_root q z) ==>
  p = poly_mul complex_ring (
    poly_pow complex_ring (
      x_minus_const complex_ring z
    ) e
  ) (
    q
  ) ==>
  ( ring_polynomial complex_ring p /\
    ~(p = poly_0 complex_ring) /\
    e = poly_ord p z
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  subgoal `~((q:(1->num)->complex) = poly_0 complex_ring)` THENL [
    intro THEN
    have `poly_eval complex_ring q z = Cx(&0)` [POLY_EVAL_0;complex_ring_clauses] THEN
    qed[complex_root]
  ; pass
  ] THEN
  subgoal `~((p:(1->num)->complex) = poly_0 complex_ring)` THENL [
    intro THEN
    have `p = ring_mul(x_poly complex_ring) (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) e) q` [x_poly_use;x_poly_use_pow] THEN
    have `integral_domain(x_poly complex_ring)` [integral_domain_x_poly_field;field_complex] THEN
    have `p = ring_0(x_poly complex_ring)` [x_poly_use] THEN
    have `~(q = ring_0(x_poly complex_ring))` [x_poly_use] THEN
    have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly;in_complex_ring] THEN
    have `ring_polynomial complex_ring (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) e)` [x_poly_use_pow;poly_pow_poly] THEN
    have `ring_mul (x_poly complex_ring) (ring_pow (x_poly complex_ring) (x_minus_const complex_ring z) e) q = ring_0(x_poly complex_ring)` [] THEN
    have `ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) e = ring_0(x_poly complex_ring)` [integral_domain;x_poly_use] THEN
    have `x_minus_const complex_ring z = ring_0(x_poly complex_ring)` [INTEGRAL_DOMAIN_POW_EQ_0;x_poly_use] THEN
    have `x_minus_const complex_ring z = poly_0 complex_ring` [x_poly_use] THEN
    have `poly_deg complex_ring (x_minus_const complex_ring z) = 1` [deg_x_minus_const;integral_domain;integral_domain_complex;in_complex_ring] THEN
    have `~(x_minus_const complex_ring z = poly_0 complex_ring)` [POLY_DEG_0;ARITH_RULE `~(0 = 1)`] THEN
    qed[]
  ; pass
  ] THEN
  have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly;in_complex_ring] THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e)` [poly_pow_poly] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [RING_POLYNOMIAL_MUL] THEN
  specialize[`p:(1->num)->complex`]poly_ord_exists THEN
  choose `f:(1->num)->complex` `ring_polynomial complex_ring f /\ ~(complex_root f z) /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (f)` [] THEN
  recall field_complex THEN
  have `poly_deg complex_ring (x_minus_const complex_ring z) = 1` [deg_x_minus_const;field;in_complex_ring] THEN
  have `ring_prime(x_poly complex_ring) (x_minus_const complex_ring z)` [prime_if_deg_1] THEN
  have `integral_domain(x_poly complex_ring)` [integral_domain_x_poly_field] THEN
  have `f IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
  have `q IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
  have `~(ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) q)` [complex_root_if_x_minus_const_divides] THEN
  have `~(ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) f)` [complex_root_if_x_minus_const_divides] THEN
  have `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e) q = ring_mul(x_poly complex_ring) (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) (poly_ord p z)) f` [x_poly_use;x_poly_use_pow] THEN
  have `poly_mul complex_ring (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) e) q = ring_mul(x_poly complex_ring) (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) (poly_ord p z)) f` [x_poly_use;x_poly_use_pow] THEN
  have `ring_mul(x_poly complex_ring) (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) e) q = ring_mul(x_poly complex_ring) (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) (poly_ord p z)) f` [x_poly_use;x_poly_use_pow] THEN
  qed[unique_prime_valuation]
);;
```
### Informal statement
For any polynomials `p` and `q` over the complex numbers, and for any natural number `e`, if `q` is a ring polynomial, `z` is not a root of `q`, and `p` equals the polynomial `q` multiplied by `(x - z)^e`, then `p` is a ring polynomial, `p` is not the zero polynomial, and `e` is the order of `p` at `z`.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent: `q` is a ring polynomial, `z` is not a root of `q`, and `p` equals the polynomial `q` multiplied by `(x - z)^e`.
- Show `~(q = poly_0 complex_ring)`:
  - Assume `q = poly_0 complex_ring`.
  - Show that `poly_eval complex_ring q z = Cx(&0)` using `POLY_EVAL_0` and `complex_ring_clauses`.
  - Conclude a contradiction with `complex_root q z` using `complex_root`.
- Show `~(p = poly_0 complex_ring)`:
  - Assume `p = poly_0 complex_ring`
  - Use `x_poly_use` and `x_poly_use_pow` to express `p` in terms of the ring operations `ring_mul` and `ring_pow`.
  - Use `integral_domain_x_poly_field` and `field_complex` to establish that `integral_domain(x_poly complex_ring)`.
  - Use `x_poly_use` to show `p = ring_0(x_poly complex_ring)` and `~(q = ring_0(x_poly complex_ring))`.
  - Show that `ring_polynomial complex_ring (x_minus_const complex_ring z)` using `x_minus_const_poly` and `in_complex_ring`.
  - Show that `ring_polynomial complex_ring (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) e)` using `x_poly_use_pow` and `poly_pow_poly`.
  - Using the integral domain property, derive a contradiction, eventually showing `~(x_minus_const complex_ring z = poly_0 complex_ring)`.
- Show that `ring_polynomial complex_ring (x_minus_const complex_ring z)` using `x_minus_const_poly` and `in_complex_ring`.
- Show that `ring_polynomial complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e)` using `poly_pow_poly`.
- Show that `ring_polynomial complex_ring p` using `RING_POLYNOMIAL_MUL`.
- Specialize `poly_ord_exists`.
- Choose `f` such that `ring_polynomial complex_ring f /\ ~(complex_root f z) /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (f)`.
- Recall `field_complex`.
- Show that `poly_deg complex_ring (x_minus_const complex_ring z) = 1` using `deg_x_minus_const`, `field`, and `in_complex_ring`.
- Show that `ring_prime(x_poly complex_ring) (x_minus_const complex_ring z)` using `prime_if_deg_1`.
- Show that `integral_domain(x_poly complex_ring)` using `integral_domain_x_poly_field`.
- Use `x_poly_use` to show `f IN ring_carrier(x_poly complex_ring)` and `q IN ring_carrier(x_poly complex_ring)`.
- Show that `~(ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) q)` and `~(ring_divides(x_poly complex_ring) (x_minus_const complex_ring z) f)` using `complex_root_if_x_minus_const_divides`.
- Establish the equation `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) e) q = ring_mul(x_poly complex_ring) (ring_pow(x_poly complex_ring) (x_minus_const complex_ring z) (poly_ord p z)) f` using `x_poly_use` and `x_poly_use_pow`.
- Conclude by applying `unique_prime_valuation`.

### Mathematical insight
This theorem formalizes the uniqueness of the order of a polynomial at a given root. If we have a polynomial `p` that can be written as `(x - z)^e * q`, where `q` does not have `z` as a root, then `e` must be equal to the order of `p` at `z`. This result ensures that the decomposition into powers of `(x - z)` is unique, which is a fundamental component when working with polynomial factorization and root multiplicities.

### Dependencies
- `complex_ring_clauses`
- `POLY_EVAL_0`
- `complex_root`
- `x_poly_use`
- `x_poly_use_pow`
- `integral_domain_x_poly_field`
- `field_complex`
- `x_minus_const_poly`
- `in_complex_ring`
- `poly_pow_poly`
- `POLY_DEG_0`
- `ARITH_RULE`
- `RING_POLYNOMIAL_MUL`
- `poly_ord_exists`
- `deg_x_minus_const`
- `field`
- `prime_if_deg_1`
- `complex_root_if_x_minus_const_divides`
- `unique_prime_valuation`

### Porting notes (optional)
The use of `x_poly` as an implicit carrier type requires careful consideration during porting. Other systems may require explicit casting or type-level reasoning to ensure the ring operations are well-typed, especially when dealing with integral domain properties. The tactic `choose` which selects a witness `f` for `poly_ord_exists` will need to be translated into a comparable mechanism for existential introduction.


---

## poly_ord_unique_0

### Name of formal statement
poly_ord_unique_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_unique_0 = prove(`
  !p:(1->num)->complex z.
  ring_polynomial complex_ring p ==>
  ~(complex_root p z) ==>
  ( ~(p = poly_0 complex_ring) /\
    poly_ord p z = 0
  )
`,
  intro THEN
  have `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) 0) (p)` [poly_pow_0;POLY_MUL_LID;ring_polynomial] THEN
  qed[poly_ord_unique]
);;
```

### Informal statement
For any `p` which is a function from `1` to the natural numbers, and any complex number `z`, if `p` is a ring polynomial over the complex numbers and `z` is not a complex root of `p`, then `p` is not the zero polynomial over the complex numbers, and the order of `p` at `z` is `0`.

### Informal sketch
The proof proceeds by:

- Introduction.
- Showing that `p` is equal to the polynomial multiplication of `poly_pow complex_ring (x_minus_const complex_ring z) 0` and `p` by using `poly_pow_0`, `POLY_MUL_LID` and `ring_polynomial` is assumed. Specifically, `poly_pow_0` is used to show that `poly_pow complex_ring (x_minus_const complex_ring z) 0` is the identity. `POLY_MUL_LID` is then used to show that multiplying `p` by the identity results in `p`.
- Applying already proved `poly_ord_unique`.

### Mathematical insight
This theorem states that if a polynomial `p` does not have `z` as a root, then the order of `p` at `z` is 0. This is a fundamental property used in algebraic analysis and polynomial manipulation. Intuitively, the order of a polynomial `p` at `z` represents the multiplicity of `z` as a root of `p`. If `z` is not a root, then it has multiplicity 0.

### Dependencies
- Theorems: `poly_ord_unique`, `poly_pow_0`, `POLY_MUL_LID`
- Definitions: `ring_polynomial`, `complex_root`, `poly_0`, `poly_ord`, `poly_mul`, `poly_pow`, `x_minus_const`


---

## poly_ord_unique_1

### Name of formal statement
poly_ord_unique_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_unique_1 = prove(`
  !p:(1->num)->complex q z.
  ring_polynomial complex_ring q ==>
  ~(complex_root q z) ==>
  p = poly_mul complex_ring (
    x_minus_const complex_ring z
  ) (
    q
  ) ==>
  ( ring_polynomial complex_ring p /\
    ~(p = poly_0 complex_ring) /\
    poly_ord p z = 1
  )
`,
  intro THEN
  have `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) 1) (q)` [poly_pow_1;series_complex] THEN
  qed[poly_ord_unique]
);;
```
### Informal statement
For any polynomials `p` and `q` over the complex numbers, and any complex number `z`, if `q` is a ring polynomial, and `z` is not a root of `q`, and `p` is equal to the polynomial `q` multiplied by `x - z`, then `p` is a ring polynomial, `p` is not the zero polynomial, and the order of `p` at `z` is equal to 1.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `q` is a ring polynomial, `z` is not a root of `q`, and `p` is equal to `q` multiplied by the linear factor `x - z`.
- Rewrite `poly_mul complex_ring (x_minus_const complex_ring z) (q)` as `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) 1) (q)` using `poly_pow_1` and `series_complex`.  This step expresses the linear factor `x - z` as its first power, which is mathematically equivalent.
- Apply the theorem `poly_ord_unique` to conclude that  `p` is a ring polynomial, `p` is not the zero polynomial, and that the order of `p` at `z` is 1.

### Mathematical insight
This theorem states a fundamental property regarding the order of a polynomial at a point. Specifically, if we have a polynomial `q` and multiply it by a linear factor `x - z` where `z` is not a root of `q`, then the resulting polynomial `p` has order 1 at `z`. This essentially formalizes the idea that multiplying by `x - z` introduces a new root at `z` with multiplicity 1, assuming that `z` was not already a root of `q`. This theorem allows us to reason about the multiplicities of polynomial roots during factorization.

### Dependencies
- Theorems:
  - `poly_pow_1`
  - `poly_ord_unique`
- Definitions:
  - `series_complex`


---

## poly_ord_const

### Name of formal statement
poly_ord_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_const = prove(`
  !c z.
  ~(c = Cx(&0)) ==>
  (
    ring_polynomial complex_ring (poly_const complex_ring c:(1->num)->complex) /\
    ~(poly_const complex_ring c = poly_0 complex_ring:(1->num)->complex) /\
    poly_ord(poly_const complex_ring c) z = 0
  )
`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  have `ring_polynomial complex_ring (poly_const complex_ring c:(1->num)->complex)` [RING_POLYNOMIAL_CONST;in_complex_ring] THEN
  have `~complex_root (poly_const complex_ring c) z` [complex_root;POLY_EVAL_CONST;in_complex_ring] THEN
  qed[poly_ord_unique_0]
);;
```
### Informal statement
For all complex numbers `c` and `z`, if `c` is not equal to 0, then the following holds: The polynomial `poly_const complex_ring c` is a ring polynomial over the complex ring, it is not the zero polynomial, and its order `poly_ord(poly_const complex_ring c)` evaluated at `z` is 0.

### Informal sketch
- The goal is to prove that for a non-zero constant `c`, the polynomial `poly_const complex_ring c` is a ring polynomial, not the zero polynomial, and has order 0 at every complex number `z`.
- Assume that `c` is a complex number not equal to zero.
- Show that `poly_const complex_ring c` is a ring polynomial using `RING_POLYNOMIAL_CONST` and the fact that the complex ring is a ring (`in_complex_ring`).
- Show that `poly_const complex_ring c` does not have `z` as a complex root using `complex_root`, `POLY_EVAL_CONST` (which shows that `poly_eval (poly_const c) z = c`) and `in_complex_ring`. Thus `~(poly_eval (poly_const complex_ring c) z = &0)`.
- Conclude that `poly_ord(poly_const complex_ring c) z = 0` using `poly_ord_unique_0`. The theorem `poly_ord_unique_0` essentially states that if a polynomial does not have `z` as a root, then its order at `z` is 0.

### Mathematical insight
The theorem `poly_ord_const` establishes a fundamental property of constant polynomials in the context of ring polynomials and their orders. It states that a non-zero constant polynomial is a ring polynomial, is not the zero polynomial, and has order 0 at every point `z` because it never evaluates to 0. This is a cornerstone result for reasoning about the order (multiplicity of root) of polynomials. `poly_ord` represents the number of times `(z - z0)` divides a polynomial and thus gives the exponent of `(z - z0)` in the factored form of the polynomial.

### Dependencies
- `RING_POLYNOMIAL_CONST`
- `in_complex_ring`
- `complex_root`
- `POLY_EVAL_CONST`
- `poly_ord_unique_0`


---

## poly_ord_1

### Name of formal statement
poly_ord_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_1 = prove(`
  !z.
  ring_polynomial complex_ring (poly_1 complex_ring:(1->num)->complex) /\
  ~(poly_1 complex_ring = poly_0 complex_ring:(1->num)->complex) /\
  poly_ord(poly_1 complex_ring) z = 0
`,
  rw[poly_1] THEN
  complex_field_fact `~(Cx(&1) = Cx(&0))` THEN
  have `~(ring_1 complex_ring = Cx(&0))` [complex_ring_clauses] THEN
  specialize[`ring_1 complex_ring`]poly_ord_const THEN
  qed[poly_1_0_complex;complex_ring_clauses]
);;
```
### Informal statement
For all `z`, the polynomial `poly_1` over the complex ring (where `poly_1` is a function from (1 -> num) to complex numbers) is a ring polynomial, `poly_1` is not equal to the zero polynomial `poly_0` over the complex ring (where `poly_0` is a function from (1->num) to complex numbers), and the polynomial order of `poly_1` at `z` is 0.

### Informal sketch
The proof shows that the polynomial order of `poly_1` (the polynomial representing the constant 1) at any value `z` is 0.
- First, expand `poly_1` to `Cx(&1)`.
- Prove that `Cx(&1)` is not equal to `Cx(&0)` using a fact about the complex field. This translates into proving that the multiplicative identity (`ring_1`) of the complex ring is not equal to the additive identity (`Cx(&0)`).
- Specialize the theorem `poly_ord_const` (which states that the polynomial order of a constant non-zero polynomial is 0) to the specific constant `ring_1 complex_ring`.
- Combine the fact that `ring_1 complex_ring` is not equal to `Cx(&0)` with the specialized `poly_ord_const` to complete the proof.

### Mathematical insight
The theorem formalizes the intuition that the constant polynomial 1 has no roots. Thus, the order of the polynomial at any point `z` is 0, since it is never 0. This is a basic fact about constant polynomials and their order.

### Dependencies
- Definitions: `poly_0`, `poly_1`, `poly_ord`, `ring_polynomial`, `complex_ring`
- Theorems: `poly_ord_const`, `complex_field_fact`, `poly_1_0_complex`, `complex_ring_clauses`


---

## poly_ord_x_minus_const

### Name of formal statement
poly_ord_x_minus_const

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_x_minus_const = prove(`
  !c z.
  ring_polynomial complex_ring (x_minus_const complex_ring c) /\
  ~(x_minus_const complex_ring c = poly_0 complex_ring) /\
  poly_ord (x_minus_const complex_ring c) z
  = if z = c then 1 else 0
`,
  REPEAT GEN_TAC THEN
  have `ring_polynomial complex_ring (x_minus_const complex_ring c)` [x_minus_const_poly;in_complex_ring] THEN
  case `z = c:complex` THENL [
    specialize_assuming[`x_minus_const complex_ring c`;`poly_1 complex_ring:(1->num)->complex`;`z:complex`]poly_ord_unique_1 THEN
    have `~complex_root (poly_1 complex_ring) z` [complex_root;POLY_EVAL_1;field_complex;field;complex_ring_clauses] THEN
    have `x_minus_const complex_ring c = poly_mul complex_ring (x_minus_const complex_ring c) (poly_1 complex_ring)` [RING_POLYNOMIAL_1;complex_root;POLY_MUL_SYM;POLY_MUL_LID;series_complex] THEN
    qed[RING_POLYNOMIAL_1]
  ; pass
  ] THEN
  have `poly_eval complex_ring (x_minus_const complex_ring c) z = z - c` [eval_x_minus_const;in_complex_ring;ring_sub_complex] THEN
  complex_field_fact `~(z = c:complex) ==> ~(z - c = Cx(&0))` THEN
  have `~(poly_eval complex_ring (x_minus_const complex_ring c) z = Cx(&0))` [] THEN
  have `~(complex_root(x_minus_const complex_ring c) z)` [complex_root] THEN
  qed[poly_ord_unique_0]
);;
```

### Informal statement
For all complex numbers `c` and `z`, if `x_minus_const complex_ring c` is a ring polynomial over the complex ring, `x_minus_const complex_ring c` is not equal to the zero polynomial `poly_0 complex_ring`, then the polynomial order `poly_ord` of `x_minus_const complex_ring c` at `z` is 1 if `z` equals `c`, and 0 otherwise.

### Informal sketch
The proof proceeds by induction on whether `z` equals `c`.
- Case 1: `z = c`. We specialize `poly_ord_unique_1` with `x_minus_const complex_ring c`, and `poly_1 complex_ring` and `z`, then show that `x_minus_const complex_ring c` remains equivalent if multiplied by the polynomial 1.
This relies on the fact that `~complex_root (poly_1 complex_ring) z` is true.

- Case 2: `z != c`. We show that the evaluation of `x_minus_const complex_ring c` at `z` is `z - c`. If `z != c`, this means that `z - c != 0`, so `~(poly_eval complex_ring (x_minus_const complex_ring c) z = Cx(&0))`. Therefore, `z` is not a root of `x_minus_const complex_ring c`. Then `poly_ord_unique_0` discharges this case.

The initial assumptions `ring_polynomial complex_ring (x_minus_const complex_ring c)` and `~(x_minus_const complex_ring c = poly_0 complex_ring)` are required by `poly_ord_unique_1` and `poly_ord_unique_0` respectively.

### Mathematical insight
This theorem gives the polynomial order of the polynomial `x - c` at the point `z`. The polynomial order is 1 if `z = c` and 0 otherwise. This aligns with the intuitive understanding that `x - c` has a single root at `c`.

### Dependencies
- Theorems: `poly_ord_unique_1`, `poly_ord_unique_0`
- Definitions: `ring_polynomial`, `complex_ring`, `x_minus_const`, `poly_0`, `poly_ord`, `poly_1`, `complex_root`, `poly_eval`, `poly_mul`
- Other: `RING_POLYNOMIAL_1`, `POLY_EVAL_1`, `POLY_MUL_SYM`, `POLY_MUL_LID`, `series_complex`, `field_complex`, `field`, `ring_sub_complex`, `complex_ring_clauses`

### Porting notes (optional)
- Ensure that a suitable notion of polynomial order (multiplicity of a root) is available.
- The handling of complex numbers and complex arithmetic should be compatible.
- The theorem `poly_ord_unique_1` and `poly_ord_unique_0` encodes properties about polynomial order and zero and non-zero root evaluations, which should have analogous equivalent statements in the target.


---

## poly_ord_mul

### Name of formal statement
poly_ord_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_mul = prove(`
  !p:(1->num)->complex q z.
  ring_polynomial complex_ring p ==>
  ring_polynomial complex_ring q ==>
  ~(p = poly_0 complex_ring) ==>
  ~(q = poly_0 complex_ring) ==>
  (
    ring_polynomial complex_ring (poly_mul complex_ring p q) /\
    ~(poly_mul complex_ring p q = poly_0 complex_ring) /\
    poly_ord (poly_mul complex_ring p q) z
    = poly_ord p z + poly_ord q z
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  choose `f:(1->num)->complex` `ring_polynomial complex_ring f /\ ~complex_root f z /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f` [poly_ord_exists] THEN
  choose `g:(1->num)->complex` `ring_polynomial complex_ring g /\ ~complex_root g z /\ q = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g` [poly_ord_exists] THEN
  subgoal `~(complex_root (poly_mul complex_ring f g) z)` THENL [
    rw[complex_root] THEN
    simp[POLY_EVAL_MUL;in_complex_ring] THEN
    have `~(poly_eval complex_ring f z = Cx(&0))` [complex_root] THEN
    have `~(poly_eval complex_ring g z = Cx(&0))` [complex_root] THEN
    qed[COMPLEX_ENTIRE;complex_ring_clauses]
  ; pass
  ] THEN
  have `p = ring_mul(x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f` [x_poly_use] THEN
  have `q = ring_mul(x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g` [x_poly_use] THEN
  specialize_assuming[`x_poly(complex_ring)`;
    `poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)`;
    `poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)`;
    `f:(1->num)->complex`;
    `g:(1->num)->complex`;
    `p:(1->num)->complex`;
    `q:(1->num)->complex`;
  ](GENL[
    `r:R ring`;`d:R`;`e:R`;`f:R`;`g:R`;`p:R`;`q:R`
  ](
    RING_RULE `p = ring_mul(r:R ring) d f ==> q = ring_mul r e g ==> ring_mul r p q = ring_mul r (ring_mul r d e) (ring_mul r f g)`
  )) THEN
  have `ring_mul (x_poly complex_ring) p q = ring_mul (x_poly complex_ring) (ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (ring_mul (x_poly complex_ring) f g)` [x_poly_use;poly_pow_poly;x_minus_const_poly;in_complex_ring] THEN
  have `ring_mul (x_poly complex_ring) p q = ring_mul (x_poly complex_ring) (ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring f g)` [x_poly_use] THEN
  have `ring_mul (x_poly complex_ring) p q = ring_mul (x_poly complex_ring) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring f g)` [x_poly_use] THEN
  have `ring_mul (x_poly complex_ring) p q = poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring f g)` [x_poly_use] THEN
  have `poly_mul complex_ring p q = poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring f g)` [x_poly_use] THEN
  have `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) = poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)` [poly_pow_add;series_complex] THEN
  have `poly_mul complex_ring p q = poly_mul complex_ring ((poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z))) (poly_mul complex_ring f g)` [] THEN
  specialize[`poly_mul complex_ring p q:(1->num)->complex`;`poly_mul complex_ring f g:(1->num)->complex`]poly_ord_unique THEN
  qed[RING_POLYNOMIAL_MUL]
);;
```

### Informal statement
For all polynomials `p` and `q` over the complex numbers, and for all complex numbers `z`, if `p` and `q` are ring polynomials, and `p` and `q` are not the zero polynomial, then the following conditions hold:

1.  The product `p * q` is also a ring polynomial.
2.  The product `p * q` is not the zero polynomial.
3.  The order of the product `p * q` at `z` is equal to the sum of the orders of `p` and `q` at `z`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` and `q` are ring polynomials, and that neither is the zero polynomial.
- Invoke the theorem `poly_ord_exists` to obtain polynomials `f` and `g` such that `p = (x - z)^(poly_ord p z) * f` and `q = (x - z)^(poly_ord q z) * g`, where `f` and `g` are ring polynomials and `z` is not a root of `f` or `g`.
- Show that `z` is not a root of `f * g` using `complex_root`, `POLY_EVAL_MUL`, `in_complex_ring`, `COMPLEX_ENTIRE`, and `complex_ring_clauses`.
- Use `x_poly_use` multiple times to rewrite `p` and `q` substituting `ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f` for `p` and `ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g` for `q`.
- Use `RING_RULE` to expand out the product `ring_mul (x_poly complex_ring) p q`.
- Use `x_poly_use`, `poly_pow_poly`, `x_minus_const_poly`, and `in_complex_ring` to rewrite `ring_mul (x_poly complex_ring) p q` to `poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring f g)`.
- Use `poly_pow_add` and `series_complex` to simplify `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))` to `poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)`.
- Apply `poly_ord_unique` to conclude the proof using `RING_POLYNOMIAL_MUL`.

### Mathematical insight
This theorem specifies how the order of a product of polynomials at a point `z` relates to the orders of the individual polynomials at that point. The order of a polynomial `p` at a point `z` is the highest power of `(x - z)` that divides `p`.  The theorem states that when multiplying polynomials `p` and `q`, their orders at a point `z` add up to produce the order of the product `p*q` at the same point `z`. This is a fundamental property used when analyzing roots and factorization of polynomials.

### Dependencies
- `poly_ord_exists`
- `complex_root`
- `POLY_EVAL_MUL`
- `in_complex_ring`
- `COMPLEX_ENTIRE`
- `complex_ring_clauses`
- `x_poly_use`
- `RING_RULE`
- `poly_pow_poly`
- `x_minus_const_poly`
- `poly_pow_add`
- `series_complex`
- `poly_ord_unique`
- `RING_POLYNOMIAL_MUL`

### Porting notes (optional)
- The main challenge in porting this theorem involves the handling of polynomial rings and the concept of the order of a polynomial at a point. Ensure that the target proof assistant has suitable definitions and theorems to work with these concepts.  Specifically, theorems related to `poly_ord_exists` and `poly_ord_unique` are crucial.
- The `RING_RULE` tactic application is important here for manipulating ring expressions; ensure that a similar capability for rewriting and simplifying ring expressions exists in the target environment.


---

## poly_ord_product

### Name of formal statement
poly_ord_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_product = prove(`
  !p z S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial complex_ring (p s)) ==>
  (!s:X. s IN S ==> ~(p s = poly_0 complex_ring)) ==>
  (
    ring_polynomial complex_ring (poly_product complex_ring S p) /\
    ~(poly_product complex_ring S p = poly_0 complex_ring) /\
    poly_ord (poly_product complex_ring S p) z
    = nsum S (\s. poly_ord (p s) z)
  )
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  STRIP_TAC THEN
  STRIP_TAC THEN
  STRIP_TAC THENL [
    rw[NSUM_CLAUSES;poly_product_empty] THEN
    rw[poly_ord_1;poly_1_0_complex]
  ;
    STRIP_TAC THEN
    STRIP_TAC THEN
    STRIP_TAC THEN
    have `(!s:X. s IN x INSERT S ==> ring_powerseries complex_ring (p s:(1->num)->complex))` [series_complex] THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    set_fact `(x:X) IN x INSERT S` THEN
    simp[poly_product_insert;NSUM_CLAUSES] THEN
    have `~(poly_product complex_ring (S:X->bool) p = poly_0(complex_ring))` [poly_product_ring_product_x_poly;x_poly_use] THEN
    have `~(poly_mul complex_ring (p(x:X)) (poly_product complex_ring S p) = poly_0 complex_ring)` [nonzero_poly_mul;series_complex;integral_domain_complex] THEN
    specialize_assuming[`p(x:X):(1->num)->complex`;`poly_product complex_ring (S:X->bool) p`;`z:complex`]poly_ord_mul THEN
    qed[poly_product_poly]
  ]
);;
```
### Informal statement
For any predicate `p` on a type `X`, any complex number `z`, and any set `S` of type `X`, if `S` is finite, and for all `s` in `S`, `p s` is a ring polynomial in the complex ring, and for all `s` in `S`, `p s` is not the zero polynomial in the complex ring, then:
  - `poly_product complex_ring S p` is a ring polynomial in the complex ring, and
  - `poly_product complex_ring S p` is not the zero polynomial in the complex ring, and
  - the order of `poly_product complex_ring S p` at `z` equals the sum over `S` of the orders of `p s` at `z`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.
- Base case: `S` is empty.  We use `NSUM_CLAUSES` and `poly_product_empty` to reduce `poly_product complex_ring S p` to `poly_1 complex_ring`. Then we use `poly_ord_1` and `poly_1_0_complex` to establish `poly_ord (poly_product complex_ring S p) z = 0 = nsum S (\s. poly_ord (p s) z)`.
- Inductive step: Assume `S` is finite and the theorem holds for all subsets of `S`. We want to show it holds for `x INSERT S`.
  - Rewrite `poly_product complex_ring (x INSERT S) p` to `poly_mul complex_ring (p x) (poly_product complex_ring S p)` using `poly_product_insert` and `NSUM_CLAUSES`.
  - Use `poly_product_ring_product_x_poly` and `nonzero_poly_mul` to establish `poly_product complex_ring (S:X->bool) p` is non-zero
  - Instantiate `poly_ord_mul` with `p x`, `poly_product complex_ring S p`, and `z`.
  - Apply the inductive hypothesis and complete the proof.

### Mathematical insight
This theorem states that the order of the product of polynomials at a point `z` is the sum of the orders of the individual polynomials at `z`. It leverages the fact that `poly_product` distributes over multiplication in the ring of polynomials, thereby allowing reduction of the order calculation to individual polynomials.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `NSUM_CLAUSES`
- `poly_product_empty`
- `poly_ord_1`
- `poly_1_0_complex`
- `poly_product_insert`
- `poly_ord_mul`
- `nonzero_poly_mul`
- `poly_product_ring_product_x_poly`

### Porting notes (optional)
- The most direct port should focus on establishing the ring structure and the property that valuation (order) of a product is the sum of valuations.
- Handling of finiteness conditions may vary among systems; ensure that these are translated appropriately.


---

## poly_ord_monic_vanishing_at

### Name of formal statement
poly_ord_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_monic_vanishing_at = prove(`
  !S c z.
  FINITE S ==>
  (
    ring_polynomial complex_ring (monic_vanishing_at complex_ring S c) /\
    ~(monic_vanishing_at complex_ring S c = poly_0 complex_ring) /\
    poly_ord (monic_vanishing_at complex_ring S c) z
    = CARD {s:X | s IN S /\ z = c s}
  )
`,
  intro THENL [
    qed[monic_vanishing_at_poly;in_complex_ring]
  ;
    have `monic complex_ring (monic_vanishing_at complex_ring S (c:X->complex))` [monic_vanishing_at_monic;in_complex_ring] THEN
    have `~(monic complex_ring (poly_0 complex_ring))` [monic_poly_0;ring_1_0_complex] THEN
    qed[]
  ;
    subgoal `poly_ord (monic_vanishing_at complex_ring S c) z = nsum S (\s:X. poly_ord (x_minus_const complex_ring (c s)) z)` THENL [
      rw[monic_vanishing_at] THEN
      specialize_assuming[
        `\s:X. x_minus_const complex_ring (c s)`;
        `z:complex`;
        `S:X->bool`
      ]poly_ord_product THEN
      qed[x_minus_const_poly;in_complex_ring;monic_x_minus_const;monic_poly_0;ring_1_0_complex]
    ; pass
    ] THEN
    subgoal `nsum S (\s. poly_ord (x_minus_const complex_ring (c s)) z) = nsum S (\s:X. if z = c s then 1 else 0)` THENL [
      sufficesby NSUM_EQ THEN
      qed[poly_ord_x_minus_const]
    ; pass
    ] THEN
    simp[] THEN
    rw[GSYM NSUM_RESTRICT_SET] THEN
    specialize[
      `S:X->bool`;
      `\s:X. z = c s:complex`
    ]FINITE_RESTRICT THEN
    qed[CARD_EQ_NSUM]
  ]
);;
```
### Informal statement
For all sets `S` (of type `X->bool`), all functions `c` (of type `X->complex`), and all complex numbers `z`, if `S` is finite, then the polynomial `monic_vanishing_at complex_ring S c` is a polynomial over the complex numbers, and it is not the zero polynomial, and its polynomial order at `z` equals the cardinality of the set of elements `s` in `S` such that `z` equals `c s`.

### Informal sketch
The proof proceeds as follows:
- First, show that `monic_vanishing_at complex_ring S c` is a polynomial in `complex_ring` and it is not the zero polynomial. This is done by referencing the theorems `monic_vanishing_at_poly`, `in_complex_ring`, `monic_vanishing_at_monic`, `monic_poly_0`, and `ring_1_0_complex`.
- Second, show that `poly_ord (monic_vanishing_at complex_ring S c) z` equals the sum over `S` of `poly_ord (x_minus_const complex_ring (c s)) z`. This step unfolds the definition of `monic_vanishing_at` and uses `poly_ord_product`.
- Next, show that the sum over `S` of `poly_ord (x_minus_const complex_ring (c s)) z` equals the sum over `S` of `if z = c s then 1 else 0`. This uses `poly_ord_x_minus_const` and `NSUM_EQ`.
- Finally, simplify the expression and rewrite the sum using `NSUM_RESTRICT_SET`, apply `FINITE_RESTRICT`, and then rewrite the sum as a cardinality using `CARD_EQ_NSUM`.

### Mathematical insight
This theorem connects the polynomial order of a specific polynomial (`monic_vanishing_at`) at a point `z` to the number of roots of the form `c s` within the finite set `S` that are equal to `z`. In essence, it shows how the multiplicities of these roots contribute to the polynomial order at that point.

### Dependencies
- Definition: `monic_vanishing_at`
- Theorem: `monic_vanishing_at_poly`
- Theorem: `in_complex_ring`
- Theorem: `monic_vanishing_at_monic`
- Theorem: `monic_poly_0`
- Theorem: `ring_1_0_complex`
- Theorem: `poly_ord_product`
- Definition: `x_minus_const`
- Theorem: `x_minus_const_poly`
- Theorem: `monic_x_minus_const`
- Theorem: `poly_ord_x_minus_const`
- Theorem: `NSUM_EQ`
- Theorem: `NSUM_RESTRICT_SET`
- Theorem: `FINITE_RESTRICT`
- Theorem: `CARD_EQ_NSUM`


---

## poly_ord_monic_vanishing_at_numpreimages

### Name of formal statement
poly_ord_monic_vanishing_at_numpreimages

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_monic_vanishing_at_numpreimages = prove(`
  !S:X->bool c z.
  FINITE S ==>
  (
    ring_polynomial complex_ring (monic_vanishing_at complex_ring S c) /\
    ~(monic_vanishing_at complex_ring S c = poly_0 complex_ring) /\
    poly_ord (monic_vanishing_at complex_ring S c) z =
    numpreimages c S z
  )
`,
  simp[poly_ord_monic_vanishing_at] THEN
  rw[numpreimages] THEN
  intro THEN
  subgoal `{s:X | s IN S /\ z = c s:complex} = {x | x IN S /\ c x = z}` THENL [
    rw[EXTENSION;IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For any set `S` of type `X -> bool`, any complex number `c` (of type `X -> complex`), and any complex number `z`, if `S` is finite, then:
*   `monic_vanishing_at complex_ring S c` is a polynomial over the complex ring;
*   `monic_vanishing_at complex_ring S c` is not the zero polynomial over the complex ring; and
*   the polynomial order of `monic_vanishing_at complex_ring S c` at `z` is equal to `numpreimages c S z`.

### Informal sketch
The proof proceeds as follows:
*   First, simplify using `poly_ord_monic_vanishing_at`, which expresses the polynomial order in terms of the set of roots of the monic polynomial.
*   Then, rewrite the `numpreimages` function.
*   Introduce the antecedent (the finiteness of `S`, `c`, and `z`) as assumptions.
*   Prove the equality of the set `{s:X | s IN S /\ z = c s:complex}` and `{x | x IN S /\ c x = z}` by extensionality and elimination of the `IN` predicate.
*   Conclude the proof using transitivity (inferred by the proof assistant).

### Mathematical insight
This theorem relates the polynomial order (multiplicity of a root) of the monic polynomial `monic_vanishing_at complex_ring S c` at a point `z` to the number of preimages of `z` under the complex-valued function `c` restricted to the set `S`. In other words, the multiplicity of `z` as a root of the polynomial constructed to vanish on the image of `S` under `c` is exactly the number of elements in `S` that map to `z` under `c`. This is a fundamental connection between the algebraic notion of polynomial order and the set-theoretic notion of preimages.

### Dependencies
*   new_definition: `numpreimages`
*   new_definition: `monic_vanishing_at`
*   theorem: `poly_ord_monic_vanishing_at`
*   theorem: `EXTENSION`
*   theorem: `IN_ELIM_THM`


---

## poly_ord_one_minus_constx

### Name of formal statement
poly_ord_one_minus_constx

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_one_minus_constx = prove(`
  !c z.
  ring_polynomial complex_ring (one_minus_constx complex_ring c) /\
  ~(one_minus_constx complex_ring c = poly_0 complex_ring) /\
  poly_ord (one_minus_constx complex_ring c) z
  = if c * z = Cx(&1) then 1 else 0
`,
  REPEAT GEN_TAC THEN
  have `ring_polynomial complex_ring (one_minus_constx complex_ring c)` [one_minus_constx_poly;in_complex_ring] THEN
  case `c * z = Cx(&1)` THENL [
    specialize_assuming[`one_minus_constx complex_ring c`;`poly_1 complex_ring:(1->num)->complex`;`z:complex`]poly_ord_unique_1 THEN
    have `~complex_root (poly_1 complex_ring) z` [complex_root;POLY_EVAL_1;field_complex;field;complex_ring_clauses] THEN
    subgoal `one_minus_constx complex_ring c = poly_mul complex_ring (x_minus_const complex_ring z) (poly_const complex_ring (--c))` THENL [
      sufficesby eq_coeff THEN
      intro THEN
      simp[coeff_times_poly_const;series_complex;in_complex_ring] THEN
      simp[coeff_one_minus_constx;in_complex_ring] THEN
      simp[coeff_x_minus_const;in_complex_ring] THEN
      case `d = 0` THENL [
        simp[ARITH_RULE `~(0 = 1)`] THEN
        rw[complex_ring_clauses] THEN
        complex_field_fact `c * z = Cx(&1) ==> Cx(&1) = --c * --z` THEN
        qed[]
      ; pass
      ] THEN
      case `d = 1` THENL [
        simp[] THEN
        rw[complex_ring_clauses] THEN
        CONV_TAC COMPLEX_FIELD
      ; pass
      ] THEN
      qed[RING_MUL_RZERO;in_complex_ring]
    ; pass
    ] THEN
    subgoal `~complex_root (poly_const complex_ring (--c)) z` THENL [
      rw[complex_root] THEN
      simp[POLY_EVAL_CONST;in_complex_ring] THEN
      complex_field_fact `c * z = Cx(&1) ==> ~(--c = Cx(&0))` THEN
      qed[]
    ; pass
    ] THEN
    specialize_assuming[`one_minus_constx complex_ring c`;`poly_const complex_ring (--c):(1->num)->complex`;`z:complex`]poly_ord_unique_1 THEN
    qed[one_minus_constx_poly;in_complex_ring;RING_POLYNOMIAL_CONST]
  ; pass
  ] THEN
  have `poly_eval complex_ring (one_minus_constx complex_ring c) z = Cx(&1) - c * z` [eval_one_minus_constx;in_complex_ring;ring_sub_complex;complex_ring_clauses] THEN
  complex_field_fact `~(c * z = Cx(&1)) ==> ~(Cx(&1) - c * z = Cx(&0))` THEN
  have `~(poly_eval complex_ring (one_minus_constx complex_ring c) z = Cx(&0))` [] THEN
  have `~(complex_root(one_minus_constx complex_ring c) z)` [complex_root] THEN
  qed[poly_ord_unique_0]
);;
```
### Informal statement
For all complex numbers `c` and `z`, it is the case that: `one_minus_constx complex_ring c` is a ring polynomial over the complex ring, `one_minus_constx complex_ring c` is not equal to the zero polynomial `poly_0 complex_ring`, and the polynomial order of `one_minus_constx complex_ring c` at `z` equals 1 if `c * z = 1` (where 1 is the complex number `Cx(&1)`) and 0 otherwise.

### Informal sketch
The proof proceeds by:

- First, proving that `one_minus_constx complex_ring c` is a ring polynomial and stating that it is in the complex ring.
- Then, considering two cases based on whether `c * z = 1`, where `1` represents the complex number `Cx(&1)`.

  - **Case 1:** Assume `c * z = 1`.
    - Use the theorem `poly_ord_unique_1`, which states that if a polynomial `p` satisfies a specific condition, then its polynomial order at `z` is 1.
    - Show that `one_minus_constx complex_ring c` can be expressed as `(x_minus_const complex_ring z) * (poly_const complex_ring (--c))`. This uses the definition `eq_coeff` to equate coefficients of the polynomials appearing on each side of the equation.
    - Show that `z` is not a complex root of `poly_1 complex_ring`.
    - Show that `z` is not a complex root of `poly_const complex_ring (--c)`.
    - Apply `poly_ord_unique_1` to conclude that the polynomial order is 1.

  - **Case 2:** Assume `~(c * z = 1)`.
    - Show that `poly_eval complex_ring (one_minus_constx complex_ring c) z = 1 - c * z`.
    - Deduce using the assumption `~(c * z = 1)` that `~(1 - c * z = 0)`.
    - Show that `z` is not a complex root of `one_minus_constx complex_ring c`.
    - Apply `poly_ord_unique_0` to conclude that the polynomial order is 0.

### Mathematical insight
This theorem determines the polynomial order of the polynomial `1 - c*x` at a given complex number `z`. It states that the polynomial order is 1 if `c*z = 1`, meaning that `z` is a root of multiplicity 1, and 0 otherwise, meaning that `z` is not a root. The polynomial `one_minus_constx complex_ring c` has a root at z if and only if $1 - cz = 0$, so $cz = 1$. When `z` is not `1/c`, the theorem correctly asserts that the polynomial order, the number of linear factors of the form `x - z` that can divide the polynomial, is zero.

### Dependencies
- Definitions: `one_minus_constx`, `poly_0`, `poly_ord`, `complex_ring`, `poly_mul`, `complex_root`, `poly_eval`, `x_minus_const`, `poly_const`, `coeff_times_poly_const`, `coeff_one_minus_constx`, `coeff_x_minus_const`, `poly_1`
- Theorems: `poly_ord_unique_1`, `eval_one_minus_constx`, `poly_ord_unique_0`
- Facts: `RING_POLYNOMIAL_CONST`, `in_complex_ring`,`RING_MUL_RZERO`, `complex_ring_clauses`, `POLY_EVAL_CONST`,`field_complex`, `field`, `complex_field_fact`

### Porting notes (optional)
- The proof relies heavily on complex field arithmetic reasoning (`complex_field_fact`). Make sure that the target proof assistant has a robust complex number and field tactic library.
- The tactic `sufficesby` is used to introduce intermediate goals that, if proven, are sufficient to prove the main goal. This tactic might need to be emulated depending on the capabilities of the target proof assistant.
- The proof makes use of `specialize_assuming` which extracts a relevant instance of a previous proven hypothesis.


---

## poly_ord_pow

### Name of formal statement
poly_ord_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_pow = prove(`
  !p:(1->num)->complex n z.
  ring_polynomial complex_ring p ==>
  ~(p = poly_0 complex_ring) ==>
  (
    ring_polynomial complex_ring (poly_pow complex_ring p n) /\
    ~(poly_pow complex_ring p n = poly_0 complex_ring) /\
    poly_ord (poly_pow complex_ring p n) z
    = n * poly_ord p z
  )
`,
  GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0;poly_1_0_complex;ARITH_RULE `0 * e = 0`] THEN
    qed[poly_ord_1]
  ;
    rw[ARITH_RULE `SUC n = n + 1`;RIGHT_ADD_DISTRIB;ARITH_RULE `1 * e = e`] THEN
    simp[poly_pow_add;poly_pow_1;series_complex] THEN
    GEN_TAC THEN
    REPEAT DISCH_TAC THEN
    have `ring_polynomial complex_ring (poly_pow complex_ring p n:(1->num)->complex)` [poly_pow_poly] THEN
    have `~(poly_pow complex_ring p n = poly_0 complex_ring:(1->num)->complex)` [] THEN
    specialize[`poly_pow complex_ring p n:(1->num)->complex`;`p:(1->num)->complex`;`z:complex`]poly_ord_mul THEN
    qed[]
  ]
);;
```
### Informal statement
For any polynomial `p` over complex numbers, viewed as a function from natural numbers to complex numbers, any complex number `n`, and any complex number `z`, if `p` is a ring polynomial over the complex ring, and `p` is not the zero polynomial, then:
1. `poly_pow complex_ring p n` is a ring polynomial over the complex ring, and
2. `poly_pow complex_ring p n` is not the zero polynomial, and
3. the order of `poly_pow complex_ring p n` at `z` is equal to `n` times the order of `p` at `z`.

### Informal sketch
The proof proceeds by induction on `n`.

- Base case: `n = 0`.
  - The theorem reduces to proving that the order of the constant polynomial 1 is 0, which follows from `poly_ord_1`. Simplification using `poly_pow_0` and `poly_1_0_complex` is performed.
- Inductive step: Assume the theorem holds for `n`. We want to show it holds for `n + 1`.
  - Rewrite `SUC n` to `n + 1`, the polynomial power using `poly_pow_add` and `poly_pow_1`.
  - Simplify the expression `poly_pow complex_ring p (n+1)` using `series_complex`, resulting in `poly_pow complex_ring p n * p`
  - We have `ring_polynomial complex_ring (poly_pow complex_ring p n)`.
  - We need to show `~(poly_pow complex_ring p n = poly_0 complex_ring)`.
  - Applying the specialized form of `poly_ord_mul`.

### Mathematical insight
This theorem relates the order of a polynomial raised to a power to the order of the original polynomial. The order of a polynomial *p* at a point *z* is the smallest *k* such that the *k*-th derivative of *p* at *z* is non-zero. Raising a polynomial to the power *n* multiplies its order at any point *z* by *n*.

### Dependencies
- `ring_polynomial`
- `complex_ring`
- `poly_0`
- `poly_pow`
- `poly_ord`
- `poly_pow_0`
- `poly_1_0_complex`
- `poly_ord_1`
- `poly_pow_add`
- `poly_pow_1`
- `series_complex`
- `poly_ord_mul`
- `poly_pow_poly`

### Porting notes (optional)
The theorem makes heavy use of polynomial algebra over complex numbers. Ensure that the target proof assistant has suitable libraries for polynomials and complex numbers. The definitions of `poly_ord` and `poly_pow` might differ slightly in other systems, so they should be carefully examined. The tactic `specialize` might need to be replaced by explicit instantiation of variables, depending on the target system's automation.


---

## poly_ord_x_pow_1

### Name of formal statement
poly_ord_x_pow_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_x_pow_1 = prove(`
  !z.
  ring_polynomial complex_ring (x_pow complex_ring 1) /\
  ~(x_pow complex_ring 1 = poly_0 complex_ring) /\
  poly_ord (x_pow complex_ring 1) z
  = if z = Cx(&0) then 1 else 0
`,
  rw[GSYM x_minus_const_0] THEN
  qed[poly_ord_x_minus_const;complex_ring_clauses]
);;
```
### Informal statement
For any complex number `z`, given that `x_pow complex_ring 1` is a ring polynomial over the complex ring, and `x_pow complex_ring 1` is not equal to the zero polynomial `poly_0 complex_ring`, then the polynomial order of `x_pow complex_ring 1` at `z` is equal to 1 if `z` equals `Cx(&0)` (complex number representation of 0), and 0 otherwise.

### Informal sketch
The proof proceeds as follows:
- Apply `GSYM x_minus_const_0` which rewrites `z = Cx(&0)` to `Cx(&0) = z`.
- Apply the theorem `poly_ord_x_minus_const` (which gives the order of `x - c` at `z`) and the clauses `complex_ring_clauses` to complete the rewriting, which gives the final result.

### Mathematical insight
This theorem provides a specific instance of computing the polynomial order, namely, the order of the polynomial `x` (or `x^1`) at any complex number `z`. The polynomial order measures the multiplicity of `z` as a root of the polynomial. It states that the polynomial `x` has a root of multiplicity 1 at `0` and no root at any other point. It is a special case of the more general result `poly_ord_x_pow`, which computes the polynomial order of `x^n`.

### Dependencies
- Theorems: `poly_ord_x_minus_const`
- Conversions: `GSYM x_minus_const_0`
- Theorems: `complex_ring_clauses`


---

## poly_ord_x_pow

### Name of formal statement
poly_ord_x_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_x_pow = prove(`
  !n z.
  ring_polynomial complex_ring (x_pow complex_ring n) /\
  ~(x_pow complex_ring n = poly_0 complex_ring) /\
  poly_ord (x_pow complex_ring n) z
  = if z = Cx(&0) then n else 0
`,
  REPEAT GEN_TAC THEN
  have `x_pow complex_ring n = poly_pow complex_ring (x_pow complex_ring 1) n` [x_pow_pow;ARITH_RULE `1*n = n`] THEN
  simp[] THEN
  have `ring_polynomial complex_ring (x_pow complex_ring 1) /\ ~(x_pow complex_ring 1 = poly_0 complex_ring) /\ poly_ord (x_pow complex_ring 1) z = if z = Cx(&0) then 1 else 0` [poly_ord_x_pow_1] THEN
  specialize_assuming[
    `x_pow complex_ring 1`;
    `n:num`;
    `z:complex`
  ]poly_ord_pow THEN
  qed[ARITH_RULE `n*1 = n`;ARITH_RULE `n*0 = 0`]
);;
```

### Informal statement
For all natural numbers `n` and complex numbers `z`, given that `x_pow complex_ring n` is a ring polynomial in the `complex_ring` and that `x_pow complex_ring n` is not equal to the zero polynomial `poly_0 complex_ring`, the polynomial order of `x_pow complex_ring n` at `z` is `n` if `z` is equal to the complex number `Cx(&0)`, and `0` otherwise.

### Informal sketch
The proof proceeds as follows:
- First, establish `x_pow complex_ring n = poly_pow complex_ring (x_pow complex_ring 1) n` using `x_pow_pow` and arithmetic reasoning.
- Then, simplify the goal using the established equality.
- Next, use `poly_ord_x_pow_1` to prove `ring_polynomial complex_ring (x_pow complex_ring 1) /\ ~(x_pow complex_ring 1 = poly_0 complex_ring) /\ poly_ord (x_pow complex_ring 1) z = if z = Cx(&0) then 1 else 0`.
- Specialize `poly_ord_pow` with `x_pow complex_ring 1`, `n`, and `z`.
- Finally, conclude using arithmetic reasoning.

### Mathematical insight
This theorem gives the precise polynomial order (or multiplicity of root) of `x^n` at any point `z`.  The polynomial `x^n` has a root of order `n` at 0, and has no other roots, so the polynomial order at any other `z` is zero. A key step is to reduce `x_pow n` to `(x_pow 1)^n` and then apply the more general theorem `poly_ord_pow`.

### Dependencies
- `x_pow_pow`
- `poly_ord_x_pow_1`
- `poly_ord_pow`


---

## poly_ord_mul_0

### Name of formal statement
poly_ord_mul_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_mul_0 = prove(`
  !p:(1->num)->complex q z.
  ( ring_polynomial complex_ring p /\
    ~(p = poly_0 complex_ring) /\
    poly_ord p z = 0
  ) ==>
  ( ring_polynomial complex_ring q /\
    ~(q = poly_0 complex_ring) /\
    poly_ord q z = 0
  ) ==>
  (
    ring_polynomial complex_ring (poly_mul complex_ring p q) /\
    ~(poly_mul complex_ring p q = poly_0 complex_ring) /\
    poly_ord (poly_mul complex_ring p q) z = 0
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  specialize_assuming[`p:(1->num)->complex`;`q:(1->num)->complex`;`z:complex`]poly_ord_mul THEN
  qed[ARITH_RULE `0+0 = 0`]
);;
```
### Informal statement
For all polynomials `p` and `q` over the complex numbers, and for all complex numbers `z`, if `p` and `q` are ring polynomials, not equal to the zero polynomial, and the order of `p` at `z` is 0, and the order of `q` at `z` is 0, then the product `p * q` is a ring polynomial, not equal to the zero polynomial, and the order of `p * q` at `z` is 0.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` and `q` are ring polynomials, not zero, and have order 0 at `z`.
- Apply the theorem `poly_ord_mul`. This theorem relates the order of a product of polynomials to the sum of the orders of the individual polynomials. Specifically, `poly_ord (poly_mul complex_ring p q) z = poly_ord p z + poly_ord q z`.
- Since `poly_ord p z = 0` and `poly_ord q z = 0`, we can deduce that `poly_ord (poly_mul complex_ring p q) z = 0 + 0`.
- Apply the arithmetic rule `0 + 0 = 0` to conclude that `poly_ord (poly_mul complex_ring p q) z = 0`.
- Furthermore, `ring_polynomial complex_ring (poly_mul complex_ring p q)` and `~(poly_mul complex_ring p q = poly_0 complex_ring)` follow from the fact that `p` and `q` are ring polynomials and not zero.

### Mathematical insight
This theorem states that if two polynomials `p` and `q` have order 0 at a point `z`, then their product `p * q` also has order 0 at `z`. The order of a polynomial at a point `z` intuitively indicates how many times `(x - z)` divides the polynomial. A polynomial having order 0 at `z` essentially means that `(x - z)` does not divide the polynomial, or that `z` is not a root of the polynomial. The multiplication property of polynomial orders shows that the order of the product equals the sum of the orders, and this theorem is a special case of that result.

### Dependencies
- Theorem: `poly_ord_mul`

### Porting notes (optional)
The main challenge in porting this theorem might be ensuring that `poly_ord_mul` is ported first. Additionally, the definition of `poly_ord` and the representation of polynomials need to be consistent across the new proof assistant to preserve the mathematical meaning. The arithmetic rule `0 + 0 = 0` might be built-in, or a simple lemma in other systems.


---

## poly_ord_ge_if

### Name of formal statement
poly_ord_ge_if

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_ge_if = prove(`
  !p:(1->num)->complex f n.
  ring_polynomial complex_ring f ==>
  p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f ==>
  (p = poly_0 complex_ring \/ n <= poly_ord p z)
`,
  intro THEN
  case `f = poly_0 complex_ring:(1->num)->complex` THENL [
    qed[POLY_MUL_0;poly_pow_poly;x_minus_const_poly;in_complex_ring]
  ; pass
  ] THEN
  choose `g:(1->num)->complex` `ring_polynomial complex_ring g /\ ~complex_root g z /\ f = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord f z)) g` [poly_ord_exists] THEN
  have `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord f z)) g)` [] THEN
  have `p = poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord f z))) g` [POLY_MUL_ASSOC;series_complex] THEN
  have `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (n + poly_ord f z)) g` [poly_pow_add;series_complex] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [x_minus_const_poly;poly_pow_poly;RING_POLYNOMIAL_MUL;in_complex_ring] THEN
  have `n + poly_ord f z = poly_ord p z` [poly_ord_unique] THEN
  ASM_ARITH_TAC
);;
```

### Informal statement
For any polynomial `p` over complex numbers (represented as a function from `1->num` to `complex`), any polynomial `f` over the complex numbers, and any natural number `n`, if `f` is a ring polynomial in the complex ring and `p` equals `f` multiplied by `(x - z)^n` (where `x` is the variable, `z` is a complex number, and the operations are specific to the complex ring), then either `p` is the zero polynomial in the complex ring, or `n` is less than or equal to the order of `p` at `z`.

### Informal sketch
The proof proceeds as follows:
- The goal is `!p:(1->num)->complex f n. ring_polynomial complex_ring f ==> p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f ==> (p = poly_0 complex_ring \/ n <= poly_ord p z)`.
- Introduce the universally quantified variables `p`, `f`, and `n`. Assume `ring_polynomial complex_ring f` and `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f`. We want to show `p = poly_0 complex_ring \/ n <= poly_ord p z`.
- Case split on whether `f` is the zero polynomial.
  - If `f = poly_0 complex_ring`, then `p = poly_0 complex_ring` directly by properties of polynomial multiplication with zero, `poly_mul_0`, `poly_pow_poly`, `x_minus_const_poly` and `in_complex_ring` so the disjunction holds.
  - Otherwise, assume `f` is not the zero polynomial.
    - Choose a polynomial `g` such that `ring_polynomial complex_ring g`, `~complex_root g z` and `f = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord f z)) g`. The existence of such a `g` is guaranteed by `poly_ord_exists`.
    - Substitute the expression for `f` in terms of `g` into the assumption `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f` to get `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord f z)) g)`.
    - Apply associativity of polynomial multiplication (`POLY_MUL_ASSOC` and `series_complex`) to obtain: `p = poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord f z))) g`.
    - Combine the polynomial powers using `poly_pow_add` to get `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (n + poly_ord f z)) g`.
    - Since `ring_polynomial complex_ring f` and `ring_polynomial complex_ring g`, show that `ring_polynomial complex_ring p` using `x_minus_const_poly`, `poly_pow_poly`, `RING_POLYNOMIAL_MUL` and `in_complex_ring`.
    - Because `f` is not zero and `g` is not a root at `z`, deduce that `n + poly_ord f z = poly_ord p z` using `poly_ord_unique`.
    - Finally, show `n <= poly_ord p z` by arithmetic (`ASM_ARITH_TAC`).

### Mathematical insight
This theorem relates the multiplicity of a root `z` of a polynomial `f` to the multiplicity of the same root in a polynomial `p` formed by multiplying `f` by `(x - z)^n`. It essentially states that if `p(x) = (x - z)^n * f(x)`, the order of `z` as a root of `p` is at least `n`, unless `p` is the zero polynomial. This is a fundamental result used for reasoning about polynomial factorization and root multiplicities.

### Dependencies
- `POLY_MUL_0`
- `poly_pow_poly`
- `x_minus_const_poly`
- `in_complex_ring`
- `poly_ord_exists`
- `POLY_MUL_ASSOC`
- `series_complex`
- `poly_pow_add`
- `RING_POLYNOMIAL_MUL`
- `poly_ord_unique`
- `ASM_ARITH_TAC`

### Porting notes (optional)
- The `ring_polynomial` predicate and its associated rules need to be defined.
- Special attention may be required when porting tactics like `ASM_ARITH_TAC`, as different proof assistants might have varying degrees of automation for arithmetic reasoning.
- The definition and properties of `poly_ord` (polynomial order) are crucial for a successful port. Ensure that the target proof assistant has a similar concept or that it can be defined.


---

## poly_ord_ge

### Name of formal statement
poly_ord_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_ge = prove(`
  !p:(1->num)->complex n.
  ring_polynomial complex_ring p ==>
  ((p = poly_0 complex_ring \/ n <= poly_ord p z)
   <=> ?f:(1->num)->complex. (
         ring_polynomial complex_ring f /\
         p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f
       )
  )
`,
  intro THEN
  splitiff THENL [
    case `p = poly_0 complex_ring:(1->num)->complex` THENL [
      intro THEN
      witness `poly_0 complex_ring:(1->num)->complex` THEN
      have `ring_polynomial complex_ring (x_minus_const complex_ring z)` [x_minus_const_poly;in_complex_ring] THEN
      have `ring_polynomial complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n)` [poly_pow_poly] THEN
      qed[POLY_MUL_0;RING_POLYNOMIAL_0]
    ; pass
    ] THEN
    intro THENL [
      qed[]
    ; pass
    ] THEN
    choose `f:(1->num)->complex` `ring_polynomial complex_ring f /\ ~complex_root f z /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f` [poly_ord_exists] THEN
    num_linear_fact `n <= poly_ord p z ==> poly_ord p z = n + (poly_ord p z - n)` THEN
    have `poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z) = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (n)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z - n))` [poly_pow_add;series_complex] THEN
    have `p = poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (n)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z - n))) f` [] THEN
    have `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (n)) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z - n)) f)` [POLY_MUL_ASSOC;series_complex] THEN
    witness `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z - n)) f` THEN
    qed[RING_POLYNOMIAL_MUL;poly_pow_poly;x_minus_const_poly;in_complex_ring]
  ;
    qed[poly_ord_ge_if]
  ]
);;
```
### Informal statement
For any polynomial `p` over the complex numbers and any natural number `n`, if `p` is a ring polynomial (i.e., a polynomial represented as a function from natural numbers to complex numbers whose support is finite), then `p = 0` or `n` is less than or equal to the order of `p` at `z` if and only if there exists a polynomial `f` over the complex numbers such that `f` is a ring polynomial and `p` is equal to the product of `(x - z)^n` and `f`.

### Informal sketch
The proof proceeds by splitting the equivalence into two directions and proving each one separately.

*   **Direction 1: `(p = poly_0 complex_ring \/ n <= poly_ord p z) ==> ?f:(1->num)->complex. ...`**
    *   Case 1: `p = poly_0 complex_ring`. Choose `f` to be the zero polynomial, and show that `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f` holds, and verify that `f` is a ring polynomial.
    *   Case 2: `n <= poly_ord p z`. We aim to show that exists a `f` such that fulfill the assumption property.
*   **Direction 2: `(?f:(1->num)->complex. ...) ==> (p = poly_0 complex_ring \/ n <= poly_ord p z)`**
    *   We assume the existence of `f` such that `ring_polynomial complex_ring f /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) n) f`. and need to prove `p = poly_0 complex_ring \/ n <= poly_ord p z`.
    *   The proof invokes `poly_ord_exists` to choose a polynomial `f` such that `ring_polynomial complex_ring f /\ ~complex_root f z /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f`.
    *   Then show `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (n)) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z - n)) f)` using `num_linear_fact` and re-arranging the powers via `POLY_MUL_ASSOC`.
    *   Then show that `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z - n)) f` is a witness for existential quantifier.

### Mathematical insight
The theorem `poly_ord_ge` relates the order of a polynomial `p` at a point `z` to the ability to factor out `(x-z)^n` from `p`. It states that if `n` is less than or equal to the order of `p` at `z`, then `(x-z)^n` can be factored out from `p`, resulting in another polynomial `f`. This captures the intuition that the order of a polynomial at a point represents the highest power of `(x-z)` that divides the polynomial.

### Dependencies
- `poly_ord_exists`
- `x_minus_const_poly`
- `in_complex_ring`
- `poly_pow_poly`
- `POLY_MUL_0`
- `RING_POLYNOMIAL_0`
- `poly_ord_ge_if`
- `RING_POLYNOMIAL_MUL`
- `poly_pow_add`
- `series_complex`
- `POLY_MUL_ASSOC`



---

## poly_ord_mul_ge_ge

### Name of formal statement
poly_ord_mul_ge_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_mul_ge_ge = prove(`
  !p:(1->num)->complex q z m n.
  ring_polynomial complex_ring p ==>
  ( p = poly_0 complex_ring \/
    m <= poly_ord p z
  ) ==>
  ring_polynomial complex_ring q ==>
  ( q = poly_0 complex_ring \/
    n <= poly_ord q z
  ) ==>
  ( ring_polynomial complex_ring (poly_mul complex_ring p q) /\
    ( poly_mul complex_ring p q = poly_0 complex_ring \/
      m + n <= poly_ord (poly_mul complex_ring p q) z
    )
  )
`,
  REPEAT GEN_TAC THEN
  simp[poly_ord_ge;RING_POLYNOMIAL_MUL] THEN
  intro THEN
  witness `poly_mul complex_ring f f':(1->num)->complex` THEN
  have `poly_pow complex_ring (x_minus_const complex_ring z) (m + n) = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) m) (poly_pow complex_ring (x_minus_const complex_ring z) n)` [poly_pow_add;series_complex] THEN
  simp[RING_POLYNOMIAL_MUL] THEN
  rw[x_series_use] THEN
  specialize_assuming[
    `x_series complex_ring`;
    `poly_pow complex_ring (x_minus_const complex_ring z) m`;
    `poly_pow complex_ring (x_minus_const complex_ring z) n`;
  ](GENL[
    `r:R ring`;
    `M:R`;
    `N:R`;
  ](RING_RULE
    `ring_mul(r:R ring) (ring_mul r M f) (ring_mul r N f') = ring_mul r (ring_mul r M N) (ring_mul r f f')`
  )) THEN
  qed[x_series_use;series_complex]
);;
```
### Informal statement
For any polynomials `p` and `q` over the complex numbers, and any complex number `z`, and natural numbers `m` and `n`, if `p` is a ring polynomial, and either `p` is the zero polynomial or `m` is less than or equal to the order of `p` at `z`, and `q` is a ring polynomial, and either `q` is the zero polynomial or `n` is less than or equal to the order of `q` at `z`, then `poly_mul complex_ring p q` is a ring polynomial, and either `poly_mul complex_ring p q` is the zero polynomial or `m + n` is less than or equal to the order of `poly_mul complex_ring p q` at `z`.

### Informal sketch
The proof proceeds as follows:
- Start by generalizing all the variables.
- Simplify using `poly_ord_ge` and `RING_POLYNOMIAL_MUL`. The simplification unfolds the definition of order greater than or equal to and uses the ring polynomial property of the multiplication.
- Introduce assumptions.
- Witness `poly_mul complex_ring f f'` for variable.
- Prove the specific case `poly_pow complex_ring (x_minus_const complex_ring z) (m + n) = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) m) (poly_pow complex_ring (x_minus_const complex_ring z) n)`. That uses `poly_pow_add` for the general property of polynomial powering and `series_complex` to specify we are working with complex polynomial series.
- Simplify the goal with `RING_POLYNOMIAL_MUL`.
- Rewrite using `x_series_use`, which rewrites the form `ring_polynomial (x_series r)`.
- Specialize the theorem `x_series complex_ring` using `poly_pow complex_ring (x_minus_const complex_ring z) m` and `poly_pow complex_ring (x_minus_const complex_ring z) n` as arguments to apply to the general case of `ring_mul(r:R ring) (ring_mul r M f) (ring_mul r N f') = ring_mul r (ring_mul r M N) (ring_mul r f f')`.
- Finally, discharge the goal using `x_series_use` and `series_complex`.

### Mathematical insight
This theorem states that if the orders of two polynomials `p` and `q` at a point `z` are at least `m` and `n` respectively, then the order of their product `p * q` at `z` is at least `m + n`. This is a fundamental property in polynomial algebra. It connects the notion of order (related to the multiplicity of roots) with polynomial multiplication.

### Dependencies
- Theorems: `poly_pow_add`, `series_complex`
- Definitions: `poly_ord_ge`, `RING_POLYNOMIAL_MUL`, `x_series_use`
- Constants: `complex_ring`, `poly_mul`, `poly_pow`, `x_minus_const`, `poly_0`

### Porting notes (optional)
- The proof makes significant use of rewriting with series and general polynomial structure. Target proof assistants might require more explicit manipulation of polynomial coefficients.
- HOL Light's ring tactic and automatic simplification are heavily used; other systems may need these steps to be performed manually.


---

## poly_ord_mul_ge_ge0

### Name of formal statement
poly_ord_mul_ge_ge0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_mul_ge_ge0 = prove(`
  !p:(1->num)->complex q z n.
  ring_polynomial complex_ring p ==>
  ( p = poly_0 complex_ring \/
    n <= poly_ord p z
  ) ==>
  ring_polynomial complex_ring q ==>
  ( ring_polynomial complex_ring (poly_mul complex_ring p q) /\
    ( poly_mul complex_ring p q = poly_0 complex_ring \/
      n <= poly_ord (poly_mul complex_ring p q) z
    )
  )
`,
  REPEAT GEN_TAC THEN
  simp[poly_ord_ge;RING_POLYNOMIAL_MUL] THEN
  intro THEN
  witness `poly_mul complex_ring f q:(1->num)->complex` THEN
  simp[RING_POLYNOMIAL_MUL] THEN
  qed[POLY_MUL_ASSOC;series_complex]
);;
```

### Informal statement
For any polynomials `p` and `q` over the complex numbers, any complex number `z`, and any natural number `n`, if `p` is a ring polynomial, and either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`, and `q` is a ring polynomial, then `poly_mul complex_ring p q` is a ring polynomial, and either `poly_mul complex_ring p q` is the zero polynomial or `n` is less than or equal to the order of `poly_mul complex_ring p q` at `z`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a ring polynomial and that either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`.
- Assume `q` is a ring polynomial.
- We need to show that `poly_mul complex_ring p q` is a ring polynomial, and either `poly_mul complex_ring p q` is the zero polynomial or `n` is less than or equal to the order of `poly_mul complex_ring p q` at `z`.
- The proof uses `poly_ord_ge`, `RING_POLYNOMIAL_MUL`, `POLY_MUL_ASSOC`, and `series_complex`. It relies on the property that the product of ring polynomials is a ring polynomial.

### Mathematical insight
This theorem states that if we multiply two ring polynomials `p` and `q`, and `n` is a lower bound for the order of `p`, then `n` is also a lower bound for the order of `p*q`, unless `p*q` is the zero polynomial. This reflects the intuition that the order of a product is at least the order of each factor.

### Dependencies
- Definitions: `ring_polynomial`, `poly_0`, `poly_ord`, `poly_mul`
- Theorems: `poly_ord_ge`, `RING_POLYNOMIAL_MUL`, `POLY_MUL_ASSOC`, `series_complex`


---

## poly_ord_mul_ge0_ge

### Name of formal statement
poly_ord_mul_ge0_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_mul_ge0_ge = prove(`
  !p:(1->num)->complex q z n.
  ring_polynomial complex_ring p ==>
  ring_polynomial complex_ring q ==>
  ( q = poly_0 complex_ring \/
    n <= poly_ord q z
  ) ==>
  ( ring_polynomial complex_ring (poly_mul complex_ring p q) /\
    ( poly_mul complex_ring p q = poly_0 complex_ring \/
      n <= poly_ord (poly_mul complex_ring p q) z
    )
  )
`,
  qed[poly_ord_mul_ge_ge0;POLY_MUL_SYM;series_complex]
);;
```
### Informal statement
For any polynomials `p` and `q` over the complex numbers, and any complex number `z` and natural number `n`, if `p` and `q` are ring polynomials, and if either `q` is the zero polynomial or `n` is less than or equal to the order of `q` at `z`, then `poly_mul complex_ring p q` is a ring polynomial, and either `poly_mul complex_ring p q` is the zero polynomial or `n` is less than or equal to the order of `poly_mul complex_ring p q` at `z`.

### Informal sketch
The theorem states that if you multiply two ring polynomials `p` and `q` and have a lower bound `n` for the order of `q`, then either `p*q` is zero or the order of `p*q` is at least `n`.

- The proof depends on `poly_ord_mul_ge_ge0`, `POLY_MUL_SYM` and `series_complex`. It starts by checking when q is equal to `poly_0 complex_ring q`.
- The symmetry of polynomial multiplication `POLY_MUL_SYM` may be used to switch the order of multiplication if necessary.
- The theorem `poly_ord_mul_ge_ge0` gives a lower bound on the order of the product of two ring polynomials.
- The theorem `series_complex` provides the core formalization of the series representation of complex polynomials.

### Mathematical insight
This theorem is important because it gives a lower bound for the order of the product of two ring polynomials. This is useful in many situations, for example, when one want to determine the number of roots of a polynomial. Multiplying polynomials is a fundamental operation, and understanding how the order behaves under multiplication is crucial for reasoning about the roots and behavior of polynomial functions.

### Dependencies
- Theorem: `poly_ord_mul_ge_ge0`
- Theorem: `POLY_MUL_SYM`
- Theorem: `series_complex`


---

## poly_ord_neg_ge

### Name of formal statement
poly_ord_neg_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
!p:(1->num)->complex z n.
  ring_polynomial complex_ring p ==>
  (p = poly_0 complex_ring \/ n <= poly_ord p z) ==>
  (poly_neg complex_ring p = poly_0 complex_ring \/ n <= poly_ord(poly_neg complex_ring p) z)
```

### Informal statement
For all polynomials `p` over the complex numbers (represented as a function from natural numbers to complex numbers), all complex numbers `z`, and all natural numbers `n`, if `p` is a ring polynomial over the complex ring, and either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`, then either the negation of `p` is the zero polynomial or `n` is less than or equal to the order of the negation of `p` at `z`.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions.
- Simplifying using `poly_ord_ge` and `RING_POLYNOMIAL_NEG`.
- Introducing the assumption `p = poly_0 complex_ring \/ n <= poly_ord p z`.
- Using the witness `poly_neg complex_ring f:(1->num)->complex`.
- Simplifying using `RING_POLYNOMIAL_NEG`.
- Rewriting using `x_series_use`.
- Applying the theorem `RING_MUL_RNEG` (right negation for rings).
- Applying the theorem `series_complex`.
- Applying the fact `x_series_use`.

### Mathematical insight
This theorem essentially states that if a polynomial `p` has order greater than or equal to `n` at a point `z`, then its negation `-p` has the same property. This is because negating a polynomial simply multiplies the coefficients by -1, which does not affect the order of the polynomial at a given point unless the polynomial is zero.

### Dependencies
- `poly_ord_ge`
- `RING_POLYNOMIAL_NEG`
- `RING_MUL_RNEG`
- `series_complex`
- `x_series_use`


---

## poly_ord_add_ge

### Name of formal statement
poly_ord_add_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_add_ge = prove(`
  !p:(1->num)->complex q z n.
  ring_polynomial complex_ring p ==>
  ring_polynomial complex_ring q ==>
  (p = poly_0 complex_ring \/ n <= poly_ord p z) ==>
  (q = poly_0 complex_ring \/ n <= poly_ord q z) ==>
  (poly_add complex_ring p q = poly_0 complex_ring \/ n <= poly_ord(poly_add complex_ring p q) z)
`,
  REPEAT GEN_TAC THEN
  simp[poly_ord_ge;RING_POLYNOMIAL_ADD] THEN
  intro THEN
  witness `poly_add complex_ring f f':(1->num)->complex` THEN
  simp[RING_POLYNOMIAL_ADD] THEN
  simp[POLY_ADD_LDISTRIB;series_complex]
);;
```
### Informal statement
For any polynomials `p` and `q` over complex numbers (represented as functions from natural numbers to complex numbers), and for any complex number `z` and natural number `n`, if `p` and `q` are ring polynomials, and if either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`, and either `q` is the zero polynomial or `n` is less than or equal to the order of `q` at `z`, then either the sum of `p` and `q` is the zero polynomial, or `n` is less than or equal to the order of the sum of `p` and `q` at `z`.

### Informal sketch
The proof proceeds as follows:
- First, generalize the statement to hold for any `p`, `q`, `z`, and `n`.
- Simplify using the definition of `poly_ord_ge` and the fact that the sum of ring polynomials is also a ring polynomial (`RING_POLYNOMIAL_ADD`).
- Introduce the assumptions into the hypothesis.
- Introduce a witness `poly_add complex_ring f f'` for the sum of the polynomials.
- Simplify using `RING_POLYNOMIAL_ADD` which states that if `p` and `q` are complex ring polynomials then their sum is also a complex ring polynomial.
- Simplify using `POLY_ADD_LDISTRIB` and `series_complex` to progress the proof.

### Mathematical insight
The theorem states that if the order of two polynomials is at least `n` at a point `z`, then the order of their sum is also at least `n` at `z`, unless the sum is the zero polynomial. This aligns with the fundamental property that the order of a sum is at least the minimum of the orders, provided neither polynomial is zero.

### Dependencies
- `poly_ord_ge`
- `RING_POLYNOMIAL_ADD`
- `POLY_ADD_LDISTRIB`
- `series_complex`


---

## poly_ord_sum_ge

### Name of formal statement
poly_ord_sum_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_sum_ge = prove(`
  !p z n S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial complex_ring (p s)) ==>
  (!s:X. s IN S ==> (p s = poly_0 complex_ring \/ n <= poly_ord (p s) z)) ==>
  (poly_sum complex_ring S p = poly_0 complex_ring \/ n <= poly_ord(poly_sum complex_ring S p) z)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_sum_empty]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `ring_powerseries complex_ring (p(x:X):(1->num)->complex)` [x_poly_use;ring_polynomial] THEN
    simp[poly_sum_insert] THEN
    have `ring_polynomial complex_ring (poly_sum complex_ring (S:X->bool) p)` [poly_sum_poly] THEN
    qed[poly_ord_add_ge]
  ]
);;
```

### Informal statement
For all polynomials `p`, complex number `z`, natural number `n`, and set `S`, if `S` is finite and for all `s` in `S`, `p s` is a ring polynomial over the complex numbers, and for all `s` in `S`, either `p s` is the zero polynomial or `n` is less than or equal to the order of `p s` at `z`, then either the sum of `p s` over `S` is the zero polynomial or `n` is less than or equal to the order of the sum of `p s` over `S` at `z`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then the polynomial sum over `S` is the zero polynomial by `poly_sum_empty`.
- Inductive step: Assuming the result holds for all subsets of `S`, we want to prove it holds for `INSERT x S`.
    - We assume `ring_powerseries complex_ring (p(x))` and rewrite `poly_sum (INSERT x S) p` as `p x + poly_sum S p` by `poly_sum_insert`.
    - We then use `ring_polynomial complex_ring (poly_sum complex_ring S p)` (by theorem `poly_sum_poly`) and the assumption that the order of each term in the sum is greater than or equal to `n`.
    - We apply `poly_ord_add_ge` to show that `n` is less than or equal to the order of the sum, provided that the sum is not the zero polynomial.

### Mathematical insight
The theorem states that if a finite sum of polynomials has the property that each polynomial in the sum either is zero or has order at least `n` at `z`, then the sum has order at least `n` at `z` or is zero. This is a useful result concerning the behavior of polynomial orders under addition.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `poly_sum_empty`
- `poly_sum_insert`
- `poly_sum_poly`
- `poly_ord_add_ge`


---

## poly_ord_sub_ge

### Name of formal statement
poly_ord_sub_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_sub_ge = prove(`
  !p:(1->num)->complex q z n.
  ring_polynomial complex_ring p ==>
  ring_polynomial complex_ring q ==>
  (p = poly_0 complex_ring \/ n <= poly_ord p z) ==>
  (q = poly_0 complex_ring \/ n <= poly_ord q z) ==>
  (poly_sub complex_ring p q = poly_0 complex_ring \/ n <= poly_ord(poly_sub complex_ring p q) z)
`,
  rw[POLY_SUB] THEN
  qed[poly_ord_add_ge;poly_ord_neg_ge;RING_POLYNOMIAL_NEG]
);;
```
### Informal statement
For any polynomials `p` and `q` over the complex numbers, and any complex number `z` and natural number `n`, if `p` and `q` are ring polynomials, and either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`, and either `q` is the zero polynomial or `n` is less than or equal to the order of `q` at `z`, then either the polynomial `p - q` is the zero polynomial or `n` is less than or equal to the order of `p - q` at `z`.

### Informal sketch
The proof proceeds as follows:
- Rewrite the statement using the definition of `poly_sub`.
- Apply the theorem `poly_ord_add_ge` regarding the order of the sum of two polynomials, along with the theorems `poly_ord_neg_ge` and `RING_POLYNOMIAL_NEG`. These theorems establish that the order of `-q` is the same as the order of `q`, and that if `q` is a ring polynomial, then so is `-q`.

### Mathematical insight
This theorem states that if two polynomials `p` and `q` have order at least `n` at a point `z`, then their difference `p - q` also has order at least `n` at point `z`. This is a fundamental property used in reasoning about the behavior of polynomials near a given point. This result about the order of the difference of polynomials is crucial for various applications, e.g. Taylor expansions, root-finding algorithms, and other numerical or symbolic manipulations.

### Dependencies
- Definitions: `POLY_SUB`
- Theorems: `poly_ord_add_ge`, `poly_ord_neg_ge`, `RING_POLYNOMIAL_NEG`


---

## poly_ord_add_dominant

### Name of formal statement
poly_ord_add_dominant

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_add_dominant = prove(`
  !p:(1->num)->complex q z n.
  ring_polynomial complex_ring p ==>
  ring_polynomial complex_ring q ==>
  (p = poly_0 complex_ring \/ n <= poly_ord p z) ==>
  ~(q = poly_0 complex_ring) ==>
  poly_ord q z < n ==>
  ( ~(poly_add complex_ring p q = poly_0 complex_ring) /\
    poly_ord(poly_add complex_ring p q) z = poly_ord q z
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  case `poly_add complex_ring p q = poly_0 complex_ring:(1->num)->complex` THENL [
    have `ring_add(x_series complex_ring) p q = ring_0(x_series complex_ring)` [x_series_use] THEN
    have `q = ring_neg(x_series complex_ring) p` [RING_ADD_EQ_0;series_complex;x_series_use] THEN
    specialize[`p:(1->num)->complex`;`z:complex`;`n:num`]poly_ord_neg_ge THEN
    have `q = poly_0 complex_ring \/ n <= poly_ord q z` [x_series_use] THEN
    qed[ARITH_RULE `n <= d:num ==> ~(d < n)`]
  ; pass
  ] THEN
  case `poly_ord q z < poly_ord(poly_add complex_ring p q) z` THENL [
    num_linear_fact `poly_ord q z < poly_ord(poly_add complex_ring p q) z ==> 1 + poly_ord q z <= poly_ord(poly_add complex_ring p q) z` THEN
    have `ring_polynomial complex_ring (poly_add complex_ring p q:(1->num)->complex)` [RING_POLYNOMIAL_ADD] THEN
    have `poly_add complex_ring p q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord (poly_add complex_ring p q) z` [] THEN
    have `p = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord p z` [ARITH_RULE `q < n ==> n <= p ==> 1+q <= p`] THEN
    specialize[`poly_add complex_ring p q:(1->num)->complex`;`p:(1->num)->complex`;`z:complex`;`1 + poly_ord q z`]poly_ord_sub_ge THEN
    have `poly_sub complex_ring (poly_add complex_ring p q) p = q:(1->num)->complex` [x_series_use;x_series_sub_use;RING_RULE `ring_sub(r:R ring) (ring_add r p q) p = q`;series_complex] THEN
    have `q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord q z` [] THEN
    num_linear_fact `~(1 + poly_ord q z <= poly_ord q z)` THEN
    qed[]
  ; pass
  ] THEN
  num_linear_fact `~(poly_ord q z < poly_ord (poly_add complex_ring p q) z) ==> poly_ord(poly_add complex_ring p q) z <= poly_ord q z` THEN
  specialize_assuming[`poly_ord q z`;`n:num`;`poly_ord p z`]LTE_TRANS THEN
  have `p = poly_0 complex_ring \/ poly_ord q z <= poly_ord p z` [LT_IMP_LE] THEN
  have `q = poly_0 complex_ring \/ poly_ord q z <= poly_ord q z` [LE_REFL] THEN
  specialize[`p:(1->num)->complex`;`q:(1->num)->complex`;`z:complex`;`poly_ord q z`]poly_ord_add_ge THEN
  have `poly_ord q z <= poly_ord(poly_add complex_ring p q) z` [] THEN
  num_linear_fact `poly_ord (poly_add complex_ring p q) z <= poly_ord q z ==> poly_ord q z <= poly_ord(poly_add complex_ring p q) z ==> poly_ord (poly_add complex_ring p q) z = poly_ord q z` THEN
  qed[]
);;
```
### Informal statement
For all polynomials `p` and `q` from numbers to complex numbers, and for all complex numbers `z` and natural numbers `n`, if `p` and `q` are ring polynomials over the complex numbers, and either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`, and `q` is not the zero polynomial, and the order of `q` at `z` is less than `n`, then `p + q` is not the zero polynomial, and the order of `p + q` at `z` is equal to the order of `q` at `z`.

### Informal sketch
The proof proceeds by cases and contradiction to establish that if the order of `q` at `z` is strictly less than `n`, and either `p` is zero or the order of `p` at `z` is greater than or equal to `n`, then the order of `p + q` at `z` is equal to the order of `q` at `z`.

- Case 1: `poly_add complex_ring p q = poly_0 complex_ring`.
  - Derive `q = ring_neg(x_series complex_ring) p`.
  - Using `poly_ord_neg_ge`, derive a contradiction. This utilizes `RING_ADD_EQ_0`, `series_complex`, and `x_series_use`, ultimately concluding by `ARITH_RULE` and the fact that `n <= d` implies `~(d < n)`.
- Case 2: `poly_ord q z < poly_ord(poly_add complex_ring p q) z`.
  - Apply `num_linear_fact` to deduce `1 + poly_ord q z <= poly_ord(poly_add complex_ring p q) z`.
  - Using `RING_POLYNOMIAL_ADD`, show that `poly_add complex_ring p q` is a ring polynomial.
  - Derive `poly_add complex_ring p q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord (poly_add complex_ring p q) z`.
  - Derive `p = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord p z` using properties of inequalities.
  - Apply `poly_ord_sub_ge` after specialization. and use several rewriting steps involving `x_series_use`, `x_series_sub_use`, `RING_RULE`, and `series_complex` to obtain `q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord q z`.
  - Derive a contradiction by negating `1 + poly_ord q z <= poly_ord q z` using `num_linear_fact`.
- Finally use `LTE_TRANS`, `LT_IMP_LE`, `LE_REFL`, and `poly_ord_add_ge`
- Apply `num_linear_fact` to deduce `poly_ord (poly_add complex_ring p q) z = poly_ord q z`

### Mathematical insight
This theorem states that when adding two polynomials, if one polynomial's order at a point `z` is strictly less than the lower bound `n` on the other's order, then the order of the sum at `z` is the same as the smaller order. This is a key property when analyzing the behavior of polynomial sums near a specific point. This indicates the `q` is in some sense the dominant term near `z`.

### Dependencies
- `ring_polynomial`
- `complex_ring`
- `poly_0`
- `poly_ord`
- `poly_add`
- `poly_ord_neg_ge`
- `RING_POLYNOMIAL_ADD`
- `poly_ord_sub_ge`
- `LTE_TRANS`
- `poly_ord_add_ge`

Dependencies by category:
- Ring Theory: `complex_ring`, `poly_0`, `poly_add`, `RING_POLYNOMIAL_ADD`
- Polynomial Order: `poly_ord`, `poly_ord_neg_ge`, `poly_ord_sub_ge`, `poly_ord_add_ge`
- General Theorems: `LTE_TRANS`
- Type Predicates: `ring_polynomial`

### Porting notes (optional)
- Defining the `ring_polynomial` predicate might be necessary in other proof assistants if it's not a standard definition.
- The complex number library might require adjustments depending on the target system.
- The tactics used are mostly for rewriting and linear arithmetic, so they should have direct equivalents in other systems.


---

## poly_ord_sub_dominant

### Name of formal statement
poly_ord_sub_dominant

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_sub_dominant = prove(`
  !p:(1->num)->complex q z n.
  ring_polynomial complex_ring p ==>
  ring_polynomial complex_ring q ==>
  (p = poly_0 complex_ring \/ n <= poly_ord p z) ==>
  ~(q = poly_0 complex_ring) ==>
  poly_ord q z < n ==>
  ( ~(poly_sub complex_ring p q = poly_0 complex_ring) /\
    poly_ord(poly_sub complex_ring p q) z = poly_ord q z
  )
`,

  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  case `poly_sub complex_ring p q = poly_0 complex_ring:(1->num)->complex` THENL [
    have `ring_sub(x_series complex_ring) p q = ring_0(x_series complex_ring)` [x_series_sub_use;x_series_use] THEN
    have `q = p:(1->num)->complex` [RING_SUB_EQ_0;series_complex;x_series_use] THEN
    qed[ARITH_RULE `n <= d:num ==> ~(d < n)`]
  ; pass
  ] THEN
  case `poly_ord q z < poly_ord(poly_sub complex_ring p q) z` THENL [
    num_linear_fact `poly_ord q z < poly_ord(poly_sub complex_ring p q) z ==> 1 + poly_ord q z <= poly_ord(poly_sub complex_ring p q) z` THEN
    have `ring_polynomial complex_ring (poly_sub complex_ring p q:(1->num)->complex)` [RING_POLYNOMIAL_SUB] THEN
    have `poly_sub complex_ring p q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord (poly_sub complex_ring p q) z` [] THEN
    have `p = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord p z` [ARITH_RULE `q < n ==> n <= p ==> 1+q <= p`] THEN
    specialize[`p:(1->num)->complex`;`poly_sub complex_ring p q:(1->num)->complex`;`z:complex`;`1 + poly_ord q z`]poly_ord_sub_ge THEN
    have `poly_sub complex_ring p (poly_sub complex_ring p q) = q:(1->num)->complex` [x_series_use;x_series_sub_use;RING_RULE `ring_sub(r:R ring) p (ring_sub r p q) = q`;series_complex] THEN
    have `q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord q z` [] THEN
    num_linear_fact `~(1 + poly_ord q z <= poly_ord q z)` THEN
    qed[]
  ; pass
  ] THEN
  num_linear_fact `~(poly_ord q z < poly_ord (poly_sub complex_ring p q) z) ==> poly_ord(poly_sub complex_ring p q) z <= poly_ord q z` THEN
  specialize_assuming[`poly_ord q z`;`n:num`;`poly_ord p z`]LTE_TRANS THEN
  have `p = poly_0 complex_ring \/ poly_ord q z <= poly_ord p z` [LT_IMP_LE] THEN
  have `q = poly_0 complex_ring \/ poly_ord q z <= poly_ord q z` [LE_REFL] THEN
  specialize[`p:(1->num)->complex`;`q:(1->num)->complex`;`z:complex`;`poly_ord q z`]poly_ord_sub_ge THEN
  have `poly_ord q z <= poly_ord(poly_sub complex_ring p q) z` [] THEN
  num_linear_fact `poly_ord (poly_sub complex_ring p q) z <= poly_ord q z ==> poly_ord q z <= poly_ord(poly_sub complex_ring p q) z ==> poly_ord (poly_sub complex_ring p q) z = poly_ord q z` THEN
  qed[]
);;
```

### Informal statement
For any polynomials `p` and `q` over the complex numbers, and any complex number `z` and natural number `n`, if `p` and `q` are ring polynomials, and either `p` is the zero polynomial or `n` is less than or equal to the order of `p` at `z`, and `q` is not the zero polynomial, and the order of `q` at `z` is less than `n`, then the polynomial `p - q` is not the zero polynomial and the order of `p - q` at `z` is equal to the order of `q` at `z`.

### Informal sketch
The proof proceeds by cases.

- Case 1: Assume `poly_sub complex_ring p q = poly_0 complex_ring`. Then `p = q`. Using the assumptions `n <= poly_ord p z`, `poly_ord q z < n` and the equality `p = q` we can derive `poly_ord q z < poly_ord p z` and hence `n <= poly_ord q z`, a contradiction.

- Case 2: Assume `poly_ord q z < poly_ord(poly_sub complex_ring p q) z`. Then `1 + poly_ord q z <= poly_ord(poly_sub complex_ring p q) z`. Using the assumption that `p` is a polynomial, we have that `poly_sub complex_ring p q` is also a polynomial. Hence, we can deduce that `poly_sub complex_ring p q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord (poly_sub complex_ring p q) z`. Furthermore, we have `p = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord p z`. Using the rule `ring_sub(r:R ring) p (ring_sub r p q) = q` we get `poly_sub complex_ring p (poly_sub complex_ring p q) = q`. Hence, we obtain `q = poly_0 complex_ring \/ 1 + poly_ord q z <= poly_ord q z`, leading to a contradiction.

- Finally, from `~(poly_ord q z < poly_ord (poly_sub complex_ring p q) z)`, we can prove `poly_ord(poly_sub complex_ring p q) z <= poly_ord q z`. From the assumption `n <= poly_ord p z` derive `poly_ord q z <= poly_ord p z`. Using `poly_ord_sub_ge`, we get `poly_ord q z <= poly_ord(poly_sub complex_ring p q) z`. Hence, `poly_ord (poly_sub complex_ring p q) z = poly_ord q z`.

### Mathematical insight
This theorem states that if we subtract a polynomial `q` from `p`, where the order of `q` at `z` is strictly less than `n`, and `n` is less than or equal to the order of `p` at `z`, then the order of the difference `p - q` at `z` is the same as order of `q` at `z`. In other words, the lower order term `q` dominates in the subtraction.

### Dependencies
- `RING_POLYNOMIAL_SUB`
- `x_series_sub_use`
- `x_series_use`
- `RING_SUB_EQ_0`
- `series_complex`
- `poly_ord_sub_ge`
- `RING_RULE`
- `LT_IMP_LE`
- `LE_REFL`

### Porting notes (optional)
The theorem relies on the properties of ring polynomials, polynomial subtraction, and the order of a polynomial at a point. The porting effort should ensure that these concepts and their related properties are available in the target proof assistant. Specifically, `poly_ord_sub_ge` probably needs to be ported first.


---

## poly_ord_sum_dominant

### Name of formal statement
poly_ord_sum_dominant

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_sum_dominant = prove(`
  !p z n S t.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial complex_ring (p s)) ==>
  (!s:X. s IN S ==> ~(s = t) ==> (p s = poly_0 complex_ring) \/ n <= poly_ord (p s) z) ==>
  t IN S ==>
  ~(p t = poly_0 complex_ring) ==>
  poly_ord (p t) z < n ==>
  ( ring_polynomial complex_ring (poly_sum complex_ring S p) /\
    ~(poly_sum complex_ring S p = poly_0 complex_ring) /\
    poly_ord(poly_sum complex_ring S p) z = poly_ord (p t) z
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  have `poly_sum complex_ring S p = poly_add complex_ring (p(t:X)) (poly_sum complex_ring (S DELETE t) p)` [poly_sum_delete2;series_complex] THEN
  have `!s:X. s IN S DELETE t ==> s IN S` [IN_DELETE] THEN
  have `!s:X. s IN S DELETE t ==> ~(s = t)` [IN_DELETE] THEN
  subgoal `poly_sum complex_ring (S DELETE (t:X)) p = poly_0 complex_ring \/ n <= poly_ord (poly_sum complex_ring (S DELETE t) p) z` THENL [
    specialize_assuming[`p:X->((1->num)->complex)`;`z:complex`;`n:num`;`S DELETE(t:X)`]poly_ord_sum_ge THEN
    qed[FINITE_DELETE]
  ; pass
  ] THEN
  have `ring_polynomial complex_ring (p(t:X):(1->num)->complex)` [] THEN
  have `ring_polynomial complex_ring (poly_sum complex_ring (S DELETE(t:X)) p)` [poly_sum_poly;FINITE_DELETE] THEN
  specialize[
    `poly_sum complex_ring (S DELETE(t:X)) p`;
    `p(t:X):(1->num)->complex`;
    `z:complex`;`n:num`]poly_ord_add_dominant THEN
  qed[POLY_ADD_SYM;series_complex;poly_sum_poly]
);;
```
### Informal statement
For any polynomial `p` of type `X -> ((1->num)->complex)`, any complex number `z`, any natural number `n`, and any finite set `S` of type `X`, if the following conditions hold:
1. `S` is a finite set.
2. For all `s` in `S`, `p s` is a ring polynomial over the complex numbers.
3. For all `s` in `S`, if `s` is not equal to `t`, then either `p s` is the zero polynomial or `n` is less than or equal to the polynomial order of `p s` at `z`.
4. `t` is in `S`.
5. `p t` is not the zero polynomial.
6. The polynomial order of `p t` at `z` is less than `n`.

Then the following hold:
1. `poly_sum complex_ring S p` is a ring polynomial over the complex numbers.
2. `poly_sum complex_ring S p` is not the zero polynomial.
3. The polynomial order of `poly_sum complex_ring S p` at `z` is equal to the polynomial order of `p t` at `z`.

### Informal sketch
The proof proceeds by induction and algebraic manipulation.

- The main idea is to show that the polynomial order of a sum of polynomials is dominated by the term with the smallest polynomial order, provided that term's order is strictly less than `n` and other terms are either 0 or have polynomial order at least `n`.

- The proof begins by decomposing the sum `poly_sum complex_ring S p` into the sum of `p t` and `poly_sum complex_ring (S DELETE t) p` using `poly_sum_delete2`.

- It is shown using `poly_ord_sum_ge` and `FINITE_DELETE` that `poly_sum complex_ring (S DELETE t) p` is either `poly_0 complex_ring` or its polynomial order is greater than or equal to `n`.

- The theorem `poly_ord_add_dominant` is specialized, showing that the polynomial order of the sum `p t + poly_sum complex_ring (S DELETE t) p` is equal to the polynomial order of `p t` because `poly_ord (p t) z < n` and `poly_sum complex_ring (S DELETE t) p = poly_0 complex_ring \/ n <= poly_ord (poly_sum complex_ring (S DELETE t) p) z`. The theorem `POLY_ADD_SYM` is used as well, most likely to rearrange arguments to suit the form expected by `poly_ord_add_dominant`.

### Mathematical insight
This theorem essentially states that when summing polynomials, if one polynomial has a strictly smaller order than a given bound `n`, and all other polynomials are either zero or have an order at least `n`, then the order of the sum is the order of the dominant polynomial. This is important when analyzing the behavior of polynomial sums and series, especially when considering limits and asymptotic behavior.

### Dependencies
- `FINITE_DELETE`
- `IN_DELETE`
- `poly_sum_delete2`
- `series_complex`
- `poly_ord_sum_ge`
- `poly_sum_poly`
- `poly_ord_add_dominant`
- `POLY_ADD_SYM`


---

## poly_ord_derivative_ge

### Name of formal statement
poly_ord_derivative_ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_derivative_ge = prove(`
  !p:(1->num)->complex q PqpQ z.
  ring_polynomial complex_ring q ==>
  ring_polynomial complex_ring p ==>
  ~(q = poly_0 complex_ring) ==>
  (p = poly_0 complex_ring \/ poly_ord q z <= poly_ord p z) ==>
  PqpQ =
    poly_sub complex_ring (
      poly_mul complex_ring (
        x_derivative complex_ring p
      ) (
        q
      )
    ) (
      poly_mul complex_ring (
        p
      ) (
        x_derivative complex_ring q
      )
    )
  ==> (
    PqpQ = poly_0 complex_ring \/
    2 * poly_ord q z <= poly_ord PqpQ z
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  choose `f:(1->num)->complex` `ring_polynomial complex_ring f /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) f` [poly_ord_ge] THEN
  choose `g:(1->num)->complex` `ring_polynomial complex_ring g /\ q = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g` [poly_ord_exists] THEN
  specialize_assuming[`complex_ring`;`f:(1->num)->complex`;`g:(1->num)->complex`;`poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)`]x_derivative_ratio_scaling THEN
  have `poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) f)) q) (poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) f) (x_derivative complex_ring q)) = poly_mul complex_ring (poly_pow complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))` [series_complex] THEN
  simp[poly_pow_mul;series_complex] THEN
  have `ring_polynomial complex_ring (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))` [RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_SUB;x_derivative_polynomial;x_minus_const_poly;in_complex_ring] THEN
  specialize[`poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z * 2)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))`;`poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))`;`poly_ord q z * 2`]poly_ord_ge_if THEN
  qed[MULT_SYM]
);;
```

### Informal statement
For all polynomials `p` and `q` over the complex numbers (represented as functions from natural numbers to complex numbers), and for all complex numbers `z`, if `q` is a ring polynomial, `p` is a ring polynomial, `q` is not the zero polynomial, and either `p` is the zero polynomial or the order of `q` at `z` is less than or equal to the order of `p` at `z`, and `PqpQ` is defined as the polynomial obtained by subtracting  (`p` multiplied by the derivative of `q`)  from  (`(the derivative of `p`) multiplied by `q`), then either `PqpQ` is the zero polynomial or twice the order of `q` at `z` is less than or equal to the order of `PqpQ` at `z`.

### Informal sketch
*   The proof proceeds by assuming the antecedent of the main implication and aiming to establish the consequent.
*   It introduces polynomials `f` and `g` such that `ring_polynomial complex_ring f`, `p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) f` and `ring_polynomial complex_ring g`, `q = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g`. These polynomials `f` and `g` represent the parts of `p` and `q`, respectively, that do not vanish at `z`.
*   It applies the theorem `x_derivative_ratio_scaling` to relate the derivative of a scaled polynomial to the scaled derivative of the polynomial.
*   A simplification step using `poly_pow_mul` and `series_complex` helps to manipulate the polynomial expressions.
*   The `RING_POLYNOMIAL_MUL`, `RING_POLYNOMIAL_SUB`, `x_derivative_polynomial`, `x_minus_const_poly` and `in_complex_ring` are used to derive that  `ring_polynomial complex_ring (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))`.
*   Finally, the theorem `poly_ord_ge_if` is used which states that if a scaled polynomial is a polynomial, than the polynomials order corresponds to the order of the scaling exponent.

### Mathematical insight
The theorem essentially states that if `p/q` does not have a pole at `z` (i.e., the order of `p` is greater than or equal to the order of `q`), then the order of the expression `p'q - pq'` at `z` is at least twice the order of `q` at `z`, provided `p'q - pq'` is not zero.  This relates the order of the derivative of a quotient to the orders of the original polynomials. The theorem is important because it provides a relationship between the roots and poles of a rational function and its derivative.

### Dependencies
- Theorems: `poly_ord_ge`, `poly_ord_exists`, `x_derivative_ratio_scaling`,`poly_pow_mul`,`poly_ord_ge_if`
- Definitions: `complex_ring`, `poly_0`, `poly_sub`, `poly_mul`, `x_derivative`, `poly_pow`, `x_minus_const`, `poly_ord`
- Other: `RING_POLYNOMIAL_MUL`, `RING_POLYNOMIAL_SUB`, `x_derivative_polynomial`, `x_minus_const_poly`, `in_complex_ring`, `series_complex`

### Porting notes (optional)
The proof relies heavily on rewriting and simplification within the polynomial ring structure. Other proof assistants might require explicit equational reasoning or ring normalization tactics to achieve the same effect. The `choose` tactic introduces witnesses based on the existence of polynomials with specific properties. Porting this aspect might require adapting to the specific mechanism for existential instantiation in the target proof assistant. Pay special attention to how polynomial rings and their derivatives are represented in the target system, as different representations may require different proof techniques.


---

## poly_ord_derivative_pole_lemma

### Name of formal statement
poly_ord_derivative_pole_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_derivative_pole_lemma = prove(`
  !z:complex m n.
  poly_sub complex_ring (
    poly_mul complex_ring (
      x_derivative complex_ring (
        poly_pow complex_ring (
          x_minus_const complex_ring z
        ) m
      )
    ) (
      poly_pow complex_ring (
        x_minus_const complex_ring z
      ) n
    )
  ) (
    poly_mul complex_ring (
      poly_pow complex_ring (
        x_minus_const complex_ring z
      ) m
    ) (
      x_derivative complex_ring (
        poly_pow complex_ring (
          x_minus_const complex_ring z
        ) n
      )
    )
  )
  =
  poly_mul complex_ring (
    poly_sub complex_ring (
      poly_const complex_ring (ring_of_num complex_ring m)
    ) (
      poly_const complex_ring (ring_of_num complex_ring n)
    )
  ) (
    poly_pow complex_ring (
      x_minus_const complex_ring z
    ) ((m+n)-1)
  )
`,
  intro THEN
  simp[x_derivative_pow;series_complex] THEN
  recall in_complex_ring THEN
  simp[x_derivative_x_minus_const] THEN
  recall series_complex THEN
  case `m = 0` THENL [
    simp[poly_pow_0;ARITH_RULE `0 - 1 = 0`;POLY_MUL_LID;RING_OF_NUM_0;GSYM poly_0;POWSER_MUL_0;ARITH_RULE `0+n = n`] THEN
    rw[x_series_use;x_series_sub_use] THEN
    qed[RING_RULE `ring_sub(r:R ring) (ring_0 r) (ring_mul r C P) = ring_mul r (ring_sub r (ring_0 r) C) P`;x_series_use]
  ; pass
  ] THEN
  case `n = 0` THENL [
    simp[poly_pow_0;ARITH_RULE `0 - 1 = 0`;POLY_MUL_LID;RING_OF_NUM_0;GSYM poly_0;POWSER_MUL_0;ARITH_RULE `m+0 = m`] THEN
    rw[x_series_use;x_series_sub_use;RING_MUL_RID] THEN
    qed[RING_RULE `ring_sub(r:R ring) (ring_mul r (ring_mul r C P) (ring_1 r)) (ring_0 r) = ring_mul r (ring_sub r C (ring_0 r)) P`;x_series_use]
  ; pass
  ] THEN
  num_linear_fact `~(m = 0) ==> (m-1)+n = (m+n)-1` THEN
  have `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (m-1)) (poly_pow complex_ring (x_minus_const complex_ring z) (n)) = poly_pow complex_ring (x_minus_const complex_ring z) ((m+n)-1)` [poly_pow_add;series_complex] THEN
  num_linear_fact `~(n = 0) ==> m+(n-1) = (m+n)-1` THEN
  have `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (m)) (poly_pow complex_ring (x_minus_const complex_ring z) (n-1)) = poly_pow complex_ring (x_minus_const complex_ring z) ((m+n)-1)` [poly_pow_add;series_complex] THEN
  rw[x_series_use;x_series_sub_use] THEN
  specialize_assuming[
    `x_series complex_ring`
    ;`poly_const complex_ring (ring_of_num complex_ring m):(1->num)->complex`
    ;`poly_const complex_ring (ring_of_num complex_ring n):(1->num)->complex`
    ;`poly_pow complex_ring (x_minus_const complex_ring z) m`
    ;`poly_pow complex_ring (x_minus_const complex_ring z) (m-1)`
    ;`poly_pow complex_ring (x_minus_const complex_ring z) n`
    ;`poly_pow complex_ring (x_minus_const complex_ring z) (n-1)`
    ;`poly_pow complex_ring (x_minus_const complex_ring z) ((m+n)-1)`
  ](GENL[
    `r:R ring`;
    `M:R`;
    `N:R`;
    `PM:R`;
    `PM1:R`;
    `PN:R`;
    `PN1:R`;
    `PMN1:R`
  ](RING_RULE `ring_mul (r:R ring) PM PN1 = PMN1 ==> ring_mul r PM1 PN = PMN1 ==> ring_sub r (ring_mul r (ring_mul r M (ring_mul r (ring_1 r) PM1)) PN) (ring_mul r PM (ring_mul r N (ring_mul r (ring_1 r) PN1))) = ring_mul r (ring_sub r M N) PMN1`)) THEN
  have `poly_const complex_ring (ring_of_num complex_ring m) IN ring_carrier (x_series complex_ring)` [POWSER_CONST;x_series_use] THEN
  have `poly_const complex_ring (ring_of_num complex_ring n) IN ring_carrier (x_series complex_ring)` [POWSER_CONST;x_series_use] THEN
  qed[x_series_use;x_series_sub_use]
);;
```
### Informal statement
For all complex numbers `z`, natural numbers `m`, and natural numbers `n`, the difference between the polynomial obtained by first differentiating the polynomial `(x - z)^m` and then multiplying the result by the polynomial `(x - z)^n`, and the polynomial obtained by first multiplying the polynomial `(x - z)^m` by the polynomial resulting from differentiating `(x - z)^n`, is equal to the polynomial obtained by multiplying the polynomial `(m - n)` by the polynomial `(x - z)^(m+n-1)`.

### Informal sketch
The proof proceeds by induction on the complex ring structure.
- Introduce the assumptions.
- Simplify using `x_derivative_pow` and `series_complex`.
- Recall the `in_complex_ring` property.
- Simplify using `x_derivative_x_minus_const`.
- Recall `series_complex`.
- Case split on `m = 0`:
    - If `m = 0`, simplify using `poly_pow_0`, `ARITH_RULE`, `POLY_MUL_LID`, `RING_OF_NUM_0`, `GSYM poly_0`, `POWSER_MUL_0`, and `ARITH_RULE`.
    - Rewrite using `x_series_use` and `x_series_sub_use`.
    - Conclude using `RING_RULE` and `x_series_use`.
    - Otherwise, proceed.
- Case split on `n = 0`:
    - If `n = 0`, simplify using `poly_pow_0`, `ARITH_RULE`, `POLY_MUL_LID`, `RING_OF_NUM_0`, `GSYM poly_0`, `POWSER_MUL_0`, and `ARITH_RULE`.
    - Rewrite using `x_series_use`, `x_series_sub_use`, and `RING_MUL_RID`.
    - Conclude using `RING_RULE` and `x_series_use`.
    - Otherwise, proceed.
- Use `num_linear_fact` to show `~(m = 0) ==> (m-1)+n = (m+n)-1`.
- Prove that `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (m-1)) (poly_pow complex_ring (x_minus_const complex_ring z) (n)) = poly_pow complex_ring (x_minus_const complex_ring z) ((m+n)-1)` using `poly_pow_add` and `series_complex`.
- Use `num_linear_fact` to show `~(n = 0) ==> m+(n-1) = (m+n)-1`.
- Prove that `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (m)) (poly_pow complex_ring (x_minus_const complex_ring z) (n-1)) = poly_pow complex_ring (x_minus_const complex_ring z) ((m+n)-1)` using `poly_pow_add` and `series_complex`.
- Rewrite using `x_series_use` and `x_series_sub_use`.
- Specialize assuming the ring rule.
- Prove `poly_const complex_ring (ring_of_num complex_ring m) IN ring_carrier (x_series complex_ring)` using `POWSER_CONST` and `x_series_use`.
- Prove `poly_const complex_ring (ring_of_num complex_ring n) IN ring_carrier (x_series complex_ring)` using `POWSER_CONST` and `x_series_use`.
- Conclude using `x_series_use` and `x_series_sub_use`.

### Mathematical insight
This theorem expresses a relationship between the derivative of powers of `(x - z)` and polynomial multiplication and subtraction. It shows how the difference of products involving derivatives of such polynomials can be expressed as a simple multiple of another power of `(x - z)`. It is useful for simplifying expressions involving derivatives and powers of linear factors in the context of complex polynomials.

### Dependencies
- `x_derivative_pow`
- `series_complex`
- `in_complex_ring`
- `x_derivative_x_minus_const`
- `series_complex`
- `poly_pow_0`
- `POLY_MUL_LID`
- `RING_OF_NUM_0`
- `poly_0`
- `POWSER_MUL_0`
- `x_series_use`
- `x_series_sub_use`
- `poly_pow_add`
- `POWSER_CONST`

### Porting notes (optional)
The frequent use of `series_complex` suggests that the theorem relies on the HOL Light's infrastructure for handling complex power series, or at least polynomials over complex numbers. Ensure that this is set up properly, or that there is an equivalent infrastructure for polynomials in your target proof assistant.
Also, the frequent usage of `x_series_use`, `x_series_sub_use`, and other related lemmas implies simplification rules dependent on the structure of HOL Light complex polynomials. Ensure that there are equivalent simplification rules in your target proof assistant.
Take special care in porting any arithmetic tactics like `ARITH_RULE` and `num_linear_fact`. The tactic `num_linear_fact` produces a side condition that must be proved separately, so ensure this is re-proven in another proof assistant.
The proof also relies heavily on `RING_RULE` to perform rewriting on ring expressions. Make sure appropriate ring simplification tactics are available.


---

## poly_ord_derivative_pole

### Name of formal statement
poly_ord_derivative_pole

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_ord_derivative_pole = prove(`
  !p:(1->num)->complex q PqpQ z.
  ring_polynomial complex_ring q ==>
  ring_polynomial complex_ring p ==>
  ~(q = poly_0 complex_ring) ==>
  ~(p = poly_0 complex_ring) ==>
  poly_ord p z < poly_ord q z ==>
  PqpQ =
    poly_sub complex_ring (
      poly_mul complex_ring (
        x_derivative complex_ring p
      ) (
        q
      )
    ) (
      poly_mul complex_ring (
        p
      ) (
        x_derivative complex_ring q
      )
    )
  ==> (
    ring_polynomial complex_ring PqpQ /\
    ~(PqpQ = poly_0 complex_ring) /\
    poly_ord PqpQ z = (poly_ord p z + poly_ord q z) - 1
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  choose `f:(1->num)->complex` `ring_polynomial complex_ring f /\ ~complex_root f z /\ p = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f` [poly_ord_exists] THEN
  choose `g:(1->num)->complex` `ring_polynomial complex_ring g /\ ~complex_root g z /\ q = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g` [poly_ord_exists] THEN
  subgoal `PqpQ = ring_sub (x_poly complex_ring) (ring_mul (x_poly complex_ring) (x_derivative complex_ring p) q) (ring_mul (x_poly complex_ring) p (x_derivative complex_ring q))` THENL [
   qed[x_poly_use;x_poly_sub_use]
  ; pass
  ] THEN
  subgoal `PqpQ = poly_add complex_ring (poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) (poly_mul complex_ring (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z))) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))))) (poly_mul complex_ring f g))` THENL [
    have `x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) IN ring_carrier (x_poly complex_ring)` [x_poly_use;x_derivative_polynomial;poly_pow_poly;x_minus_const_poly;in_complex_ring] THEN
    have `x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) IN ring_carrier (x_poly complex_ring)` [x_poly_use;x_derivative_polynomial;poly_pow_poly;x_minus_const_poly;in_complex_ring] THEN
    have `x_derivative complex_ring f IN ring_carrier (x_poly complex_ring)` [x_poly_use;x_derivative_polynomial] THEN
    have `x_derivative complex_ring g IN ring_carrier (x_poly complex_ring)` [x_poly_use;x_derivative_polynomial] THEN
    have `x_derivative complex_ring p IN ring_carrier (x_poly complex_ring)` [x_poly_use;x_derivative_polynomial] THEN
    have `x_derivative complex_ring q IN ring_carrier (x_poly complex_ring)` [x_poly_use;x_derivative_polynomial] THEN
    have `poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z) IN ring_carrier (x_poly complex_ring)` [x_poly_use;poly_pow_poly;x_minus_const_poly;in_complex_ring] THEN
    have `poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z) IN ring_carrier (x_poly complex_ring)` [x_poly_use;poly_pow_poly;x_minus_const_poly;in_complex_ring] THEN
    have `f IN ring_carrier (x_poly complex_ring)` [x_poly_use] THEN
    have `g IN ring_carrier (x_poly complex_ring)` [x_poly_use] THEN
    have `p IN ring_carrier (x_poly complex_ring)` [x_poly_use] THEN
    have `q IN ring_carrier (x_poly complex_ring)` [x_poly_use] THEN
    have `p = ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) f` [x_poly_use] THEN
    have `q = ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) g` [x_poly_use] THEN
    subgoal `x_derivative complex_ring p = ring_add (x_poly complex_ring) (ring_mul (x_poly complex_ring) (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z))) f) (ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (x_derivative complex_ring f))` THENL [
      rw[GSYM x_poly_use] THEN
      rw[GSYM x_poly_sub_use] THEN
      qed[x_derivative_mul;series_complex]
    ; pass
    ] THEN
    subgoal `x_derivative complex_ring q = ring_add (x_poly complex_ring) (ring_mul (x_poly complex_ring) (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) g) (ring_mul (x_poly complex_ring) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) (x_derivative complex_ring g))` THENL [
      rw[GSYM x_poly_use] THEN
      rw[GSYM x_poly_sub_use] THEN
      qed[x_derivative_mul;series_complex]
    ; pass
    ] THEN
    specialize[
      `x_poly complex_ring`
      ;`x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z))`
      ;`x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))`
      ;`x_derivative complex_ring f`
      ;`x_derivative complex_ring g`
      ;`x_derivative complex_ring p`
      ;`x_derivative complex_ring q`
      ;`(poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z))`
      ;`(poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))`
      ;`f:(1->num)->complex`
      ;`g:(1->num)->complex`
      ;`p:(1->num)->complex`
      ;`q:(1->num)->complex`
    ](GENL [
      `r:R ring`;`D:R`;`E:R`;`FF:R`;`G:R`;`P:R`;`Q:R`;`d:R`;`e:R`;`f:R`;`g:R`;`p:R`;`q:R`
    ](RING_RULE `
      p = ring_mul(r:R ring) d f ==>
      q = ring_mul r e g ==>
      P = ring_add r (ring_mul r D f) (ring_mul r d FF) ==>
      Q = ring_add r (ring_mul r E g) (ring_mul r e G) ==>
      ring_sub r (ring_mul r P q) (ring_mul r p Q)
      = ring_add r
        (ring_mul r (ring_mul r d e) (ring_sub r (ring_mul r FF g) (ring_mul r f G)))
        (ring_mul r (ring_sub r (ring_mul r D e) (ring_mul r d E)) (ring_mul r f g))
    `)) THEN
    rw[x_poly_use;x_poly_sub_use] THEN
    qed[]
  ; pass
  ] THEN
  have `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)) = poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)` [poly_pow_add;series_complex] THEN
  have `PqpQ = poly_add complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) (poly_mul complex_ring (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z))) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))))) (poly_mul complex_ring f g))` [] THEN
  have `poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z))) (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z))) (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z)) (x_derivative complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord q z)))) = poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))` [poly_ord_derivative_pole_lemma] THEN
  have `PqpQ = poly_add complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) (poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g))` [] THEN
  subgoal `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) = poly_0 complex_ring \/ poly_ord p z + poly_ord q z <= poly_ord(poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) z` THENL [
    specialize_assuming[`poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))`;`poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))`;`poly_ord p z + poly_ord q z`]poly_ord_ge_if THEN
    qed[x_derivative_polynomial;RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_SUB]
  ; pass
  ] THEN
  subgoal `~(poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g) = poly_0 complex_ring) /\ poly_ord(poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g)) z = (poly_ord p z + poly_ord q z) - 1` THENL [
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g))` [RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_CONST;poly_pow_poly;x_minus_const_poly;in_complex_ring] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_mul complex_ring f g:(1->num)->complex))` [RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_CONST;in_complex_ring] THEN
    subgoal `~complex_root (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_mul complex_ring f g)) z` THENL [
      rw[complex_root] THEN
      simp[POLY_EVAL_MUL;POLY_EVAL_SUB;POLY_EVAL_CONST;in_complex_ring;RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_CONST] THEN
      recall integral_domain_complex THEN
      have `~(poly_eval complex_ring f z = Cx(&0))` [complex_root] THEN
      have `~(poly_eval complex_ring g z = Cx(&0))` [complex_root] THEN
      have `~(ring_mul complex_ring (poly_eval complex_ring f z) (poly_eval complex_ring g z) = Cx(&0))` [complex_ring_clauses;COMPLEX_ENTIRE] THEN
      num_linear_fact `poly_ord p z < poly_ord q z ==> ~(poly_ord p z = poly_ord q z)` THEN
      have `~(ring_of_num complex_ring (poly_ord p z) = ring_of_num complex_ring (poly_ord q z))` [ring_of_num_injective;ring_char_complex] THEN
      complex_field_fact `~(ring_of_num complex_ring (poly_ord p z) = ring_of_num complex_ring (poly_ord q z)) ==> ~(ring_of_num complex_ring (poly_ord p z) - ring_of_num complex_ring (poly_ord q z) = Cx(&0))` THEN
      have `~(ring_sub complex_ring (ring_of_num complex_ring (poly_ord p z)) (ring_of_num complex_ring (poly_ord q z)) = Cx(&0))` [ring_sub_complex] THEN
      qed[complex_ring_clauses;COMPLEX_ENTIRE]
    ; pass
    ] THEN
    subgoal `poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g) = poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1)) (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_mul complex_ring f g))` THENL [
      rw[x_series_use;x_series_sub_use] THEN
      qed[x_series_use;series_complex;RING_RULE `ring_mul(r:R ring) (ring_mul r (ring_sub r P Q) MN1) (ring_mul r f g) = ring_mul r MN1 (ring_mul r (ring_sub r P Q) (ring_mul r f g))`]
    ; pass
    ] THEN
    specialize[`poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g)`;`poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_mul complex_ring f g:(1->num)->complex)`;`(poly_ord p z + poly_ord q z) - 1`]poly_ord_unique THEN
    qed[]
  ; pass
  ] THEN
  num_linear_fact `poly_ord p z < poly_ord q z ==> (poly_ord p z + poly_ord q z) - 1 < poly_ord p z + poly_ord q z` THEN
  have `poly_ord (poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g)) z < poly_ord p z + poly_ord q z` [] THEN
  recall in_complex_ring THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z))` [poly_pow_poly;x_minus_const_poly] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g)` [RING_POLYNOMIAL_MUL;x_derivative_polynomial] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))))` [RING_POLYNOMIAL_MUL;poly_pow_poly;x_minus_const_poly;RING_POLYNOMIAL_SUB;x_derivative_polynomial] THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))` [poly_pow_poly;x_minus_const_poly] THEN
  have `ring_polynomial complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)):(1->num)->complex))` [RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_CONST] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g))` [RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_CONST;x_minus_const_poly;poly_pow_poly] THEN
  have `~(poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g) = poly_0 complex_ring)` [] THEN
  specialize[
    `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))`;
    `poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g)`;
    `z:complex`;
    `poly_ord p z + poly_ord q z`
  ]poly_ord_add_dominant THEN
  subgoal `ring_polynomial complex_ring (PqpQ:(1->num)->complex)` THENL [
    simp[] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (x_derivative complex_ring p) q)` [RING_POLYNOMIAL_MUL;x_derivative_polynomial] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring p (x_derivative complex_ring q))` [RING_POLYNOMIAL_MUL;x_derivative_polynomial] THEN
    qed[RING_POLYNOMIAL_SUB]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For any polynomials `p` and `q` over the complex numbers, and any complex number `z`, if `q` is a non-zero polynomial, `p` is a non-zero polynomial, and the order of `p` at `z` is less than the order of `q` at `z`, and if `PqpQ` is defined as the polynomial obtained by subtracting `p * (derivative of q)` from `(derivative of p) * q`, then `PqpQ` is a polynomial, `PqpQ` is a non-zero polynomial, and the order of `PqpQ` at `z` is equal to `(order of p at z + order of q at z) - 1`.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` and `q` are polynomials, `q` and `p` are non-zero, and `poly_ord p z < poly_ord q z`. Define `PqpQ` as specified in the theorem.
- Decompose `p` and `q` into `p = (x - z)^(ord_p) * f` and `q = (x - z)^(ord_q) * g`, where `ord_p = poly_ord p z`, `ord_q = poly_ord q z`, and `f` and `g` are polynomials such that `f(z) != 0` and `g(z) != 0`. This uses `poly_ord_exists`.
- Show that `PqpQ` can be rewritten in terms of `f`, `g`, their derivatives, and powers of `(x - z)`.
- Use `poly_ord_derivative_pole_lemma` to simplify the expression for `PqpQ` further. This lemma essentially provides a formula for differentiating `(x-z)^n`.
- Show that `poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) = poly_0 complex_ring \/ poly_ord p z + poly_ord q z <= poly_ord(poly_mul complex_ring (poly_pow complex_ring (x_minus_const complex_ring z) (poly_ord p z + poly_ord q z)) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) z`, which uses `poly_ord_ge_if`.
- Prove that `~(poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g) = poly_0 complex_ring) /\ poly_ord(poly_mul complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_const complex_ring (ring_of_num complex_ring (poly_ord p z))) (poly_const complex_ring (ring_of_num complex_ring (poly_ord q z)))) (poly_pow complex_ring (x_minus_const complex_ring z) ((poly_ord p z + poly_ord q z) - 1))) (poly_mul complex_ring f g)) z = (poly_ord p z + poly_ord q z) - 1`, which uses `poly_ord_unique`.
- Show that `poly_ord_add_dominant` is applicable, and then complete the proof which demonstrates `ring_polynomial complex_ring (PqpQ:(1->num)->complex)`.

### Mathematical insight
This theorem describes how the order of a pole changes when taking the derivative of a quotient `p/q`. Informally, if `p` has a zero of order smaller than the order of `q` at `z`, then `p/q` has a pole, and the derivative of `p/q` has a pole of order one greater than the original pole. The theorem formulates the order of the numerator of the derivative.

### Dependencies
- Definitions: `poly_0`, `poly_mul`, `poly_sub`, `x_derivative`, `poly_ord`, `poly_pow`,`x_minus_const`
- Theorems: `poly_ord_exists`, `poly_ord_derivative_pole_lemma`, `poly_ord_ge_if`, `poly_ord_unique`, `poly_ord_add_dominant`

### Porting notes (optional)
- The `choose` tactics rely on the `poly_ord_exists` theorem, which may need to be reconstructed depending on available libraries or automation in the target proof assistant.
- Libraries for polynomials and their formal derivatives are needed, and theorems characterizing the order of roots/poles.
- Simplification is done using `RING_RULE`; ensure availability of comparable ring tactics in the target assistant.


---

## ord_minpoly

### Name of formal statement
ord_minpoly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ord_minpoly = prove(`
  !P q y.
  FINITE P ==>
  distinct_minpolys P ==>
  q IN P ==>
  poly_ord q y = (if complex_root q y then 1 else 0)
`,
  intro THEN
  subgoal `poly_product complex_ring (complex_root q) (\z. x_minus_const complex_ring (I z)) = q` THENL [
    rw[GSYM monic_vanishing_at] THEN
    qed[distinct_minpolys_monic_vanishing_at]
  ; pass
  ] THEN
  have `FINITE(complex_root q)` [distinct_minpolys_finite_root] THEN
  subgoal `poly_ord (poly_product complex_ring (complex_root q) (\z. x_minus_const complex_ring (I z))) y = nsum (complex_root q) (\s. poly_ord (x_minus_const complex_ring (I s)) y)` THENL [
    have `!z. z IN complex_root q ==> ring_polynomial complex_ring (x_minus_const complex_ring (I z))` [x_minus_const_poly;in_complex_ring] THEN
    have `!z. z IN complex_root q ==> ~(x_minus_const complex_ring (I z) = poly_0 complex_ring)` [x_minus_const_nonzero;ring_1_0_complex;in_complex_ring] THEN
    specialize[
      `\z. x_minus_const complex_ring (I z)`;
      `y:complex`;
      `complex_root q`
    ]poly_ord_product THEN
    qed[]
  ; pass
  ] THEN
  subgoal `nsum (complex_root q) (\s. poly_ord (x_minus_const complex_ring (I s)) y) = nsum (complex_root q) (\z. if z = y then 1 else 0)` THENL [
    sufficesby NSUM_EQ THEN
    rw[BETA_THM;I_THM] THEN
    qed[poly_ord_x_minus_const;x_minus_const_poly;in_complex_ring;x_minus_const_nonzero;ring_1_0_complex]
  ; pass
  ] THEN
  have `poly_ord q y = nsum (complex_root q) (\s. poly_ord (x_minus_const complex_ring (I s)) y)` [] THEN
  have `poly_ord q y = nsum (complex_root q) (\s. if s = y then 1 else 0)` [] THEN
  specialize[
    `complex_root q`;
    `y:complex`;
    `1`
  ]nsum_delta THEN
  qed[IN]
);;
```
### Informal statement
For any finite set of polynomials `P`, if the polynomials in `P` are distinct minimal polynomials, and `q` is a polynomial in `P`, then the order of `q` at `y` is 1 if `y` is a complex root of `q`, and 0 otherwise.

### Informal sketch
The proof proceeds by showing that under the assumptions:

- Establishing the equivalent representation of `q` as a product of linear factors `x_minus_const complex_ring (I z)` over its complex roots using `monic_vanishing_at` and `distinct_minpolys_monic_vanishing_at`.
- Proving that the order of the polynomial `q` at `y` is equal to the sum of the orders of the factors `x_minus_const complex_ring (I s)` at `y`. This uses the theorem `poly_ord_product`. To apply this theorem, certain conditions must be met, namely each factor needs to be a polynomial (`x_minus_const_poly`, `in_complex_ring`) and non-zero (`x_minus_const_nonzero`, `ring_1_0_complex`, `in_complex_ring`).
- Simplifying the sum of orders by showing that the order of `x_minus_const complex_ring (I s)` at `y` is 1 if `s = y` and 0 otherwise, using `poly_ord_x_minus_const`, `x_minus_const_poly`, `in_complex_ring`, `x_minus_const_nonzero`, and `ring_1_0_complex`. This step essentially reduces the problem to counting the number of complex roots `s` that are equal to `y`.
- Applying `nsum_delta` to reduce the summation to a conditional that checks if `y` is in the set of roots of `q`, resulting to desired the equivalence. From there we obtain the desired result.

### Mathematical insight
This theorem relates the order of a minimal polynomial at a point to whether that point is a root of the polynomial. Since minimal polynomials are irreducible, a root can only have an order of 1. The theorem essentially formalizes the idea that a minimal polynomial vanishes to order 1 at each of its roots and to order 0 at all other points. The `distinct_minpolys` condition is required so the constituent polynomials have no common factors, so the product's roots and multiplicities accurately reflect each distinct factor's roots.

### Dependencies
- `monic_vanishing_at`
- `distinct_minpolys_finite_root`
- `x_minus_const_poly`
- `in_complex_ring`
- `x_minus_const_nonzero`
- `ring_1_0_complex`
- `poly_ord_product`
- `poly_ord_x_minus_const`
- `nsum_delta`
- `distinct_minpolys_monic_vanishing_at`


---

## ord_pow_minpoly

### Name of formal statement
ord_pow_minpoly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ord_pow_minpoly = prove(`
  !P q y n.
  FINITE P ==>
  distinct_minpolys P ==>
  q IN P ==>
  poly_ord (poly_pow QinC_ring q n) y
  = (if complex_root q y then n else 0)
`,
  intro THEN
  have `ring_polynomial complex_ring (q:(1->num)->complex)` [distinct_minpolys;poly_complex_if_poly_QinC] THEN
  have `~((q:(1->num)->complex) = poly_0 complex_ring)` [distinct_minpolys_nonzero;poly_0_QinC_eq_poly_0_complex] THEN
  specialize[
    `q:(1->num)->complex`;
    `n:num`;
    `y:complex`
  ]poly_ord_pow THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `q:(1->num)->complex`;
    `y:complex`
  ]ord_minpoly THEN
  have `n * poly_ord q y = (if complex_root q y then n else 0)` [ARITH_RULE `n * 1 = n`;ARITH_RULE `n * 0 = 0`] THEN
  have `poly_pow complex_ring q n = poly_pow QinC_ring q n:(1->num)->complex` [poly_pow_subring;subring_complex_QinC;ring_polynomial;distinct_minpolys] THEN
  qed[]
);;
```

### Informal statement
For all sets of polynomials `P`, polynomials `q`, complex numbers `y`, and natural numbers `n`, if `P` is finite and consists of distinct minimal polynomials, and `q` is in `P`, then the `poly_ord` of `poly_pow` of `q` raised to the power of `n` (in `QinC_ring`) evaluated at `y` is equal to `n` if `y` is a complex root of `q`, and `0` otherwise.

### Informal sketch
The proof proceeds as follows:
- We start by introducing the assumptions.
- We establish `ring_polynomial complex_ring (q:(1->num)->complex)` from the hypothesis `distinct_minpolys P` by using `poly_complex_if_poly_QinC`.
- We prove that `q` is not the zero polynomial in `complex_ring` from the hypothesis `distinct_minpolys P` by using `distinct_minpolys_nonzero` and `poly_0_QinC_eq_poly_0_complex`.
- We specialize the theorem `poly_ord_pow` with `q`, `n`, and `y`.
- We specialize the theorem `ord_minpoly` with `P`, `q`, and `y`.
- We use arithmetic reasoning (`ARITH_RULE`) to simplify the expression `n * poly_ord q y`, reducing it to `n` when `complex_root q y` is true (i.e., `poly_ord q y = 1`), and to `0` when `complex_root q y` is false (i.e., `poly_ord q y = 0`).
- We show that `poly_pow complex_ring q n` equals `poly_pow QinC_ring q n` by using `poly_pow_subring`, `subring_complex_QinC`, `ring_polynomial` and `distinct_minpolys`.
- Finally, the theorem is proven by combining the previous results.

### Mathematical insight
This theorem relates the order of a polynomial `q` in a set of minimal polynomials `P` to the order of a power of that polynomial. It shows how the `poly_ord` function interacts with polynomial exponentiation, specifically within the context of finite sets of distinct minimal polynomials. The statement essentially says that raising a polynomial to the `n`-th power scales its `poly_ord` value by `n` only if `y` remains a complex root of the original polynomial .

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `complex_root`
- `poly_ord`
- `QinC_ring`
- `poly_pow`
- `poly_complex_if_poly_QinC`
- `distinct_minpolys_nonzero`
- `poly_0_QinC_eq_poly_0_complex`
- `poly_ord_pow`
- `ord_minpoly`
- `poly_pow_subring`
- `subring_complex_QinC`
- `ring_polynomial`


---

## ord_product_distinct_minpolys

### Name of formal statement
ord_product_distinct_minpolys

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ord_product_distinct_minpolys = prove(`
  !P e z.
  FINITE P ==>
  distinct_minpolys P ==>
  poly_ord (poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))) z
  = nsum P (\p. if complex_root p z then e p else 0)
`,
  intro THEN
  subgoal `poly_ord (poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))) z = nsum P (\p. poly_ord (poly_pow QinC_ring p (e p)) z)` THENL [
    subgoal `!p:(1->num)->complex. p IN P ==> ring_polynomial complex_ring (poly_pow QinC_ring p (e p))` THENL [
      intro THEN
      have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
      have `ring_polynomial QinC_ring (poly_pow QinC_ring (p:(1->num)->complex) (e p))` [poly_pow_poly] THEN
      qed[poly_complex_if_poly_QinC]
    ; pass
    ] THEN
    subgoal `!p:(1->num)->complex. p IN P ==> ~(poly_pow QinC_ring p (e p) = poly_0 complex_ring)` THENL [
      intro THEN
      have `~(p:(1->num)->complex = poly_0 QinC_ring)` [distinct_minpolys_nonzero] THEN
      have `~(poly_pow QinC_ring (p:(1->num)->complex) (e p) = poly_0 QinC_ring)` [nonzero_poly_pow;integral_domain_QinC;ring_polynomial;distinct_minpolys] THEN
      qed[poly_0_QinC_eq_poly_0_complex]
    ; pass
    ] THEN
    specialize[
      `\p:(1->num)->complex. poly_pow QinC_ring p (e p)`;
      `z:complex`;
      `P:((1->num)->complex)->bool`
    ]poly_ord_product THEN
    specialize_assuming[
      `complex_ring`;
      `QinC`;
      `\p:(1->num)->complex. poly_pow QinC_ring p (e p)`;
      `P:((1->num)->complex)->bool`
    ]poly_product_subring THEN
    qed[ring_polynomial;distinct_minpolys;subring_complex_QinC;poly_pow_poly]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby NSUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `x:(1->num)->complex`;
    `z:complex`;
    `e(x:(1->num)->complex):num`
  ]ord_pow_minpoly THEN
  qed[]
);;
```
### Informal statement
For any set `P` of functions from a type to the natural numbers to the complex numbers, any function `e` from a type to the natural numbers to the natural numbers, and any complex number `z`, if `P` is finite and contains only distinct minimal polynomials, then the order of the polynomial obtained by multiplying the elements of `P`, where each element `p` is raised to the power `e p`, evaluated at `z`, is equal to the sum over `P` of the values that are `e p` if `p` has `z` as a complex root, and `0` otherwise.

### Informal sketch
The proof proceeds by induction and simplification.

- First, show that `poly_ord (poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))) z = nsum P (\p. poly_ord (poly_pow QinC_ring p (e p)) z)`.
  - The goal is achieved using `poly_ord_product`, but some conditions of `poly_ord_product` and `poly_product_subring` must be satisfied.
  - Show `ring_polynomial complex_ring (poly_pow QinC_ring p (e p))` using `poly_pow_poly` and `poly_complex_if_poly_QinC`. The assumption `distinct_minpolys P` is used.
  - Show `~(poly_pow QinC_ring p (e p) = poly_0 complex_ring)` using `distinct_minpolys_nonzero`, `nonzero_poly_pow`, `integral_domain_QinC`, `ring_polynomial`, `distinct_minpolys`, and `poly_0_QinC_eq_poly_0_complex`.
  - Show `subring complex_ring QinC` using `subring_complex_QinC`.
- Simplify using `simp[]`.
- The proof is completed by using `NSUM_EQ`, rewriting with `BETA_THM`, introducing assumptions, specializing `ord_pow_minpoly`, and discharging the remaining goal.

### Mathematical insight
This theorem relates the order of a product of powers of minimal polynomials to the sum of the exponents of those polynomials that have a common root. It leverages the properties of minimal polynomials and their roots. This is important in algebraic number theory and field theory, as it allows us to determine multiplicities of roots for polynomials constructed from minimal polynomials.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `poly_ord`
- `poly_product`
- `QinC_ring`
- `poly_pow`
- `nsum`
- `complex_root`
- `intro`
- `specialize`
- `ring_polynomial`
- `complex_ring`
- `distinct_minpolys`
- `poly_pow_poly`
- `poly_complex_if_poly_QinC`
- `distinct_minpolys_nonzero`
- `nonzero_poly_pow`
- `integral_domain_QinC`
- `poly_0_QinC_eq_poly_0_complex`
- `subring_complex_QinC`
- `simp[]`
- `NSUM_EQ`
- `BETA_THM`
- `ord_pow_minpoly`


---

## ord_product_distinct_minpolys_root

### Name of formal statement
ord_product_distinct_minpolys_root

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ord_product_distinct_minpolys_root = prove(`
  !P q e z.
  FINITE P ==>
  distinct_minpolys P ==>
  q IN P ==>
  complex_root q z ==>
  poly_ord (poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))) z
  = e q
`,
  intro THEN
  simp[ord_product_distinct_minpolys] THEN
  subgoal `nsum P (\p. if complex_root p z then e p else 0) = nsum P (\p. if p = q then e q else 0)` THENL [
    sufficesby NSUM_EQ THEN
    rw[BETA_THM] THEN
    intro THEN
    qed[distinct_minpolys_distinct_roots]
  ; pass
  ] THEN
  subgoal `nsum P (\p:(1->num)->complex. if p = q then e q else 0) = e q` THENL [
    specialize[
      `P:((1->num)->complex)->bool`;
      `q:(1->num)->complex`;
      `e(q:(1->num)->complex):num`
    ]nsum_delta THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For all `P`, `q`, `e`, and `z`, if `P` is a finite set of polynomials, and `P` contains only distinct minimal polynomials, and `q` is in `P`, and `z` is a complex root of `q`, then the order to which `z` is a root of the polynomial given by the product of the polynomials in P, where each polynomial `p` is raised to the power `e p`, is equal to `e q`.

### Informal sketch
The proof proceeds by induction and simplification, using the theorem `ord_product_distinct_minpolys`. It aims to show that the root order of the product of polynomials in `P` (where each polynomial `p` is raised to the power `e p`) at a complex number `z` is equal to `e q`, given that `q` is a minimal polynomial in `P` and `z` is a root of `q`.
- First, simplify using `ord_product_distinct_minpolys`.

- The goal is reduced to showing that the sum, over all `p` in `P`, of `e p` if `z` is a root of `p` else 0, is equal to the sum, over all `p` in `P`, of `e q` if `p` is `q` else 0. To prove this, demonstrate that this equality holds by showing that if `complex_root p z`, then `p = q`, which is based on the fact that minimal polynomials are unique. (`distinct_minpolys_distinct_roots`)

- The next goal is to show `nsum P (\p:(1->num)->complex. if p = q then e q else 0) = e q`. This goal is proved by specializing the theorem `nsum_delta` showing that `nsum` over a set of an expression that is zero everywhere except at a single point can be simplified to just the value at that point.

### Mathematical insight
This theorem demonstrates that when taking a product of distinct minimal polynomials each raised to some power, where `z` is a root of one of those minimal polynomials `q`, the order of `z` as a root of the overall product is determined solely by the power to which `q` is raised. This makes sense because the other minimal polynomials in the product, which `z` is not a root of, dont affect the order of `z` when the polys are multiplied, i.e. the order is zero at those polys.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `complex_root`
- `poly_ord`
- `poly_product`
- `QinC_ring`
- `poly_pow`
- `ord_product_distinct_minpolys`
- `NSUM_EQ`
- `BETA_THM`
- `distinct_minpolys_distinct_roots`
- `nsum_delta`

### Porting notes (optional)
- The theorem relies heavily on the properties of sums over finite sets (nsums). Ensure that the target proof assistant has comparable infrastructure for finite sums.
- The handling of polynomials and roots may differ. Pay attention to the definitions of `poly_ord` and `complex_root` and ensure that the corresponding concepts are adequately represented in the target system.


---

## sum_root_decomposition_if_monic_vanishing_at_factorization_lemma

### Name of formal statement
sum_root_decomposition_if_monic_vanishing_at_factorization_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let sum_root_decomposition_if_monic_vanishing_at_factorization_lemma = prove(`
  !P:((1->num)->complex)->bool S:X->bool e:((1->num)->complex)->num c:X->complex g:complex->complex.
  FINITE P ==>
  distinct_minpolys P ==>
  FINITE S ==>
  (!p. p IN P ==> ~(e p = 0)) ==>
  poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))
  = monic_vanishing_at complex_ring S c ==>
  ring_sum complex_ring P (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g) =
  ring_sum complex_ring S (g o c)
`,
  intro THEN
  subgoal `!z:complex. nsum P (\p. if complex_root p z then e p else 0) = numpreimages c (S:X->bool) z` THENL [
    intro THEN
    specialize[
      `P:((1->num)->complex)->bool`;
      `e:((1->num)->complex)->num`;
      `z:complex`
    ]ord_product_distinct_minpolys THEN
    specialize[
      `S:X->bool`;
      `c:X->complex`;
      `z:complex`
    ]poly_ord_monic_vanishing_at_numpreimages THEN
    qed[]
  ; pass
  ] THEN
  have `!y:complex. y IN IMAGE (c:X->complex) S ==> g y IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[
    `complex_ring`;
    `S:X->bool`;
    `c:X->complex`;
    `g:complex->complex`
  ]ring_sum_o_v2 THEN
  simp[] THEN
  subgoal `ring_sum complex_ring P (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g) = ring_sum complex_ring P (\p. ring_sum complex_ring {y | ~(numpreimages c (S:X->bool) y = 0)} (\y. if y IN complex_root p then Cx(&(e p)) * g y else Cx(&0)))` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM] THEN
    intro THEN
    have `FINITE(complex_root a)` [distinct_minpolys_finite_root] THEN
    simp[GSYM vsum_ring_sum_complex] THEN
    simp[GSYM VSUM_COMPLEX_LMUL] THEN
    simp[vsum_ring_sum_complex] THEN
    subgoal `complex_root a SUBSET {y | ~(numpreimages c (S:X->bool) y = 0)}` THENL [
      rw[SUBSET;IN_ELIM_THM] THEN
      intro THEN
      have `(if complex_root a x then e a else 0) <= nsum P (\p. if complex_root p x then e p else 0)` [term_le_nsum] THEN
      have `e a <= nsum P (\p. if complex_root p x then e p else 0)` [IN] THEN
      have `e(a:(1->num)->complex) <= numpreimages c (S:X->bool) (x:complex)` [] THEN
      have `~(e(a:(1->num)->complex) = 0)` [] THEN
      ASM_ARITH_TAC
    ; pass
    ] THEN
    specialize[
      `complex_ring`;
      `complex_root a`;
      `{y:complex | ~(numpreimages c (S:X->bool) y = 0)}`;
      `\y:complex. ring_mul complex_ring (Cx(&(e(a:(1->num)->complex)))) (g y)`
    ]ring_sum_restrict_subset THEN
    rw[GSYM complex_ring_clauses] THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  simp[GSYM image_numpreimages] THEN
  have `FINITE(IMAGE (c:X->complex) S)` [FINITE_IMAGE] THEN
  have `!i j. i IN P ==> j IN IMAGE c (S:X->bool) ==> (if j IN complex_root i then Cx (&(e i)) * g j else Cx (&0)) IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[
    `complex_ring`;
    `\p y. if y IN complex_root p then Cx(&(e p)) * g y else Cx(&0)`;
    `P:((1->num)->complex)->bool`;
    `IMAGE (c:X->complex) S`
  ]RING_SUM_SWAP THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[in_image_vw] THEN
  intro THEN
  case `!q:(1->num)->complex. q IN P ==> ~complex_root q a` THENL [
    subgoal `nsum P (\p. if complex_root p a then e p else 0) = nsum P (\p. 0)` THENL [
      sufficesby NSUM_EQ THEN
      qed[]
    ; pass
    ] THEN
    have `nsum P (\p:(1->num)->complex. 0) = 0` [NSUM_0] THEN
    have `numpreimages (c:X->complex) S a = 0` [] THEN
    have `CARD {x:X | x IN S /\ c x = a:complex} = 0` [numpreimages] THEN
    specialize[`S:X->bool`;`\x:X. c x = a:complex`]FINITE_RESTRICT THEN
    have `{x:X | x IN S /\ c x = a:complex} = {}` [CARD_EQ_0] THEN
    ASM SET_TAC[]
  ; pass
  ] THEN
  choose `q:((1->num)->complex)` `(q:(1->num)->complex) IN P /\ complex_root q a` [] THEN
  subgoal `ring_sum complex_ring P (\p. if a IN complex_root p then Cx (&(e p)) * g a else Cx (&0)) = ring_sum complex_ring P (\p. if p = q then Cx(&(e q)) * g a else Cx(&0))` THENL [
    sufficesby RING_SUM_EQ THEN
    qed[distinct_minpolys_distinct_roots;IN]
  ; pass
  ] THEN
  simp[] THEN
  rw[GSYM complex_ring_clauses] THEN
  simp[RING_SUM_DELTA] THEN
  rw[in_complex_ring] THEN
  rw[ring_of_num_complex;complex_of_num] THEN
  subgoal `e(q:(1->num)->complex) = numpreimages c S (c(v:X):complex)` THENL [
    rw[GSYM(know `!z. nsum P (\p. if complex_root p z then e p else 0) = numpreimages (c:X->complex) S z`)] THEN
    subgoal `nsum P (\p. if complex_root p (c(v:X)) then e p else 0) = nsum P (\p. if p = q then e q else 0)` THENL [
      sufficesby NSUM_EQ THEN
      qed[distinct_minpolys_distinct_roots]
    ; pass
    ] THEN
    simp[] THEN
    simp[NSUM_DELTA]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For any predicate `P` on polynomials from natural numbers to complex numbers, any predicate `S` on a type `X`, any function `e` mapping polynomials from natural numbers to complex numbers to numbers, any function `c` from `X` to complex numbers, and any function `g` from complex numbers to complex numbers, if `P` is finite, `P` contains only distinct minimal polynomials, `S` is finite, the image of `e` contains no zero, and the polynomial `poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))` equals `monic_vanishing_at complex_ring S c`, then the ring sum over `P` of the function mapping `p` to `Cx (&(e p)) * ring_sum complex_ring (complex_root p) g` equals the ring sum over `S` of the function mapping `x` to `g (c x)`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Show that `nsum P (\p. if complex_root p z then e p else 0) = numpreimages c (S:X->bool) z` for any complex number `z`, by using `ord_product_distinct_minpolys` and `poly_ord_monic_vanishing_at_numpreimages`.
- Show that `y IN IMAGE (c:X->complex) S ==> g y IN ring_carrier complex_ring` by using `in_complex_ring`.
- Use `ring_sum_o_v2` and simplification to reduce the goal.
- Show that `ring_sum complex_ring P (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g) = ring_sum complex_ring P (\p. ring_sum complex_ring {y | ~(numpreimages c (S:X->bool) y = 0)} (\y. if y IN complex_root p then Cx(&(e p)) * g y else Cx(&0)))` by using `vsum_ring_sum_complex`, `VSUM_COMPLEX_LMUL`, subset property, `ring_sum_restrict_subset`, and `complex_ring_clauses`.
     - Show that `complex_root a SUBSET {y | ~(numpreimages c (S:X->bool) y = 0)}` by using `term_le_nsum`, `IN` and ASM_ARITH_TAC.
- Simplify the goal by using `image_numpreimages`.
- Use `RING_SUM_SWAP` and simplification to swap the order of summation.
- Show that `nsum P (\p. if complex_root p a then e p else 0) = nsum P (\p. 0)`  and `numpreimages (c:X->complex) S a = 0` if `!q:(1->num)->complex. q IN P ==> ~complex_root q a`
- Choose `q:((1->num)->complex)` such that `(q:(1->num)->complex) IN P /\ complex_root q a`.
- Show that `ring_sum complex_ring P (\p. if a IN complex_root p then Cx (&(e p)) * g a else Cx (&0)) = ring_sum complex_ring P (\p. if p = q then Cx(&(e q)) * g a else Cx(&0))` by using `distinct_minpolys_distinct_roots` and `IN`.
- Simplify using `complex_ring_clauses`, `RING_SUM_DELTA`.
- Prove `e(q:(1->num)->complex) = numpreimages c S (c(v:X):complex)` by using assumption `!z. nsum P (\p. if complex_root p z then e p else 0) = numpreimages (c:X->complex) S z` and `distinct_minpolys_distinct_roots`, `NSUM_DELTA`.
- Conclude.

### Mathematical insight
This theorem relates the ring sum over a set of polynomials, `P`, to the ring sum over a set `S`.
The key idea is to decompose the `monic_vanishing_at` polynomial, whose roots are the elements of the set `S` mapped by the complex valued function `c`, into a product of powers of distinct minimal polynomials `p` in `P`.
The exponent of each `p` is given by `e p`. The theorem then equates the sum over `P` involving roots of `p` together with the exponents `e p` to the sum over the original set `S`, acted upon by `c` and `g`.
This is important when relating sums over roots of polynomials with sums over the original domain `X`.

### Dependencies
*Definitions:*
- `poly_product`
- `QinC_ring`
- `poly_pow`
- `monic_vanishing_at`
- `complex_ring`
- `complex_root`
- `ring_sum`
- `numpreimages`

*Theorems:*
- `ord_product_distinct_minpolys`
- `poly_ord_monic_vanishing_at_numpreimages`
- `ring_sum_o_v2`
- `distinct_minpolys_finite_root`
- `vsum_ring_sum_complex`
- `VSUM_COMPLEX_LMUL`
- `ring_sum_restrict_subset`
- `complex_ring_clauses`
- `FINITE_IMAGE`
- `RING_SUM_SWAP`
- `distinct_minpolys_distinct_roots`
- `ring_of_num_complex`
- `complex_of_num`
- `in_complex_ring`
- `image_numpreimages`
- `NSUM_0`
- `CARD_EQ_0`
- `FINITE_RESTRICT`


---

## sum_root_decomposition_if_monic_vanishing_at_factorization

### Name of formal statement
sum_root_decomposition_if_monic_vanishing_at_factorization

### Type of the formal statement
theorem

### Formal Content
```ocaml
let sum_root_decomposition_if_monic_vanishing_at_factorization = prove(`
  !P:((1->num)->complex)->bool S:X->bool e:((1->num)->complex)->num c:X->complex g:complex->complex.
  FINITE P ==>
  distinct_minpolys P ==>
  FINITE S ==>
  poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))
  = monic_vanishing_at complex_ring S c ==>
  ring_sum complex_ring P (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g) =
  ring_sum complex_ring S (g o c)
`,
  intro THEN
  def `Q:((1->num)->complex)->bool` `{p:(1->num)->complex | p IN P /\ ~(e p = 0)}` THEN
  havetac `Q SUBSET (P:((1->num)->complex)->bool)` (ASM SET_TAC[]) THEN
  subgoal `FINITE(Q:((1->num)->complex)->bool)` THENL [
    specialize[
      `P:((1->num)->complex)->bool`;
      `\p:(1->num)->complex. ~(e p = 0)`
    ]FINITE_RESTRICT THEN
    qed[]
  ; pass
  ] THEN
  subgoal `distinct_minpolys Q` THENL [
    ASM SET_TAC[distinct_minpolys]
  ; pass
  ] THEN
  subgoal `poly_product QinC_ring Q (\p. poly_pow QinC_ring p (e p)) = monic_vanishing_at complex_ring (S:X->bool) c` THENL [
    specialize[
      `QinC_ring`;
      `Q:((1->num)->complex)->bool`;
      `P:((1->num)->complex)->bool`;
      `\p:(1->num)->complex. poly_pow QinC_ring p (e p)`
    ](GSYM poly_product_restrict_subset) THEN
    simp[] THEN
    rw[IN_ELIM_THM] THEN
    subgoal `poly_product QinC_ring P (\s. if s IN P /\ ~(e s = 0) then poly_pow QinC_ring s (e s) else poly_1 QinC_ring) = poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))` THENL [
      sufficesby poly_product_eq THEN
      qed[poly_pow_0]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!p:(1->num)->complex. p IN Q ==> ~(e p = 0)` THENL [
    simp[IN_ELIM_THM]
  ; pass
  ] THEN
  specialize[
    `Q:((1->num)->complex)->bool`;
    `S:X->bool`;
    `e:((1->num)->complex)->num`;
    `c:X->complex`;
    `g:complex->complex`
  ]sum_root_decomposition_if_monic_vanishing_at_factorization_lemma THEN
  subgoal `ring_sum complex_ring Q (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g) = ring_sum complex_ring P (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g)` THENL [
    specialize[
      `complex_ring`;
      `Q:((1->num)->complex)->bool`;
      `P:((1->num)->complex)->bool`;
      `\p:(1->num)->complex. Cx(&(e p)) * ring_sum complex_ring (complex_root p) g`
    ]ring_sum_restrict_subset THEN
    subgoal `ring_sum complex_ring P (\s. if s IN Q then Cx (&(e s)) * ring_sum complex_ring (complex_root s) g else ring_0 complex_ring) = ring_sum complex_ring P (\p. Cx (&(e p)) * ring_sum complex_ring (complex_root p) g)` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      simp[IN_ELIM_THM] THEN
      case `e(a:(1->num)->complex) = 0` THENL [
        rw[complex_ring_clauses] THEN
        have `Cx (&0) * ring_sum complex_ring (complex_root a) g = Cx(&0)` [COMPLEX_MUL_LZERO] THEN
        simp[]
      ; pass
      ] THEN
      simp[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For any predicate `P` on functions from `1->num` to complex numbers, any predicate `S` on a type `X`, any function `e` from functions from `1->num` to complex numbers to numbers, any function `c` from `X` to complex numbers, and any function `g` from complex numbers to complex numbers, if `P` is finite, `P` satisfies `distinct_minpolys`, `S` is finite, and the polynomial product of the powers of the polynomials in `P` with exponents given by `e` equals the `monic_vanishing_at` polynomial for the set `S` evaluated at `c`, then the sum over `P` of `Cx (&(e p)) * (sum of g over the roots of p)` equals the sum over `S` of `g` composed with `c`.

### Informal sketch
The proof proceeds by introducing the goal and then defining a predicate `Q` such that it's a subset of `P`, including those polynomials `p` in `P` for which `e p` is not zero.
- It's proven that `Q` is a finite set.
- It's proven that all elements of `Q` have distinct minimal polynomials.
- It's proven that the product of the polynomial powers of `Q` is equal to the `monic_vanishing_at` polynomial for the set `S` evaluated at `c`.
- It's proven that for all `p` in `Q`, `e p` is not zero.
- The lemma `sum_root_decomposition_if_monic_vanishing_at_factorization_lemma` is specialized to `Q`, `S`, `e`, `c`, and `g`.
- It remains to show the sum over `Q` equals the sum over `P`. This step involves showing that if `s` is in `Q`, the term is as expected, otherwise it is zero. The case where `e(a) = 0` reduces to zero.

### Mathematical insight
This theorem relates the sum of `g` over roots determined by a polynomial factorization to the sum taken over a set `S`. Specifically, it shows under the given conditions a decomposition of a polynomial whose roots are derived by `S` into component polynomials `P` and functions `e` results in equality between related sums.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `poly_product`
- `QinC_ring`
- `poly_pow`
- `monic_vanishing_at`
- `complex_ring`
- `ring_sum`
- `complex_root`
- `Cx`
- `sum_root_decomposition_if_monic_vanishing_at_factorization_lemma`
- `poly_product_restrict_subset`
- `poly_product_eq`
- `poly_pow_0`
### Porting notes (optional)
The definition of `distinct_minpolys` must be available. Also, the user discharging the proofs of subgoals might need knowledge of HOL Light's `ASM SET_TAC` and the `IN_ELIM_THM` usage.


---

## transcendence_v_denom

### Name of formal statement
transcendence_v_denom

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_v_denom = prove(`
  !P D B u.
  FINITE P ==>
  distinct_minpolys P ==>
  D IN ZinC ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  !n vn.
  vn = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) ==>
  D pow n * vn IN ZinC
`,
  intro THEN
  have `!n. D pow n * u n IN ZinC` [weighted_powersums_distinct_minpolys] THEN
  subgoal `D pow n * vn = ring_sum complex_ring (0..n) (\i. D pow n * Cx(&(FACT(n-i) * binom(n,i))) * u i)` THENL [
    have `D pow n IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `FINITE (0..n)` [FINITE_NUMSEG] THEN
    have `!i. i IN (0..n) ==> Cx (&(FACT (n - i) * binom (n,i))) * u i IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[`complex_ring`;`\i. Cx (&(FACT (n - i) * binom (n,i))) * u i`;`(D:complex) pow n`;`0..n`](GSYM RING_SUM_LMUL) THEN
    have `D pow n * vn = ring_sum complex_ring (0..n) (\x. ring_mul complex_ring (D pow n) (Cx (&(FACT (n - x) * binom (n,x))) * u x))` [complex_ring_clauses] THEN
    qed[RING_SUM_EQ;complex_ring_clauses]
  ; pass
  ] THEN
  recall subring_complex_empty THEN
  subgoal `ring_sum complex_ring (0..n) (\i. D pow n * Cx (&(FACT (n - i) * binom (n,i))) * u i) IN ring_carrier(subring_generated complex_ring {})` THENL [
    sufficesby ring_sum_in_subring THEN
    intro THEN
    have `s <= n:num` [IN_NUMSEG_0] THEN
    num_linear_fact `s <= n ==> n = s + (n-s):num` THEN
    have `(D:complex) pow n = D pow s * D pow (n-s)` [COMPLEX_POW_ADD] THEN
    complex_field_fact `(D:complex) pow n = D pow s * D pow (n-s) ==> D pow n * Cx (&(FACT (n - s) * binom (n,s))) * u s = D pow (n-s) * Cx (&(FACT (n - s) * binom (n,s))) * (D pow s * u s)` THEN
    have `D pow s * u s IN ZinC` [] THEN
    have `D pow (n-s) IN ZinC` [ring_pow_ZinC;RING_POW;ZinC_ring_clauses] THEN
    have `Cx(&(FACT(n-s) * binom(n,s))) IN ZinC` [ZinC_ring_clauses;num_in_ZinC] THEN
    have `Cx (&(FACT (n - s) * binom (n,s))) * (D pow s * u s) IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
    have `D pow (n-s) * Cx (&(FACT (n - s) * binom (n,s))) * (D pow s * u s) IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
    have `D pow n * Cx (&(FACT (n - s) * binom (n,s))) * u s IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
    qed[ZinC_ring_clauses]
  ; pass
  ] THEN
  qed[ZinC_ring_clauses]
);;
```
### Informal statement
If `P` is a finite set of complex polynomials, such that all polynomials in `P` have distinct minimal polynomials, and `D` is an integer, such that for all `p` in `P` and for all `i`, `D` to the power of `i` times the coefficient of the term with degree `poly_deg p - i` in `p` is an integer, and for all `n`, `u n` is equal to the sum over `P` of `B p` times the power sums of the roots of `p` to the power `n`, where `B` is a function from polynomials to integers. If `vn` is equal to the sum from `i = 0` to `n` of `Cx(&(FACT(n-i) * binom(n,i))) * u i`, then `D` to the power `n` times `vn` is an integer.

### Informal sketch
The theorem states that under certain conditions, `D^n * vn` is an integer. The proof proceeds as follows:
- It is first shown that `D^n * u n` is an integer using the result `weighted_powersums_distinct_minpolys`.
- The goal is reduced to proving `ring_sum complex_ring (0..n) (\i. D pow n * Cx(&(FACT(n-i) * binom(n,i))) * u i) IN ring_carrier(subring_generated complex_ring {})`.
- Then it expands the definition of `vn` as summation: `vn = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)`.
- It uses `RING_SUM_LMUL` along with the fact that `Dpow n` is in the ring, transforming the product outside of the summation.
- It then uses `RING_SUM_EQ` and `complex_ring_clauses` to establish the reduction.
- To prove `ring_sum_in_subring`, we need to show each term in the sum belongs to `ZinC`.
- For each `i` in `(0..n)`, it utilizes the fact that `D^s * u s` is an element of integers and `D^(n-s)` is in the integers too. It also uses the fact that `Cx(&(FACT(n-s)*binom(n,s)))` is Integer.
- Using the transitivity of operations given for integers, it proves `D pow n * Cx (&(FACT (n - s) * binom (n,s))) * u s IN ZinC`.

### Mathematical insight
This theorem is part of a larger effort to prove transcendence results. It appears to be dealing with algebraic manipulations of sums and power sums related to roots of polynomials. The condition `distinct_minpolys P` is crucial since it ensures that the polynomials in `P` do not share roots, which is important when dealing with roots and power sums.

### Dependencies
- `FINITE_NUMSEG`
- `in_complex_ring`
- `RING_SUM_LMUL`
- `complex_ring_clauses`
- `RING_SUM_EQ`
- `IN_NUMSEG_0`
- `COMPLEX_POW_ADD`
- `ring_pow_ZinC`
- `RING_POW`
- `ZinC_ring_clauses`
- `num_in_ZinC`
- `RING_MUL`
- `subring_complex_empty`
- `ring_sum_in_subring`
- `weighted_powersums_distinct_minpolys`
- `ZinC_ring_clauses`

### Porting notes (optional)
- Ensure that the target proof assistant has comparable support for ring theory, complex numbers, and polynomial manipulation. Specifically, the ability to work with sums over sets and the properties of integers and complex numbers are central to the proof.
- Tactics like `num_linear_fact` and `complex_field_fact` suggest that a similar level of algebraic automation would be help facilitate a smooth port.


---

## transcendence_w_denom

### Name of formal statement
transcendence_w_denom

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_w_denom = prove(`
  !P D B u.
  FINITE P ==>
  distinct_minpolys P ==>
  D IN ZinC ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  !n k wn.
  wn = (if k <= n then ring_sum complex_ring (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) else Cx(&0)) ==>
  (D pow (n-k) * wn) / Cx(&(FACT k)) IN ZinC
`,
  intro THEN
  case `k <= n:num` THENL [
    have `!i. D pow i * u i IN ZinC` [weighted_powersums_distinct_minpolys] THEN
    rw[COMPLEX_FIELD `(D pow (n-k) * wn) / Cx(&(FACT k)) = (D pow (n-k) / Cx(&(FACT k))) * wn`] THEN
    subgoal `(D pow (n-k) / Cx(&(FACT k))) * wn = ring_sum complex_ring (0..n-k) (\i. (D pow (n-k) / Cx(&(FACT k))) * Cx(&(FACT(n-i) * binom(n,i))) * u i)` THENL [
      have `(D pow (n-k) / Cx(&(FACT k))) IN ring_carrier complex_ring` [in_complex_ring] THEN
      have `FINITE (0..n-k)` [FINITE_NUMSEG] THEN
      have `!i. i IN (0..n-k) ==> Cx (&(FACT (n - i) * binom (n,i))) * u i IN ring_carrier complex_ring` [in_complex_ring] THEN
      specialize[`complex_ring`;`\i. Cx (&(FACT (n - i) * binom (n,i))) * u i`;`(D:complex) pow (n-k) / Cx(&(FACT k))`;`0..n-k`](GSYM RING_SUM_LMUL) THEN
      have `(D pow (n-k) / Cx(&(FACT k))) * wn = ring_sum complex_ring (0..n-k) (\x. ring_mul complex_ring ((D pow (n-k) / Cx(&(FACT k)))) (Cx (&(FACT (n - x) * binom (n,x))) * u x))` [complex_ring_clauses] THEN
      qed[RING_SUM_EQ;complex_ring_clauses]
    ; pass
    ] THEN
    recall subring_complex_empty THEN
    subgoal `ring_sum complex_ring (0..n-k) (\i. D pow (n-k) / Cx(&(FACT k)) * Cx (&(FACT (n - i) * binom (n,i))) * u i) IN ring_carrier(subring_generated complex_ring {})` THENL [
      sufficesby ring_sum_in_subring THEN
      intro THEN
      have `s <= n-k:num` [IN_NUMSEG_0] THEN
      num_linear_fact `s <= n-k ==> n-k = s + ((n-k)-s):num` THEN
      have `(D:complex) pow (n-k) = D pow s * D pow ((n-k)-s)` [COMPLEX_POW_ADD] THEN
      num_linear_fact `k <= n ==> s <= n-k ==> n-s = ((n-s)-k)+k:num` THEN
      have `FACT(((n-s)-k)+k) = FACT((n-s)-k) * FACT k * binom(((n-s)-k)+k,k)` [BINOM_FACT] THEN
      have `FACT(n-s) = FACT((n-s)-k) * FACT k * binom(((n-s)-k)+k,k)` [] THEN
      have `((n-s)-k)+k,k = n-s,(k:num)` [] THEN
      have `FACT(n-s) = FACT((n-s)-k) * FACT k * binom(n-s,k)` [] THEN
      have `(&(FACT(n-s))) = (&(FACT((n-s)-k))) * (&(FACT k)) * (&(binom(n-s,k)))` [REAL_OF_NUM_MUL] THEN
      have `Cx(&(FACT(n-s))) = Cx(&(FACT((n-s)-k))) * Cx(&(FACT k)) * Cx(&(binom(n-s,k)))` [CX_MUL] THEN
      have `~(FACT k = 0)` [FACT_NZ] THEN
      have `~(&(FACT k) = &0:real)` [REAL_OF_NUM_EQ] THEN
      have `~(Cx(&(FACT k)) = Cx(&0))` [CX_INJ] THEN
      complex_field_fact `
        ~(Cx(&(FACT k)) = Cx(&0)) ==>
        (D:complex) pow (n-k) = D pow s * D pow ((n-k)-s) ==>
        Cx(&(FACT(n-s))) = Cx(&(FACT((n-s)-k))) * Cx(&(FACT k)) * Cx(&(binom(n-s,k))) ==>
        D pow (n-k) / Cx(&(FACT k)) * (Cx(&(FACT (n - s))) * Cx(&(binom (n,s)))) * u s
        = D pow ((n-k)-s) * Cx(&(FACT ((n-s)-k))) * Cx(&(binom(n-s,k))) * Cx(&(binom (n,s))) * D pow s * u s
      ` THEN
      have `(&(FACT(n-s) * binom(n,s))) = (&(FACT(n-s))) * (&(binom(n,s)))` [REAL_OF_NUM_MUL] THEN
      have `Cx(&(FACT(n-s) * binom(n,s))) = Cx(&(FACT(n-s))) * Cx(&(binom(n,s)))` [CX_MUL] THEN
      have `D pow ((n-k)-s) IN ZinC` [ring_pow_ZinC;RING_POW;ZinC_ring_clauses] THEN
      have `Cx(&(FACT(n-s-k))) IN ZinC` [ZinC_ring_clauses;num_in_ZinC] THEN
      have `Cx(&(binom(n-s,k))) IN ZinC` [ZinC_ring_clauses;num_in_ZinC] THEN
      have `Cx(&(binom(n,s))) IN ZinC` [ZinC_ring_clauses;num_in_ZinC] THEN
      have `D pow s * u s IN ZinC` [] THEN
      have `Cx (&(binom (n,s))) * D pow s * u s IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
      have `Cx (&(binom (n - s,k))) * Cx (&(binom (n,s))) * D pow s * u s IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
      have `Cx (&(FACT (n - s - k))) * Cx (&(binom (n - s,k))) * Cx (&(binom (n,s))) * D pow s * u s IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
      have `D pow ((n-k)-s) * Cx (&(FACT (n - s - k))) * Cx (&(binom (n - s,k))) * Cx (&(binom (n,s))) * D pow s * u s IN ZinC` [ZinC_ring_clauses;RING_MUL] THEN
      have `D pow (n-k) / Cx(&(FACT k)) * (Cx (&(FACT (n - s))) * Cx (&(binom (n,s)))) * u s IN ZinC` [] THEN
      have `D pow (n-k) / Cx(&(FACT k)) * Cx (&(FACT (n - s) * binom (n,s))) * u s IN ZinC` [] THEN
      qed[ZinC_ring_clauses]
    ; pass
    ] THEN
    qed[ZinC_ring_clauses]
  ;
    have `wn = Cx(&0)` [] THEN
    qed[COMPLEX_FIELD `(x * Cx(&0)) / y = Cx(&0)`;ZinC_0]
  ]
);;
```
### Informal statement
For all sets of complex polynomials `P`, integers `D`, functions `B` mapping polynomials to integers, and functions `u` from natural numbers to complex numbers, if `P` is finite, the minimal polynomials in `P` are distinct, `D` is an integer, for every polynomial `p` in `P` and every natural number `i`, `D` to the power of `i` times the coefficient of `p` at `poly_deg complex_ring p - i` is an integer, for all natural numbers `n`, `u n` is the ring sum over `P` of `complex_of_int(B p) * complex_root_powersums p n`, for all natural numbers `n` and `k`, if `wn` equals, for all `k <= n`, the ring sum from 0 to `n-k` of `Cx(&(FACT(n-i) * binom(n,i))) * u i`; otherwise `Cx(&0)`, then `(D pow (n-k) * wn) / Cx(&(FACT k))` is an integer.

### Informal sketch
The proof proceeds by induction and case splitting on whether `k <= n`.
- If `k <= n`, we first show that `D pow i * u i IN ZinC` (integers as a subring of complex numbers).
- We then rewrite the expression `(D pow (n-k) * wn) / Cx(&(FACT k))` using the fact that scalar multiplication distributes over ring sums in a complex ring to get `ring_sum complex_ring (0..n-k) (\i. (D pow (n-k) / Cx(&(FACT k))) * Cx(&(FACT(n-i) * binom(n,i))) * u i)`.
- We prove that each term in the ring sum is in `ZinC` using the fact that `D pow ((n-k)-s) IN ZinC`, `Cx(&(FACT(n-s-k))) IN ZinC`, `Cx(&(binom(n-s,k))) IN ZinC`, `Cx(&(binom(n,s))) IN ZinC`, and `D pow s * u s IN ZinC`. The binomial coefficient and the factorial expressions are integers, and thus in `ZinC`. Then by properties of `ZinC` and the subring properties, we conclude that the ring sum belongs to `ZinC`.
- If `not (k <= n)`, i.e. `k > n`, then `wn = Cx(&0)`. This makes `(D pow (n-k) * wn) / Cx(&(FACT k))` equal to `Cx(&0)`, which is in `ZinC`.

### Mathematical insight
This theorem addresses the transcendence of numbers. It builds upon the idea that algebraic integers exhibit certain properties related to power sums and integer combinations. By showing certain expressions built from power sums of roots belong to the integers(`ZinC`), it provides a step towards proving transcendence results.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ZinC`
- `COMPLEX_FIELD`
- `RING_SUM_LMUL`
- `in_complex_ring`
- `FINITE_NUMSEG`
- `GSYM`
- `RING_SUM_EQ`
- `subring_complex_empty`
- `IN_NUMSEG_0`
- `COMPLEX_POW_ADD`
- `BINOM_FACT`
- `REAL_OF_NUM_MUL`
- `CX_MUL`
- `FACT_NZ`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `num_in_ZinC`
- `ring_pow_ZinC`
- `RING_POW`
- `ZinC_ring_clauses`
- `FACT`
- `binom`

### Porting notes (optional)
- The theorem relies heavily on properties of complex numbers and polynomial rings. It's important to have a well-developed complex number library and polynomial ring library in the target proof assistant.
- The `ZinC` predicate (integers as a subring of complex) and the manipulation of integer expressions within the complex numbers requires support for subrings and ring homomorphisms.
- Automation for ring reasoning (e.g., using `complex_field_fact`), might be needed, or the field/ring axioms must be explicitly applied during the port.


---

## transcendence_H_poly

### Name of formal statement
transcendence_H_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_poly = prove(`
  !P H t.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  ring_polynomial complex_ring H
`,
  intro THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring (I p)` [I_THM] THEN
  have `ring_polynomial QinC_ring (poly_product QinC_ring P I)` [poly_product_poly] THEN
  have `ring_powerseries QinC_ring (poly_product QinC_ring P I)` [ring_polynomial] THEN
  qed[x_truncreverse_poly;poly_complex_if_poly_QinC]
);;
```
### Informal statement
For all sets `P` of complex polynomials, all natural numbers `t`, and all complex ring polynomials `H`, if `P` is finite, all polynomials in `P` have distinct minimal polynomials, `t` is the sum over `P` of the degrees of the polynomials in `P`, and `H` is the truncation of the formal power series representation of the polynomial which is the product of polynomials formed by evaluating the indeterminate `I` at each polynomial `p` in `P`, with the truncation occurring at degree `t`, then `H` is a ring polynomial over the complex numbers.

### Informal sketch
The proof proceeds by showing that the polynomial `H` is equal to `x_truncreverse QinC_ring t (poly_product QinC_ring P I)` is a ring polynomial, given that `P` is a finite set of polynomials with distinct minimal polynomials.
- First, `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` is derived from the premise `distinct_minpolys P`.
- Next, similarly, `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring (I p)` is obtained using theorem `I_THM`.
- Then, using `poly_product_poly` and the above assertions for `I p`, it's shown that `ring_polynomial QinC_ring (poly_product QinC_ring P I)`.
- Next this polynomial is a ring power series by `ring_polynomial`.
- Finally, it is shown by `x_truncreverse_poly;poly_complex_if_poly_QinC` that truncating the series yields a polynomial; specifically `ring_polynomial complex_ring H`

### Mathematical insight
The theorem establishes that a certain truncation of a product of polynomials (in this case polynomials evaluated at the indeterminate `I`) is indeed a ring polynomial under specific conditions. This is especially important when dealing with transcendence proofs, where the manipulation of polynomials and power series plays a significant role. The condition `distinct_minpolys P` is typical of transcendence proofs, as it prevents algebraic dependencies among the polynomials in `P`.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `nsum`
- `poly_deg`
- `complex_ring`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `I`
- `ring_polynomial`
- `ring_powerseries`

#### Theorems
- `I_THM`
- `poly_product_poly`
- `x_truncreverse_poly`
- `poly_complex_if_poly_QinC`


---

## transcendence_Gp_poly

### Name of formal statement
transcendence_Gp_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Gp_poly = prove(`
  !P p.
  FINITE P ==>
  distinct_minpolys P ==>
  p IN P ==>
  ring_polynomial complex_ring (poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q))
`,
  intro THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> q IN P` [IN_DELETE] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> ring_polynomial QinC_ring q` [distinct_minpolys] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> ring_powerseries QinC_ring q` [ring_polynomial] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> ring_polynomial QinC_ring (x_truncreverse QinC_ring (poly_deg complex_ring q) q)` [x_truncreverse_poly] THEN
  have `FINITE (P DELETE (p:(1->num)->complex))` [FINITE_DELETE] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> ring_polynomial complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring q) q)` [poly_complex_if_poly_QinC] THEN
  qed[poly_product_poly]
);;
```
### Informal statement
For all sets `P` of polynomials (from numbers to complex numbers), and for all polynomials `p`, if `P` is finite, and the minimal polynomials in `P` are distinct, and `p` is in `P`, then the polynomial that results from taking the product of the polynomials obtained by truncating and reversing the elements of `P` excluding `p` using `x_truncreverse`, is a ring polynomial in the complex ring.

### Informal sketch
The proof proceeds by induction on the hypotheses. Specifically, it relies on proving the following:

- Assume `P` is a finite set of distinct minimal polynomials over the complex numbers and `p` is an element of `P`.
- Show that if `q` is in `P DELETE p` then `q` is in `P`.
- Show that if `q` is in `P DELETE p` then `q` is a ring polynomial over `QinC_ring`.
- Show that if `q` is in `P DELETE p` then `q` is a ring power series over `QinC_ring`.
- Show that if `q` is in `P DELETE p` then the truncated reverse of `q` is a ring polynomial over `QinC_ring`.
- Show that `P DELETE p` is finite.
- Show that if `q` is in `P DELETE p` then the truncated reverse of `q` is a ring polynomial over the complex numbers.
- The result then follows from the theorem `poly_product_poly`.

### Mathematical insight
The theorem states that, under certain conditions regarding finiteness and distinctness of minimal polynomials, a certain polynomial product constructed from truncated and reversed elements forms a ring polynomial. This result likely serves as a lemma in a larger proof concerning transcendence, where manipulation and analysis of polynomial properties are crucial.

### Dependencies
- `IN_DELETE`
- `FINITE_DELETE`
- `distinct_minpolys`
- `ring_polynomial`
- `ring_powerseries`
- `x_truncreverse_poly`
- `poly_complex_if_poly_QinC`
- `poly_product_poly`

### Porting notes (optional)
The tactic `qed[poly_product_poly]` suggests that the proof relies heavily on the theorem `poly_product_poly` as the final step. Ensure its equivalent is established.
The proof relies on results regarding polynomial rings and finiteness. Make sure the target proof assistant has sufficient support and automation for these facts.


---

## transcendence_H_product

### Name of formal statement
transcendence_H_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_product = prove(`
  !P H t.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  H = poly_product QinC_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)
`,
  intro THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring (I p)` [I_THM] THEN
  have `!p:(1->num)->complex. p IN P ==> poly_deg QinC_ring (I p) <= poly_deg complex_ring p` [I_THM;poly_deg_subring;subring_complex_QinC;ARITH_RULE `d <= d:num`] THEN
  subgoal `poly_product QinC_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p) = poly_product QinC_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) (I p))` THENL [
    sufficesby poly_product_eq THEN
    qed[I_THM]
  ; pass
  ] THEN
  specialize[`QinC_ring`;`\p:(1->num)->complex. poly_deg complex_ring p`;`I:((1->num)->complex)->(1->num)->complex`;`P:((1->num)->complex)->bool`]x_truncreverse_product THEN
  qed[]
);;
```
### Informal statement
For any predicate `P` on functions from `(1->num)` to complex numbers, any function `H` from `(1->num)` to complex numbers, and any natural number `t`, if `P` is finite, and the polynomials in `P` have distinct minimal polynomials, and `t` is the sum over `P` of the polynomial degrees (in the complex field) of the polynomials in `P`, and `H` is the truncated power series representation in `QinC_ring` to order `t` of the product of the polynomials in `P` with the `I` embedding, then `H` is the product of polynomials in `P` of truncated power series representation in `QinC_ring` to order `t` of `p`.

### Informal sketch
The proof proceeds by induction. The theorem states that under the assumption that `P` is a finite set of polynomials, which have distinct minimal polynomials, and `t` is the sum of their degrees, then truncating (to order `t`) the product of `I p`'s, for p in `P`, is the same as taking the product of the truncations.
- The proof starts by introducing the assumptions.
- It shows that for any polynomial `p` in `P`, `p` is a ring polynomial in `QinC_ring` because `distinct_minpolys P` holds.
- It shows that for any polynomial `p` in `P`, `I p` is a ring polynomial in `QinC_ring` because `I_THM` holds.
- It shows that for any polynomial `p` in `P`, the polynomial degree of `I p` in `QinC_ring` is less than or equal to the polynomial degree of `p` because `I_THM;poly_deg_subring;subring_complex_QinC` hold.
- It proves `poly_product QinC_ring P (λp. x_truncreverse QinC_ring (poly_deg complex_ring p) p) = poly_product QinC_ring P (λp. x_truncreverse QinC_ring (poly_deg complex_ring p) (I p))` by proving that `I p = p`, with `I_THM` and `poly_product_eq`.
- It specializes the theorem `x_truncreverse_product` and completes the proof.

### Mathematical insight
The theorem essentially states that truncating the product of polynomials is the same as the product of truncations, provided we truncate to the appropriate order. This is useful when dealing with power series approximations of polynomials. The `I` embedding is used to embed polynomials with complex coefficients into the algebraic closure that includes transcendental numbers.

### Dependencies
- Theorem: `I_THM`
- Theorem: `poly_deg_subring`
- Theorem: `subring_complex_QinC`
- Theorem: `poly_product_eq`
- Theorem: `x_truncreverse_product`

### Porting notes (optional)
The theorem uses the notion of truncated power series which could be defined in other proof assistants with similar effect. The construction of the intermediate field (algebraic closure) containing transcendental numbers `QinC_ring` will be specific to each proof assistant. The proof relies on rewriting and equational reasoning, so proof assistants with strong automation for these tasks (e.g., Coq, Lean) may be able to reproduce the proof with minimal effort.


---

## transcendence_H_product_complex_ring

### Name of formal statement
transcendence_H_product_complex_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_product_complex_ring = prove(`
  !P H t.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  H = poly_product complex_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)
`,
  intro THEN
  specialize[`P:((1->num)->complex)->bool`;`H:(1->num)->complex`;`t:num`]transcendence_H_product THEN
  have `!q. q IN P ==> ring_powerseries QinC_ring (q:(1->num)->complex)` [distinct_minpolys;ring_polynomial] THEN
  have `!q. q IN P ==> ring_powerseries QinC_ring (x_truncreverse QinC_ring (poly_deg complex_ring q) q)` [x_truncreverse_series] THEN
  specialize_assuming[`complex_ring`;`QinC`;`\q:(1->num)->complex. x_truncreverse QinC_ring (poly_deg complex_ring q) q`;`P:((1->num)->complex)->bool`]poly_product_subring THEN
  qed[subring_complex_QinC]
);;
```

### Informal statement
For any finite set `P` of complex polynomials, if the polynomials in `P` have distinct minimal polynomials, then for any `t` equal to the sum over `P` of the degrees of each polynomial `p` in `P` considered as a polynomial over the complex numbers, and for any `H` equal to the truncation of the formal power series `poly_product QinC_ring P I` to degree `t` within the ring `QinC_ring`, `H` is also equal to the product over `P` of the truncations of each polynomial `p` in `P` to its degree over the complex numbers within the ring `QinC_ring`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Specialize the theorem `transcendence_H_product` with the given parameters `P`, `H` and `t`.
- Prove that if `q` is in `P`, then `q` is a power series in the ring `QinC_ring`. Use `distinct_minpolys` and `ring_polynomial`.
- Prove that if `q` is in `P`, then the truncation of `q` to its degree is a power series in `QinC_ring`. Use `x_truncreverse_series`.
- Specialize the theorem `poly_product_subring` with the sets `complex_ring`, `QinC`, the function mapping `q` to the truncation of `q` to its degree, and the set `P`, assuming the previously derived fact that the truncation is a powerseries rings.
- The goal is discharged using `subring_complex_QinC`.

### Mathematical insight
This theorem relates the truncation of a product of polynomials to the product of the truncations of those polynomials. The theorem essentially states that under the assumptions, the truncation operator distributes over the polynomial product. This is useful when dealing with transcendence bases and algebraic independence in fields.

### Dependencies
- `transcendence_H_product`
- `distinct_minpolys`
- `ring_polynomial`
- `x_truncreverse_series`
- `poly_product_subring`
- `subring_complex_QinC`

### Porting notes (optional)
- The user should define `complex_ring` and `QinC`.
- The user needs to verify subring property of `complex_ring` & `QinC`.


---

## transcendence_H_botcoeff1

### Name of formal statement
transcendence_H_botcoeff1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_botcoeff1 = prove(`
  !P H t.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  coeff 0 H = Cx(&1)
`,
  intro THEN
  have `!p:(1->num)->complex. p IN P ==> monic QinC_ring p` [distinct_minpolys] THEN
  have `!p:(1->num)->complex. p IN P ==> coeff (poly_deg QinC_ring p - 0) p = ring_1 QinC_ring` [monic;ARITH_RULE `x - 0 = x`] THEN
  have `!p:(1->num)->complex. p IN P ==> coeff 0 (x_truncreverse QinC_ring (poly_deg QinC_ring p) p) = ring_1 QinC_ring` [coeff_x_truncreverse;ARITH_RULE `0 <= x`] THEN
  have `!p:(1->num)->complex. p IN P ==> coeff 0 (x_truncreverse QinC_ring (poly_deg complex_ring p) p) = ring_1 QinC_ring` [poly_deg_subring;subring_complex_QinC] THEN
  have `H = poly_product QinC_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [transcendence_H_product] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring (x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [x_truncreverse_poly;ring_polynomial] THEN
  specialize_assuming[`QinC_ring`;`\p:(1->num)->complex. x_truncreverse QinC_ring (poly_deg complex_ring p) p`;`P:((1->num)->complex)->bool`]poly_product_botcoeff1 THEN
  have `coeff 0 (H:(1->num)->complex) = ring_1 QinC_ring` [] THEN
  qed[QinC_ring_clauses]
);;
```

### Informal statement
For any finite set `P` of polynomials over the complex numbers, if the polynomials in `P` have distinct minimal polynomials, if `t` is the sum of the degrees of the polynomials in `P`, and if `H` is the polynomial obtained by truncating and reversing the polynomial product of `P` at degree `t`, then the constant term of `H` is 1.

### Informal sketch
The proof demonstrates that the constant coefficient of the polynomial `H` is equal to 1, under the conditions that `P` is a finite set of polynomials with distinct minimal polynomials, `t` is the sum of the degrees of polynomials in `P`, and `H` is `x_truncreverse QinC_ring t (poly_product QinC_ring P I)`.

- Firstly, given `distinct_minpolys P`, it is inferred that each polynomial `p` in `P` is monic.
- Secondly, since each `p` in `P` is monic, `coeff (poly_deg QinC_ring p - 0) p = ring_1 QinC_ring`.
- Thirdly, it shows that `coeff 0 (x_truncreverse QinC_ring (poly_deg complex_ring p) p) = ring_1 QinC_ring`.
- Fourthly, it shows that `H` can be expressed as `poly_product QinC_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)`.
- The proof uses `poly_product_botcoeff1` to derive that the coefficient of degree 0 (constant term) of `H` is `ring_1 QinC_ring`, which corresponds to the complex number 1.

### Mathematical insight
This theorem is used in the larger context of transcendence proofs. The polynomial `H` is being constructed in a way that its bottom coefficient is 1. This fact becomes important when proving properties about algebraic independence and transcendence degrees. The truncation and reversing operation ensures that the degree of `H` does not exceed a certain bound (here, `t`).

### Dependencies
- Definitions:
  - `FINITE`
  - `distinct_minpolys`
  - `nsum`
  - `poly_deg`
  - `x_truncreverse`
  - `poly_product`
  - `I`
  - `coeff`
- Theorems:
  - `transcendence_H_product`
  - `coeff_x_truncreverse`
  - `poly_deg_subring`
  - `subring_complex_QinC`
  - `poly_product_botcoeff1`
- Other:
  - `intro`
  - `ARITH_RULE`
  - `specialize_assuming`
  - `qed`
  - `QinC_ring_clauses`
  - `ring_1 QinC_ring`
  - `monic QinC_ring`
  - `ring_polynomial QinC_ring`
  - `x_truncreverse_poly`
  - `ring_polynomial`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification. A proof assistant with strong automation in ring theory and polynomial manipulation will be beneficial.
- Ensure that finiteness of sets is handled correctly.
- Correctly interpreting the subring coercions, especially between complex field and `QinC_ring` is crucial.


---

## transcendence_H_denom

### Name of formal statement
transcendence_H_denom

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_denom = prove(`
  !P H D t.
  FINITE P ==>
  distinct_minpolys P ==>
  D IN ZinC ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!i. D pow i * coeff i H IN ZinC)
`,
  intro THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys] THEN
  have `!p:(1->num)->complex. p IN P ==> monic QinC_ring p` [distinct_minpolys] THEN
  have `!p i. p IN P ==> D pow i * coeff i (x_truncreverse QinC_ring (poly_deg complex_ring p) p) IN ZinC` [denominator_reverse] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_powerseries QinC_ring (x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [ring_polynomial;x_truncreverse_series] THEN
  specialize[`\p:(1->num)->complex. x_truncreverse QinC_ring (poly_deg complex_ring p) p`;`D:complex`;`P:((1->num)->complex)->bool`]denominator_reverse_product THEN
  qed[transcendence_H_product]
);;
```
### Informal statement
For all sets `P` of complex polynomials, complex numbers `H` and `D`, and natural number `t`, if:
1. `P` is finite, and
2. all polynomials in `P` have distinct minimal polynomials, and
3. `D` is an element of the complex integers `Z[i]`, and
4. for all polynomials `p` in `P` and all natural numbers `i`, `D^i * (coeff (poly_deg complex_ring p - i) p)` is in `Z[i]`, and
5. `t` is the sum over the polynomials `p` in `P` of the degree of `p`, and
6. `H` is the `x_truncreverse` of the product of the polynomials in P, truncated to degree t, then
7. for all natural numbers `i`, `D^i * (coeff i H)` is in `Z[i]`.

### Informal sketch
The proof proceeds as follows:
- It starts by introducing the assumptions using `intro`.
- It then uses the assumption `distinct_minpolys` to prove that all polynomials `p` in `P` are ring polynomials in the complex integers `QinC_ring` (Gaussian integers).
- It uses the assumption `distinct_minpolys` again to prove that all polynomials `p` in `P` are monic in `QinC_ring`.
- It uses the theorem `denominator_reverse` to prove that `D pow i * coeff i (x_truncreverse QinC_ring (poly_deg complex_ring p) p) IN ZinC`.
- It shows that `x_truncreverse QinC_ring (poly_deg complex_ring p) p` are ring power series by `ring_polynomial` and `x_truncreverse_series`.
- Finally, it specializes the theorem `denominator_reverse_product` with the appropriate inputs and uses `qed` in combination with the `transcendence_H_product` theorem to complete the proof.

### Mathematical insight
This theorem essentially proves that when we have a finite set of polynomials with distinct minimal polynomials, and when we construct another polynomial `H` by taking the product of the reversed truncations of the initial set, then the coefficients of `H` will also be Gaussian integers when multiplied by a suitable power of a common denominator `D`.  This result is important for transcendence theory where controlling the denominators of coefficients is crucial.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ZinC`
- `coeff`
- `poly_deg`
- `complex_ring`
- `pow`
- `nsum`
- `poly_product`
- `QinC_ring`
- `x_truncreverse`
- `denominator_reverse`
- `ring_polynomial`
- `x_truncreverse_series`
- `ring_powerseries`
- `monic`
- `transcendence_H_product`


---

## transcendence_H_pow_denom

### Name of formal statement
transcendence_H_pow_denom

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_pow_denom = prove(`
  !P H D t k.
  FINITE P ==>
  distinct_minpolys P ==>
  D IN ZinC ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!i. D pow i * coeff i (poly_pow QinC_ring H k) IN ZinC)
`,
  intro THEN
  have `!i. D pow i * coeff i H IN ZinC` [transcendence_H_denom] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_powerseries QinC_ring (I p)` [ring_polynomial;I_THM] THEN
  have `ring_powerseries QinC_ring (poly_product QinC_ring P I:(1->num)->complex)` [poly_product_series] THEN
  have `ring_powerseries QinC_ring (H:(1->num)->complex)` [x_truncreverse_series] THEN
  qed[denominator_reverse_pow]
);;
```
### Informal statement
For all sets `P` of polynomials, complex numbers `H`, natural number `D`, natural numbers `t` and `k`, if `P` is finite, the minimal polynomials in `P` are distinct, `D` is a positive integer, for any polynomial `p` in `P` and any natural number `i`, `D^i * (coeff (poly_deg complex_ring p - i) p)` is a positive integer, `t` is the sum over `P` of the degrees of the polynomials in `P`, `H` is the reversal up to degree `t` of the power series expansion of the polynomial which is the product of all `I(p)` for `p` in `P`, and for any natural number `i`, `D^i * coeff i H` is a positive integer, then for any natural number `i`, `D^i * coeff i (H pow k)` is a positive integer.

### Informal sketch
The proof proceeds by induction on `k`. The base case `k = 0` is trivial. For the inductive step, we need to show that if `!i. D pow i * coeff i (poly_pow QinC_ring H k) IN ZinC`, then `!i. D pow i * coeff i (poly_pow QinC_ring H (k+1)) IN ZinC`. The theorem relies on the following key steps:

- Assuming `!i. D pow i * coeff i H IN ZinC` [transcendence_H_denom]. Namely, we assume that the coefficients of `H` scaled by `D^i` are integers.
- We have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys]. This states that the polynomials `p` in `P` are ring polynomials.
- Then we derive `!p:(1->num)->complex. p IN P ==> ring_powerseries QinC_ring (I p)` [ring_polynomial;I_THM]. I(p) is a ring power series.
- We demonstrate that `ring_powerseries QinC_ring (poly_product QinC_ring P I:(1->num)->complex)` [poly_product_series]. The polynomial product of power series I(p) is a ring powerseries.
- Finally, we show that `ring_powerseries QinC_ring (H:(1->num)->complex)` [x_truncreverse_series]. H is a ring powerseries.
- The induction step is handled via `denominator_reverse_pow`.

### Mathematical insight
The theorem establishes a result about the denominators of coefficients in powers of a specific algebraic number. The condition `D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC` requires some power of `D` to clear the denominators of the coefficients of the minimal polynomial of `p`. The polynomial `H` which occurs in the theorem, is derived from the minimal polynomials in `P`. The result relates coefficients of powers of `H`, `H pow k`, to these denominators.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ZinC`
- `coeff`
- `poly_deg`
- `QinC_ring`
- `nsum`
- `poly_product`
- `I`
- `x_truncreverse`
- `poly_pow`
- `transcendence_H_denom`
- `ring_polynomial`
- `I_THM`
- `poly_product_series`
- `x_truncreverse_series`
- `denominator_reverse_pow`

### Porting notes (optional)
The theorem's proof depends on properties of polynomials, power series, and algebraic numbers. Porting efforts must ensure the target theories have appropriate definitions and theorems for these concepts. The `I` function is implicitly converting polynomial `p` into a power series. HOL Light's `x_truncreverse` and `denominator_reverse_pow` may need special attention during porting, as they are likely specific to its library.


---

## transcendence_newton_pe

### Name of formal statement
transcendence_newton_pe

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_newton_pe = prove(`
  !P p e.
  FINITE P ==>
  distinct_minpolys P ==>
  p IN P ==>
  poly_mul complex_ring (
    poly_pow complex_ring (
      x_truncreverse complex_ring (poly_deg complex_ring p) p
    ) (e + 1)
  ) (
    poly_sum complex_ring (complex_root p) (\s.
      series_from_coeffs (\n.
        ring_mul complex_ring (
          Cx(&(FACT e * binom (n,e)))
        ) (
          ring_pow complex_ring s (n - e)
        )
      )
    )
  )
  = scaled_pow_newton_rightside complex_ring I (complex_root p) e
`,
  intro THEN
  have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_irreducible(x_poly QinC_ring) p` [distinct_minpolys] THEN
  have `monic QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  recall subring_complex_QinC THEN
  have `monic complex_ring (p:(1->num)->complex)` [monic_subring] THEN
  have `~(p:(1->num)->complex = poly_0 complex_ring)` [monic_poly_0;field_complex;field] THEN
  have `ring_squarefree(x_poly QinC_ring) p` [squarefree_if_irreducible_over_field;field_QinC] THEN
  have `ring_squarefree(x_poly complex_ring) p` [monic_QinC_squarefree_complex_squarefree] THEN
  have `monic_vanishing_at complex_ring (complex_root p) I = p` [monic_vanishing_at_complex_root] THEN
  have `FINITE (complex_root p)` [distinct_minpolys_finite_root] THEN
  have `!c. c IN complex_root p ==> I c IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`I:complex->complex`;`complex_root p`]deg_monic_vanishing_at THEN
  have `poly_deg complex_ring (p:(1->num)->complex) = CARD(complex_root p)` [distinct_minpolys_card_root] THEN
  specialize[`complex_ring`;`I:complex->complex`;`complex_root p`;`e:num`]scaled_pow_newton_identities_monic_vanishing_at THEN
  subgoal `poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (ring_of_num complex_ring (FACT e * binom (n,e))) (ring_pow complex_ring (I s) (n - e)))) = poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))` THENL [
    sufficesby poly_sum_eq THEN
    intro THEN
    sufficesby eq_coeff THEN
    intro THEN
    simp[coeff_series_from_coeffs] THEN
    simp[ring_of_num_complex;complex_of_num;I_THM]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For all sets `P` of polynomials, polynomials `p`, and natural numbers `e`, if `P` is finite, the polynomials in `P` are distinct minimal polynomials, `p` is in `P`, then the polynomial resulting from multiplying `poly_pow` of the truncated and reversed polynomial `p` (truncated at its degree) to the power of `(e + 1)` by the sum over the roots of `p` of a series (where the nth coefficient of the series at root `s` is `FACT e * binom (n, e) * s^(n - e)`) is equal to `scaled_pow_newton_rightside complex_ring I (complex_root p) e`.

### Informal sketch

*   The proof starts by introducing the assumptions `P`, `p`, and `e`.
*   It uses the assumption `distinct_minpolys P` to prove that `p` is a ring polynomial over `QinC_ring` and that `p` is irreducible over `QinC_ring`, and thus that `p` is monic over `QinC_ring`.
*   Then it proves that `p` is also a ring polynomial over `complex_ring`.
*   Then it proves that `p` is monic over `complex_ring` and not equal to zero.
*   Then it is show, using `squarefree_if_irreducible_over_field` due to the field being `QinC`, that `p` is squarefree.
*   Then it concludes that `p` is squarefree also over `complex_ring`.
*   It shows that the monic vanishing polynomial `monic_vanishing_at complex_ring (complex_root p) I` is equal to `p`.
*   It specialises `deg_monic_vanishing_at` with `complex_ring`, `I`, and `complex_root p` to show that the degree of `p` is the cardinality of the roots of `p` (using `distinct_minpolys_card_root`).
*   Specialising `scaled_pow_newton_identities_monic_vanishing_at`.
*   The goal is reduced to showing: `poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (ring_of_num complex_ring (FACT e * binom (n,e))) (ring_pow complex_ring (I s) (n - e)))) = poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))`.
*   This equality is proven by showing that the coefficients of the two polynomials are equal, using `poly_sum_eq` and `eq_coeff`. Simplification is done using rules for coefficients `coeff_series_from_coeffs`, `ring_of_num_complex`,`complex_of_num` and the definition of `I_THM`.

### Mathematical insight
This theorem relates the polynomial `p` with distinct minimal polynomials to `scaled_pow_newton_rightside complex_ring I (complex_root p) e` where `scaled_pow_newton_rightside` involves taking derivatives of a monic polynomial.
It involves the algebraic manipulation of polynomials and their roots, along with combinatorial identities.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `poly_mul`
- `poly_pow`
- `x_truncreverse`
- `poly_deg`
- `poly_sum`
- `complex_root`
- `series_from_coeffs`
- `ring_mul`
- `FACT`
- `binom`
- `ring_pow`
- `scaled_pow_newton_rightside`
- `intro`
- `QinC_ring`
- `ring_irreducible`
- `x_poly`
- `monic`
- `poly_complex_if_poly_QinC`
- `subring_complex_QinC`
- `monic_subring`
- `monic_poly_0`
- `field_complex`
- `field`
- `ring_squarefree`
- `squarefree_if_irreducible_over_field`
- `field_QinC`
- `monic_QinC_squarefree_complex_squarefree`
- `monic_vanishing_at_complex_root`
- `distinct_minpolys_finite_root`
- `in_complex_ring`
- `deg_monic_vanishing_at`
- `distinct_minpolys_card_root`
- `scaled_pow_newton_identities_monic_vanishing_at`
- `sufficesby`
- `poly_sum_eq`
- `eq_coeff`
- `coeff_series_from_coeffs`
- `ring_of_num_complex`
- `complex_of_num`
- `I_THM`

### Porting notes
- The proof relies on several algebraic properties of polynomials and their roots.
- Ensure that the target proof assistant has equivalent theorems for irreducibility, squarefreeness, and the relationship between a polynomial's degree and the cardinality of its roots.
- The tactic calls provide a high-level overview of the proof strategy. Translating the tactic script directly might not be the most effective approach; instead, focus on reproducing the logical flow and mathematical reasoning.


---

## transcendence_newton_He_Ge

### Name of formal statement
transcendence_newton_He_Ge

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_newton_He_Ge = prove(`
  !P t H.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  !p Gp.
  p IN P ==>
  Gp = poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p) ==>
  !e.
  poly_mul complex_ring (
    poly_pow complex_ring H (e+1)
  ) (
    poly_sum complex_ring (complex_root p) (\s.
      series_from_coeffs (\n.
        ring_mul complex_ring (
          Cx(&(FACT e * binom (n,e)))
        ) (
          ring_pow complex_ring s (n - e)
        )
      )
    )
  )
  =
  poly_mul complex_ring (
    poly_pow complex_ring Gp (e+1)
  ) (
    scaled_pow_newton_rightside complex_ring I (complex_root p) e
  )
`,
  intro THEN
  have `ring_polynomial QinC_ring (p:(1->num)->complex)` [distinct_minpolys] THEN
  def `revp:(1->num)->complex` `x_truncreverse QinC_ring (poly_deg complex_ring p) p` THEN
  have `revp = x_truncreverse complex_ring (poly_deg complex_ring p) p` [x_truncreverse_subring;subring_complex_QinC] THEN
  specialize[`P:((1->num)->complex)->bool`;`H:(1->num)->complex`;`t:num`]transcendence_H_product_complex_ring THEN
  subgoal `H = poly_mul complex_ring revp Gp:(1->num)->complex` THENL [
    specialize_assuming[`complex_ring`;`P:((1->num)->complex)->bool`;`p:(1->num)->complex`;`\q:(1->num)->complex. x_truncreverse QinC_ring (poly_deg complex_ring q) q`]poly_product_delete THEN
    qed[series_complex]
  ; pass
  ] THEN
  have `H = poly_mul complex_ring Gp revp:(1->num)->complex` [POLY_MUL_SYM;series_complex] THEN
  def `Z:(1->num)->complex` `poly_sum complex_ring (complex_root p) (\s.  series_from_coeffs (\n. ring_mul complex_ring (Cx(&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))` THEN
  have `poly_mul complex_ring (poly_pow complex_ring revp (e + 1)) Z = scaled_pow_newton_rightside complex_ring I (complex_root p) e` [transcendence_newton_pe] THEN
  have `poly_pow complex_ring H (e+1) = poly_mul complex_ring (poly_pow complex_ring Gp (e+1)) (poly_pow complex_ring revp (e+1)):(1->num)->complex` [poly_mul_pow;series_complex] THEN
  qed[POLY_MUL_ASSOC;series_complex]
);;
```
### Informal statement
For all `P`, `t`, and `H`, if `P` is finite and the minimal polynomials in `P` are distinct and `t` is the sum over `P` of the degrees of the polynomials in `P` and `H` is the truncated reversed polynomial product of `P` up to degree t, then for all `p` in `P`, if `Gp` is the polynomial product of `P \ {p}` where each polynomial `q` is truncated and reversed to its degree, then for all `e`, the polynomial multiplication of the polynomial `H` raised to the power `e+1` and the sum over the roots `s` of `p` of the series with coefficients given by `FACT e * binom(n,e) * s^(n-e)` is equal to the polynomial multiplication of the polynomial `Gp` raised to the power `e+1` and `scaled_pow_newton_rightside complex_ring I (complex_root p) e`.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions.
- Establishing that `p` is a ring polynomial over `QinC_ring` using `distinct_minpolys`.
- Defining `revp` as the truncated reversed polynomial of `p`.
- Showing that `revp` is the truncated reversed polynomial of `p` over complex numbers.
- Specializing the theorem `transcendence_H_product_complex_ring` to the current context.
- Showing `H = poly_mul complex_ring revp Gp` by specializing `poly_product_delete` and using `series_complex`.
- Showing `H = poly_mul complex_ring Gp revp` by commutativity of multiplication.
- Defining `Z` as the sum of series involving roots of `p`.
- Applying `transcendence_newton_pe` to relate `poly_mul complex_ring (poly_pow complex_ring revp (e + 1)) Z` and `scaled_pow_newton_rightside complex_ring I (complex_root p) e`.
- Showing `poly_pow complex_ring H (e+1) = poly_mul complex_ring (poly_pow complex_ring Gp (e+1)) (poly_pow complex_ring revp (e+1))` using `poly_mul_pow`.
- Concluding by associativity of multiplication.

### Mathematical insight
This theorem relates certain polynomial expressions involving the minimal polynomials of algebraic numbers, their roots, and truncations/reversals. These relations are crucial in the proof of transcendence results, specifically in constructing auxiliary functions with special properties. The truncated reversed polynomials and their power sums play a key role in eliminating denominators and controlling growth rates in transcendence arguments.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `nsum`
- `poly_deg`
- `complex_ring`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `complex_root`
- `series_from_coeffs`
- `ring_mul`
- `FACT`
- `binom`
- `ring_pow`
- `DELETE`
- `poly_pow`
- `poly_sum`
- `scaled_pow_newton_rightside`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `POLY_MUL_SYM`
- `transcendence_newton_pe`
- `poly_mul_pow`
- `POLY_MUL_ASSOC`


---

## transcendence_newton_Hk

### Name of formal statement
transcendence_newton_Hk

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_newton_Hk = prove(`
  !P t H p Gp e k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  p IN P ==>
  Gp = poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p) ==>
  e < k ==>
  poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    poly_sum complex_ring (complex_root p) (\s.
      series_from_coeffs (\n.
        ring_mul complex_ring (
          Cx(&(FACT e * binom (n,e)))
        ) (
          ring_pow complex_ring s (n - e)
        )
      )
    )
  )
  =
  poly_mul complex_ring (
    poly_pow complex_ring H (k-(e+1))
  ) (
    poly_mul complex_ring (
      poly_pow complex_ring Gp (e+1)
    ) (
      scaled_pow_newton_rightside complex_ring I (complex_root p) e
    )
  )
`,
  intro THEN
  have `poly_mul complex_ring (poly_pow complex_ring H (e+1)) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx(&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))) = poly_mul complex_ring (poly_pow complex_ring Gp (e+1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [transcendence_newton_He_Ge] THEN
  num_linear_fact `e < k ==> k = (k-(e+1))+(e+1)` THEN
  have `poly_pow complex_ring (H:(1->num)->complex) k = poly_mul complex_ring (poly_pow complex_ring H (k-(e+1))) (poly_pow complex_ring H (e+1))` [poly_pow_add;series_complex] THEN
  qed[POLY_MUL_ASSOC;series_complex]
);;
```
### Informal statement
For all finite sets `P` of polynomials, all natural numbers `t`, `H`, `p`, `Gp`, `e`, and `k`, if `P` is finite, the minimal polynomials in `P` are distinct, `t` is the sum over `P` of the degrees of the polynomials in `P`, `H` is the truncation of the product of the polynomials in `P` at degree `t`, `p` is an element of `P`, `Gp` is the product of the polynomials in `P` excluding `p`, where each polynomial is truncated to its degree, and `e` is less than `k`, then the polynomial multiplication of `H` raised to the power of `k` with the sum of series derived from complex roots of `p` equals the polynomial multiplication of `H` to power `k-(e+1)` with polynomial multiplication of `Gp` raised to `e+1` with `scaled_pow_newton_rightside` term involving complex roots of `p` and `e`.

### Informal sketch
The proof shows that if `P` is a finite set of distinct minimal polynomials and certain conditions hold for `t`, `H`, `p`, `Gp`, `e`, and `k`, then a particular polynomial equation is true.

- The proof starts by introducing assumptions.
- It uses the previously-proved theorem `transcendence_newton_He_Ge` which establishes an equality for `poly_mul complex_ring (poly_pow complex_ring H (e+1)) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx(&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))) = poly_mul complex_ring (poly_pow complex_ring Gp (e+1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)`.
- The arithmetic fact `e < k ==> k = (k-(e+1))+(e+1)` is used to decompose `k`.
- The equation `poly_pow complex_ring (H:(1->num)->complex) k = poly_mul complex_ring (poly_pow complex_ring H (k-(e+1))) (poly_pow complex_ring H (e+1))` is proved using `poly_pow_add` and `series_complex`.
- Finally, `POLY_MUL_ASSOC` and `series_complex` are used to conclude.

### Mathematical insight
This theorem looks to be a step in a larger proof of transcendence, likely related to constructing algebraic approximations and bounding error terms. The equality established in the theorem probably helps in relating different polynomial expressions that arise in the transcendence proof. The `scaled_pow_newton_rightside` term suggests the use of Newton's method or similar approximation techniques.

### Dependencies
- `transcendence_newton_He_Ge`
- `poly_pow_add`
- `series_complex`
- `POLY_MUL_ASSOC`


---

## transcendence_newton_Hk_psum

### Name of formal statement
transcendence_newton_Hk_psum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_newton_Hk_psum = prove(`
  !P B t H G u e k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!p. p IN P ==> G p = poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q)) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  e < k ==>
  poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    series_from_coeffs (\n.
      Cx(&(FACT(e) * binom(n,e))) * u(n-e)
    )
  )
  =
  poly_sum complex_ring P (\p:(1->num)->complex.
    poly_mul complex_ring (
      poly_const complex_ring ((complex_of_int(B p)))
    ) (
      poly_mul complex_ring (
        poly_pow complex_ring H (k-(e+1))
      ) (
        poly_mul complex_ring (
          poly_pow complex_ring (G p) (e+1)
        ) (
          scaled_pow_newton_rightside complex_ring I (complex_root p) e
        )
      )
    )
  )
`,
  intro THEN
  subgoal `series_from_coeffs (\n. Cx(&(FACT(e) * binom(n,e))) * u(n-e)) = poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx(&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))))` THENL [
    sufficesby eq_coeff THEN
    intro THEN
    rw[coeff_series_from_coeffs] THEN
    simp[coeff_poly_sum;series_complex] THEN
    simp[coeff_poly_const_times;series_complex;in_complex_ring] THEN
    rw[complex_ring_clauses] THEN
    subgoal `ring_sum complex_ring P (\a. (complex_of_int(B a)) * coeff d (poly_sum complex_ring (complex_root a) (\s. series_from_coeffs (\n. Cx (&(FACT e * binom (n,e))) * ring_pow complex_ring s (n - e))))) = ring_sum complex_ring P (\a. (complex_of_int(B a)) * ring_sum complex_ring (complex_root a) (\s. Cx (&(FACT e * binom (d,e))) * ring_pow complex_ring s (d - e)))` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      have `FINITE(complex_root a)` [distinct_minpolys_finite_root] THEN
      simp[coeff_poly_sum;series_complex] THEN
      rw[coeff_series_from_coeffs]
    ; pass
    ] THEN
    simp[] THEN
    subgoal `Cx (&(FACT e * binom (d,e))) * ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p (d - e)) = ring_sum complex_ring P (\p. Cx (&(FACT e * binom (d,e))) * (complex_of_int(B p)) * complex_root_powersums p (d - e))` THENL [
      rw[GSYM complex_ring_clauses] THEN
      specialize_assuming[`complex_ring`;`\p. ring_mul complex_ring ((complex_of_int(B p))) (complex_root_powersums p (d - e))`;`Cx(&(FACT e * binom(d,e)))`;`P:((1->num)->complex)->bool`]RING_SUM_LMUL THEN
      qed[in_complex_ring]
    ; pass
    ] THEN
    simp[] THEN
    sufficesby RING_SUM_EQ THEN
    intro THEN
    rw[complex_root_powersums;ring_pow_complex] THEN
    subgoal `ring_sum complex_ring (complex_root a) (\s. Cx (&(FACT e * binom (d,e))) * s pow (d - e)) = Cx (&(FACT e * binom (d,e))) * ring_sum complex_ring (complex_root a) (\s. s pow (d - e))` THENL [
      rw[GSYM complex_ring_clauses] THEN
      have `FINITE(complex_root a)` [distinct_minpolys_finite_root] THEN
      specialize_assuming[`complex_ring`;`\s:complex. s pow (d-e)`;`Cx(&(FACT e * binom(d,e)))`;`complex_root a`]RING_SUM_LMUL THEN
      qed[in_complex_ring]
    ; pass
    ] THEN
    simp[] THEN
    complex_field_fact `Cx (&(FACT e * binom (d,e))) * (complex_of_int(B a)) * ring_sum complex_ring (complex_root a) (\z. z pow (d - e)) = (complex_of_int(B a)) * Cx (&(FACT e * binom (d,e))) * ring_sum complex_ring (complex_root a) (\z. z pow (d - e))` THEN
    qed[]
  ; pass
  ] THEN
  subgoal `poly_mul complex_ring (poly_pow complex_ring H k) (poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))))) = poly_sum complex_ring P (\p. poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))))` THENL [
    specialize_assuming[`complex_ring`;`\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))`;`poly_pow complex_ring H k:(1->num)->complex`;`P:((1->num)->complex)->bool`]poly_sum_lmul THEN
    qed[series_complex]
  ; pass
  ] THEN
  subgoal `poly_sum complex_ring P (\p. poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))))) = poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))` THENL [
    sufficesby poly_sum_eq THEN
    intro THEN
    rw[BETA_THM] THEN
    have `poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))) = poly_mul complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) (poly_const complex_ring ((complex_of_int(B s))))) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))` [POLY_MUL_ASSOC;series_complex] THEN
    have `poly_mul complex_ring (poly_pow complex_ring H k) (poly_const complex_ring ((complex_of_int(B(s:(1->num)->complex))))) = poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_pow complex_ring H k):(1->num)->complex` [POLY_MUL_SYM;series_complex] THEN
    have `poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))) = poly_mul complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_pow complex_ring H k)) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))` [] THEN
    have `poly_mul complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_pow complex_ring H k)) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))) = poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_mul complex_ring (poly_pow complex_ring H k) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))))` [POLY_MUL_ASSOC;series_complex] THEN
    have `poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))) = poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B s)))) (poly_mul complex_ring (poly_pow complex_ring H k) (poly_sum complex_ring (complex_root s) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))))` [] THEN
    have `G(s:(1->num)->complex) = poly_product complex_ring (P DELETE s) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q)` [] THEN
    subgoal `poly_product complex_ring (P DELETE s) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q) = poly_product complex_ring (P DELETE s) (\q. x_truncreverse complex_ring (poly_deg complex_ring q) q)` THENL [
      sufficesby poly_product_eq THEN
      qed[x_truncreverse_subring;subring_complex_QinC]
    ; pass
    ] THEN
    have `G(s:(1->num)->complex) = poly_product complex_ring (P DELETE s) (\q. x_truncreverse complex_ring (poly_deg complex_ring q) q)` [] THEN
    specialize_assuming[`P:((1->num)->complex)->bool`;`t:num`;`H:(1->num)->complex`;`s:(1->num)->complex`;`G(s:(1->num)->complex):(1->num)->complex`;`e:num`;`k:num`]transcendence_newton_Hk THEN
    have `poly_mul complex_ring (poly_pow complex_ring H k) (poly_sum complex_ring (complex_root s) (\z. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring z (n - e))))) = poly_mul complex_ring (poly_pow complex_ring H (k-(e+1))) (poly_mul complex_ring (poly_pow complex_ring (G s) (e+1)) (scaled_pow_newton_rightside complex_ring I (complex_root s) e))` [] THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For all `P`, `B`, `t`, `H`, `G`, `u`, `e`, and `k`, if `P` is a finite set of polynomials, the minimal polynomials in `P` are distinct, `t` is the sum over `P` of the degrees of the polynomials `p` in `P`, `H` is the polynomial obtained by truncating the formal power series of the polynomial which is the product of the polynomials in `P`, `G` maps each polynomial `p` in `P` to the polynomial which is the product over the polynomials in `P` excluding `p` of the truncation of `q` at degree `poly_deg complex_ring q`, `u` maps each `n` to the sum over polynomials `p` in `P` of `complex_of_int(B p)` times the complex root powersums of `p` at `n`, and `e` is less than `k`, then the polynomial which is the product of `H` raised to the `k`th power and the formal power series with coefficients `Cx(&(FACT(e) * binom(n,e))) * u(n-e)` is equal to the sum over `P` of the polynomial which is the product of `complex_of_int(B p)` and the product of `H` raised to the power `k-(e+1)` and `G(p)` raised to the power `e+1` and `scaled_pow_newton_rightside complex_ring I (complex_root p) e`.

### Informal sketch
The proof shows that the polynomial 
```
poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. Cx(&(FACT(e) * binom(n,e))) * u(n-e)))
```
is equal to the polynomial
```
poly_sum complex_ring P (\p:(1->num)->complex.
    poly_mul complex_ring (
      poly_const complex_ring ((complex_of_int(B p)))
    ) (
      poly_mul complex_ring (
        poly_pow complex_ring H (k-(e+1))
      ) (
        poly_mul complex_ring (
          poly_pow complex_ring (G p) (e+1)
        ) (
          scaled_pow_newton_rightside complex_ring I (complex_root p) e
        )
      )
    )
  )
```
- The first subgoal involves proving that `series_from_coeffs (\n. Cx(&(FACT(e) * binom(n,e))) * u(n-e))` is equal to `poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e))))))`. This is done by showing that the coefficients of the series are equal on both sides.
- After simplification, the proof relies on the fact that `ring_sum complex_ring P (\a. (complex_of_int(B a)) * coeff d (poly_sum complex_ring (complex_root a) (\s. series_from_coeffs (\n. Cx (&(FACT e * binom (n,e))) * ring_pow complex_ring s (n - e)))))` equals `ring_sum complex_ring P (\a. (complex_of_int(B a)) * ring_sum complex_ring (complex_root a) (\s. Cx (&(FACT e * binom (d,e))) * ring_pow complex_ring s (d - e)))`. This step uses `RING_SUM_EQ` tactic.
- This leads to proving `Cx (&(FACT e * binom (d,e))) * ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p (d - e)) = ring_sum complex_ring P (\p. Cx (&(FACT e * binom (d,e))) * (complex_of_int(B p)) * complex_root_powersums p (d - e))`. This is shown using `GSYM complex_ring_clauses` and `RING_SUM_LMUL`.
- Finally, the goal reduces to showing that `ring_sum complex_ring (complex_root a) (\s. Cx (&(FACT e * binom (d,e))) * s pow (d - e)) = Cx (&(FACT e * binom (d,e))) * ring_sum complex_ring (complex_root a) (\s. s pow (d - e))`, which again employs `RING_SUM_LMUL`. `complex_field_fact` is used to commute multiplication in the complex field.
- The second subgoal involves showing that `poly_mul complex_ring (poly_pow complex_ring H k) (poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))))` is equal to `poly_sum complex_ring P (\p. poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))))`. This uses `poly_sum_lmul`.
- The last subgoal consists of proving that `poly_sum complex_ring P (\p. poly_mul complex_ring (poly_pow complex_ring H k) (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_sum complex_ring (complex_root p) (\s. series_from_coeffs (\n. ring_mul complex_ring (Cx (&(FACT e * binom (n,e)))) (ring_pow complex_ring s (n - e)))))))` is equal to `poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))`. This step uses the theorem `transcendence_newton_Hk` after simplification steps involving polynomial multiplication associativity and commutativity.

### Mathematical insight
This theorem is a step towards proving the transcendence of `e`. It relates a polynomial involving powers of another polynomial `H` and a series defined in terms of root power sums to a sum of polynomials involving `scaled_pow_newton_rightside`. This identity is crucial for bounding certain expressions and ultimately showing that `e` cannot be algebraic.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `nsum`
- `poly_deg`
- `complex_ring`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `I`
- `DELETE`
- `complex_of_int`
- `complex_root_powersums`
- `series_from_coeffs`
- `Cx`
- `FACT`
- `binom`
- `poly_mul`
- `poly_pow`
- `poly_sum`
- `poly_const`
- `scaled_pow_newton_rightside`
- `complex_root`
- `eq_coeff`
- `coeff_series_from_coeffs`
- `coeff_poly_sum`
- `series_complex`
- `coeff_poly_const_times`
- `in_complex_ring`
- `complex_ring_clauses`
- `ring_sum`
- `ring_pow`
- `series_complex`
- `distinct_minpolys_finite_root`
- `RING_SUM_EQ`
- `GSYM complex_ring_clauses`
- `RING_SUM_LMUL`
- `complex_root_powersums`
- `ring_pow_complex`
- `complex_field_fact`
- `poly_sum_lmul`
- `BETA_THM`
- `POLY_MUL_ASSOC`
- `POLY_MUL_SYM`
- `poly_product_eq`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `transcendence_newton_Hk`


---

## transcendence_Huv_lemma

### Name of formal statement
transcendence_Huv_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Huv_lemma = prove(`
  !H u k.
  poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    series_from_coeffs (\n.
      ring_sum complex_ring {e | e < k} (\e.
        Cx(&(FACT(e) * binom(n,e))) * u(n-e)
      )
    )
  )
  =
  poly_sum complex_ring {e | e < k} (\e:num.
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs (\n.
        Cx(&(FACT e * binom (n,e))) * u(n-e))
    )
  )
`,
  intro THEN
  have `FINITE {e:num | e < k}` [FINITE_NUMSEG_LT] THEN
  subgoal `series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx(&(FACT(e) * binom(n,e))) * u(n-e))) = poly_sum complex_ring {e | e < k} (\e:num. series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e)))` THENL [
    sufficesby eq_coeff THEN
    intro THEN
    rw[coeff_series_from_coeffs] THEN
    simp[coeff_poly_sum;series_complex] THEN
    sufficesby RING_SUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    rw[coeff_series_from_coeffs]
  ; pass
  ] THEN
  specialize[`complex_ring`
    ;`\e:num. series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e))`
  ]poly_sum_lmul THEN
  have `
  poly_sum complex_ring {e | e < k} (\e:num.
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs (\n.
        Cx(&(FACT e * binom (n,e))) * u(n-e))
    )
  )
  =
  poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    poly_sum complex_ring {e | e < k} (\e:num.
      series_from_coeffs (\n.
        Cx(&(FACT e * binom (n,e))) * u(n-e))
    )
  )
  ` [series_complex] THEN
  qed[]
);;
```
### Informal statement
For all complex-valued functions `H` and `u` and for all natural numbers `k`, the polynomial `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx(&(FACT(e) * binom(n,e))) * u(n-e))))` is equal to `poly_sum complex_ring {e | e < k} (\e:num. poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e))))`.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions `H`, `u`, and `k`.
- Showing that the set `{e | e < k}` is finite.
- Reducing the main goal to proving that `series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx(&(FACT(e) * binom(n,e))) * u(n-e))) = poly_sum complex_ring {e | e < k} (\e:num. series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e)))`. This is proven by showing that the coefficients of each side of equality are the same, expanding the definitions using `coeff_series_from_coeffs`, `coeff_poly_sum`, and `series_complex`, and finally using `RING_SUM_EQ`.
- Using the lemma `poly_sum_lmul`, instantiated with `complex_ring` and `\e:num. series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e))`.
- The final step is to prove the equality `poly_sum complex_ring {e | e < k} (\e:num. poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e)))) = poly_mul complex_ring (poly_pow complex_ring H k) (poly_sum complex_ring {e | e < k} (\e:num. series_from_coeffs (\n. Cx(&(FACT e * binom (n,e))) * u(n-e))))` by using the definition `series_complex`.

### Mathematical insight
This lemma is related to showing that a certain expression, which involves a sum (indexed by *e*) of series, can be rearranged. Specifically the goal is to show that a certain power (`poly_pow complex_ring H k`) can be factored out of that sum. The polynomials represented as series of coefficients, use the complex field as their ring. The constant `Cx(&(FACT e * binom (n,e)))` represents a constant polynomial.

### Dependencies
- `FINITE_NUMSEG_LT`
- `complex_ring`
- `coeff_series_from_coeffs`
- `coeff_poly_sum`
- `series_complex`
- `poly_sum_lmul`
- `BETA_THM`


---

## transcendence_H_main

### Name of formal statement
transcendence_H_main

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_main = prove(`
  !P B t H G u k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!p. p IN P ==> G p = poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    series_from_coeffs (\n.
      ring_sum complex_ring {e | e < k} (\e.
        Cx(&(FACT(e) * binom(n,e))) * u(n-e)
      )
    )
  )
  = poly_sum complex_ring {e | e < k} (\e:num.
      poly_sum complex_ring P (\p:(1->num)->complex.
        poly_mul complex_ring (
          poly_const complex_ring ((complex_of_int(B p)))
        ) (
          poly_mul complex_ring (
            poly_pow complex_ring H (k-(e+1))
          ) (
            poly_mul complex_ring (
              poly_pow complex_ring (G p) (e+1)
            ) (
              scaled_pow_newton_rightside complex_ring I (complex_root p) e
            )
          )
        )
      )
    )
`,
  intro THEN
  rw[transcendence_Huv_lemma] THEN
  sufficesby poly_sum_eq THEN
  intro THEN
  rw[BETA_THM] THEN
  set_fact `s IN {e | e < k} ==> s < k:num` THEN
  qed[transcendence_newton_Hk_psum]
);;
```

### Informal statement
Given a finite set `P` of polynomials with distinct minimal polynomials, let `t` be the sum of the degrees of these polynomials, and let `H` be the truncation and reversal of the polynomial, which is the product of the polynomials in the set `P` multiplied with `I`. Also, for each polynomial `p` in `P`, let `G p` be the product of the polynomials in `P` excluding `p`, each truncated and reversed to the degree of `p`. Further, suppose `u n` is defined as the sum of the product of the integer coefficient `B p` associated with `p` and the `n`-th power sum of the roots of `p`, summed over all `p` in `P`. Then, the product of the `k`-th power of `H` and a polynomial whose coefficients are sums (ranging over `e` less than `k`) of `Cx(&(FACT(e) * binom(n,e))) * u(n-e)` is equal to the sum (ranging over `e` less than `k`) of sums (ranging over `p` in `P`) of the product of `B p`, the `(k-(e+1))`th power of `H`, the `(e+1)`th power of `G p`, and `scaled_pow_newton_rightside complex_ring I (complex_root p) e`.

### Informal sketch
- The theorem is proved by introducting the assumptions, then applying the lemma `transcendence_Huv_lemma` and then proving the equality of two polynomial sums with `poly_sum_eq`.
- `transcendence_Huv_lemma` unfolds some definitions and simplifies the main expression.
- `poly_sum_eq` reduces to showing the equality of terms inside the outer sum.
- By introducing a variable `s` and assuming it is in `{e | e < k}`, then deducing `s < k:num`, and then applying `transcendence_newton_Hk_psum` to conclude the proof.
- `transcendence_newton_Hk_psum` likely involves manipulations related to Newton's sums formulas and properties of power sums of roots of polynomials.

### Mathematical insight
This theorem seems to be a core step in a proof related to transcendence theory, likely connecting polynomials, their roots, and certain sums of powers of those roots. The construction of `H` and `G` suggests an inductive argument or a telescoping sum argument where contributions from individual polynomials are isolated and manipulated. `scaled_pow_newton_rightside` hints at using Newton's identities to relate power sums to elementary symmetric polynomials. It might also involve a careful manipulation of combinatorial coefficients.

### Dependencies
- `transcendence_Huv_lemma`
- `poly_sum_eq`
- `transcendence_newton_Hk_psum`


---

## transcendence_Htimes_poly

### Name of formal statement
transcendence_Htimes_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Htimes_poly = prove(`
  !P B t H u k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  ring_polynomial complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs (\n.
        ring_sum complex_ring {e | e < k} (\e.
          Cx(&(FACT(e) * binom(n,e))) * u(n-e)
        )
      )
    )
  )
`,
  intro THEN
  def `G:((1->num)->complex)->((1->num)->complex)` `\p. poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)` THEN
  have `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e)))) = poly_sum complex_ring {e | e < k} (\e. poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))` [transcendence_H_main] THEN
  have `FINITE {e:num | e < k}` [FINITE_NUMSEG_LT] THEN
  subgoal `!e. e IN {e | e < k} ==> ring_polynomial complex_ring (poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))` THENL [
    intro THEN
    subgoal `!p:(1->num)->complex. p IN P ==> ring_polynomial complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))` THENL [
      intro THEN
      have `ring_polynomial complex_ring (poly_const complex_ring ((complex_of_int(B(p:(1->num)->complex)))):(1->num)->complex)` [RING_POLYNOMIAL_CONST;in_complex_ring] THEN
      have `ring_polynomial complex_ring (poly_pow complex_ring H (k - (e + 1)):(1->num)->complex)` [transcendence_H_poly;poly_pow_poly;poly_complex_if_poly_QinC] THEN
      have `ring_polynomial complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1):(1->num)->complex)` [poly_pow_poly;transcendence_Gp_poly;poly_complex_if_poly_QinC] THEN
      have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
      have `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [poly_scaled_pow_newton_rightside;in_complex_ring] THEN
      qed[RING_POLYNOMIAL_MUL]
    ; pass
    ] THEN
    qed[poly_sum_poly]
  ; pass
  ] THEN
  qed[transcendence_H_main;poly_sum_poly]
);;
```

### Informal statement
For all `P`, `B`, `t`, `H`, `u`, and `k`, if `P` is a finite set of complex polynomials, if the polynomials in `P` have distinct minimal polynomials, if `t` is the sum over `P` of the degrees of the polynomials in `P`, if `H` is the polynomial obtained by truncating the formal power series of the product of polynomials in `P` at degree `t`, and if for all `n`, `u(n)` is the sum over `P` of the product of `complex_of_int(B p)` and the complex root powersums of `p` to the power `n`, then the following polynomial is a ring polynomial: the polynomial obtained by multiplying `H` raised to the power `k` by the power series whose `n`-th coefficient is the sum over `{e | e < k}` of `Cx(&(FACT(e) * binom(n,e))) * u(n-e)`.

### Informal sketch
The proof demonstrates that a particular polynomial constructed from a finite set of minimal polynomials, their degrees, truncation, complex root powersums, and other polynomial operations is indeed a ring polynomial.

- The core idea is to show that `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))))` can be rewritten as a sum of polynomials and then to show that each element of the sum is a ring polynomial. This rewriting is achieved by `transcendence_H_main`.
- It proceeds by induction on the set `{e | e < k}`. The base case isn't called out but the inductive hypothesis is used in assuming `!p:(1->num)->complex. p IN P ==> ring_polynomial complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))` where `G` is a function defined as `\p. poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)`.
- The proof utilizes several previously established results. `RING_POLYNOMIAL_CONST` shows `complex_of_int(B(p:(1->num)->complex))` is a ring polynomial. `transcendence_H_poly` along with `poly_pow_poly;poly_complex_if_poly_QinC` shows the polynomial `H` when raised to the power `(k-e+1)` is a ring polynomial. `poly_pow_poly;transcendence_Gp_poly;poly_complex_if_poly_QinC` proves that `G` raised to the power `(e+1)` is also a ring polynomial. `poly_scaled_pow_newton_rightside;in_complex_ring` proves `scaled_pow_newton_rightside complex_ring I (complex_root p) e` is also a ring polynomial.
- Finally using `RING_POLYNOMIAL_MUL` to show that each element in the sum is a ring polynomial.
- Finally, the theorem is proved using `poly_sum_poly` and `transcendence_H_main` to show that the polynomial in question is a ring polynomial.

### Mathematical insight
This theorem is likely a step in a larger argument related to transcendence theory. It constructs complex polynomials from sets of smaller degree polynomials based on their sums of roots in terms of `u(n)` and proves these constructed polynomial objects belong to the `ring_polynomial` type (i.e. polynomials whose coefficients belong to the complex ring).

### Dependencies
- `FINITE_NUMSEG_LT`
- `distinct_minpolys_finite_root`
- `transcendence_H_main`
- `RING_POLYNOMIAL_CONST`
- `transcendence_H_poly`
- `poly_pow_poly`
- `poly_complex_if_poly_QinC`
- `transcendence_Gp_poly`
- `poly_scaled_pow_newton_rightside`
- `RING_POLYNOMIAL_MUL`
- `poly_sum_poly`

### Porting notes (optional)
The port to other proof assistants may require adapting the definitions of polynomials, power series, and operations on them to match the target system's libraries. Also, the handling of complex numbers and their associated ring structure needs to be carefully considered for consistency.
Tactics such as `intro`, `def`, `have`, `subgoal`, `THEN`, `THENL`, `qed`, and `pass` are specific to HOL Light. The corresponding proof in another system will need to be built using the appropriate tactics or proof commands. The key dependencies listed will need to be ported beforehand.


---

## transcendence_H_deg_G_lemma

### Name of formal statement
transcendence_H_deg_G_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_deg_G_lemma = prove(`
  !p d g s t n:num.
  ~(p = 0) ==>
  d <= g + s ==>
  g <= (e+1)*n ==>
  s <= e + (p-1)*(e+1) ==>
  t = p+n ==>
  d <= e+(t-1)*(e+1)
`,
  intro THEN
  num_linear_fact `~(p = 0) ==> (p+n)-1 = n+(p-1)` THEN
  num_linear_fact `d <= g + s ==> g <= (e+1)*n ==> s <= e + (p-1)*(e+1) ==> d <= e+(n+(p-1))*(e+1)` THEN
  qed[]
);;
```
### Informal statement
For all natural numbers `p`, `d`, `g`, `s`, `t`, and `n`, if `p` is not equal to 0, and `d` is less than or equal to `g + s`, and `g` is less than or equal to `(e+1)*n`, and `s` is less than or equal to `e + (p-1)*(e+1)`, and `t` is equal to `p+n`, then `d` is less than or equal to `e+(t-1)*(e+1)`.

### Informal sketch
The proof is an algebraic simplification.
- Assume `p` is not equal to 0, `d <= g + s`, `g <= (e+1)*n`, `s <= e + (p-1)*(e+1)` and `t = p+n`.
- First, show that `(p+n)-1 = n+(p-1)`.
- Then derive `d <= e+(n+(p-1))*(e+1)` from the assumption that `d <= g + s ==> g <= (e+1)*n ==> s <= e + (p-1)*(e+1)`.
- The final goal `d <= e+(t-1)*(e+1)` follows by substituting `t = p+n`.

### Mathematical insight
The lemma establishes an inequality concerning the degrees of certain polynomials represented by `d`, `g`, `s` based on given conditions involving `p`, `n`, `e` and `t`. It is useful for proving transcendence results, likely by bounding degrees of polynomials involved in some approximation arguments.

### Dependencies
- `num_linear_fact`


---

## transcendence_H_deg_G

### Name of formal statement
transcendence_H_deg_G

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_deg_G = prove(`
  !P t p Gp e.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  p IN P ==>
  Gp = poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q) ==>
  poly_deg complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring Gp (e + 1)
    ) (
      scaled_pow_newton_rightside complex_ring I (complex_root p) e
    )
  ) <= e + (t-1)*(e+1)
`,
  intro THEN
  have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
  have `CARD(complex_root p) = poly_deg complex_ring p` [distinct_minpolys_card_root] THEN
  have `poly_deg complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e) <= e + (CARD(complex_root p)-1)*(e+1)` [deg_scaled_pow_newton_rightside;in_complex_ring] THEN
  have `poly_deg complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e) <= e + ((poly_deg complex_ring p)-1)*(e+1)` [deg_scaled_pow_newton_rightside;in_complex_ring] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> poly_deg complex_ring (x_truncreverse complex_ring (poly_deg complex_ring q) q) <= poly_deg complex_ring q` [deg_x_truncreverse_le;series_complex] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> ring_polynomial complex_ring (x_truncreverse complex_ring (poly_deg complex_ring q) q)` [x_truncreverse_poly;series_complex] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> poly_deg complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring q) q) <= poly_deg complex_ring q` [x_truncreverse_subring;subring_complex_QinC] THEN
  have `!q:(1->num)->complex. q IN P DELETE p ==> ring_polynomial complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring q) q)` [x_truncreverse_subring;subring_complex_QinC] THEN
  have `FINITE(P DELETE (p:(1->num)->complex))` [FINITE_DELETE] THEN
  specialize[`complex_ring`;`\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q`;`\q:(1->num)->complex. poly_deg complex_ring q`;`P DELETE (p:(1->num)->complex)`]poly_deg_product_le THEN
  have `poly_deg complex_ring (Gp:(1->num)->complex) <= nsum(P DELETE p) (\q:(1->num)->complex. poly_deg complex_ring q)` [] THEN
  have `ring_polynomial complex_ring (Gp:(1->num)->complex)` [transcendence_Gp_poly] THEN
  have `poly_deg complex_ring (poly_pow complex_ring Gp (e+1):(1->num)->complex) <= (e+1) * (poly_deg complex_ring Gp)` [poly_deg_pow_le] THEN
  have `poly_deg complex_ring (poly_pow complex_ring Gp (e+1):(1->num)->complex) <= (e+1) * nsum(P DELETE p) (\q:(1->num)->complex. poly_deg complex_ring q)` [LE_MULT2;LE_REFL;LE_TRANS] THEN
  have `t = (poly_deg complex_ring (p:(1->num)->complex)) + nsum(P DELETE p) (\q:(1->num)->complex. poly_deg complex_ring q)` [NSUM_DELETE] THEN
  have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
  have `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [poly_scaled_pow_newton_rightside;in_complex_ring] THEN
  have `poly_deg complex_ring (poly_mul complex_ring (poly_pow complex_ring Gp (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)) <= poly_deg complex_ring (poly_pow complex_ring Gp (e + 1)) + poly_deg complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [POLY_DEG_MUL_LE;poly_pow_poly] THEN
  have `~(poly_deg complex_ring (p:(1->num)->complex) = 0)` [distinct_minpolys_deg_nonzero] THEN
  specialize[
    `poly_deg complex_ring (p:(1->num)->complex)`;
    `poly_deg complex_ring (poly_mul complex_ring (poly_pow complex_ring Gp (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))`;
    `poly_deg complex_ring (poly_pow complex_ring (Gp:(1->num)->complex) (e + 1))`;
    `poly_deg complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)`;
    `t:num`;
    `nsum (P DELETE p) (\q:(1->num)->complex. poly_deg complex_ring q)`
  ]transcendence_H_deg_G_lemma THEN
  qed[]
);;
```

### Informal statement
For all sets of polynomials `P`, natural numbers `t`, polynomials `p`, polynomials `Gp`, and natural numbers `e`, if `P` is finite, all polynomials in `P` have distinct minimal polynomials, `t` is the sum over `P` of the degrees of each polynomial `p` in `P`, `p` is in `P`, and `Gp` is the product of polynomials (where each polynomial `q` in `P` excluding `p` is transformed into `x_truncreverse QinC_ring (poly_deg complex_ring q) q`), then the degree of the polynomial `poly_mul complex_ring (poly_pow complex_ring Gp (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` is less than or equal to `e + (t-1)*(e+1)`.

### Informal sketch
The proof proceeds as follows:
- We start with the assumptions that `P` is finite, all polynomials in `P` have distinct minimal polynomials, `t` represents the sum of the degrees of polynomials in `P`, `p` belongs to `P`, and `Gp` is a product of polynomials derived from `P` excluding `p`.
- We show `FINITE(complex_root p)` using `distinct_minpolys_finite_root`, meaning that set of roots is finite.
- Then we demonstrate `CARD(complex_root p) = poly_deg complex_ring p` using `distinct_minpolys_card_root`, i.e. the cardinality of the set of roots is equal to the degree of the polynomial.
- Next, we find an upper bound for the degree of `scaled_pow_newton_rightside complex_ring I (complex_root p) e` using `deg_scaled_pow_newton_rightside` and `in_complex_ring`.
- Using `deg_x_truncreverse_le` and `series_complex`, it is shown that the degree of `x_truncreverse` applied to a polynomial in `P DELETE p` is less than or equal to the degree of the original polynomial. Also using  `x_truncreverse_poly` and `series_complex` show that the transformed result `x_truncreverse` is still a ring polynomial.
- Using `x_truncreverse_subring` and `subring_complex_QinC` establish the same properties from the last step where the argument is `x_truncreverse QinC_ring...`.
- We apply `poly_deg_product_le` (after a specialization) and `FINITE_DELETE` to find an upper bound for the degree of `Gp`. Crucially, the finiteness condition is preserved when we remove `p`.
- Using `transcendence_Gp_poly`, show that `Gp` is a ring polynomial.
- We then find an upper bound for the degree of `poly_pow complex_ring Gp (e+1)` using `poly_deg_pow_le`, `LE_MULT2`, `LE_REFL`, and `LE_TRANS`.
- Next, we relate `t` to the degrees of `p` and the polynomials in `P DELETE p` using `NSUM_DELETE`.
- We show that `scaled_pow_newton_rightside complex_ring I (complex_root p) e` is a ring polynomial using `poly_scaled_pow_newton_rightside` and `in_complex_ring`.
- We find an upper bound for the degree of the product of `poly_pow complex_ring Gp (e + 1)` and `scaled_pow_newton_rightside complex_ring I (complex_root p) e`, using `POLY_DEG_MUL_LE` and `poly_pow_poly`.
- Show that the degree of `p` is non zero using `distinct_minpolys_deg_nonzero`.
- Finally, `transcendence_H_deg_G_lemma` is specialized and applied to conclude the proof.

### Mathematical insight
This theorem provides an upper bound on the degree of a polynomial constructed from various operations on polynomials in a finite set `P` with distinct minimal polynomials. The polynomial `Gp` represents a product of modified polynomials from `P`. The main result bounds the degree of a polynomial constructed using `Gp`, exponentiation, and a `scaled_pow_newton_rightside` term associated with a specific polynomial `p` in `P`. This result is likely a part of a larger argument related to transcendence theory, bounding the complexity of certain algebraic constructions.

### Dependencies
- `distinct_minpolys_finite_root`
- `distinct_minpolys_card_root`
- `deg_scaled_pow_newton_rightside`
- `in_complex_ring`
- `deg_x_truncreverse_le`
- `series_complex`
- `x_truncreverse_poly`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `FINITE_DELETE`
- `poly_deg_product_le`
- `transcendence_Gp_poly`
- `poly_deg_pow_le`
- `LE_MULT2`
- `LE_REFL`
- `LE_TRANS`
- `NSUM_DELETE`
- `poly_scaled_pow_newton_rightside`
- `POLY_DEG_MUL_LE`
- `poly_pow_poly`
- `distinct_minpolys_deg_nonzero`
- `transcendence_H_deg_G_lemma`

### Porting notes (optional)
- The theorem relies heavily on polynomial degree calculations within the complex field, so ensure proper handling of polynomial rings and degrees in the target proof assistant.
- The `x_truncreverse` function may require a custom definition in other systems.
- Theorems related to finite sets (`FINITE`) and summation over finite sets (`nsum`) should be ported first.


---

## transcendence_H_deg_HG

### Name of formal statement
transcendence_H_deg_HG

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_deg_HG = prove(`
  !P t p Gp e k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  p IN P ==>
  Gp = poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q) ==>
  e < k ==>
  poly_deg complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H (k - (e + 1))
    ) (
      poly_mul complex_ring (
        poly_pow complex_ring Gp (e + 1)
      ) (
        scaled_pow_newton_rightside complex_ring I (complex_root p) e
      )
    )
  ) <= e + (t-1)*(e+1) + t*(k-(e+1))
`,
  intro THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring H (k - (e + 1)):(1->num)->complex)` [transcendence_H_poly;poly_pow_poly;poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring (Gp:(1->num)->complex) (e + 1):(1->num)->complex)` [poly_pow_poly;transcendence_Gp_poly;poly_complex_if_poly_QinC] THEN
  have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
  have `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [poly_scaled_pow_newton_rightside;in_complex_ring] THEN
  have `!p:(1->num)->complex. p IN P ==> ring_powerseries QinC_ring (I p)` [I_THM;ring_polynomial;distinct_minpolys] THEN
  have `poly_deg QinC_ring (H:(1->num)->complex) <= t` [deg_x_truncreverse_le;poly_product_series] THEN
  have `poly_deg complex_ring (H:(1->num)->complex) <= t` [poly_deg_subring;subring_complex_QinC] THEN
  have `ring_polynomial QinC_ring (H:(1->num)->complex)` [x_truncreverse_poly;poly_product_series] THEN
  have `ring_polynomial complex_ring (H:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring (H:(1->num)->complex) (k-(e+1)))` [poly_pow_poly] THEN
  have `poly_deg complex_ring (poly_pow complex_ring (H:(1->num)->complex) (k-(e+1))) <= (k-(e+1))*(poly_deg complex_ring H)` [poly_deg_pow_le] THEN
  have `poly_deg complex_ring (poly_pow complex_ring (H:(1->num)->complex) (k-(e+1))) <= (k-(e+1))*t` [LE_MULT2;LE_TRANS;LE_REFL] THEN
  have `poly_deg complex_ring (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring Gp (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))) <= poly_deg complex_ring (poly_pow complex_ring H (k - (e + 1))) + poly_deg complex_ring (poly_mul complex_ring (poly_pow complex_ring Gp (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))` [POLY_DEG_MUL_LE;RING_POLYNOMIAL_MUL] THEN
  qed[transcendence_H_deg_G;ARITH_RULE `d <= h+g ==> g <= e + (t-1)*(e+1) ==> h <= (k-(e+1))*t ==> d <= e+(t-1)*(e+1)+t*(k-(e+1))`]
);;
```

### Informal statement
For all `P`, `t`, `p`, `Gp`, `e`, and `k`, if `P` is a finite set of polynomials, the minimal polynomials in `P` are distinct, `t` is the sum over `P` of the degree of each polynomial `p` in `P`, `H` is the truncation of the polynomial product of `P` to degree `t`, `p` is an element of `P`, `Gp` is the polynomial product of `P` excluding `p`, where each factor `q` is truncated to degree `poly_deg complex_ring q`, and `e` is less than `k`, then the degree of the polynomial obtained by multiplying `poly_pow complex_ring H (k - (e + 1))` by the product of `poly_pow complex_ring Gp (e + 1)` and `scaled_pow_newton_rightside complex_ring I (complex_root p) e` is less than or equal to `e + (t-1)*(e+1) + t*(k-(e+1))`.

### Informal sketch
The theorem asserts an inequality on the degree of a particular polynomial expression. The argument proceeds as follows:

- First, establish intermediate facts that the polynomials involved are ring polynomials with given coefficients in `complex_ring`.
- Show that each `I p` is a powerseries (in ring `QinC_ring`), where `I` maps polynomials to formal power series, using the hypothesis that the minimal polynomials of `P` are distinct.
- Then, derive degree bounds for `H` inside `complex_ring`, exploiting the truncation inherent in its definition in terms of ring `QinC_ring` and degree properties of polynomial products.
- Use the degree bound on `H` to bound the degree of `poly_pow complex_ring (H:(1->num)->complex) (k-(e+1))`.
- By applying `transcendence_H_deg_G` and appealing to transitivity and arithmetic reasoning, obtain the desired degree inequality.

### Mathematical insight
This theorem plays a role in bounding the degree of certain polynomials arising in transcendence theory, specifically when dealing with algebraic independence. The main idea is to control the degree growth when constructing auxiliary polynomials. The truncation operator `x_truncreverse` provides a way to keep the polynomial degrees small. The inequality provides a key relationship for proving a bound needed in a transcendence argument.

### Dependencies
- `transcendence_H_poly`
- `poly_pow_poly`
- `poly_complex_if_poly_QinC`
- `transcendence_Gp_poly`
- `distinct_minpolys_finite_root`
- `poly_scaled_pow_newton_rightside`
- `in_complex_ring`
- `I_THM`
- `ring_polynomial`
- `distinct_minpolys`
- `deg_x_truncreverse_le`
- `poly_product_series`
- `poly_deg_subring`
- `subring_complex_QinC`
- `x_truncreverse_poly`
- `poly_deg_pow_le`
- `LE_MULT2`
- `LE_TRANS`
- `LE_REFL`
- `POLY_DEG_MUL_LE`
- `RING_POLYNOMIAL_MUL`
- `transcendence_H_deg_G`

### Porting notes (optional)
- The result relies on properties of polynomials and formal power series, so a target theorem prover will need libraries supporting these features, as well as associated ring and field structures.
- Pay special attention to the definitions and properties of `x_truncreverse` and `scaled_pow_newton_rightside` as those are non-standard operators.
- Porting would require careful attention to the ring structures (e.g. `QinC_ring`, `complex_ring`) as well as the type conversions between them.


---

## transcendence_H_deg_HG_simpler

### Name of formal statement
transcendence_H_deg_HG_simpler

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_deg_HG_simpler = prove(`
  !P t p Gp e k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  p IN P ==>
  Gp = poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q) ==>
  e < k ==>
  poly_deg complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H (k - (e + 1))
    ) (
      poly_mul complex_ring (
        poly_pow complex_ring Gp (e + 1)
      ) (
        scaled_pow_newton_rightside complex_ring I (complex_root p) e
      )
    )
  ) <= t*k-1
`,
  intro THEN
  subgoal `~(t = 0)` THENL [
    set_fact `(p:(1->num)->complex) IN P ==> ~(P = {})` THEN
    qed[distinct_minpolys_total_deg]
  ; pass
  ] THEN
  subgoal `e + (t-1)*(e+1) + t*(k-(e+1)) = t*k-1` THENL [
    num_linear_fact `~(t = 0) ==> t = (t-1)+1` THEN
    have `t*(k-(e+1)) = (t-1)*(k-(e+1))+1*(k-(e+1))` [RIGHT_ADD_DISTRIB] THEN
    have `1*(k-(e+1)) = k-(e+1)` [MULT_CLAUSES] THEN
    have `t*(k-(e+1)) = (t-1)*(k-(e+1))+(k-(e+1))` [] THEN
    have `e + (t-1)*(e+1) + t*(k-(e+1)) = e + (t-1)*(e+1) + (t-1)*(k-(e+1)) + (k-(e+1))` [] THEN
    num_linear_fact `e < k ==> (e+1) + (k-(e+1)) = k` THEN
    have `(t-1)*(e+1) + (t-1)*(k-(e+1)) = (t-1)*k` [LEFT_ADD_DISTRIB] THEN
    num_linear_fact `e < k ==> (t-1)*(e+1) + (t-1)*(k-(e+1)) = (t-1)*k ==> e + (t-1)*(e+1) + (t-1)*(k-(e+1)) + (k-(e+1)) = ((t-1)*k + 1*k) - 1` THEN
    have `(t-1)*k + 1*k = t*k` [RIGHT_ADD_DISTRIB] THEN
    qed[]
  ; pass
  ] THEN
  qed[transcendence_H_deg_HG;LE_TRANS]
);;
```

### Informal statement
For all `P`, `t`, `p`, `Gp`, `e`, and `k`, if `P` is a finite set of polynomials, the polynomials in `P` have distinct minimal polynomials, `t` is the sum over `P` of the polynomial degrees of each polynomial in `P` (degrees taken in the complex ring `QinC_ring`), `H` is the `x_truncreverse` of degree `t` of the product over all polynomials in `P` of these polynomials (the product taken in the complex ring `QinC_ring`, with `I` as the indeterminate), `p` is an element of `P`, `Gp` is the product over all polynomials in `P` except `p` of the `x_truncreverse` of degree (in the complex ring `QinC_ring`) equal to the degree of these polynomials multiplied by these polynomials (the product taken in the complex ring `complex_ring`, with `I` as the indeterminate), and `e` is strictly less than `k`, then the degree of the polynomial resulting from multiplying `poly_pow H (k - (e + 1))` by the polynomial resulting from multiplying `poly_pow Gp (e + 1)` by `scaled_pow_newton_rightside I (complex_root p) e` is less than or equal to `t*k-1`, where all polynomial degrees are taken in the complex ring.

### Informal sketch
The proof proceeds by induction and equational reasoning.
- First, we prove that `t` is not zero from the fact that `P` is finite and contains at least one element. The proof relies on `distinct_minpolys_total_deg`.
- Then, we establish that `e + (t-1)*(e+1) + t*(k-(e+1)) = t*k-1` based on the assumption that `e < k` and using algebraic manipulation. We repeatedly make use of distributivity and commutativity.
- We combine these results with existing theorem `transcendence_H_deg_HG` and `LE_TRANS` to complete the final theorem.

### Mathematical insight
This theorem provides an upper bound on the degree of a complex polynomial constructed from polynomials related to the minimal polynomial of an algebraic number and its conjugates. The bound is crucial in proving transcendence results, as it allows bounding the complexity of certain polynomial constructions.

### Dependencies
- `distinct_minpolys_total_deg`
- `transcendence_H_deg_HG`
- `LE_TRANS`
- `RIGHT_ADD_DISTRIB`
- `MULT_CLAUSES`
- `LEFT_ADD_DISTRIB`

### Porting notes (optional)
The proof relies on arithmetic simplification using the `num_linear_fact` tactic. When porting, ensure that the target system can automatically perform similar simplifications or provide manual proof steps for arithmetic identities. Also, the lemmas and theorems `transcendence_H_deg_HG` and `distinct_minpolys_total_deg` must be ported beforehand. The `x_truncreverse`, `poly_product` and `scaled_pow_newton_rightside` will need appropriate definitions implemented in the target system, and appropriate theorems need to be available or derived locally.


---

## transcendence_H_deg_overall

### Name of formal statement
transcendence_H_deg_overall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_deg_overall = prove(`
  !P B t H u k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  poly_deg complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs (\n.
        ring_sum complex_ring {e | e < k} (\e.
          Cx(&(FACT(e) * binom(n,e))) * u(n-e)
        )
      )
    )
  ) <= t*k-1
`,
  intro THEN
  def `G:((1->num)->complex)->((1->num)->complex)` `\p. poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)` THEN
  have `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e)))) = poly_sum complex_ring {e | e < k} (\e. poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))` [transcendence_H_main] THEN
  have `FINITE {e:num | e < k}` [FINITE_NUMSEG_LT] THEN
  subgoal `!e p. e IN {e | e < k} ==> p IN P ==> ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))` THENL [
    intro THEN
    have `ring_polynomial complex_ring (poly_pow complex_ring H (k - (e + 1)):(1->num)->complex)` [transcendence_H_poly;poly_pow_poly;poly_complex_if_poly_QinC] THEN
    have `ring_polynomial complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1):(1->num)->complex)` [poly_pow_poly;transcendence_Gp_poly;poly_complex_if_poly_QinC] THEN
    have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
    have `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [poly_scaled_pow_newton_rightside;in_complex_ring] THEN
    qed[RING_POLYNOMIAL_MUL]
  ; pass
  ] THEN
  subgoal `!e p. e IN {e | e < k} ==> p IN P ==> ring_polynomial complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))` THENL [
    intro THEN
    have `ring_polynomial complex_ring (poly_const complex_ring ((complex_of_int(B(p:(1->num)->complex)))):(1->num)->complex)` [RING_POLYNOMIAL_CONST;in_complex_ring] THEN
    qed[RING_POLYNOMIAL_MUL]
  ; pass
  ] THEN
  have `!e. e IN {e | e < k} ==> ring_polynomial complex_ring (poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))` [poly_sum_poly] THEN
  subgoal `!e. e IN {e | e < k} ==> poly_deg complex_ring (poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))) <= t*k-1` THENL [
    intro THEN
    set_fact `e IN {e:num | e < k} ==> e < k` THEN
    have `!p:(1->num)->complex. p IN P ==> ring_polynomial complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))` [] THEN
    have `!p:(1->num)->complex. p IN P ==> poly_deg complex_ring (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))) <= t*k-1` [transcendence_H_deg_HG_simpler] THEN
    have `!p:(1->num)->complex. p IN P ==> poly_deg complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))) <= poly_deg complex_ring (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))` [deg_const_mul_le;in_complex_ring] THEN
    have `!p:(1->num)->complex. p IN P ==> poly_deg complex_ring (poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))) <= t*k-1` [LE_TRANS] THEN
    specialize[`complex_ring`;`\p:(1->num)->complex. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))`;`t*k-1`;`P:((1->num)->complex)->bool`]poly_deg_sum_le THEN
    qed[]
  ; pass
  ] THEN
  subgoal `poly_deg complex_ring (poly_sum complex_ring {e | e < k} (\e. poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))) <= t*k-1` THENL [
    specialize_assuming[`complex_ring`;`\e. poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))`;`t*k-1`;`{e:num | e < k}`]poly_deg_sum_le THEN
    qed[]
  ; pass
  ] THEN
  qed[transcendence_H_main]
);;
```

### Informal statement
Given a finite set `P` of polynomials with distinct minimal polynomials, let `t` be the sum of the degrees of the polynomials in `P`. Let `H` be the polynomial obtained by truncating and reversing the polynomial product of `P` with respect to the `QinC_ring` to degree `t`.  Suppose that for all `n`, `u(n)` is the sum over `P` of `B(p)` times the `n`-th power sum of the roots of `p`, where `B(p)` is an integer. Then the degree of the polynomial resulting from multiplying the `k`-th power of `H` and the power series whose `n`-th coefficient is the sum for `e` from 0 to `k-1` of `Cx(&(FACT(e) * binom(n,e)))*u(n-e)` is less than or equal to `t*k - 1`.

### Informal sketch
The proof establishes an inequality on the degree of a polynomial.

- The main step, handled by `transcendence_H_main`, expresses `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e)))) ` as:
`poly_sum complex_ring {e | e < k} (\e. poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))`
where `G p` is defined as `poly_product complex_ring (P DELETE p) (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)`.

- It's shown that each term in the outer sum, `poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring ((complex_of_int(B p)))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))))` is a ring polynomial. This relies on `transcendence_H_poly`, `transcendence_Gp_poly`, `poly_scaled_pow_newton_rightside` and the fact that `complex_ring` is an instance of `ring_polynomial`.

- Next, it's show that the degree of each term in the outer sum `poly_sum complex_ring {e | e < k}...` is bound by `t*k - 1`. This is done by using `transcendence_H_deg_HG_simpler` and `deg_const_mul_le`, together with the fact that `e < k`. Therefore, because each polynomial has degree less than or equal to `t*k -1`, the degree of the final sum is less than or equal to `t*k -1` by repeated applications of `poly_deg_sum_le`.

### Mathematical insight
This theorem is a specific bound on the degree of a certain polynomial, given several conditions. It demonstrates relationships between polynomial products, truncations, power sums of roots, and polynomial degrees. This shows that the degree is maintained with the given conditions.

### Dependencies
- `FINITE_NUMSEG_LT`
- `transcendence_H_main`
- `transcendence_H_poly`
- `poly_pow_poly`
- `poly_complex_if_poly_QinC`
- `distinct_minpolys_finite_root`
- `poly_scaled_pow_newton_rightside`
- `in_complex_ring`
- `RING_POLYNOMIAL_MUL`
- `RING_POLYNOMIAL_CONST`
- `poly_sum_poly`
- `transcendence_H_deg_HG_simpler`
- `deg_const_mul_le`
- `poly_deg_sum_le`


---

## transcendence_vw_diff

### Name of formal statement
transcendence_vw_diff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_vw_diff = prove(`
  !u n k vn wn.
  vn = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) ==>
  wn = (if k <= n then ring_sum complex_ring (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) else Cx(&0)) ==>
  vn - wn = ring_sum complex_ring {e | e < k} (\e. Cx(&(FACT(e) * binom(n,e))) * u (n-e))
`,
  intro THEN
  case `k <= n:num` THENL [
    num_linear_fact `k <= n ==> n-k <= n:num` THEN
    specialize[`complex_ring`;`n-k:num`;`n:num`;`\i. Cx(&(FACT(n-i) * binom(n,i))) * u i`]ring_sum_numseg_0_diff_reflect THEN
    num_linear_fact `k <= n ==> n-(n-k) = k:num` THEN
    subgoal `{e:num | e < k} = {e | e < n-(n-k)}` THENL [
      rw[EXTENSION;IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `ring_sum complex_ring {e:num | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e)) = ring_sum complex_ring {i | i < k} (\i. Cx (&(FACT (n - (n - i)) * binom (n,n - i))) * u (n - i))` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      set_fact `a IN {e:num | e < k} ==> a < k` THEN
      num_linear_fact `a < k:num ==> k <= n ==> n-(n-a) = a` THEN
      num_linear_fact `a < k:num ==> k <= n ==> a <= n` THEN
      have `binom(n,n-a) = binom(n,a)` [BINOM_SYM] THEN
      have `FACT(n-(n-a)) = FACT(a)` [] THEN
      qed[]
    ; pass
    ] THEN
    have `ring_sub complex_ring (ring_sum complex_ring (0..n) (\i. Cx (&(FACT (n - i) * binom (n,i))) * u i)) (ring_sum complex_ring (0..n - k) (\i. Cx (&(FACT (n - i) * binom (n,i))) * u i)) = ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))` [] THEN
    qed[ring_sub_complex]
  ;
    have `wn = Cx(&0)` [] THEN
    complex_field_fact `wn = Cx(&0) ==> vn - wn = vn` THEN
    specialize[`complex_ring`;`n:num`;`\i. Cx (&(FACT (n - i) * binom (n,i))) * u i`]ring_sum_numseg_le_reflect THEN
    have `vn - wn = ring_sum complex_ring (0..n) (\i. Cx (&(FACT (n - (n-i)) * binom (n,n-i))) * u (n-i))` [] THEN
    subgoal `ring_sum complex_ring (0..n) (\i. Cx (&(FACT (n - (n-i)) * binom (n,n-i))) * u (n-i)) = ring_sum complex_ring (0..n) (\i. Cx (&(FACT i * binom (n,i))) * u (n-i))` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      rw[BETA_THM] THEN
      have `a <= n:num` [IN_NUMSEG] THEN
      num_linear_fact `a <= n:num ==> n-(n-a) = a` THEN
      have `FACT (n-(n-a)) = FACT a` [] THEN
      have `binom(n,n-a) = binom(n,a)` [BINOM_SYM] THEN
      qed[]
    ; pass
    ] THEN
    have `vn - wn = ring_sum complex_ring (0..n) (\i. Cx (&(FACT i * binom (n,i))) * u (n-i))` [] THEN
    num_linear_fact `~(k <= n) ==> n <= k-1` THEN
    specialize[`complex_ring`;`n:num`;`k-1`;`\i. Cx (&(FACT i * binom (n,i))) * u (n-i)`]ring_sum_numseg_le_expand THEN
    subgoal `ring_sum complex_ring (0..k - 1) (\a. if a <= n then Cx (&(FACT a * binom (n,a))) * u (n - a) else ring_0 complex_ring) = ring_sum complex_ring (0..k - 1) (\a. Cx (&(FACT a * binom (n,a))) * u (n - a))` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      rw[BETA_THM] THEN
      proven_if `a <= n:num` [] THEN
      num_linear_fact `~(a <= n) ==> n < a:num` THEN
      simp[BINOM_LT;MULT_0;COMPLEX_MUL_LZERO;complex_ring_clauses]
    ; pass
    ] THEN
    have `vn - wn = ring_sum complex_ring (0..k - 1) (\a. Cx (&(FACT a * binom (n,a))) * u (n - a))` [] THEN
    num_linear_fact `~(k <= n) ==> ~(k = 0)` THEN
    have `{e:num | e < k} = (0..k-1)` [NUMSEG_LT] THEN
    qed[]
  ]
);;
```

### Informal statement
For all `u`, `n`, `k`, `vn` and `wn`, if `vn` is the ring sum in the complex ring from `0` to `n` of the terms `Cx(&(FACT(n-i) * binom(n,i))) * u i` for all `i` in the range, and `wn` is the ring sum in the complex ring from `0` to `n-k` of the terms `Cx(&(FACT(n-i) * binom(n,i))) * u i` for all `i` in the range if `k` is less than or equal to `n`, and `Cx(&0)` otherwise, then `vn - wn` is the ring sum in the complex ring over the set of `e` such that `e < k` of the terms `Cx(&(FACT(e) * binom(n,e))) * u (n-e)`.

### Informal sketch
The proof proceeds by case distinction on whether `k <= n`.

- Case `k <= n`:
  - It is shown that `n-k <= n`.
  - The theorem `ring_sum_numseg_0_diff_reflect` is specialized to derive a difference of ring sums.
  - The identity `n-(n-k) = k` is used.
  - It is proven that `{e | e < k} = {e | e < n-(n-k)}`.
  - A subgoal is introduced to show that the ring sum over `{e:num | e < k}` equals the ring sum over `{i | i < k}` of `Cx (&(FACT (n - (n - i)) * binom (n,n - i))) * u (n - i)`. This relies on showing `binom(n, n-a) = binom(n, a)` and `FACT(n-(n-a)) = FACT(a)`.
  - The original goal is then proven using `ring_sub_complex`.
- Case `~(k <= n)`:
  - It is shown that `wn = Cx(&0)`.
  - Using `complex_field_fact`, the goal is simplified to showing `vn - wn = vn`.
  - The theorem `ring_sum_numseg_le_reflect` is specialized and applied.
  - A subgoal is introduced to rewrite `ring_sum complex_ring (0..n) (\i. Cx (&(FACT (n - (n-i)) * binom (n,n-i))) * u (n-i))` into `ring_sum complex_ring (0..n) (\i. Cx (&(FACT i * binom (n,i))) * u (n-i))`. This relies on simplifying `n-(n-a) = a` and using `binom(n,n-a) = binom(n,a)`.
  - Since `~(k <= n)`, it follows that `n <= k-1`.
  - The theorem `ring_sum_numseg_le_expand` is specialized.
  - A subgoal shows the equivalence between `ring_sum complex_ring (0..k - 1) (\a. if a <= n then Cx (&(FACT a * binom (n,a))) * u (n - a) else ring_0 complex_ring)` and `ring_sum complex_ring (0..k - 1) (\a. Cx (&(FACT a * binom (n,a))) * u (n - a))`.
  - Finally, since `~(k <= n)` implies `~(k = 0)`, `{e:num | e < k} = (0..k-1)`.

### Mathematical insight
This theorem provides a way to compute the difference between two partial sums of a series. The series appears to be related to a discrete form of the Taylor expansion, or more generally, a re-expansion in powers of another term. The combinatorial terms `FACT(n-i)` and `binom(n,i)` suggest a close connection to binomial coefficients and factorial representation. The theorem effectively isolates the terms that were excluded when summing to `n-k` instead of `n`.

### Dependencies
- `complex_ring`
- `ring_sum_numseg_0_diff_reflect`
- `ring_sub_complex`
- `ring_sum_numseg_le_reflect`
- `ring_sum_numseg_le_expand`
- `EXTENSION`
- `IN_ELIM_THM`
- `BINOM_SYM`
- `NUMSEG_LT`

### Porting notes (optional)
- The handling of ring sums, complex numbers, and binomial coefficients might vary across different provers.
- Ensure that the target prover has a library for complex numbers and associated ring operations.
- The tactic `num_linear_fact` is used to prove facts about natural numbers, which relies on linear arithmetic. Ensure that the target prover has similar automation for linear arithmetic.


---

## transcendence_vw_diff_series

### Name of formal statement
transcendence_vw_diff_series

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_vw_diff_series = prove(`
  !P B u v w.
  FINITE P ==>
  distinct_minpolys P ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n. w n = if k <= n then ring_sum complex_ring (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) else Cx(&0)) ==>
  poly_sub complex_ring (
    series_from_coeffs v
  ) (
    series_from_coeffs w
  ) =
  series_from_coeffs (\n.
    ring_sum complex_ring {e | e < k} (\e.
      Cx(&(FACT(e) * binom(n,e))) * u(n-e)
    )
  )
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_poly_sub;coeff_series_from_coeffs] THEN
  rw[ring_sub_complex] THEN
  qed[transcendence_vw_diff]
);;
```
### Informal statement
For all sets `P` of complex algebraic numbers, integers `B p` indexed by `p` in `P`, and functions `u`, `v`, and `w` from natural numbers to complex numbers, if `P` is finite, `P` contains numbers with distinct minimal polynomials, `u n` equals the ring sum over `P` of `complex_of_int(B p) * complex_root_powersums p n` for all `n`, `v n` equals the ring sum from `0` to `n` of `Cx(&(FACT(n-i) * binom(n,i))) * u i` for all `n`, and `w n` equals the ring sum from `0` to `n-k` of `Cx(&(FACT(n-i) * binom(n,i))) * u i` if `k <= n` and `Cx(&0)` otherwise for all `n`, then the polynomial subtraction of the series from coefficients `v` and `w` is equal to the series from coefficients given by the function which maps `n` to the ring sum over the set `{e | e < k}` of `Cx(&(FACT(e) * binom(n,e))) * u(n-e)`.

### Informal sketch
The proof proceeds by induction on the coefficients of the series. The main steps are as follows:
- Introduce the assumptions using `intro`.
- Reduce the goal to proving equality of coefficients using `sufficesby eq_coeff`.
- Introduce a natural number `n` using `intro`, aiming to show the equality of `n`-th coefficients.
- Rewrite the goal using properties of polynomial subtraction (`coeff_poly_sub`) and series from coefficients (`coeff_series_from_coeffs`).
- Rewrite the goal using the property of ring subtraction in the complex ring (`ring_sub_complex`).
- Complete the proof by appealing to a supporting lemma named `transcendence_vw_diff` which likely encapsulates the core algebraic manipulation.

### Mathematical insight
This theorem relates different series constructed from a set of algebraic numbers `P`, integers `B p`, and a power sum function `complex_root_powersums`. It expresses a relationship between series `v` and `w` derived from `u`, and relates their difference back to `u`. The theorem likely plays a part in proving transcendence results, possibly by showing that certain series are transcendental.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `complex_ring`
- `complex_of_int`
- `complex_root_powersums`
- `FACT`
- `binom`
- `Cx`
- `poly_sub`
- `series_from_coeffs`
- `coeff_poly_sub`
- `coeff_series_from_coeffs`
- `ring_sub_complex`
- `transcendence_vw_diff`


---

## transcendence_vw_diff_series_H

### Name of formal statement
transcendence_vw_diff_series_H

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_vw_diff_series_H = prove(`
  !P B t H u v w k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n. w n = if k <= n then ring_sum complex_ring (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) else Cx(&0)) ==>
  poly_sub complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs v
    )
  ) (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
    series_from_coeffs w
    )
  ) =
  poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    series_from_coeffs (\n.
      ring_sum complex_ring {e | e < k} (\e.
        Cx(&(FACT(e) * binom(n,e))) * u(n-e)
      )
    )
  )
`,
  intro THEN
  specialize[`P:((1->num)->complex)->bool`;`B:((1->num)->complex)->int`;`u:num->complex`;`v:num->complex`;`w:num->complex`]transcendence_vw_diff_series THEN
  specialize_assuming[`complex_ring`;`poly_pow complex_ring H k:(1->num)->complex`;`series_from_coeffs v:(1->num)->complex`;`series_from_coeffs w:(1->num)->complex`]poly_sub_ldistrib THEN
  have `poly_mul complex_ring (poly_pow complex_ring H k) (poly_sub complex_ring (series_from_coeffs v) (series_from_coeffs w)) = poly_sub complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)):(1->num)->complex` [series_complex] THEN
  qed[]
);;
```

### Informal statement
For any predicate `P` on functions from `(1->num)` to `complex`, any `B` of function from `(1->num)` to `complex` to integers, any natural number `t`, any `H`, `u`, `v`, `w` from natural numbers to complex numbers, and any natural number `k`, if `P` is finite, the minimal polynomials in `P` are distinct, `t` is the sum over `P` of the degrees of the polynomials in `P`, `H` is the truncation of the inverse of the polynomial which is the product of the polynomials in `P`, at degree `t` , for all `n`, `u n` is the sum over `P` of `complex_of_int (B p) * complex_root_powersums p n`, for all `n`, `v n` is `sum (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)`, and for all `n`, `w n` is `sum (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)` if `k <= n` and `Cx(&0)` otherwise, then
```
poly_sub complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs v
    )
  ) (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
    series_from_coeffs w
    )
  )
```
is equal to
```
poly_mul complex_ring (
    poly_pow complex_ring H k
  ) (
    series_from_coeffs (\n.
      ring_sum complex_ring {e | e < k} (\e.
        Cx(&(FACT(e) * binom(n,e))) * u(n-e)
      )
    )
  )
```

### Informal sketch
The proof proceeds as follows:
- Introduction: Introduce the assumptions.
- Specialize using `transcendence_vw_diff_series`, replacing the quantified variables with concrete instantiations based on the input types. Instantiations include `P:((1->num)->complex)->bool`;`B:((1->num)->complex)->int`;`u:num->complex`;`v:num->complex`;`w:num->complex`.
- Specialize using `poly_sub_ldistrib`, assuming the conditions of the `complex_ring`, `poly_pow complex_ring H k:(1->num)->complex`, `series_from_coeffs v:(1->num)->complex`, and `series_from_coeffs w:(1->num)->complex`.
- Use the distributivity of polynomial multiplication over polynomial subtraction in `complex_ring` to rewrite the goal, generating the `poly_mul complex_ring (poly_pow complex_ring H k) (poly_sub complex_ring (series_from_coeffs v) (series_from_coeffs w)) = poly_sub complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)):(1->num)->complex`.
- QED: Close the proof.

### Mathematical insight
This theorem simplifies a polynomial expression involving truncated series, polynomial powers, and polynomial multiplication in the context of transcendental number theory, specifically regarding the construction often used in proofs related to the Hermite-Lindemann theorem. It shows how certain combinations of powers of `H` multiplied by generating functions relate to truncated sums. `transcendence_vw_diff_series` presumably contains the core combinatorial argument, with this result focusing on algebraic manipulation.

### Dependencies
- `transcendence_vw_diff_series`
- `complex_ring`
- `poly_sub_ldistrib`
- `series_complex`


---

## transcendence_uv_trivial

### Name of formal statement
transcendence_uv_trivial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_uv_trivial = prove(`
  !P B u v.
  P = {} ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n. u n = Cx(&0) /\ v n = Cx(&0))
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  have `!d:num. u d = Cx(&0)` [RING_SUM_CLAUSES;complex_ring_clauses] THEN
  subgoal `!d:num. ring_sum complex_ring (0..d) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) = Cx(&0)` THENL [
    intro THEN
    rw[GSYM complex_ring_clauses] THEN
    sufficesby RING_SUM_EQ_0 THEN
    intro THEN
    rw[BETA_THM] THEN
    rw[complex_ring_clauses] THEN
    qed[COMPLEX_MUL_RZERO]
  ;
    qed[]
  ]
);;
```

### Informal statement
For all sets `P`, `B`, functions `u`, and `v` from natural numbers to complex numbers, if `P` is the empty set, and for all natural numbers `n`, `u(n)` is equal to the sum over `P` of `(B(p) * p^n)` where the sum is taken in the complex ring, and for all natural numbers `n`, `v(n)` is equal to the sum from `i = 0` to `n` of `Cx(&(FACT(n-i) * binom(n,i))) * u(i)` where the sum is taken in the complex ring, then for all natural numbers `n`, `u(n)` and `v(n)` are both `Cx(&0)`.

### Informal sketch
The proof proceeds by assuming the hypotheses and then showing that under these assumptions, `u(n) = Cx(&0)` and `v(n) = Cx(&0)` for all natural numbers `n`.

- First, show that `u(d) = Cx(&0)` for all natural numbers `d`. This follows since `P` is empty, and the sum over an empty set in any ring is the zero element of that ring. The lemma `RING_SUM_CLAUSES` is used here to simplify the sum, noting that the sum over the empty set is zero. The `complex_ring_clauses` are also used to manipulate the complex numbers.
- Next, show that `ring_sum complex_ring (0..d) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) = Cx(&0)` for all natural numbers `d`.
  - Introduce `d` and rewrite using `GSYM complex_ring_clauses`.
  - It suffices to show `ring_sum complex_ring (0..d) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) = ring_sum complex_ring (0..d) (\i. Cx (&(FACT (i - i) * binom (i,i))) * Cx(&0))` by `RING_SUM_EQ_0`.
  - Introduce `i` and rewrite by `BETA_THM` then `complex_ring_clauses` to simplify to `Cx(&(FACT (d - i) * binom (d,i))) * Cx (&0) = Cx(&0)`.
  - The product is zero since anything multiplied by zero is zero, using the clause `COMPLEX_MUL_RZERO`.

### Mathematical insight
The theorem essentially states that if the sum of some terms is zero (because the index set is empty), and a second sequence is defined as a specific linear combination of the first sequence, then all terms of both sequences are zero. The heart of the proof is using the definition of `u(n)` and `v(n)` to show they are both zero.

### Dependencies
- `RING_SUM_CLAUSES`
- `complex_ring_clauses`
- `RING_SUM_EQ_0`
- `BETA_THM`
- `COMPLEX_MUL_RZERO`


---

## transcendence_vw_match

### Name of formal statement
transcendence_vw_match

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_vw_match = prove(`
  !P B t H u v w.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n k. k*t <= n ==>
         (!d. w d = if k <= d then ring_sum complex_ring (0..d-k) (\i. Cx(&(FACT(d-i) * binom(d,i))) * u i) else Cx(&0)) ==>
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs v
           )
         )
         =
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs w
           )
         )
  )
`,
  intro THEN
  case `P = {}:((1->num)->complex)->bool` THENL [
    have `!n:num. u n = Cx(&0)` [transcendence_uv_trivial] THEN
    have `!n:num. v n = Cx(&0)` [transcendence_uv_trivial] THEN
    subgoal `!d:num. (if k <= d then ring_sum complex_ring (0..d-k) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) else Cx(&0)) = Cx(&0)` THENL [
      intro THEN
      rw[GSYM complex_ring_clauses] THEN
      rw[COND_ELIM_THM] THEN
      sufficesby (prove(`x:A = y ==> (if p then x else y) = y`,qed[])) THEN
      sufficesby RING_SUM_EQ_0 THEN
      intro THEN
      rw[BETA_THM] THEN
      rw[complex_ring_clauses] THEN
      qed[COMPLEX_MUL_RZERO]
    ; pass
    ] THEN
    have `!n:num. w n = Cx(&0)` [] THEN
    have `v = w:num->complex` [FUN_EQ_THM] THEN
    qed[]
  ; pass
  ] THEN
  case `t = 0` THENL [
    have `P = {}:((1->num)->complex)->bool` [distinct_minpolys_total_deg] THEN
    qed[]
  ; pass
  ] THEN
  num_linear_fact `~(t = 0) ==> 1 <= t` THEN
  have `k <= k:num` [LE_REFL] THEN
  have `k*1 <= k*t:num` [LE_MULT2] THEN
  num_linear_fact `k*1 <= k*t ==> k <= k*t` THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `v:num->complex`;
    `w:num->complex`;
    `k:num`
  ]transcendence_vw_diff_series_H THEN
  specialize[`complex_ring`;`poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)`;`poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)`;`n:num`]coeff_poly_sub THEN
  have `(coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))) - (coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w))) = coeff n (poly_sub complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)))` [ring_sub_complex] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `k:num`
  ]transcendence_H_deg_overall THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `k:num`
  ]transcendence_Htimes_poly THEN
  case `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))))) = ring_0 complex_ring` THENL [
    have `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))))) = Cx(&0)` [complex_ring_clauses] THEN
    have `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) - coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)) = Cx(&0)` [] THEN
    qed[COMPLEX_FIELD `a - b = Cx(&0) ==> a = b`]
  ;
    specialize[`complex_ring`;`poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))))`;`t*k-1`;`n:num`]coeff_deg_le THEN
    num_linear_fact `k*t <= n ==> n <= t*k-1 ==> n = 0` THEN
    num_linear_fact `k*t <= n ==> n = 0 ==> k*t = 0` THEN
    have `k = 0` [MULT_EQ_0] THEN
    subgoal `!d. ring_sum complex_ring (0..d) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) = (if k <= d then ring_sum complex_ring (0..d - k) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) else Cx (&0))` THENL [
      intro THEN
      num_linear_fact `k = 0 ==> k <= d` THEN
      sufficesby(prove(`k <= d:num /\ x = y:A ==> x = (if k <= d then y else z)`,qed[])) THEN
      intro THENL [
        qed[]
      ; pass
      ] THEN
      rw[know(`k = 0`)] THEN
      rw[ARITH_RULE `d-0 = d`]
    ; pass
    ] THEN
    have `!d. v d = (if k <= d then ring_sum complex_ring (0..d - k) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) else Cx (&0))` [] THEN
    have `!d. w d = (if k <= d then ring_sum complex_ring (0..d - k) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) else Cx (&0))` [] THEN
    specialize[
      `v:num->complex`;
      `w:num->complex`;
      `\d. (if k <= d then ring_sum complex_ring (0..d - k) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) else Cx (&0))`
    ](prove(`!v w f. (!d:num. v d = f d:complex) ==> (!d:num. w d = f d:complex) ==> (!d:num. v d = w d)`,qed[])) THEN
    have `v = w:num->complex` [FUN_EQ_THM] THEN
    qed[]
  ]
);;
```

### Informal statement
Given a finite set `P` of polynomials with distinct minimal polynomials, let `t` be the sum of the degrees of the polynomials in `P`. Define `H` as the `t`-th truncated reverse of the product of polynomials in `P`. Suppose that for all `n`, `u(n)` is the ring sum over `P` of `B(p)` times the `n`-th power sum of the roots of `p` (where `B(p)` is an integer value associated with the polynomial `p`). Suppose that for all `n`, `v(n)` is the ring sum from `i = 0` to `n` of `Cx(&(FACT(n-i) * binom(n,i)))` times `u(i)`. Suppose that for all `n` and `k`, if `k*t <= n`, then for all `d`, `w(d)` is equal to the ring sum from `i = 0` to `d-k` of `Cx(&(FACT(d-i) * binom(d,i)))` times `u(i)` if `k <= d`, and `Cx(&0)` otherwise. Then the `n`-th coefficient of the polynomial `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)` is equal to the `n`-th coefficient of the polynomial `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)`.

### Informal sketch
The proof proceeds by induction and case splitting.

- First, consider the case where `P` is the empty set. In this case, it is shown that `u(n)` and `v(n)` are both equal to zero for all `n`. Then, the goal `w d = Cx(&0)` is proven by simplification and using `COMPLEX_MUL_RZERO`. Finally, Functional equality(`FUN_EQ_THM`) is used to resolve the goal.
- Next, consider the case where `t = 0`. By `distinct_minpolys_total_deg` it's concluded that `P` must be empty and the result follows trivially from the previous case.
- Assuming `t` is not zero, it follows that `1 <= t`. Also, `k <= k` is shown and by `LE_MULT2` we have `k*1 <= k*t` and then `k <= k*t`.
- Specialize transcendence_vw_diff_series_H and coeff_poly_sub.
- Use ring_sub_complex to rewrite the expression.
- Specialize transcendence_H_deg_overall and transcendence_Htimes_poly.
- Case split on `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))))) = ring_0 complex_ring`.
    - If the case is true we have `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. ring_sum complex_ring {e | e < k} (\e. Cx (&(FACT e * binom (n,e))) * u (n - e))))) = Cx(&0)` which implies that `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) - coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)) = Cx(&0)`. Finally, by using `COMPLEX_FIELD a - b = Cx(&0) ==> a = b` the goal is resolved.
    - If the case is false we can use coeff_deg_le. After some arithmetic simplification, `k = 0` is derived. Then `!d. ring_sum complex_ring (0..d) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) = (if k <= d then ring_sum complex_ring (0..d - k) (\i. Cx (&(FACT (d - i) * binom (d,i))) * u i) else Cx (&0))` is shown. Afterwards Functional equality (`FUN_EQ_THM`) is used to resolve the goal.

### Mathematical insight
This theorem relates the coefficients of two power series that are constructed from power sums of roots of polynomials. It is a technical lemma used in the proof of transcendence results, specifically related to constructing series with specific algebraic properties.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `nsum`
- `poly_deg`
- `complex_ring`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `I`
- `complex_of_int`
- `complex_root_powersums`
- `ring_sum`
- `FACT`
- `binom`
- `Cx`
- `coeff`
- `poly_mul`
- `poly_pow`
- `series_from_coeffs`
- `INTRO`
- `CASE`
- `THENL`
- `rw`
- `GSYM`
- `complex_ring_clauses`
- `COND_ELIM_THM`
- `sufficesby`
- `qed`
- `RING_SUM_EQ_0`
- `BETA_THM`
- `COMPLEX_MUL_RZERO`
- `FUN_EQ_THM`
- `distinct_minpolys_total_deg`
- `num_linear_fact`
- `LE_REFL`
- `LE_MULT2`
- `COMPLEX_FIELD`
- `MULT_EQ_0`
- `ARITH_RULE`
- `transcendence_uv_trivial`
- `transcendence_vw_diff_series_H`
- `coeff_poly_sub`
- `ring_sub_complex`
- `transcendence_H_deg_overall`
- `transcendence_Htimes_poly`
- `coeff_deg_le`
- `know`

### Porting notes (optional)
The extensive use of ring axioms (`complex_ring_clauses`) and arithmetic simplification (`ARITH_RULE`, `num_linear_fact`) suggests that a target proof assistant with strong automation for ring reasoning and arithmetic is important. The case splits may need to be explicitly triggered in other proof assistants.


---

## transcendence_Hw_denom

### Name of formal statement
transcendence_Hw_denom

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hw_denom = prove(`
  !P D B t H u w.
  FINITE P ==>
  distinct_minpolys P ==>
  D IN ZinC ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n k. k*t <= n ==>
         (!d. w d = if k <= d then ring_sum complex_ring (0..d-k) (\i. Cx(&(FACT(d-i) * binom(d,i))) * u i) else Cx(&0)) ==>
         (D pow (n-k) / Cx(&(FACT k))) *
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs w
           )
         ) IN ZinC
  )
`,
  intro THEN
  rw[coeff_poly_mul_oneindex] THEN
  have `(D pow (n-k) / Cx(&(FACT k))) IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `FINITE (0..n)` [FINITE_NUMSEG] THEN
  have `!i. i IN 0..n ==> ring_mul complex_ring (coeff i (poly_pow complex_ring H k)) (coeff (n - i) (series_from_coeffs w)) IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`(\a. ring_mul complex_ring (coeff a (poly_pow complex_ring H k)) (coeff (n - a) (series_from_coeffs w)))`;`D pow (n-k) / Cx(&(FACT k))`;`0..n`](GSYM RING_SUM_LMUL) THEN
  have `(D pow (n - k) / Cx(&(FACT k))) * ring_sum complex_ring (0..n) (\a. ring_mul complex_ring (coeff a (poly_pow complex_ring H k)) (coeff (n - a) (series_from_coeffs w))) = ring_sum complex_ring (0..n) (\x. ring_mul complex_ring (D pow (n - k) / Cx(&(FACT k))) (ring_mul complex_ring (coeff x (poly_pow complex_ring H k)) (coeff (n - x) (series_from_coeffs w))))` [complex_ring_clauses] THEN
  subgoal `ring_sum complex_ring (0..n) (\x. ring_mul complex_ring (D pow (n - k) / Cx(&(FACT k))) (ring_mul complex_ring (coeff x (poly_pow complex_ring H k)) (coeff (n - x) (series_from_coeffs w)))) IN ZinC` THENL [
    rw[GSYM ZinC_ring_clauses;GSYM subring_complex_empty;coeff_series_from_coeffs] THEN
    sufficesby ring_sum_in_subring THEN
    rw[complex_ring_clauses;subring_complex_empty] THEN
    intro THEN
    rw[BETA_THM] THEN
    have `s <= n:num` [IN_NUMSEG_0] THEN
    have `D pow s * coeff s (poly_pow QinC_ring H k) IN ZinC` [transcendence_H_pow_denom] THEN
    have `!p:(1->num)->complex. p IN P ==> ring_powerseries QinC_ring (I p)` [I_THM;ring_polynomial;distinct_minpolys] THEN
    have `ring_powerseries QinC_ring (poly_product QinC_ring P I:(1->num)->complex)` [poly_product_series] THEN
    have `ring_powerseries QinC_ring (H:(1->num)->complex)` [x_truncreverse_series] THEN
    have `poly_pow complex_ring H k = poly_pow QinC_ring H k:(1->num)->complex` [poly_pow_subring;subring_complex_QinC] THEN
    have `D pow s * coeff s (poly_pow complex_ring H k) IN ZinC` [] THEN
    specialize[`P:((1->num)->complex)->bool`;`D:complex`;`B:((1->num)->complex)->int`;`u:num->complex`]transcendence_w_denom THEN
    specialize_assuming[
      `n-s:num`;
      `k:num`;
      `w(n-s:num):complex`
    ](
      know(`!n k wn. wn = (if k <= n then ring_sum complex_ring (0..n - k) (\i. Cx (&(FACT (n - i) * binom (n,i))) * u i) else Cx (&0)) ==> (D pow (n - k) * wn) / Cx (&(FACT k)) IN ZinC`)
    ) THEN
    have `(D pow ((n-s)-k) * w(n-s)) / Cx(&(FACT k)) IN ZinC` [] THEN
    case `k <= n-s:num` THENL [
      num_linear_fact `s <= n ==> k <= n-s:num ==> n-k = (n-s-k)+s` THEN
      have `(D:complex) pow (n-k) = D pow (n-s-k) * D pow s` [COMPLEX_POW_ADD] THEN
      complex_field_fact `D pow (n - k) = D pow (n - s - k) * D pow s ==> D pow (n - k) / Cx (&(FACT k)) * coeff s (poly_pow complex_ring H k) * w (n - s) = (D pow s * coeff s (poly_pow complex_ring H k)) * (D pow ((n-s)-k) * w(n-s)) / Cx(&(FACT k))` THEN
      qed[mul_in_ZinC;ZinC_ring_clauses]
    ;
      have `w(n-s:num) = Cx(&0)` [] THEN
      simp[COMPLEX_MUL_RZERO] THEN
      qed[ZinC_ring_clauses;ZinC_0]
    ]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For all sets `P` of complex polynomials, for all complex numbers `D`, for all functions `B` from complex polynomials to integers, for all natural numbers `t`, for all functions `H` from natural numbers to complex numbers, for all functions `u` from natural numbers to complex numbers, for all functions `w` from natural numbers to complex numbers, if `P` is finite and the polynomials in `P` have distinct minimal polynomials, if `D` is an element of the integers in the complex numbers, if for all polynomials `p` in `P` and for all natural numbers `i`, `D` raised to the power of `i` multiplied by the coefficient of `p` at degree `poly_deg complex_ring p - i` is an element of the integers in the complex numbers, if `t` is the sum over `P` of the degrees of the polynomials in `P`, if `H` is the truncated series obtained by reversing the polynomial product of `P` with minimal polynomials as power series until term `t`, if for all natural numbers `n`, `u(n)` is the sum over `P` of `B(p)` multiplied by the power sum of the roots of `p` to the `n`-th power, and if for all natural numbers `n` and `k` such that `k*t` is less than or equal to `n`, for all natural numbers `d`, `w(d)` equals the sum over `0` to `d-k` of complex numbers constructed from the integers `FACT(d-i) * binom(d,i) * u(i)` if `k` is less than or equal to `d` else `Cx(&0)`, then `(D pow (n-k) / Cx(&(FACT k))) * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w))` is an element of the integers in the complex numbers.

### Informal sketch
The proof aims to show that a certain expression involving polynomials, power sums, and coefficients lies in the integers in the complex numbers (`ZinC`). The core idea is to exploit properties of `ZinC` being a subring and to reduce the expression to simpler terms that are already known to be in `ZinC`.

- Introduction and rewriting of the coefficient of a polynomial multiplication.
- Show that `(D pow (n-k) / Cx(&(FACT k)))` is an element of the carrier of complex ring.
- Show that `FINITE (0..n)`.
- Show that `ring_mul complex_ring (coeff i (poly_pow complex_ring H k)) (coeff (n - i) (series_from_coeffs w))` is an element of the carrier of complex ring.
- Application of `RING_SUM_LMUL` lemma.
- Apply `ZinC_ring_clauses` to show `ring_sum` in `ZinC` by showing each term in `ZinC`.
- Use `transcendence_H_pow_denom` to show `D pow s * coeff s (poly_pow QinC_ring H k) IN ZinC`.
- Apply `transcendence_w_denom`.
- Consider two cases `k <= n-s` and `~(k <= n-s)`.
   - If `k <= n-s` use `COMPLEX_POW_ADD` and complex field facts to show the expression is in ZinC.
   - If `~(k <= n-s)` simplify with `COMPLEX_MUL_RZERO` and `ZinC_0`.

### Mathematical insight
This theorem appears to be an intermediate result in a larger transcendence proof. It establishes that a constructed quantity, involving polynomial coefficients, powers of a complex number `D`, factorials, binomial coefficients, and power sums of roots, is an algebraic integer (i.e., belongs to `ZinC`). The significance likely resides in setting up the machinery needed to derive a contradiction, characteristic of many transcendence arguments.

### Dependencies
Relevant definitions and theorems used include:
- `FINITE`
- `distinct_minpolys`
- `ZinC`
- `coeff`
- `poly_deg`
- `poly_product`
- `x_truncreverse`
- `complex_root_powersums`
- `series_from_coeffs`
- `coeff_poly_mul_oneindex`
- `FINITE_NUMSEG`
- `RING_SUM_LMUL`
- `ZinC_ring_clauses`
- `subring_complex_empty`
- `ZinC_ring_clauses`
- `transcendence_H_pow_denom`
- `I_THM`
- `poly_product_series`
- `x_truncreverse_series`
- `poly_pow_subring`
- `transcendence_w_denom`
- `COMPLEX_POW_ADD`
- `ZinC_0`

### Porting notes (optional)
- The theorem heavily relies on algebraic properties of complex numbers and polynomials, especially those related to subrings and integer coefficients.
- When porting, ensure that the target proof assistant has adequate support for complex arithmetic, polynomial manipulation, and subring reasoning.
- The subring `ZinC` (integers in the complex numbers) needs to be defined appropriately in the target system, along with related lemmas about closure under addition, multiplication, etc.
- `transcendence_H_pow_denom` and `transcendence_w_denom` are critical dependencies, so ensure they are ported beforehand.


---

## transcendence_Hv_denom

### Name of formal statement
transcendence_Hv_denom

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_denom = prove(`
  !P D B t H u v.
  FINITE P ==>
  distinct_minpolys P ==>
  D IN ZinC ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n k. k*t <= n ==>
         (D pow (n-k) / Cx(&(FACT k))) *
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs v
           )
         ) IN ZinC
  )
`,
  intro THEN
  def `w:num->complex` `\n. if k <= n then ring_sum complex_ring (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) else Cx(&0)` THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `v:num->complex`;
    `w:num->complex`
  ]transcendence_vw_match THEN
  have `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w))` [] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `D:complex`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `w:num->complex`
  ]transcendence_Hw_denom THEN
  have `D pow (n - k) / Cx (&(FACT k)) * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)) IN ZinC` [] THEN
  qed[]
);;
```

### Informal statement
For all sets of complex polynomials `P`, algebraic integers `D`, functions from complex polynomials to integers `B`, natural numbers `t`, complex polynomials `H`, functions from natural numbers to complex numbers `u` and `v`, if `P` is finite, the minimal polynomials in `P` are distinct, `D` is an algebraic integer, for all `p` in `P` and natural numbers `i`, `D` raised to the power of `i` multiplied by the coefficient of `x` to the power of (`degree(p) - i`) in `p` is an algebraic integer, `t` is the sum over `P` of the degrees of the polynomials, `H` is the truncation of the product of the polynomials in `P`, `u(n)` is the sum over `P` of `B(p)` times the `n`-th power sum of the roots of `p`, `v(n)` is the sum from `i = 0` to `n` of `(n-i)! * binomial(n,i) * u(i)`, then for all natural numbers `n` and `k`, if `k*t <= n`, then `(D^(n-k) / k!)` multiplied by the coefficient of `x^n` in the series obtained by multiplying `H^k` with the series defined by the coefficients `v`, is an algebraic integer.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions.
- Defining `w n` to be `ring_sum complex_ring (0..n-k) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)` if `k <= n` and `Cx(&0)` otherwise.
- Applying the theorem `transcendence_vw_match`, specializing it with the given variables and the definition of `w`.
- Showing that `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w))`.
- Applying the theorem `transcendence_Hw_denom`, specializing it with the given variables and the definition of `w`.
- Showing that `D pow (n - k) / Cx (&(FACT k)) * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs w)) IN ZinC`.

### Mathematical insight
This theorem is part of a larger argument establishing the transcendence of certain numbers. Specifically, it shows that under certain conditions on a finite set of polynomials `P` and related values, a certain expression involving `H` and `v` belongs to the algebraic integers (`ZinC`). The conditions involve finiteness of `P`, distinctness of the minimal polynomials, algebraic integrality of `D` and its powers multiplied by certain polynomial coefficients, relationships between `t`, `H`, `u`, and `v` which construct key values from `P`, `B`, and root power sums. This result is important because it sets up a condition leading to a contradiction if a number under consideration is assumed to be algebraic, ultimately proving transcendence.

### Dependencies
- `transcendence_vw_match`
- `transcendence_Hw_denom`


---

## transcendence_u_tail

### Name of formal statement
transcendence_u_tail

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_u_tail = prove(`
  !P A B u.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  !n.
  norm(vsum(0..n) (\i. u i / Cx(&(FACT i))))
  <= (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))) * exp A * A pow (n + 1) / &(FACT n)
`,
  intro THEN
  subgoal `!p z. p IN P ==> complex_root p z ==> norm (cexp z - vsum (0..n) (\i. z pow i / Cx(&(FACT i)))) <= exp A * A pow (n+1) / &(FACT n)` THENL [
    intro THEN
    have `norm (cexp z - vsum (0..n) (\i. z pow i / Cx(&(FACT i)))) <= exp(abs(Re z)) * norm z pow (n+1) / &(FACT n)` [TAYLOR_CEXP] THEN
    have `norm(z:complex) <= A` [] THEN
    have `&0 <= norm(z:complex)` [NORM_POS_LE] THEN
    have `&0 <= norm(z:complex) pow (n+1)` [REAL_POW_LE] THEN
    have `norm(z:complex) pow (n+1) <= A pow (n+1)` [REAL_POW_LE2] THEN
    real_linear_fact `&0 <= &(FACT n):real` THEN
    have `&0 <= inv(&(FACT n):real)` [REAL_LE_INV] THEN
    have `norm(z:complex) pow (n+1) * inv(&(FACT n)) <= A pow (n+1) * inv(&(FACT n))` [REAL_LE_RMUL] THEN
    have `norm(z:complex) pow (n+1) / &(FACT n) <= A pow (n+1) / &(FACT n)` [real_div] THEN
    have `&0 <= norm(z:complex) pow (n+1) * inv(&(FACT n))` [REAL_LE_MUL] THEN
    have `&0 <= norm(z:complex) pow (n+1) / &(FACT n)` [real_div] THEN
    have `abs(Re z) <= A` [COMPLEX_NORM_GE_RE_IM;REAL_LE_TRANS] THEN
    have `exp(abs(Re z)) <= exp A` [REAL_EXP_MONO_LE] THEN
    have `&0 <= exp(abs(Re z))` [REAL_EXP_POS_LE] THEN
    have `exp(abs(Re z)) * norm z pow (n+1) / &(FACT n) <= exp A * A pow (n+1) / &(FACT n)` [REAL_LE_MUL2] THEN
    qed[REAL_LE_TRANS]
  ; pass
  ] THEN
  subgoal `!p. p IN P ==> vsum (0..n) (\i. complex_root_powersums p i / Cx(&(FACT i))) = vsum (complex_root p) (\z. vsum (0..n) (\i. z pow i / Cx(&(FACT i))))` THENL [
    intro THEN
    rw[complex_root_powersums] THEN
    have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
    have `FINITE(0..n)` [FINITE_NUMSEG] THEN
    specialize[`\z i. z pow i / Cx(&(FACT i))`;`complex_root p`;`0..n`]VSUM_SWAP THEN
    have `vsum (complex_root p) (\z. vsum (0..n) (\i. z pow i / Cx (&(FACT i)))) = vsum (0..n) (\i. vsum (complex_root p) (\z. z pow i / Cx (&(FACT i))))` [] THEN
    simp[] THEN
    sufficesby VSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    simp[vsum_ring_sum_complex] THEN
    rw[complex_div;GSYM complex_ring_clauses] THEN
    sufficesby(GSYM RING_SUM_RMUL) THEN
    qed[in_complex_ring]
  ; pass
  ] THEN
  subgoal `!p. p IN P ==> norm(ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. complex_root_powersums p i / Cx(&(FACT i)))) <= &(poly_deg complex_ring p) * exp A * A pow (n+1) / &(FACT n)` THENL [
    intro THEN
    have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
    simp[vsum_ring_sum_complex] THEN
    rw[GSYM ring_sub_complex] THEN
    simp[GSYM ring_sum_sub;in_complex_ring] THEN
    simp[GSYM vsum_ring_sum_complex] THEN
    specialize[`complex_root p`]VSUM_NORM_LE THEN
    have `!z. z IN complex_root p ==> norm(cexp z - vsum (0..n) (\i. z pow i / Cx (&(FACT i)))) <= exp A * A pow (n + 1) / &(FACT n)` [IN] THEN
    have `norm(vsum (complex_root p) (\z. cexp z - vsum (0..n) (\i. z pow i / Cx (&(FACT i))))) <= sum (complex_root p) (\z. exp A * A pow (n + 1) / &(FACT n))` [VSUM_NORM_LE] THEN
    specialize[`exp A * A pow (n + 1) / &(FACT n)`;`complex_root p`]SUM_CONST THEN
    have `CARD(complex_root p) = poly_deg complex_ring p` [distinct_minpolys_card_root] THEN
    rw[ring_sub_complex] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!p. p IN P ==> norm (complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int(B p) * complex_root_powersums p i) / Cx (&(FACT i)))) <= abs(real_of_int(B p)) * &(poly_deg complex_ring p) * exp A * A pow (n + 1) / &(FACT n)` THENL [
    intro THEN
    subgoal `vsum (0..n) (\i. (complex_of_int(B p) * complex_root_powersums p i) / Cx (&(FACT i))) = vsum (0..n) (\i. complex_of_int(B p) * (complex_root_powersums p i / Cx (&(FACT i))))` THENL [
      sufficesby VSUM_EQ THEN
      rw[complex_div] THEN
      qed[COMPLEX_MUL_ASSOC]
    ; pass
    ] THEN
    subgoal `vsum (0..n) (\i. complex_of_int(B p) * (complex_root_powersums p i / Cx (&(FACT i)))) = complex_of_int(B p) * vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i))))` THENL [
      specialize[`complex_of_int(B(p:(1->num)->complex))`;`\i. complex_root_powersums p i / Cx (&(FACT i))`]VSUM_COMPLEX_LMUL THEN
      qed[FINITE_NUMSEG]
    ; pass
    ] THEN
    have `vsum (0..n) (\i. (complex_of_int(B p) * complex_root_powersums p i) / Cx (&(FACT i))) = complex_of_int(B p) * vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i))))` [] THEN
    have `complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int(B p) * complex_root_powersums p i) / Cx (&(FACT i))) = complex_of_int(B p) * (ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i)))))` [COMPLEX_SUB_LDISTRIB] THEN
    have `norm(complex_of_int(B p) * (ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i)))))) = norm(complex_of_int(B p)) * norm(ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i)))))` [COMPLEX_NORM_MUL] THEN
    have `norm(complex_of_int(B(p:(1->num)->complex))) = abs(real_of_int(B p))` [complex_of_int;COMPLEX_NORM_CX] THEN
    have `norm(complex_of_int(B p) * (ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i)))))) = abs(real_of_int(B p)) * norm(ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i)))))` [] THEN
    have `abs(real_of_int(B p)) * norm(ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_root_powersums p i / Cx (&(FACT i))))) <= abs(real_of_int(B p)) * &(poly_deg complex_ring p) * exp A * A pow (n + 1) / &(FACT n)` [REAL_ABS_POS;REAL_LE_LMUL] THEN
    qed[REAL_LE_TRANS]
  ; pass
  ] THEN
  subgoal `norm(vsum P (\p. vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i))))) <= sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p) * exp A * A pow (n + 1) / &(FACT n))` THENL [
    specialize[`P:((1->num)->complex)->bool`;`\p. (complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i))))`;`\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p) * exp A * A pow (n + 1) / &(FACT n)`]VSUM_NORM_LE THEN
    specialize[`\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp`;`\p. vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i)))`;`P:((1->num)->complex)->bool`]VSUM_SUB THEN
    have `vsum P (\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i)))) = vsum P (\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp) - vsum P (\p. vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i))))` [] THEN
    have `vsum P (\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i)))) = -- vsum P (\p. vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i))))` [vsum_ring_sum_complex;COMPLEX_SUB_LZERO] THEN
    have `norm(vsum P (\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i))))) = norm(vsum P (\p. vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i)))))` [NORM_NEG] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `vsum P (\p. vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i)))) = vsum(0..n) (\i. u i / Cx(&(FACT i)))` THENL [
    have `FINITE (0..n)` [FINITE_NUMSEG] THEN
    specialize[`\p i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i))`;`P:((1->num)->complex)->bool`;`0..n`]VSUM_SWAP THEN
    simp[] THEN
    sufficesby VSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    simp[vsum_ring_sum_complex] THEN
    rw[complex_div] THEN
    specialize_assuming[`complex_ring`;`\p. ring_mul complex_ring (complex_of_int (B p)) (complex_root_powersums p x)`;`inv(Cx(&(FACT x)))`;`P:((1->num)->complex)->bool`]RING_SUM_RMUL THEN
    simp[GSYM complex_ring_clauses] THEN
    qed[in_complex_ring]
  ; pass
  ] THEN
  have `norm(vsum(0..n) (\i. u i / Cx(&(FACT i)))) <= sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p) * exp A * A pow (n + 1) / &(FACT n))` [] THEN
  subgoal `sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p) * exp A * A pow (n + 1) / &(FACT n)) = sum P (\p:(1->num)->complex. (abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) / &(FACT n))` THENL [
    rw[REAL_DIV] THEN
    sufficesby SUM_EQ THEN
    CONV_TAC REAL_FIELD
  ; pass
  ] THEN
  subgoal `sum P (\p:(1->num)->complex. (abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) / &(FACT n)) = (sum P (\p:(1->num)->complex. (abs (real_of_int (B p)) * &(poly_deg complex_ring p)))) * exp A * A pow (n + 1) / &(FACT n)` THENL [
    specialize[`\p:(1->num)->complex. (abs (real_of_int (B p)) * &(poly_deg complex_ring p))`;`exp A * A pow (n + 1) / &(FACT n)`]SUM_RMUL THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For all `P`, `A`, `B`, and `u`, if `P` is finite, `P` has distinct minimal polynomials, for every `p` in `P` and every `z` such that `z` is a complex root of `p`, the norm of `z` is less than or equal to `A`, and the ring sum (over complex numbers) of `P` applied to the function mapping `p` to `complex_of_int(B p) * ring_sum (over complex numbers) of the complex roots of p applied to `cexp` is equal to the complex number 0, and for all `n`, `u n` is equal to the ring sum (over complex numbers) of `P` applied to the function mapping `p` to `(complex_of_int(B p)) * complex_root_powersums p n`, then for all `n`, the norm of the sum from `0` to `n` of `u i / Cx(&(FACT i))` is less than or equal to the sum of `P` of the function mapping `p` to `abs (real_of_int (B p)) * &(poly_deg complex_ring p)` which is then multiplied by `exp A * A pow (n + 1) / &(FACT n)`.

### Informal sketch
The proof establishes an upper bound on the norm of a summation involving `u`.

- The initial goal is to show that the norm of a sum involving `u` is bounded by an expression involving `A`, `B`, `P`, and `n`.
- The proof proceeds by a series of subgoal refinements.
- The first subgoal proves an inequality about the norm of the difference between `cexp z` and the truncated Taylor series of `cexp`. This inequality is derived using `TAYLOR_CEXP` and several manipulations of inequalities based on the assumptions about the norm of the complex root `z`.
- The second subgoal proves an equality that rewrites a summation of `complex_root_powersums` in terms of a summation over the roots themselves. This step involves swapping summations and simplifying.
- The third subgoal establishes an upper bound for the norm of the difference between a ring sum involving `cexp` and a related vsum. It uses the fact that `complex_root p` is finite, and the result about `cexp` derived earlier.
- The fourth subgoal establishes an upper bound on the absolute value of something of the form `(complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int(B p) * complex_root_powersums p i) / Cx (&(FACT i))))`. It simplifies, and uses the fact that `norm(complex_of_int(B(p:(1->num)->complex))) = abs(real_of_int(B p))`.
- The fifth subgoal establishes an upper bound on the norm of a `vsum P` of something where the function being summed over is `complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp - vsum (0..n) (\i. (complex_of_int (B p) * complex_root_powersums p i) / Cx (&(FACT i)))`. This uses `VSUM_NORM_LE` and manipulation of vsums.
- The sixth subgoal rewrites a vsum in terms of `u i`.
- The last steps perform algebraic manipulation to obtain the final result.

### Mathematical insight
This theorem provides an upper bound on the truncation error when approximating a certain sum involving complex exponentials and powers of roots of minimal polynomials. The result is likely relevant for proving the transcendence of certain numbers by showing that this error term converges to zero faster than the other terms in a related expression.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `complex_root`
- `norm`
- `complex_ring`
- `complex_of_int`
- `cexp`
- `complex_root_powersums`
- `vsum`
- `Cx`
- `FACT`
- `poly_deg`
- `exp`
- `TAYLOR_CEXP`
- `NORM_POS_LE`
- `REAL_POW_LE`
- `REAL_POW_LE2`
- `REAL_LE_INV`
- `REAL_LE_RMUL`
- `REAL_LE_MUL`
- `COMPLEX_NORM_GE_RE_IM`
- `REAL_LE_TRANS`
- `REAL_EXP_MONO_LE`
- `REAL_EXP_POS_LE`
- `REAL_LE_MUL2`
- `complex_root_powersums`
- `FINITE_NUMSEG`
- `distinct_minpolys_finite_root`
- `SUM_CONST`
- `distinct_minpolys_card_root`
- `COMPLEX_MUL_ASSOC`
- `COMPLEX_SUB_LDISTRIB`
- `COMPLEX_NORM_MUL`
- `COMPLEX_NORM_CX`
- `REAL_ABS_POS`
- `REAL_LE_LMUL`
- `REAL_DIV`
- `REAL_FIELD`
- `RING_SUM_RMUL`
- `IN`
- `VSUM_COMPLEX_LMUL`
- `vsum_ring_sum_complex`
- `GSYM`
- `complex_ring_clauses`
- `VSUM_SUB`
- `NORM_NEG`
- `REAL_FIELD`
- `COMPLEX_SUB_LZERO`
- `in_complex_ring`
- `REAL_LE_MUL`
- `COMPLEX_MUL_ASSOC`
- `VSUM_COMPLEX_LMUL`
- `VSUM_NORM_LE`
- `BETA_THM`

### Porting notes (optional)
- The extensive use of real and complex analysis lemmas may require a well-developed library in the target proof assistant.
- The rewriting tactics may need to be adapted depending on the rewriting capabilities available.
- The `complex_ring` structure needs to be defined.


---

## transcendence_v_bound

### Name of formal statement
transcendence_v_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_v_bound = prove(`
  !P A B u.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  !n vn.
  vn = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) ==>
  norm vn
  <= (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))) * exp A * A pow (n + 1)
`,
  intro THEN
  subgoal `ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i) = Cx(&(FACT n)) * vsum(0..n) (\i. u i / Cx(&(FACT i)))` THENL [
    have `FINITE(0..n)` [FINITE_NUMSEG] THEN
    simp[GSYM vsum_ring_sum_complex] THEN
    simp[GSYM VSUM_COMPLEX_LMUL] THEN
    sufficesby VSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    rw[complex_div] THEN
    simp[GSYM VSUM_COMPLEX_RMUL] THEN
    simp[GSYM VSUM_COMPLEX_LMUL] THEN
    sufficesby VSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    have `x <= n:num` [IN_NUMSEG] THEN
    simp[GSYM REAL_OF_NUM_MUL] THEN
    simp[REAL_OF_NUM_BINOM] THEN
    have `~(FACT(n-x) = 0)` [FACT_NZ] THEN
    have `~(&(FACT(n-x)) = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&(FACT(n-x))) = Cx(&0))` [CX_INJ] THEN
    have `~(FACT(x) = 0)` [FACT_NZ] THEN
    have `~(&(FACT(x)) = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&(FACT(x))) = Cx(&0))` [CX_INJ] THEN
    rw[CX_MUL;CX_DIV] THEN
    rw[GSYM complex_div] THEN
    complex_field_fact `~(Cx(&(FACT x)) = Cx(&0)) ==> ~(Cx(&(FACT(n-x))) = Cx(&0)) ==> (Cx (&(FACT (n - x))) * Cx (&(FACT n)) / (Cx (&(FACT (n - x))) * Cx (&(FACT x)))) * complex_of_int (B x') * complex_root_powersums x' x = Cx (&(FACT n)) * (complex_of_int (B x') * complex_root_powersums x' x) / Cx (&(FACT x))` THEN
    qed[]
  ; pass
  ] THEN
  have `vn = Cx(&(FACT n)) * vsum(0..n) (\i. u i / Cx(&(FACT i)))` [] THEN
  have `norm(vn:complex) = norm(Cx(&(FACT n))) * norm(vsum(0..n) (\i. u i / Cx(&(FACT i))))` [COMPLEX_NORM_MUL] THEN
  have `norm(vn:complex) = abs(&(FACT n)) * norm(vsum(0..n) (\i. u i / Cx(&(FACT i))))` [COMPLEX_NORM_CX] THEN
  have `abs(&(FACT n)) = &(FACT n):real` [REAL_ABS_REFL;FACT_LT;LT_IMP_LE;REAL_OF_NUM_LE] THEN
  have `norm(vn:complex) = &(FACT n) * norm(vsum(0..n) (\i. u i / Cx(&(FACT i))))` [] THEN
  have `norm(vsum(0..n) (\i. u i / Cx(&(FACT i)))) <= (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))) * exp A * A pow (n + 1) / &(FACT n)` [transcendence_u_tail] THEN
  have `&(FACT n) * norm(vsum(0..n) (\i. u i / Cx(&(FACT i)))) <= &(FACT n) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))) * exp A * A pow (n + 1) / &(FACT n)` [REAL_LE_LMUL;FACT_LT;LT_IMP_LE;REAL_OF_NUM_LE] THEN
  have `norm(vn:complex) <= &(FACT n) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))) * exp A * A pow (n + 1) / &(FACT n)` [] THEN
  have `~(FACT(n) = 0)` [FACT_NZ] THEN
  have `~(&(FACT(n)) = &0:real)` [REAL_OF_NUM_EQ] THEN
  real_field_fact `~(&(FACT n) = &0:real) ==> &(FACT n) * sum P (\p. abs (real_of_int (B(p:(1->num)->complex))) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) / &(FACT n) = sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` THEN
  qed[]
);;
```

### Informal statement
For any set `P` of polynomials, any real numbers `A`, `B`, any function `u` from natural numbers to complex numbers :
If `P` is finite, and the minimal polynomials in `P` are distinct, and for all polynomials `p` in `P` and all complex roots `z` of `p`, the norm of `z` is less than or equal to `A`, and the sum of `complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp` over `P` equals the complex zero, and for all `n`, `u n` is equal to `ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n)`, then for all `n` and `vn`, if `vn` equals `ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)`, then the norm of `vn` is less than or equal to the `sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)`.

### Informal sketch
The proof proceeds as follows:
- First, show that `ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)` equals `Cx(&(FACT n)) * vsum(0..n) (\i. u i / Cx(&(FACT i)))`. This is done by simplifying the left-hand side using properties of `vsum` and `ring_sum`, and then employing `VSUM_EQ` after several rewriting steps involving `BETA_THM`, `complex_div`, and field facts.
- Next, prove that `vn = Cx(&(FACT n)) * vsum(0..n) (\i. u i / Cx(&(FACT i)))`.
- Then, derive `norm(vn:complex) = norm(Cx(&(FACT n))) * norm(vsum(0..n) (\i. u i / Cx(&(FACT i))))` using `COMPLEX_NORM_MUL`.
- Simplify `norm(Cx(&(FACT n)))` to `abs(&(FACT n))` by `COMPLEX_NORM_CX`, and further to `&(FACT n)` using `REAL_ABS_REFL`,`FACT_LT`,`LT_IMP_LE` and `REAL_OF_NUM_LE`.
- Bound `norm(vsum(0..n) (\i. u i / Cx(&(FACT i))))` using `transcendence_u_tail` to get `(sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))) * exp A * A pow (n + 1) / &(FACT n)`.
- Conclude by algebraic manipulation and using a field fact to cancel out `&(FACT n)`.

### Mathematical insight
This theorem provides an upper bound on the norm of a complex number `vn` defined in terms of a sum involving the function `u`. The function `u` itself is related to power sums of roots of polynomials in the set `P`. This bound is crucial for proving transcendence results, particularly for showing that certain numbers cannot be roots of polynomials with integer coefficients.

### Dependencies
- `FINITE_NUMSEG`
- `GSYM vsum_ring_sum_complex`
- `GSYM VSUM_COMPLEX_LMUL`
- `VSUM_EQ`
- `BETA_THM`
- `complex_div`
- `GSYM REAL_OF_NUM_MUL`
- `GSYM REAL_OF_NUM_BINOM`
- `FACT_NZ`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `CX_MUL`
- `CX_DIV`
- `GSYM complex_div`
- `COMPLEX_NORM_MUL`
- `COMPLEX_NORM_CX`
- `REAL_ABS_REFL`
- `FACT_LT`
- `LT_IMP_LE`
- `REAL_OF_NUM_LE`
- `transcendence_u_tail`
- `REAL_LE_LMUL`

### Porting notes (optional)
- The key step is porting all the field tactics in the first subgoal using the field tactic present in other provers. 
- `complex_field_fact`; `real_field_fact` use HOL Light's specific mechanism for rewriting using field arithmetic. When porting to other proof assistants, this may require invoking a field tactic or manually performing the algebraic simplifications.



---

## transcendence_p_bound

### Name of formal statement
transcendence_p_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_p_bound = prove(`
  !P p A.
  distinct_minpolys P ==>
  p IN P ==>
  (!z. complex_root p z ==> norm z <= A) ==>
  (!d. norm(coeff d (x_truncreverse QinC_ring (poly_deg complex_ring p) p)) <= A pow d * &(binom(poly_deg complex_ring p,d)))
`,
  intro THEN
  have `monic_vanishing_at complex_ring (complex_root p) I = p` [distinct_minpolys_monic_vanishing_at] THEN
  have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
  have `CARD(complex_root p) = poly_deg complex_ring p` [distinct_minpolys_card_root] THEN
  have `!z. z IN complex_root p ==> I z IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`I:complex->complex`;`complex_root p`]x_truncreverse_monic_vanishing_at THEN
  have `x_truncreverse complex_ring (CARD(complex_root p)) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` [] THEN
  have `x_truncreverse complex_ring (poly_deg complex_ring p) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` [] THEN
  have `x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` [x_truncreverse_subring;subring_complex_QinC] THEN
  simp[] THEN
  have `!z. z IN complex_root p ==> ring_powerseries complex_ring (one_minus_constx complex_ring (I z))` [series_complex] THEN
  have `!z. z IN complex_root p ==> norm(I z) <= A` [IN;I_THM] THEN
  have `!z d. z IN complex_root p ==> norm(coeff d (one_minus_constx complex_ring (I z))) <= A pow d * &(binom(1,d))` [coeff_root_bound_one_minus_constx] THEN
  specialize[`\z. one_minus_constx complex_ring (I z)`;`A:real`;`\z:complex. 1:num`;`complex_root p`]coeff_root_bound_product THEN
  have `norm (coeff d (poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z)))) <= A pow d * &(binom (CARD (complex_root p),d))` [CARD_EQ_NSUM] THEN
  qed[]
);;
```
### Informal statement
For any set of polynomials `P`, any polynomial `p`, and any real number `A`, if `P` consists of distinct minimal polynomials, `p` is an element of `P`, and for all complex numbers `z`, if `z` is a complex root of `p`, then the norm of `z` is less than or equal to `A`, then for all natural numbers `d`, the norm of the coefficient of `x^d` in the truncated and reversed polynomial `QinC_ring (poly_deg complex_ring p) p` is less than or equal to `A` raised to the power of `d` multiplied by the binomial coefficient of `poly_deg complex_ring p` and `d`.

### Informal sketch
The proof proceeds as follows:

- Assume `P` is a set of distinct minimal polynomials, `p` is in `P`, and all complex roots `z` of `p` satisfy `norm z <= A`.

- Use `distinct_minpolys_monic_vanishing_at` to show that the polynomial `p` is equal to the monic polynomial that vanishes at the complex root of `p`.
- Use `distinct_minpolys_finite_root` to show that `complex_root p` is a finite set.
- Use `distinct_minpolys_card_root` to show that the cardinality of `complex_root p` is equal to `poly_deg complex_ring p`.
- Use `in_complex_ring` to show that for any complex polynomial `z`, if it is a root of `p`, then `I z` is in the complex ring carrier.  Here `I` injects complex field elements into the complex ring.
- Use `x_truncreverse_monic_vanishing_at` to express the truncated and reversed polynomial `x_truncreverse` `complex_ring (CARD(complex_root p)) p` as the product of `one_minus_constx complex_ring (I z)` over all roots `z` of `p` in the complex ring.

- Rewrite `x_truncreverse complex_ring (poly_deg complex_ring p) p` as `poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))`.

- Use `x_truncreverse_subring` and `subring_complex_QinC` to rewrite `x_truncreverse QinC_ring (poly_deg complex_ring p) p` as `poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))`.

- Simplify the goal.
- Use `series_complex` to show that `one_minus_constx complex_ring (I z)` is in `ring_powerseries complex_ring`.
- Use the assumption that `norm(I z) <= A` for `z` in `complex_root p`.

- Apply `coeff_root_bound_one_minus_constx`: show norm of coefficient d of `one_minus_constx complex_ring (I z)` is bounded by `A pow d * &(binom(1,d))`.
- Apply `coeff_root_bound_product` to bound the norm of coefficients of a polynomial product by binomial coefficients and the bound `A`.

- Use `CARD_EQ_NSUM` to show `norm (coeff d (poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z)))) <= A pow d * &(binom (CARD (complex_root p),d))`.

### Mathematical insight
This theorem provides a bound on the coefficients of a polynomial `p` based on the norms of its complex roots. Specifically, it bounds the coefficients of the reversed and truncated version of `p`. This is useful in transcendence theory as it relates the size of the coefficients of a polynomial to the size of its roots, providing a tool for analyzing algebraic numbers.

### Dependencies
- `distinct_minpolys_monic_vanishing_at`
- `distinct_minpolys_finite_root`
- `distinct_minpolys_card_root`
- `in_complex_ring`
- `x_truncreverse_monic_vanishing_at`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `series_complex`
- `coeff_root_bound_one_minus_constx`
- `coeff_root_bound_product`
- `CARD_EQ_NSUM`

### Porting notes (optional)
- The `x_truncreverse` function and the `QinC_ring` may need careful consideration when porting. The definition of `x_truncreverse` generally involves truncating a polynomial at a certain degree and reversing the order of coefficients. `QinC_ring` and the injection `I` relate to coercions to the complex numbers.
- The handling of complex numbers and their norms might differ across proof assistants, requiring adjustments to the HOL Light's definitions.
- The proof relies heavily on properties of binomial coefficients and polynomial products, so corresponding theorems in the target proof assistant will be needed.


---

## transcendence_H_bound

### Name of formal statement
transcendence_H_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_H_bound = prove(`
  !P A t H.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!d. norm(coeff d H) <= A pow d * &(binom(t,d)))
`,
  intro THEN
  specialize[`P:((1->num)->complex)->bool`;`H:(1->num)->complex`;`t:num`]transcendence_H_product_complex_ring THEN
  have `!p d. p IN P ==> norm(coeff d (x_truncreverse QinC_ring (poly_deg complex_ring p) p)) <= A pow d * &(binom(poly_deg complex_ring p,d))` [transcendence_p_bound] THEN
  specialize[`\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p`;`A:real`;`\p:(1->num)->complex. poly_deg complex_ring p`;`P:((1->num)->complex)->bool`]coeff_root_bound_product THEN
  qed[]
);;
```
### Informal statement
For any set `P` of complex polynomials, any real number `A`, any natural number `t`, and any complex polynomial `H`, if `P` is finite, the elements of `P` have distinct minimal polynomials, the norm of every complex root `z` of every polynomial `p` in `P` is less than or equal to `A`, `t` is the sum, over elements `p` of `P`, of the degree of `p`, and `H` is the polynomial obtained by reversing the coefficients of `poly_product QinC_ring P I` after truncating to degree `t`, then for any degree `d`, the norm of the `d`-th coefficient of `H` is less than or equal to `A` to the power of `d` multiplied by the binomial coefficient of `t` choose `d`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions: the finiteness of the set of polynomials `P`, the distinctness of their minimal polynomials, a bound `A` on the norms of their complex roots; `t` being the sum of the degrees of the polynomials in `P`, and `H` obtained by reversing and truncating the product of polynomials in `P`.  
- Apply `transcendence_H_product_complex_ring`.
- Obtain an upper bound for the coefficients of `x_truncreverse QinC_ring (poly_deg complex_ring p) p` called `transcendence_p_bound`.
- Apply `coeff_root_bound_product` with the parameters `\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p`, `A`, `\p:(1->num)->complex. poly_deg complex_ring p`, and `P`.
- Conclude.

### Mathematical insight
This theorem provides a bound on the magnitude of the coefficients of a polynomial `H` constructed from a set `P` of other polynomials. `H` is created by taking the product of the polynomials in `P`, truncating the result to a specified degree `t`, and then reversing the coefficients. The theorem essentially states that if the roots of polynomials in `P` are bounded in magnitude by `A`, then the coefficients of `H` are also bounded by a quantity that depends on `A`, `t`, and the binomial coefficients. This is crucial in transcendence theory, where one needs precise control over the sizes of the algebraic numbers being constructed.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `complex_root`
- `norm`
- `nsum`
- `poly_deg`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `I`
- `coeff`
- `binom`
- `transcendence_H_product_complex_ring`
- `transcendence_p_bound`
- `coeff_root_bound_product`


---

## transcendence_Hk_bound

### Name of formal statement
transcendence_Hk_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hk_bound = prove(`
  !P A t H k.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!d. norm(coeff d (poly_pow complex_ring H k)) <= A pow d * &(binom(k*t,d)))
`,
  intro THEN
  have `!d. norm(coeff d H:complex) <= (A:real) pow d * &(binom(t,d))` [transcendence_H_bound] THEN
  qed[coeff_root_bound_pow;series_complex;MULT_SYM]
);;
```
### Informal statement
For all sets of polynomials `P`, real numbers `A`, natural numbers `t`, polynomials `H`, and natural numbers `k`, if `P` is finite and `P` contains only distinct minimal polynomials, and for all polynomials `p` in `P` and complex numbers `z`, if `z` is a complex root of `p`, then the norm of `z` is less than or equal to `A`, and `t` is the sum over `P` of the degrees of the polynomials in `P` as elements of the complex ring, and `H` is the truncation of the formal power series obtained by reversing the series of `QinC_ring`, at `t`, of the product over `P` (in the sense of `QinC_ring`) of the polynomials in `P` with the identity polynomial `I`, then for all natural numbers `d`, the norm of the `d`-th coefficient of `H` raised to the `k`-th power (as a polynomial in the complex ring) is less than or equal to `A` to the power of `d` times the binomial coefficient of `k*t` and `d`.

### Informal sketch
The proof demonstrates a bound on the coefficients of a polynomial `H` raised to a power `k`. The key steps are as follows:

- Assume the hypotheses about `P`, `A`, `t`, `H`, and `k`.
- Apply `transcendence_H_bound` to show that for all natural numbers `d`, the norm of the `d`-th coefficient of `H` is less than or equal to `A` to the power of `d` times the binomial coefficient of `t` and `d`. This step probably uses the relationship between `H` and the product of minimal polynomials.
- Use `coeff_root_bound_pow` and other lemmas `series_complex` and `MULT_SYM`  to lift this bound to `H` raised to the power `k`, replacing `t` with `k*t` in the binomial coefficient.

### Mathematical insight
This theorem provides a bound on the coefficients of a polynomial related to a set of minimal polynomials. This bound is crucial in transcendence theory, as it allows to control the growth of certain expressions that arise when studying algebraic independence. The bound is expressed in terms of `A` (a bound on the roots of the minimal polynomials), `k` (an exponent), and binomial coefficients. The polynomial `H` is constructed using a truncated power series and the product of minimal polynomials, which makes it a key object in measuring the `transcendence degree` of field extensions.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `complex_root`
- `norm`
- `nsum`
- `poly_deg`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `I`
- `poly_pow`
- `coeff`
- `binom`
- `transcendence_H_bound`
- `coeff_root_bound_pow`
- `series_complex`
- `MULT_SYM`


---

## transcendence_A_nonnegative

### Name of formal statement
transcendence_A_nonnegative

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_A_nonnegative = prove(`
  !P A.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  (P = {} \/ &0 <= A)
`,
  intro THEN
  proven_if `P = {}:((1->num)->complex)->bool` [] THEN
  set_fact `~(P = {}) ==> ?p:(1->num)->complex. p IN P` THEN
  choose `p:(1->num)->complex` `(p:(1->num)->complex) IN P` [] THEN
  have `~(poly_deg complex_ring (p:(1->num)->complex) = 0)` [distinct_minpolys_deg_nonzero] THEN
  have `~(CARD(complex_root p) = 0)` [distinct_minpolys_card_root] THEN
  have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
  have `~(complex_root p = {})` [CARD_EQ_0] THEN
  set_fact `~(complex_root p = {}) ==> ?z:complex. z IN complex_root p` THEN
  choose `z:complex` `z IN complex_root p` [] THEN
  have `complex_root p z` [IN] THEN
  have `norm(z:complex) <= A` [] THEN
  qed[NORM_POS_LE;REAL_LE_TRANS]
);;
```
### Informal statement
For all sets `P` of complex polynomials and for all real numbers `A`, if `P` is finite, and all polynomials in `P` have distinct minimal polynomials, and for all polynomials `p` in `P` and all complex numbers `z`, if `z` is a complex root of `p`, then the norm of `z` is less than or equal to `A`, then either `P` is empty or `0` is less than or equal to `A`.

### Informal sketch
The proof proceeds by contradiction. We assume that `P` satisfies the given conditions (finiteness, distinct minimal polynomials, and norm bound on the roots), and that `P` is non-empty. The goal is to show that `0 <= A`.
- Assume `P` is non-empty, so there exists a polynomial `p` in `P`.
- Since the minimal polynomials are distinct, we know `poly_deg complex_ring p` is nonzero, meaning that `p` is not a constant polynomial. Also, the `complex_root p` set is non-empty and finite. The proof uses the theorems `distinct_minpolys_deg_nonzero`, `distinct_minpolys_card_root`, and `distinct_minpolys_finite_root` to establish these properties about the roots.
- Since `complex_root p` is non-empty, we can choose a complex root `z` of `p`.
- We know that `z` is a complex root of `p`, which is in `P`. Thus, by assumption, `norm z <= A`.
- Since norm is always nonnegative (by theorem `NORM_POS_LE`), we have 0 <= norm z <= A. Therefore, `0 <= A` by transitivity (`REAL_LE_TRANS`).

### Mathematical insight
The theorem establishes a necessary condition for a finite set of polynomials with distinct minimal polynomials to have all their complex roots bounded by a real number `A`. If `P` is non-empty and its roots are bounded, then `A` must be non-negative. The core idea hinges on the fact that the norm of a complex number is non-negative and that a root must exists because the degree of the minimal polynomial is positive.

### Dependencies
- `distinct_minpolys_deg_nonzero`: States that a polynomial with distinct minimal polynomials has a degree greater than zero.
- `distinct_minpolys_card_root`: States that the roots of polynomials with distinct minimal polynomials is non-empty.
- `distinct_minpolys_finite_root`: States that the complex roots of a polynomial with distinct minimal polynomials is finite.
- `CARD_EQ_0`: Relates the cardinality of a set to emptiness.
- `NORM_POS_LE`: States that the norm of any complex number is greater or equal to zero.
- `REAL_LE_TRANS`: States the transitivity of the real less than or equal to relation.

### Porting notes (optional)
- The theorem relies on properties of complex numbers and their norms, which are typically standard in proof assistants.
- Ensure that the definitions of `FINITE`, `distinct_minpolys`, `complex_root`, and `norm` are compatible.
- The proof uses classical reasoning to pick elements from non-empty sets. This might need explicit handling in some constructive proof assistants.


---

## transcendence_Hv_bound

### Name of formal statement
transcendence_Hv_bound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_bound = prove(`
  !P A B t H u v.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n k. norm (
           coeff n (
             poly_mul complex_ring (
               poly_pow complex_ring H k
             ) (
               series_from_coeffs v
             )
           )
         ) <= &2 pow (k*t) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)
  )
`,
  intro THEN
  rw[coeff_poly_mul_oneindex;complex_ring_clauses;coeff_series_from_coeffs] THEN
  specialize[`P:((1->num)->complex)->bool`;`A:real`;`t:num`]transcendence_Hk_bound THEN
  have `!d. norm(coeff d (poly_pow complex_ring H k)) <= A pow d * &(binom(k*t,d))` [] THEN
  specialize[`P:((1->num)->complex)->bool`;`A:real`;`B:((1->num)->complex)->int`;`u:num->complex`]transcendence_v_bound THEN
  have `!d. norm(v(n-d):complex) <= sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow ((n-d) + 1)` [] THEN
  have `!d. d IN (0..n) ==> norm(coeff d (poly_pow complex_ring H k) * v(n-d)) <= (A pow d * &(binom(k*t,d))) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow ((n-d) + 1)` [COMPLEX_NORM_MUL;REAL_LE_MUL2;NORM_POS_LE] THEN
  have `FINITE (0..n)` [FINITE_NUMSEG] THEN
  specialize[`0..n`;`\d. coeff d (poly_pow complex_ring H k) * v(n-d)`]VSUM_NORM_LE THEN
  have `norm(vsum(0..n) (\d. coeff d (poly_pow complex_ring H k) * v(n-d))) <= sum(0..n) (\d. (A pow d * &(binom(k*t,d))) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow ((n-d) + 1))` [] THEN
  subgoal `sum (0..n) (\d. (A pow d * &(binom (k * t,d))) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n - d + 1)) = sum (0..n) (\d. &(binom (k * t,d)) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1))` THENL [
    sufficesby SUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    have `x <= n:num` [IN_NUMSEG] THEN
    num_linear_fact `x <= n:num ==> n+1 = x + (n-x+1)` THEN
    have `(A:real) pow (n+1) = A pow x * A pow (n-x+1)` [REAL_POW_ADD] THEN
    real_linear_fact `(A pow x * &(binom (k * t,x))) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n - x + 1) = &(binom (k * t,x)) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * (A pow x * A pow (n-x+1))` THEN
    qed[]
  ; pass
  ] THEN
  have `norm(vsum(0..n) (\d. coeff d (poly_pow complex_ring H k) * v(n-d))) <= sum(0..n) (\d. &(binom(k*t,d)) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1))` [] THEN
  specialize[`\d. &(binom(k*t,d))`;`sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)`]SUM_RMUL THEN
  have `sum(0..n) (\d. &(binom(k*t,d)) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)) = sum(0..n) (\d. &(binom(k*t,d))) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` [] THEN
  subgoal `sum(0..n) (\d. &(binom(k*t,d))) <= (&2:real) pow (k*t)` THENL [
    simp[GSYM REAL_OF_NUM_SUM] THEN
    specialize[`k * nsum P (\p:(1->num)->complex. poly_deg complex_ring p)`;`n:num`]binom_rowsum_partial THEN
    qed[REAL_OF_NUM_POW;REAL_OF_NUM_LE]
  ; pass
  ] THEN
  subgoal `&0:real <= sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` THENL [
    have `!p:(1->num)->complex. p IN P ==> &0 <= abs(real_of_int(B p))` [REAL_ABS_POS] THEN
    have `!p:(1->num)->complex. p IN P ==> &0:real <= &(poly_deg complex_ring p)` [REAL_OF_NUM_LE;ARITH_RULE `0 <= x`] THEN
    have `!p:(1->num)->complex. p IN P ==> &0 <= abs (real_of_int (B p)) * &(poly_deg complex_ring p)` [REAL_LE_MUL] THEN
    have `&0 <= sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))` [SUM_POS_LE] THEN
    have `&0 <= exp A` [REAL_EXP_POS_LE] THEN
    case `&0:real <= A` THENL [
      have `&0:real <= A pow (n+1)` [REAL_POW_LE] THEN
      qed[REAL_LE_MUL]
    ;
      specialize[`P:((1->num)->complex)->bool`;`A:real`]transcendence_A_nonnegative THEN
      have `P = {}:((1->num)->complex)->bool` [] THEN
      simp[SUM_CLAUSES] THEN
      CONV_TAC REAL_FIELD
    ]
  ; pass
  ] THEN
  have `sum (0..n) (\d. &(binom (k * t,d))) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) <= &2 pow (k * t) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` [REAL_LE_RMUL] THEN
  have `norm (ring_sum complex_ring (0..n) (\a. coeff a (poly_pow complex_ring H k) * v (n - a))) = norm (vsum (0..n) (\a. coeff a (poly_pow complex_ring H k) * v (n - a)))` [vsum_ring_sum_complex] THEN
  qed[REAL_LE_TRANS]
);;
```

### Informal statement
For all `P`, `A`, `B`, `t`, `H`, `u`, and `v`, if `P` is a finite set of polynomials over the complex numbers, and `P` consists of distinct minimal polynomials, and the ring sum over `P` of terms of the form (`complex_of_int(B p)` times the ring sum over the complex roots of `p` of the exponential function `cexp`) equals the complex number 0, and for all `p` in `P` and complex root `z` of `p`, the norm of `z` is less than or equal to `A`, and `t` is the sum over `P` of the degrees of the polynomials `p`, and `H` is the truncation of the product of polynomials in `P` at degree `t`, and for all `n`, `u n` is the ring sum over `P` of terms of the form `complex_of_int(B p)` times the powersums of degree `n` of the complex roots of `p`, and for all `n`, `v n` is the ring sum over `0..n` of terms of the form `Cx(&(FACT(n-i) * binom(n,i))) * u i`, then for all `n` and `k`, the norm of the `n`-th coefficient of the polynomial resulting from multiplying the `k`-th power of `H` by the series derived from the coefficients `v`, is less than or equal to `2^(k*t) * (sum over P of `abs(real_of_int(B p)) * degree(p)`) * exp(A) * A^(n+1)`.

### Informal sketch
The proof demonstrates an upper bound on the norm of the `n`-th coefficient of the product of `H^k` and `series_from_coeffs v`, where `H` is a truncated polynomial and `v` is a series derived from powersums of roots of polynomials in `P`.

- The proof starts by rewriting using `coeff_poly_mul_oneindex` and `complex_ring_clauses`, and `coeff_series_from_coeffs`. After rewriting, it specializes hypotheses using `transcendence_Hk_bound` and `transcendence_v_bound` to obtain bounds on the norm of `coeff d (poly_pow complex_ring H k)` and `norm(v(n-d):complex)`, respectively.
- It uses `COMPLEX_NORM_MUL`, `REAL_LE_MUL2`, `NORM_POS_LE` to show that the norm of the product `coeff d (poly_pow complex_ring H k) * v(n-d)` is bounded by the product of their norms.
- Using `FINITE_NUMSEG` and `VSUM_NORM_LE`, we bound the norm of the vsum by the sum of the norms.
- The proof subsequently simplifies the sum and uses `SUM_RMUL` to extract a common factor.
- Two subgoals are generated:
    - bound `sum(0..n) (\d. &(binom(k*t,d)))` by `(&2:real) pow (k*t)` which is proved using `binom_rowsum_partial`
    - show `&0:real <= sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` by considering the cases `&0:real <= A` and `NOT &0:real <= A`
- Finally, it combines these inequalities using `REAL_LE_TRANS` to arrive at the desired bound.

### Mathematical insight
The theorem establishes a bound on the growth of coefficients in a polynomial expression, which is essential in transcendence theory. The construction is motivated by bounding an expression related to the powersums of algebraic numbers.

### Dependencies
- `coeff_poly_mul_oneindex`
- `complex_ring_clauses`
- `coeff_series_from_coeffs`
- `transcendence_Hk_bound`
- `COMPLEX_NORM_MUL`
- `REAL_LE_MUL2`
- `NORM_POS_LE`
- `FINITE_NUMSEG`
- `VSUM_NORM_LE`
- `SUM_EQ`
- `BETA_THM`
- `IN_NUMSEG`
- `REAL_POW_ADD`
- `GSYM REAL_OF_NUM_SUM`
- `binom_rowsum_partial`
- `REAL_OF_NUM_POW`
- `REAL_OF_NUM_LE`
- `REAL_ABS_POS`
- `ARITH_RULE \`0 <= x\``
- `REAL_LE_MUL`
- `SUM_POS_LE`
- `REAL_EXP_POS_LE`
- `REAL_POW_LE`
- `transcendence_A_nonnegative`
- `SUM_CLAUSES`
- `vsum_ring_sum_complex`
- `REAL_LE_TRANS`
Categories:
- Complex Analysis: `COMPLEX_NORM_MUL`, `NORM_POS_LE`, `vsum_ring_sum_complex`
- Real Analysis: `REAL_LE_MUL2`, `REAL_LE_MUL`, `REAL_EXP_POS_LE`, `REAL_POW_LE`, `REAL_LE_TRANS`, `REAL_POW_ADD`
- Polynomials: `coeff_poly_mul_oneindex`, `coeff_series_from_coeffs`
- Sets and Sums: `FINITE_NUMSEG`, `VSUM_NORM_LE`, `SUM_CLAUSES`, `SUM_POS_LE`, `SUM_RMUL`, `SUM_EQ`
- Arithmetic: `BETA_THM`, `IN_NUMSEG`, `ARITH_RULE \`0 <= x\``,`REAL_OF_NUM_SUM`, `REAL_OF_NUM_POW`, `REAL_OF_NUM_LE`
- Binomials: `binom_rowsum_partial`

### Porting notes (optional)
- The handling of complex numbers and polynomials might differ across proof assistants. Ensure that the ring structures and associated theorems (`complex_ring_clauses`) are adapted accordingly.
- The tactic `num_linear_fact` and `real_linear_fact` might need to be replaced by suitable rewriting or algebraic simplification tactics available in the target proof assistant.
- The handling of reals and complex powers as well as the `REAL_ABS_POS` will probably vary from system to system.


---

## transcendence_Hv_zero

### Name of formal statement
transcendence_Hv_zero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_zero = prove(`
  !P A D B t H u v.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  D IN ZinC ==>
  ~(D = Cx(&0)) ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n k. k*t <= n ==>
         norm(D pow (n-k) / Cx(&(FACT k))) * &2 pow (k * t) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) < &1 ==>
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs v
           )
         ) = Cx(&0)
  )
`,
  intro THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `D:complex`;
    `B:((1->num)->complex)->int`
  ]transcendence_Hv_denom THEN
  have `D pow (n-k) / Cx(&(FACT k)) * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) IN ZinC` [] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `A:real`;
    `B:((1->num)->complex)->int`
  ]transcendence_Hv_bound THEN
  have `norm(coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))) <= &2 pow (k * t) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` [] THEN
  subgoal `~(D pow (n-k) / Cx(&(FACT k)) = Cx(&0))` THENL [
    have `~(D pow (n-k) = Cx(&0))` [COMPLEX_POW_EQ_0] THEN
    have `~(FACT k = 0)` [FACT_NZ] THEN
    have `~(&(FACT k) = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&(FACT k)) = Cx(&0))` [CX_INJ] THEN
    qed[COMPLEX_DIV_EQ_0]
  ; pass
  ] THEN
  qed[zero_if_ZinC_scale_bound]
);;
```

### Informal statement
For any set `P` of polynomials (from integers to complex numbers, represented as a function `(1->num)->complex`), any real number `A`, any integer-valued function `B` on polynomials, any complex number `D`, any natural number `t`, any function `H` on natural numbers, and any functions `u` and `v` on natural numbers, if the following conditions hold:

1.  `P` is finite.
2.  The minimum polynomials in `P` are distinct.
3.  The sum of `complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp` over all `p` in `P` equals the complex number `0`.
4.  For all `p` in `P` and all `z` in `complex_root p`, the norm of `z` is less than or equal to `A`.
5.  `D` is an integer (complex number with integer coefficients).
6.  `D` is not equal to `0`.
7.  For all `p` in `P` and all natural numbers `i`, `D pow i * (coeff (poly_deg complex_ring p - i) p)` is an integer.
8.  `t` is the sum of the degrees of the polynomials in `P`.
9.  `H` is the truncated reversed polynomial of degree `t` obtained by taking the product of polynomials in `P`.
10. For all natural numbers `n`, `u n` is the sum `ring_sum complex_ring P (\p. complex_of_int(B p) * complex_root_powersums p n)`.
11. For all natural numbers `n`, `v n` is the sum `ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)`.
12. For all natural numbers `n` and `k`, if `k*t <= n` and `norm(D pow (n-k) / Cx(&(FACT k))) * &2 pow (k * t) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) < &1`, then the coefficient of `n` in the product of `poly_pow complex_ring H k` and `series_from_coeffs v` is `0`.

### Informal sketch
The proof proceeds by specializing the theorem `transcendence_Hv_denom` and `transcendence_Hv_bound`. It then combines these results using `zero_if_ZinC_scale_bound`.

-   First specializing `transcendence_Hv_denom` to establish that `D pow (n-k) / Cx(&(FACT k)) * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) IN ZinC`.

-   Then specializing `transcendence_Hv_bound` to establish that `norm(coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))) <= &2 pow (k * t) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)`.

-   The last part establishes that assuming `~(D pow (n-k) / Cx(&(FACT k)) = Cx(&0))` leads to `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = Cx(&0)`.

-   Proving that `~(D pow (n-k) / Cx(&(FACT k)) = Cx(&0))` can be shown because `D` is not zero and FACT `k` is not zero. Specifically applies COMPLEX_POW_EQ_0 to prove `~(D pow (n-k) = Cx(&0))`, `FACT_NZ` and `REAL_OF_NUM_EQ` to prove `~(&(FACT k) = &0:real)` and `CX_INJ` to prove `~(Cx(&(FACT k)) = Cx(&0))` and `COMPLEX_DIV_EQ_0` to prove the goal.

-   The main result `coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = Cx(&0)` is then concluded by an application of `zero_if_ZinC_scale_bound`.

### Mathematical insight
This theorem is a step in proving the transcendence of `e`. It provides a condition under which a particular coefficient in a power series expansion is zero. This condition involves bounds on the norms of roots of certain polynomials and divisibility properties related to the coefficients of these polynomials. This is a key step in showing that `e` cannot be the root of any polynomial with integer coefficients.

### Dependencies
- `transcendence_Hv_denom`
- `transcendence_Hv_bound`
- `COMPLEX_POW_EQ_0`
- `FACT_NZ`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `COMPLEX_DIV_EQ_0`
- `zero_if_ZinC_scale_bound`

### Porting notes (optional)
-   The theorem relies heavily on complex number arithmetic and polynomial manipulation in HOL Light. Ensure that the target proof assistant has similar libraries.
-   The use of `complex_root`, `poly_deg`, `coeff`, `poly_mul`, `series_from_coeffs`, `Cx(&0)` and `Cx(&1)` indicates a need for detailed complex polynomial definitions.
-   The `ring_sum` operator requires a suitable port of algebraic structures, especially rings.
-   Tactics like `specialize` for instantiating quantifiers and `have` for creating subgoals are frequently used. Ensure that the target system has similar capabilities or alternative proof strategies.


---

## transcendence_Hv_zero_Ptrivial

### Name of formal statement
transcendence_Hv_zero_Ptrivial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_zero_Ptrivial = prove(`
  !P H u v.
  P = {} ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  (!n k. coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs v
           )
         ) = Cx(&0)
  )
`,
  intro THEN
  have `!n:num. v n = Cx(&0)` [transcendence_uv_trivial] THEN
  have `!n:num. v n = ring_0 complex_ring` [complex_ring_clauses] THEN
  rw[coeff_poly_mul_oneindex;coeff_series_from_coeffs] THEN
  rw[GSYM complex_ring_clauses] THEN
  sufficesby RING_SUM_EQ_0 THEN
  intro THEN
  rw[BETA_THM] THEN
  qed[RING_MUL_RZERO;in_complex_ring]
);;
```

### Informal statement
For all sets `P`, `H`, sequences `u`, and `v` of complex numbers, if `P` is the empty set and for all `n`, `u n` is the sum over `P` of `complex_of_int(B p) * complex_root_powersums p n` (where `B` and `complex_root_powersums` are unspecified functions related to roots of polynomials) and for all `n`, `v n` is the sum from `0` to `n` of `Cx(&(FACT(n-i) * binom(n,i))) * u i`, then for all `n` and `k`, the `n`-th coefficient of the power series obtained by multiplying the polynomial `H` raised to the `k`-th power with the power series generated by the coefficients `v`, is equal to the complex number `Cx(&0)`.

### Informal sketch
The proof proceeds as follows:

- First, introduce the assumptions of the theorem.
- Using the facts from `transcendence_uv_trivial` and `complex_ring_clauses`, show that for all `n`, `v n = Cx(&0)`.
- Rewrite the goal using `coeff_poly_mul_oneindex` and `coeff_series_from_coeffs`. This simplifies the left-hand side of the final equality.
- Rewrite using `complex_ring_clauses` to convert `Cx(&0)` into the ring zero element.
- Suffice to show that the ring sum is zero.
- Introduce `n` and `k`.
- Simplify using `BETA_THM`
- Conclude by using `RING_MUL_RZERO` and `in_complex_ring`.

### Mathematical insight
This theorem provides a condition under which the coefficients of a product of a polynomial and a power series are zero. The condition involves sums related to roots of polynomials and binomial coefficients. The key idea is that if `P` is empty, then the series `u n` is identically zero which implies `v n` is identically zero, leading to all coefficients being zero.

### Dependencies
- `transcendence_uv_trivial`
- `complex_ring_clauses`
- `coeff_poly_mul_oneindex`
- `coeff_series_from_coeffs`
- `BETA_THM`

Ring Theory:
- `RING_MUL_RZERO`
- `in_complex_ring`


---

## transcendence_Hv_zero_k0

### Name of formal statement
transcendence_Hv_zero_k0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_zero_k0 = prove(`
  !P A D B t H u v k0.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  D IN ZinC ==>
  ~(D = Cx(&0)) ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  1 <= k0 ==>
  norm(D) pow (10*t) * &2 pow t * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k0 ==>
  (!n k. k0 <= k ==>
         k*t <= n ==>
         n <= 10*k*t ==>
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs v
           )
         ) = Cx(&0)
  )
`,
  intro THEN
  proven_if `P = {}:((1->num)->complex)->bool` [transcendence_Hv_zero_Ptrivial] THEN
  case `t = 0` THENL [
    have `P = {}:((1->num)->complex)->bool` [distinct_minpolys_total_deg] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `norm (D pow (n - k) / Cx (&(FACT k))) * &2 pow (k * t) * sum P (\p:(1->num)->complex.  abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) < &1` THENL [
    have `&k0 <= &k:real` [REAL_OF_NUM_LE] THEN
    have `norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k` [REAL_LTE_TRANS] THEN
    real_linear_fact `norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) = (norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1)) * exp(&1)` THEN
    have `(norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1)) * exp(&1) < &k` [REAL_LTE_TRANS] THEN
    have `&0 < exp(&1)` [REAL_EXP_POS_LT] THEN
    have `norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) < &k / exp(&1)` [REAL_LT_RDIV_EQ] THEN
    subgoal `&0 <= norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1)` THENL [
      have `&0 <= norm(D:complex)` [NORM_POS_LE] THEN
      have `&0 <= norm(D:complex) pow (10*t)` [REAL_POW_LE] THEN
      real_linear_fact `&0 <= &2:real` THEN
      have `&0 <= &2 pow t` [REAL_POW_LE] THEN
      real_linear_fact `&0 <= &1:real` THEN
      have `&0 <= max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A)` [REAL_LE_MAX] THEN
      have `&0 <= max (&1) A` [REAL_LE_MAX] THEN
      have `&0 <= (max (&1) A) pow (10*t+1)` [REAL_POW_LE] THEN
      qed[REAL_LE_MUL]
    ; pass
    ] THEN
    num_linear_fact `1 <= k0 ==> k0 <= k ==> ~(k = 0)` THEN
    have `(norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1)) pow k < (&k / exp (&1)) pow k` [REAL_POW_LT2] THEN
    have `(&k / exp(&1)) pow k <= &(FACT k)` [factorial_lower_bound] THEN
    have `(norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1)) pow k < &(FACT k)` [REAL_LTE_TRANS] THEN
    havetac `(norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1)) pow k = norm(D:complex) pow ((10 * t) * k) * &2 pow (t * k) * (max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A)) pow k * (max (&1) A) pow ((10*t+1)*k)` (simp[REAL_POW_MUL;REAL_POW_POW]) THEN
    have `norm(D:complex) pow ((10*t) * k) * &2 pow (k * t) * (max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A)) pow k * (max (&1) A) pow ((10*t+1)*k) < &(FACT k)` [MULT_SYM] THEN
    rw[COMPLEX_NORM_DIV;COMPLEX_NORM_CX;COMPLEX_NORM_POW] THEN
    subgoal `norm(D:complex) pow (n - k) <= norm D pow ((10*t) * k)` THENL [
      have `~(norm(D:complex) < &1)` [zero_if_ZinC_norm_lt1] THEN
      real_linear_fact `~(norm(D:complex) < &1) ==> &1 <= norm D` THEN
      num_linear_fact `n <= 10*k*t ==> n-k <= (10*t)*k` THEN
      qed[REAL_POW_MONO]
    ; pass
    ] THEN
    subgoal `sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A <= max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) pow k` THENL [
      have `sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A <= max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A)` [REAL_LE_MAX;REAL_LE_REFL] THEN
      have `&1 <= max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A)` [REAL_LE_MAX;REAL_LE_REFL] THEN
      num_linear_fact `1 <= k0 ==> k0 <= k ==> 1 <= k` THEN
      have `max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) pow 1 <= max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) pow k` [REAL_POW_MONO] THEN
      qed[REAL_POW_1;REAL_LE_TRANS]
    ; pass
    ] THEN
    subgoal `(A:real) pow (n+1) <= (max (&1) A) pow ((10*t+1)*k)` THENL [
      have `&0 <= A:real` [transcendence_A_nonnegative] THEN
      have `A:real <= max (&1) A` [REAL_LE_MAX;REAL_LE_REFL] THEN
      have `(A:real) pow (n+1) <= (max (&1) A) pow (n+1)` [REAL_POW_LE2] THEN
      have `&1:real <= max (&1) A` [REAL_LE_MAX;REAL_LE_REFL] THEN
      num_linear_fact `1 <= k0 ==> k0 <= k ==> 1 <= k` THEN
      num_linear_fact `n <= 10*k*t ==> 1 <= k ==> n+1 <= (10*t+1)*k` THEN
      have `(max (&1:real) A) pow (n+1) <= (max (&1:real) A) pow ((10*t+1)*k)` [REAL_POW_MONO] THEN
      qed[REAL_LE_TRANS]
    ; pass
    ] THEN
    subgoal `norm(D:complex) pow (n - k) * &2 pow (k * t) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1) <= norm D pow ((10 * t) * k) * &2 pow (k * t) * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) pow k * max (&1) A pow ((10 * t + 1) * k)` THENL [
      have `&0 <= norm(D:complex)` [NORM_POS_LE] THEN
      have `&0 <= norm(D:complex) pow (n-k)` [REAL_POW_LE] THEN
      real_linear_fact `&0 <= &2:real` THEN
      have `&0 <= &2 pow (k*t)` [REAL_POW_LE] THEN
      real_linear_fact `&0 <= &1:real` THEN
      have `!p:(1->num)->complex. p IN P ==> &0 <= abs(real_of_int(B p))` [REAL_ABS_POS] THEN
      have `!p:(1->num)->complex. p IN P ==> &0:real <= &(poly_deg complex_ring p)` [REAL_OF_NUM_LE;ARITH_RULE `0 <= x`] THEN
      have `!p:(1->num)->complex. p IN P ==> &0 <= abs (real_of_int (B p)) * &(poly_deg complex_ring p)` [REAL_LE_MUL] THEN
      have `&0 <= sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p))` [SUM_POS_LE] THEN
      have `&0 <= exp A` [REAL_EXP_POS_LE] THEN
      specialize[`P:((1->num)->complex)->bool`;`A:real`]transcendence_A_nonnegative THEN
      have `&0 <= A:real` [] THEN
      have `&0 <= (A:real) pow (n+1)` [REAL_POW_LE] THEN
      have `(sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1) <= max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) pow k * max (&1) A pow ((10 * t + 1) * k)` [REAL_LE_MUL2;REAL_LE_MUL] THEN
      have `&2 pow (k * t) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1) <= &2 pow (k * t) * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) pow k * max (&1) A pow ((10 * t + 1) * k)` [REAL_LE_MUL2;REAL_LE_MUL;REAL_LE_REFL] THEN
      have `&0 <= &2 pow (k * t) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1)` [REAL_LE_MUL] THEN
      qed[REAL_LE_MUL2]
    ; pass
    ] THEN
    have `norm(D:complex) pow (n - k) * &2 pow (k * t) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1) < &(FACT k)` [REAL_LET_TRANS] THEN
    have `&0 < &(FACT k)` [REAL_OF_NUM_LT;FACT_LT] THEN
    have `&0 < inv(&(FACT k))` [REAL_LT_INV] THEN
    have `(norm(D:complex) pow (n - k) * &2 pow (k * t) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1)) * inv(&(FACT k)) < &(FACT k) * inv(&(FACT k))` [REAL_LT_RMUL] THEN
    real_field_fact `&0 < &(FACT k) ==> (norm(D:complex) pow (n - k) * &2 pow (k * t) * (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * A pow (n + 1)) * inv(&(FACT k)) = norm D pow (n - k) / abs (&(FACT k)) * &2 pow (k * t) * sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1)` THEN
    real_field_fact `&0 < &(FACT k) ==> &(FACT k) * inv(&(FACT k)) = &1` THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `A:real`;
    `D:complex`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `v:num->complex`;
  ]transcendence_Hv_zero THEN
  qed[]
);;
```

### Informal statement
For all sets of complex polynomials `P`, complex numbers `A`, `D`, `B`, numbers `t`, `H`, `u`, `v`, and `k0`, if the following conditions hold:
  - `P` is a finite set.
  - The minimal polynomials in `P` are distinct.
  - The sum, over all polynomials `p` in `P`, of `B p` times the sum of `cexp z` over all complex roots `z` of `p`, equals 0.
  - For all `p` in `P` and all complex roots `z` of `p`, the norm of `z` is less than or equal to `A`.
  - `D` is an integer.
  - `D` is not equal to 0.
  - For all `p` in `P` and all `i`, `D` to the power of `i` times the coefficient of `x` to the power of (`poly_deg p - i`) in `p` is an integer.
  - `t` is the sum, over all `p` in `P`, of `poly_deg p`.
  - `H` is the truncation of the reversed series of the product of polynomials in `P`.
  - For all `n`, `u n` is the sum, over all `p` in `P`, of `B p` times the sum of the `n`-th powers of complex roots of `p`.
  - For all `n`, `v n` is the sum from `i = 0` to `n` of `(FACT(n-i) * binom(n,i)) * u i`.
  - `k0` is greater than or equal to 1.
  - `norm(D)` to the power of `(10*t)` times `2` to the power of `t` times the maximum of `1` and the sum, over `p` in `P`, of `abs (B p)` times `poly_deg p` times `exp A` times the maximum of `1` and `A` to the power of `(10*t+1)` times `exp 1` is less than `k0`.
  - For all `n` and `k`, if `k0` is less than or equal to `k`, `k*t` is less than or equal to `n`, and `n` is less than or equal to `10*k*t`, then the coefficient of `x` to the power of `n` in the series product of `H` to the power of `k` and the power series with coefficients `v` is 0.

### Informal sketch
The proof proceeds by induction and uses other results concerning transcendence.

- Base Case: If `P` is empty, the theorem holds trivially thanks to `transcendence_Hv_zero_Ptrivial` and `distinct_minpolys_total_deg`.
- Inductive Step:
  - We aim to prove that `norm (D pow (n - k) / Cx (&(FACT k))) * &2 pow (k * t) * sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A * A pow (n + 1) < &1`
  - The proof uses the hypothesis that `norm(D) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k`
  - It proves that the bound on the norm holds by a series of inequalities and algebraic manipulations.
  - It uses `zero_if_ZinC_norm_lt1`
  - It applies the `factorial_lower_bound`.
  - It bounds `norm(D:complex) pow (n - k)` using the fact that `~(norm(D:complex) < &1)`
  - It shows `transcendence_A_nonnegative` to get `&0 <= A:real`
- Then, the proof uses `transcendence_Hv_zero` to finish the proof.

### Mathematical insight
This theorem is related to results in transcendence theory, particularly concerning the transcendence of `exp a` for algebraic `a != 0`. The statement provides conditions under which a certain power series, constructed from sums of powers of roots of polynomials in a finite set `P`, has zero coefficients beyond a certain point.

### Dependencies
- `transcendence_Hv_zero_Ptrivial`
- `distinct_minpolys_total_deg`
- `REAL_OF_NUM_LE`
- `REAL_LTE_TRANS`
- `REAL_EXP_POS_LT`
- `REAL_LT_RDIV_EQ`
- `NORM_POS_LE`
- `REAL_POW_LE`
- `REAL_LE_MUL`
- `REAL_LE_MAX`
- `num_linear_fact`
- `REAL_POW_LT2`
- `factorial_lower_bound`
- `REAL_POW_MUL`
- `REAL_POW_POW`
- `COMPLEX_NORM_DIV`
- `COMPLEX_NORM_CX`
- `COMPLEX_NORM_POW`
- `zero_if_ZinC_norm_lt1`
- `REAL_POW_MONO`
- `REAL_LE_REFL`
- `REAL_POW_1`
- `REAL_LET_TRANS`
- `REAL_OF_NUM_LT`
- `FACT_LT`
- `REAL_LT_INV`
- `REAL_LT_RMUL`
- `transcendence_Hv_zero`
- `SUM_POS_LE`
- `REAL_ABS_POS`

### Porting notes (optional)
- The extensive use of real and complex number inequalities might require careful attention to the corresponding tactics in the target proof assistant.
- The handling of polynomials and power series may also require specific adaptation depending on the libraries available. Specifically, the HOL Light `complex_ring` definitions.


---

## transcendence_Hv_induction

### Name of formal statement
transcendence_Hv_induction

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_induction = prove(`
  !P A D B t H u v k0.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  D IN ZinC ==>
  ~(D = Cx(&0)) ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  1 <= k0 ==>
  norm(D) pow (10*t) * &2 pow t * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k0 ==>
  (!j n k. k0 <= k ==>
           k*t <= n ==>
           n <= 10*k*t+j ==>
           coeff n (
             poly_mul complex_ring (
               poly_pow complex_ring H k
             ) (
               series_from_coeffs v
             )
           ) = Cx(&0)
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  INDUCT_TAC THENL [
    rw[ARITH_RULE `10*k*t+0 = 10*k*t`] THEN
    specialize[
      `P:((1->num)->complex)->bool`;
      `A:real`;
      `D:complex`;
      `B:((1->num)->complex)->int`
    ]transcendence_Hv_zero_k0 THEN
    qed[]
  ; pass
  ] THEN
  intro THEN
  proven_if `P = {}:((1->num)->complex)->bool` [transcendence_Hv_zero_Ptrivial] THEN
  case `t = 0` THENL [
    have `P = {}:((1->num)->complex)->bool` [distinct_minpolys_total_deg] THEN
    qed[]
  ; pass
  ] THEN
  proven_if `n <= 10*k*t + j` [] THEN
  num_linear_fact `n <= 10 * k * t + SUC j ==> ~(n <= 10 * k * t + j) ==> n = 10*k*t+j+1` THEN
  subgoal `coeff n (poly_mul complex_ring (poly_pow complex_ring H (1+k)) (series_from_coeffs v)) = Cx (&0)` THENL [
    num_linear_fact `k0 <= k ==> k0 <= 1+k` THEN
    num_linear_fact `1 <= k0 ==> k0 <= k ==> 1+k <= 10*k` THEN
    have `(1+k)*t <= (10*k)*t` [LE_MULT2;LE_REFL] THEN
    num_linear_fact `(1+k)*t <= (10*k)*t ==> (1+k)*t <= 10*k*t+j+1` THEN
    have `(1+k)*t <= n` [] THEN
    num_linear_fact `~(t = 0) ==> 10*k*t+j+1 <= 10*(1+k)*t+j` THEN
    have `n <= 10*(1+k)*t+j` [] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `poly_mul complex_ring (poly_pow complex_ring H (1 + k)) (series_from_coeffs v) = poly_mul complex_ring H (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))` THENL [
    simp[poly_pow_add;poly_pow_1;series_complex] THEN
    simp[POLY_MUL_ASSOC;series_complex]
  ; pass
  ] THEN
  have `coeff n (poly_mul complex_ring H (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))) = Cx(&0)` [] THEN
  specialize[`complex_ring`;`n:num`;`H:(1->num)->complex`;`poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)`]coeff_poly_mul_oneindex THEN
  have `ring_sum complex_ring (0..n) (\i. ring_mul complex_ring (coeff i H) (coeff (n-i) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)))) = Cx(&0)` [] THEN
  subgoal `ring_sum complex_ring (0..n) (\i. ring_mul complex_ring (coeff i H) (coeff (n-i) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)))) = ring_sum complex_ring (0..n) (\i. if i = 0 then (coeff 0 H) * (coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))) else ring_0 complex_ring)` THENL [
    sufficesby RING_SUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    proven_if `a = 0` [ARITH_RULE `n-0 = n`;complex_ring_clauses] THEN
    case `a <= t:num` THENL [
      num_linear_fact `~(a = 0) ==> (10*k*t+j+1)-a <= 10*k*t+j` THEN
      have `n-a <= 10*k*t+j` [] THEN
      num_linear_fact `1 <= k0 ==> k0 <= k ==> k <= 10*k-1` THEN
      have `k*t <= (10*k)*t-1*t` [LE_MULT2;LE_REFL;RIGHT_SUB_DISTRIB] THEN
      num_linear_fact `a <= t ==> k*t <= (10*k)*t-1*t ==> k*t <= (10*k*t+j+1)-a` THEN
      have `k*t <= n-a:num` [] THEN
      have `coeff (n-a) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = ring_0 complex_ring` [complex_ring_clauses] THEN
      qed[RING_MUL_RZERO;in_complex_ring]
    ; pass
    ] THEN
    have `H = x_truncreverse complex_ring t (poly_product QinC_ring P I)` [x_truncreverse_subring;subring_complex_QinC] THEN
    have `poly_deg complex_ring (H:(1->num)->complex) <= t` [deg_x_truncreverse_le;series_complex] THEN
    have `ring_polynomial complex_ring (H:(1->num)->complex)` [transcendence_H_poly] THEN
    have `coeff a H = ring_0 complex_ring` [coeff_deg_le] THEN
    qed[RING_MUL_LZERO;in_complex_ring]
  ; pass
  ] THEN
  subgoal `ring_sum complex_ring (0..n) (\i. if i = 0 then coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) else ring_0 complex_ring) = coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))` THENL [
    have `0 IN (0..n)` [IN_NUMSEG;ARITH_RULE `0 <= n`] THEN
    specialize[`complex_ring`;`0..n`;`0`;`coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))`]RING_SUM_DELTA THEN
    qed[in_complex_ring]
  ; pass
  ] THEN
  have `coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = Cx(&0)` [] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `H:(1->num)->complex`
  ]transcendence_H_botcoeff1 THEN
  have `coeff 0 (H:(1->num)->complex) = Cx(&1)` [] THEN
  qed[COMPLEX_MUL_LID]
);;
```

### Informal statement
For any set `P` of complex polynomials, any real number `A`, any complex number `D`, function `B` from polynomials to integers, natural number `t`, complex polynomial `H`, functions `u` and `v` from natural numbers to complex numbers, and natural number `k0`, if
- `P` is finite,
- all polynomials in `P` have distinct minimal polynomials,
- the sum over `P` of `B(p)` times the sum over the complex roots of `p` of the exponentials of the roots equals 0,
- the norm of any complex root `z` of any polynomial `p` in `P` is less than or equal to `A`,
- `D` is a complex integer,
- `D` is not zero,
- for any polynomial `p` in `P`, `D` raised to the power `i` times the coefficient of degree `poly_deg complex_ring p - i` in `p` is a complex integer, for all `i`,
- `t` is the sum over `P` of the degrees of the polynomials `p`,
- `H` is the truncation of `poly_product QinC_ring P I` to degree `t`, viewed as a polynomial with complex integer coefficients,
- for any `n`, `u(n)` is the sum over `P` of `B(p)` times the sum of the `n`-th powers of the complex roots of `p`,
- for any `n`, `v(n)` is the sum from `i = 0` to `n` of `FACT(n-i) * binom(n,i)` times `u(i)`,
- `1 <= k0`,
- `norm(D) pow (10*t) * &2 pow t * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k0`,
then, for any `j`, `n`, and `k`, if
  - `k0 <= k`,
  - `k*t <= n`,
  - `n <= 10*k*t+j`,
  then the coefficient of `n` in the polynomial that results from multiplying `H` raised to the power `k` by the series with coefficients `v(n)` is zero.

### Informal sketch
The theorem is proven by induction on `k`.
- Base case: Prove that the property holds for `k0`. This uses the theorem `transcendence_Hv_zero_k0`.
- Inductive step: Assume the property holds for `k` and prove it for `k + 1`.
    - Show that if `P` is empty, then the result holds by `transcendence_Hv_zero_Ptrivial`.
    - Show that if `t = 0` then `P` must be empty, using `distinct_minpolys_total_deg`
    - Given `n <= 10 * k * t + SUC j`, assume that `n` is equal to the successor case, `10*k*t+j+1`.
    - Show that `coeff n (poly_mul complex_ring (poly_pow complex_ring H (1+k)) (series_from_coeffs v)) = Cx (&0)` by using `k0 <= k ==> k0 <= 1+k`, facts about `k0`, and showing that `(1+k)*t <= n` and `n <= 10*(1+k)*t+j`.
    Decompose `poly_mul complex_ring (poly_pow complex_ring H (1 + k)) (series_from_coeffs v)` to `poly_mul complex_ring H (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))`.
    Specialize the `coeff_poly_mul_oneindex` theorem to show `ring_sum complex_ring (0..n) (\i. ring_mul complex_ring (coeff i H) (coeff (n-i) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)))) = Cx(&0)`. This is then simplified by proving that `ring_sum complex_ring (0..n) (\i. ring_mul complex_ring (coeff i H) (coeff (n-i) (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)))) = ring_sum complex_ring (0..n) (\i. if i = 0 then (coeff 0 H) * (coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))) else ring_0 complex_ring)` and breaking this down into cases where `a=0` using `ARITH_RULE `n-0 = n`;complex_ring_clauses`, `a <= t` using `RING_MUL_RZERO;in_complex_ring` and `coeff a H = ring_0 complex_ring` using `RING_MUL_LZERO;in_complex_ring`.
    - Further simplification shows `ring_sum complex_ring (0..n) (\i. if i = 0 then coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) else ring_0 complex_ring) = coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v))`.
    - The final step uses `transcendence_H_botcoeff1` to show that `coeff 0 (H:(1->num)->complex) = Cx(&1)` and uses `COMPLEX_MUL_LID` to show that `coeff 0 H * coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = Cx(&0)`.

### Mathematical insight
This theorem is a key inductive step in proving the transcendence of e. It establishes a crucial relationship between the coefficients of certain polynomials and power series derived from the roots of minimal polynomials of a finite set `P`. The core idea is to show that, under specific conditions on the set `P`, the complex numbers `D`, the bounds on the roots `A`, and functions `u` and `v`, the coefficients of the product of a power of `H` and a power series generated by `v` are zero after some point. This vanishing property is essential for constructing a contradiction in the transcendence proof.

### Dependencies
- `transcendence_Hv_zero_k0`
- `transcendence_Hv_zero_Ptrivial`
- `distinct_minpolys_total_deg`
- `coeff_poly_mul_oneindex`
- `transcendence_H_botcoeff1`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `deg_x_truncreverse_le`
- `series_complex`
- `transcendence_H_poly`
- `coeff_deg_le`
- `poly_pow_add`
- `poly_pow_1`
- `POLY_MUL_ASSOC`
- `series_complex`
- `IN_NUMSEG`
- `ARITH_RULE `0 <= n``
- `RIGHT_SUB_DISTRIB`
- `RING_SUM_DELTA`
- `COMPLEX_MUL_LID`
- `LE_MULT2`
- `LE_REFL`
- `RIGHT_SUB_DISTRIB`
- `RING_MUL_RZERO`
- `in_complex_ring`
- `RING_MUL_LZERO`
- `in_complex_ring`

### Porting notes (optional)
- The extensive use of `num_linear_fact` suggests a need for strong arithmetic reasoning capabilities in the target proof assistant.
- The manipulation of polynomial coefficients relies on algebraic properties that should be represented faithfully.
- The handling of `ring_sum` may require careful attention to the underlying ring theory formalization.


---

## transcendence_Hv_noupperbound

### Name of formal statement
transcendence_Hv_noupperbound

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_noupperbound = prove(`
  !P A D B t H u v k0.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  D IN ZinC ==>
  ~(D = Cx(&0)) ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  1 <= k0 ==>
  norm(D) pow (10*t) * &2 pow t * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k0 ==>
  (!n k. k0 <= k ==>
         k*t <= n ==>
         coeff n (
           poly_mul complex_ring (
             poly_pow complex_ring H k
           ) (
             series_from_coeffs v
           )
         ) = Cx(&0)
  )
`,
  intro THEN
  num_linear_fact `n <= 10*k*t+n` THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `A:real`;
    `D:complex`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`
  ]transcendence_Hv_induction THEN
  qed[]
);;
```

### Informal statement
For all sets `P` of complex polynomials, real numbers `A`, complex numbers `D`, integer-valued polynomials `B` (mapping polynomials to integers), natural numbers `t`, complex-valued functions `H`, `u`, `v` over the natural numbers, and natural numbers `k0`, if:
1. `P` is finite,
2. the minimum polynomials in `P` are distinct,
3. the sum of the values `complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp` over all `p` in `P` is equal to the complex number 0, where `complex_root p` is meant to be the roots of the polynomial `p`, `cexp` is the exponential function, and the summation is performed within the complex ring,
4. for every `p` in `P` and every `z` such that `z` is a complex root of `p`, the norm of `z` is less than or equal to `A`,
5. `D` is an element of the integers in the complex numbers,
6. `D` is not equal to the complex number 0,
7. for every `p` in `P` and every natural number `i`, `D` raised to the power of `i` multiplied by the coefficient of the `(poly_deg complex_ring p - i)`-th term of `p` is an element of the integers in the complex numbers,
8. `t` is the sum of the degrees of the polynomials `p` in `P` for all `p` in `P`,
9. `H` is the reverse truncation of length `t` using the integers in the complex numbers as defined by `QinC_ring`of the product polynomial formed using the polynomials `p` in `P`,
10. for every natural number `n`, `u n` is equal to the sum of `complex_of_int(B p) * complex_root_powersums p n` over all `p` in `P`, where `complex_root_powersums p n` is the sum of the n-th power of the roots of `p`,
11. for every natural number `n`, `v n` is equal to the sum, from `i = 0` to `n`, of `Cx(&(FACT(n-i) * binom(n,i))) * u i`, where `Cx` converts a real number to a complex number, `FACT` is the factorial function, and `binom` is the binomial coefficient,
12. `1` is less than or equal to `k0`,
13. `norm(D) pow (10*t) * &2 pow t * max (&1) (sum P (\p. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k0`
14. for all natural numbers `n` and `k`, if `k0 <= k` and `k*t <= n`, then the `n`-th coefficient of the polynomial, which is the product of `poly_pow complex_ring H k` and `series_from_coeffs v`, when computed in the complex ring is equal to the complex number 0.

### Informal sketch
The theorem states that under certain conditions on a set of polynomials `P`, their roots, and related quantities (`A`, `D`, `B`, `t`, `H`, `u`, `v`, `k0`), a specific inequality holds.  The core of the proof seems to involve utilizing an induction argument (`transcendence_Hv_induction`) after some initial setup.

- The proof starts with an introduction step (`intro`).
- It then uses a linear arithmetic fact (`num_linear_fact n <= 10*k*t+n`).  The purpose of this step is not clear from the theorem statement alone but likely is used in the inductive step to maintain a relationship between induction parameters and bounds.
- The crucial step is to specialize the already existing theorem `transcendence_Hv_induction` by providing specific values for the type variables namely `P`, `A`, `D`, `B`, `t`, `H`. The tactic `specialize` replaces the universally quantified type variables in the original induction theorem.
- Finally, the proof is concluded using `qed[]`.

### Mathematical insight
This theorem appears to be a step within a larger proof related to transcendence theory, potentially demonstrating that a specific value cannot be algebraic. The conditions listed involve complex numbers, norms, polynomial roots, and bounds. The inequality suggests a contradiction argument, showing that if certain conditions are met, a coefficient in a polynomial expansion must be zero. This is a common technique in transcendence proofs, where one assumes the number is algebraic and derives a contradiction based on properties of the coefficients in its minimal polynomial.

The condition involving `u n` and `v n `suggests that the theorem exploits properties of power sums of roots of polynomials.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ring_sum`
- `complex_ring`
- `complex_of_int`
- `complex_root`
- `cexp`
- `ZinC`
- `D pow i` in the integers
- `coeff`
- `poly_deg`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `nsum`
- `complex_root_powersums`
- `FACT`
- `binom`
- `norm`
- `exp`
- `poly_mul`
- `poly_pow`
- `series_from_coeffs`
- `transcendence_Hv_induction`
- `num_linear_fact`


---

## transcendence_Hv_kexists

### Name of formal statement
transcendence_Hv_kexists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_kexists = prove(`
  !P A D B t H u v.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p z. p IN P ==> complex_root p z ==> norm z <= A) ==>
  D IN ZinC ==>
  ~(D = Cx(&0)) ==>
  (!p i. p IN P ==> D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  ?k. 1 <= k /\
  !n. k*t <= n ==>
      coeff n (
        poly_mul complex_ring (
          poly_pow complex_ring H k
        ) (
          series_from_coeffs v
        )
      ) = Cx(&0)
`,
  intro THEN
  choose `k0:num` `max (&1) (norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1)) < &k0` [REAL_ARCH_LT] THEN
  have `&1 <= max (&1) (norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1))` [REAL_LE_MAX;REAL_LE_REFL] THEN
  have `&1 <= &k0:real` [REAL_LET_TRANS;REAL_LT_IMP_LE] THEN
  have `1 <= k0` [REAL_OF_NUM_LE] THEN
  have `norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) <= max (&1) (norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1))` [REAL_LE_MAX;REAL_LE_REFL] THEN
  have `norm(D:complex) pow (10*t) * &2 pow t * max (&1) (sum P (\p:(1->num)->complex. abs (real_of_int (B p)) * &(poly_deg complex_ring p)) * exp A) * (max (&1) A) pow (10*t+1) * exp(&1) < &k0:real` [REAL_LET_TRANS] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `A:real`;
    `D:complex`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `v:num->complex`;
    `k0:num`
  ]transcendence_Hv_noupperbound THEN
  witness `k0:num` THEN
  qed[LE_REFL]
);;
```
### Informal statement
Given:
- `P` is a finite set of polynomials.
- The polynomials in `P` have distinct minimal polynomials.
- The sum, over all polynomials `p` in `P`, of `complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp`, is equal to the complex number 0, where `B` is a function from polynomials to integers and `cexp` is the complex exponential function.
- For every polynomial `p` in `P` and every complex root `z` of `p`, the norm of `z` is less than or equal to `A`.
- `D` is a non-zero complex integer.
- For every polynomial `p` in `P` and every non-negative integer `i`, `D` to the power of `i` multiplied by the coefficient of `x` to the power of `(poly_deg complex_ring p - i)` in `p` is a complex integer.
- `t` is the sum, over all polynomials `p` in `P`, of the degree of `p`.
- `H` is the truncation and reverse of the power series representation of the polynomial obtained by taking the product of all polynomials in `P`, truncated to degree `t`.
- For every non-negative integer `n`, `u n` is the sum, over all polynomials `p` in `P`, of `complex_of_int(B p) * complex_root_powersums p n`.
- For every non-negative integer `n`, `v n` is the sum, over all non-negative integers `i` less than or equal to `n`, of `Cx(&(FACT(n-i) * binom(n,i))) * u i)`.

Then:
There exists a positive integer `k` such that for all non-negative integers `n` satisfying `k*t <= n`, the coefficient of `x` to the power of `n` in the polynomial which is the product of `H` raised to the power of `k` and the series `v` represented by its coefficients, is equal to zero.

### Informal sketch
The proof establishes the existence of a natural number `k` satisfying a certain condition.

- It first introduces the assumptions.
- A specific value `k0` is chosen using `choose` tactic, based on bounding norms related to `D`, `A`, `P` and `B`, using `REAL_ARCH_LT`.
- Then it proves `1 <= k0` by showing related inequalities.
- The theorem `transcendence_Hv_noupperbound` is specialized with the introduced assumptions and `k0`
- Finally, the theorem is proven by witnessing `k0` using `witness` tactic, and proves the equality using `LE_REFL`.

### Mathematical insight
This theorem is likely related to a step in a transcendence proof, such as Liouville's or Hermite's transcendence proofs. It establishes that, under certain conditions involving a set of polynomials with integer coefficients and their roots, there exists a `k` after which the coefficients of the given `poly_mul` will consistently be 0. This mirrors a process in certain transcendence arguments of manipulating quantities involving algebraic numbers and demonstrating relationships that preclude them taking certain values (such as being rational)

### Dependencies
- `REAL_ARCH_LT`
- `REAL_LE_MAX`
- `REAL_LE_REFL`
- `REAL_LET_TRANS`
- `REAL_LT_IMP_LE`
- `REAL_OF_NUM_LE`
- `LE_REFL`
- `transcendence_Hv_noupperbound`

### Porting notes (optional)
The `choose` tactic and surrounding real arithmetic reasoning within this tactic might be challenging to reproduce in other proof assistants, and might need to be replaced by explicit construction of `k0` and proof of its properties.
Similarly, the handling of complex numbers and polynomials in other systems might differ substantially, requiring adaptation of the polynomial operations and coefficient extraction.


---

## transcendence_Hv_kexists_v2

### Name of formal statement
transcendence_Hv_kexists_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_kexists_v2 = prove(`
  !P B t H u v.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  ?k. 1 <= k /\
  !n. k*t <= n ==>
      coeff n (
        poly_mul complex_ring (
          poly_pow complex_ring H k
        ) (
          series_from_coeffs v
        )
      ) = Cx(&0)
`,
  intro THEN
  proven_if `P = {}:((1->num)->complex)->bool` [transcendence_Hv_zero_Ptrivial;ARITH_RULE `1 <= 1`] THEN
  def `A:real` `sum P (\p:(1->num)->complex. sum (complex_root p) norm)` THEN
  subgoal `!p z. p IN P ==> complex_root p z ==> norm z <= sum (complex_root p) norm` THENL [
    intro THEN
    have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
    have `z IN complex_root p` [IN] THEN
    specialize[`norm:complex->real`;`complex_root p`;`z:complex`]SUM_DELETE THEN
    have `&0 <= sum(complex_root p DELETE z) norm` [SUM_POS_LE;NORM_POS_LE] THEN
    real_linear_fact `&0 <= sum (complex_root p DELETE z) norm ==> sum (complex_root p DELETE z) norm = sum (complex_root p) norm - norm z ==> norm z <= sum(complex_root p) norm` THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!p. p IN P ==> sum(complex_root p) norm <= A` THENL [
    intro THEN
    specialize[`\p:(1->num)->complex. sum(complex_root p) norm`;`P:((1->num)->complex)->bool`;`p:(1->num)->complex`]SUM_DELETE THEN
    have `&0 <= sum(P DELETE p) (\p. sum(complex_root p) norm)` [SUM_POS_LE;NORM_POS_LE] THEN
    real_linear_fact `&0 <= sum(P DELETE p) (\p. sum(complex_root p) norm) ==> sum(P DELETE p) (\p. sum(complex_root p) norm) = sum P (\p. sum(complex_root p) norm) - sum(complex_root p) norm ==> sum(complex_root p) norm <= sum P (\p. sum(complex_root p) norm)` THEN
    qed[]
  ; pass
  ] THEN
  have `!p z. p IN P ==> complex_root p z ==> norm z <= A` [REAL_LE_TRANS] THEN
  choose `D:complex` `D IN ZinC /\ ~(D = Cx(&0)) /\ (!p. p IN P ==> !i. D pow i * (coeff (poly_deg complex_ring p - i) p) IN ZinC)` [distinct_minpolys_denominator] THEN
  specialize_assuming[
    `P:((1->num)->complex)->bool`;
    `A:real`;
    `D:complex`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `v:num->complex`
  ]transcendence_Hv_kexists THEN
  qed[]
);;
```

### Informal statement
Given a finite set `P` of minimal polynomials such that the minimal polynomials are distinct, if the sum over `P` of `B p` times the sum of the exponentials of the roots of `p` is zero, where `B p` is an integer-valued function of the polynomial `p`, and `t` is the sum over `P` of the degrees of the polynomials `p`, and `H` is the truncation of the product of polynomials `p` in `P`, and for all `n`, `u n` is the sum over `P` of `B p` times the power sums of the roots of `p`, and for all `n`, `v n` is the sum from `i = 0` to `n` of binomial coefficients times `u i`, then there exists a `k` greater than or equal to `1`, such that for all `n`, if `k*t` is less than or equal to `n`, then the `n`-th coefficient of the polynomial obtained by multiplying `H` raised to the power `k` by the series with coefficients `v` is zero.

### Informal sketch
The proof proceeds by assuming `P` is the empty set. We use `transcendence_Hv_zero_Ptrivial` to eliminate that case with `ARITH_RULE`. We then define `A` to be the sum over elements in `P` of the sum of the norms of roots of each polynomial. Show that the norm of root `z` of polynomial `p` is less or equal to `A`. Choose a `D` by `distinct_minpolys_denominator` such that `D` belongs to the set of Gaussian Integers, is not zero, and for all `p` in `P` and for all `i`, `D` power `i` times the `(deg p - i)`-th coefficient of `p` is in the Gaussian Integers. Finally, specialize the theorem `transcendence_Hv_kexists` using assumptions about `P`, `A`, `D`, `B`, `t`, `H`, `u`, and `v`.

- The proof starts by handling the trivial case when `P` is empty.
- We prove an intermediate result that the norm of a root `z` of any polynomial `p` in `P` is bounded above by `A`.
- We choose a complex number `D` using `distinct_minpolys_denominator` that belongs to the Gaussian integers but is not zero. `D` is a common denominator for the coefficients.
- Finally, we use theorem `transcendence_Hv_kexists` with appropriate assumptions for `P`, `A`, `D`, `B`, `t`, `H`, `u`, and `v` and complete the proof.

### Mathematical insight
This theorem provides a key step in proving transcendence results. It relates the power sums of roots of minimal polynomials to the coefficients of a power series. This relation is crucial for obtaining contradiction when assuming the algebraic number is actually algebraic. The theorem involves subtle manipulations of sums and polynomial coefficients to derive a condition that can be violated if the considered number were algebraic.

### Dependencies
- `transcendence_Hv_zero_Ptrivial`
- `distinct_minpolys_finite_root`
- `distinct_minpolys_denominator`
- `transcendence_Hv_kexists`

### Porting notes (optional)
- The use of sums over finite sets is prevalent. Ensure that the target proof assistant has good support for sums over finite sets, potentially including automation for proving inequalities about sums.
- The definition and properties of complex numbers and polynomials over complex numbers should be accurately represented in the target system along with support for polynomial arithmetic.
- The choice of `D` uses `distinct_minpolys_denominator`. It might require careful handling.


---

## transcendence_Hv_poly

### Name of formal statement
transcendence_Hv_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_Hv_poly = prove(`
  !P B t H u v.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  ?k. 1 <= k /\
  ring_polynomial complex_ring (
    poly_mul complex_ring (
      poly_pow complex_ring H k
    ) (
      series_from_coeffs v
    )
  )
`,
  intro THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`;
    `v:num->complex`;
  ]transcendence_Hv_kexists_v2 THEN
  choose `k:num` `1 <= k /\ !n. k*t <= n ==> coeff n (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs v)) = Cx(&0)` [] THEN
  witness `k:num` THEN
  qed[poly_if_coeff;series_complex;complex_ring_clauses]
);;
```
### Informal statement
For all predicates `P` on functions from `1->num` to complex numbers, all functions `B` from `(1->num)->complex` to integers, all natural numbers `t`, all functions `H` from natural numbers to complex numbers, all functions `u` from natural numbers to complex numbers, and all functions `v` from natural numbers to complex numbers, if the set described by `P` is finite, and the minimal polynomials in `P` are distinct, and the sum over `P` of `B(p)` times the sum over the complex roots of `p` of the exponential of that root is equal to the complex number 0, and `t` is the sum over `P` of the degree of `p`, and `H` is the `x_truncreverse` of the polynomial which is the product over `P` of `p` with `QinC_ring`, and for all `n`, `u(n)` is the sum over `P` of `B(p)` times the nth power sum of the complex roots of `p`, and for all `n`, `v(n)` is the sum from 0 to `n` of the complex number formed from `FACT(n-i) * binom(n,i)` times `u(i)`, then there exists a natural number `k` such that `1 <= k` and the polynomial ring formed by multiplying `H` to the power of `k` by the formal power series generated from `v` has coefficients all zero.

### Informal sketch
The proof demonstrates the existence of a natural number `k` satisfying certain conditions related to polynomials, roots, and power sums.

- The proof starts by introducing assumptions about `P`, `B`, `t`, `H`, `u`, and `v` and specializing the theorem `transcendence_Hv_kexists_v2`.
- Then existentially quantify `k` to satisfy `1 <= k` and a condition where, for all `n`, if `k * t <= n`, then the `n`-th coefficient of the product of `H` raised to the power of `k` and the formal power series generated by `v` is equal to zero. This is achieved by choosing a specific `k`.
- The proof involves reasoning about polynomials, power series, roots of polynomials, and complex numbers.
- The proof then witnesses `k` where `k` is some natural number and finally applying a sequence of tactics which includes `poly_if_coeff`, `series_complex`, `complex_ring_clauses`.

### Mathematical insight
This theorem is related to transcendence theory, specifically in the context of proving the transcendence of certain numbers. The statement combines algebraic and analytic concepts. It uses properties of minimal polynomials, roots of polynomials, power sums of roots, factorials, binomial coefficients, formal power series, and sums in complex rings. The ultimate goal is to show the existence of a `k` that satisfies a condition involving the polynomial `H` raised to `k` and a formal power series, which is used to prove transcendence results.

### Dependencies
- `transcendence_Hv_kexists_v2`
- `poly_if_coeff`
- `series_complex`
- `complex_ring_clauses`


---

## transcendence_uv_diffeq

### Name of formal statement
transcendence_uv_diffeq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_uv_diffeq = prove(`
  !u v.
  (!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)) ==>
  poly_sub complex_ring (
    poly_sub complex_ring (
      series_from_coeffs v
    ) (
      poly_mul complex_ring (
        x_pow complex_ring 1
      ) (
        series_from_coeffs v
      )
    )
  ) (
    poly_mul complex_ring (
      x_pow complex_ring 2
    ) (
      x_derivative complex_ring (
        series_from_coeffs v
      )
    )
  ) = series_from_coeffs u
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_series_from_coeffs;coeff_poly_sub;complex_coeff_x_pow_times;coeff_x_derivative;complex_ring_clauses;ring_sub_complex;ring_of_num_complex;complex_of_num] THEN
  simp[] THEN
  case `d = 0` THENL [
    simp[ARITH_RULE `0 < 1`;ARITH_RULE `0 < 2`] THEN
    rw[RING_SUM_CLAUSES_NUMSEG;in_complex_ring;binom;ARITH_RULE `0 - 0 = 0`;FACT;ARITH_RULE `1 * 1 = 1`] THEN
    CONV_TAC COMPLEX_FIELD
  ; pass
  ] THEN
  num_linear_fact `~(d = 0) ==> ~(d < 1)` THEN
  case `d = 1` THENL [
    simp[ARITH_RULE `1 < 2`;ARITH_RULE `1 - 1 = 0`] THEN
    rw[RING_SUM_CLAUSES_NUMSEG;ARITH_RULE `1 = SUC 0`;in_complex_ring;ARITH_RULE `0 <= SUC 0`] THEN
    rw[ARITH_RULE `SUC 0 = 1`;ARITH_RULE `1 - 0 = 1`;ARITH_RULE `1 - 1 = 0`;ARITH_RULE `0 - 0 = 0`;FACT;binom;ARITH_RULE `0 + 1 = 1`;ARITH_RULE `x * 1 = x`;complex_ring_clauses;fact_1] THEN
    CONV_TAC COMPLEX_FIELD
  ; pass
  ] THEN
  num_linear_fact `~(d = 0) ==> ~(d = 1) ==> ~(d < 2)` THEN
  num_linear_fact `~(d < 2) ==> d - 2 + 1 = d - 1` THEN
  num_linear_fact `d - 1 <= d` THEN
  specialize[`complex_ring`;`d-1`;`d:num`]ring_sum_numseg_le_expand THEN
  simp[] THEN
  simp[GSYM vsum_ring_sum_complex;FINITE_NUMSEG;complex_ring_clauses] THEN
  simp[GSYM VSUM_COMPLEX_LMUL;FINITE_NUMSEG] THEN
  simp[GSYM VSUM_SUB;FINITE_NUMSEG] THEN
  subgoal `vsum (0..d) (\x. Cx (&(FACT (d - x) * binom (d,x))) * u x - (if x <= d - 1 then Cx (&(FACT (d - 1 - x) * binom (d - 1,x))) * u x else Cx (&0)) - Cx (&(d - 1)) * (if x <= d - 1 then Cx (&(FACT (d - 1 - x) * binom (d - 1,x))) * u x else Cx (&0))) = vsum (0..d) (\i. if i = d then u d else Cx(&0))` THENL [
    sufficesby VSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    case `x = d:num` THENL [
      num_linear_fact `~(d < 2) ==> ~(d <= d - 1)` THEN
      simp[ARITH_RULE `d - d = 0`;BINOM_REFL;FACT;ARITH_RULE `1 * 1 = 1`] THEN
      CONV_TAC COMPLEX_FIELD
    ; pass
    ] THEN
    have `x <= d:num` [IN_NUMSEG] THEN
    num_linear_fact `x <= d ==> ~(x = d) ==> x <= d-1` THEN
    complex_field_fact `Cx (&(FACT (d - x) * binom (d,x))) * u x - Cx (&(FACT (d - 1 - x) * binom (d - 1,x))) * u x - Cx (&(d - 1)) * Cx (&(FACT (d - 1 - x) * binom (d - 1,x))) * u x = (Cx (&(FACT (d - x) * binom (d,x))) - Cx (&(FACT (d - 1 - x) * binom (d - 1,x))) - Cx (&(d - 1)) * Cx (&(FACT (d - 1 - x) * binom (d - 1,x)))) * u x` THEN
    simp[GSYM CX_MUL;GSYM CX_SUB;REAL_OF_NUM_MUL] THEN
    num_linear_fact `x <= d ==> ~(x = d) ==> x < d:num` THEN
    simp[fact_binom_lemma_37_real] THEN
    CONV_TAC COMPLEX_FIELD
  ; pass
  ] THEN
  simp[vsum_delta_complex;FINITE_NUMSEG;IN_NUMSEG_0;ARITH_RULE `d <= d:num`]
);;
```

### Informal statement
For all functions `u` and `v` from natural numbers to complex numbers, if for all natural numbers `n`, `v n` equals the ring sum, over the range from 0 to `n`, of the terms `Cx(&(FACT(n-i) * binom(n,i))) * u i` (where `i` is the index of summation), then the difference between `series_from_coeffs v` minus the ring product of `x_pow complex_ring 1` and `series_from_coeffs v`, all minus the ring product of `x_pow complex_ring 2` and the `x_derivative complex_ring (series_from_coeffs v)`, equals `series_from_coeffs u`.

### Informal sketch
The theorem states that if `v` is defined by a certain recurrence involving `u`, then a certain differential equation involving the formal power series generated by `v` holds; roughly, that `v(x) - x*v(x) - x^2 * v'(x) = u(x)`.

- The proof starts by introducing the assumptions and reduces the goal to showing equality of the coefficients of the formal power series on both sides. `intro THEN sufficesby eq_coeff`
- The proof proceeds by induction on the coefficient index `d`.
- Simplification is performed to expand the definitions of series operations and ring operations. `rw[coeff_series_from_coeffs;coeff_poly_sub;complex_coeff_x_pow_times;coeff_x_derivative;complex_ring_clauses;ring_sub_complex;ring_of_num_complex;complex_of_num] THEN simp[]`
- Base cases `d = 0` and `d = 1` are proved using field simplification. `case \`d = 0\` THENL [...] ; case \`d = 1\` THENL [...]`
- For the inductive step, arithmetic facts are established and a rewriting of the ring sum using `ring_sum_numseg_le_expand` allows to isolate the last term of the sum.
- Applying `VSUM_EQ` reduces the problem to showing that the summands are equal.
- The case `x = d` is handled separately and simplified using basic arithmetic and binomial coefficient identities.
- For `x < d` a field identity expressed by `complex_field_fact` is used, together with the binomial coefficient identity `fact_binom_lemma_37_real`, to show that the summand is zero as desired.
- The theorem `vsum_delta_complex` is invoked to prove the equality of an appropriate `vsum` with `u d`.
- Tactic `CONV_TAC COMPLEX_FIELD` is used to handle most of the complex field arithmetic.

### Mathematical insight
The theorem relates the coefficients of two power series `u` and `v` by a recurrence relation, and shows that this corresponds to a certain differential equation between the power series `u` and `v`. The recurrence relation is a discrete version of the differential equation, and this theorem makes that intuition rigorous. This theorem is used in the proof of the transcendence of `e`.

### Dependencies
- `coeff_series_from_coeffs`
- `coeff_poly_sub`
- `complex_coeff_x_pow_times`
- `coeff_x_derivative`
- `complex_ring_clauses`
- `ring_sub_complex`
- `ring_of_num_complex`
- `complex_of_num`
- `RING_SUM_CLAUSES_NUMSEG`
- `in_complex_ring`
- `binom`
- `FACT`
- `fact_1`
- `GSYM vsum_ring_sum_complex`
- `FINITE_NUMSEG`
- `GSYM VSUM_COMPLEX_LMUL`
- `GSYM VSUM_SUB`
- `VSUM_EQ`
- `BINOM_REFL`
- `GSYM CX_MUL`
- `GSYM CX_SUB`
- `REAL_OF_NUM_MUL`
- `fact_binom_lemma_37_real`
- `vsum_delta_complex`
- `IN_NUMSEG_0`

### Porting notes (optional)
- The main work of the proof involves rewriting complex field identities and summation identities involving binomial coefficients and factorials. Porting this theorem would require access to similar algebraic simplification and rewriting capabilities in the target proof assistant. The tactic `CONV_TAC COMPLEX_FIELD` is extensively used here.
- Note the HOL Light-specific notations like `Cx(&...)` for complex numbers.


---

## ord_product_one_minus_constx_I

### Name of formal statement
ord_product_one_minus_constx_I

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ord_product_one_minus_constx_I = prove(`
  !S y yinv.
  FINITE S ==>
  y * yinv = Cx(&1) ==>
  (
    ring_polynomial complex_ring (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) /\
    ~(poly_product complex_ring S (\z. one_minus_constx complex_ring (I z)) = poly_0 complex_ring) /\
    poly_ord (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) yinv
    = if y IN S then 1 else 0
  )
`,
  REPEAT GEN_TAC THEN REPEAT DISCH_TAC THEN
  have `~(poly_product complex_ring S (\z. one_minus_constx complex_ring (I z)) = poly_0 complex_ring)` [nonzero_poly_product;integral_domain_complex;nonzero_one_minus_constx;in_complex_ring;integral_domain] THEN
  case `(y:complex) IN S` THENL [
    specialize_assuming[`complex_ring`;`S:complex->bool`;`y:complex`;`\z. one_minus_constx complex_ring (I z)`]poly_product_delete THEN
    have `poly_product complex_ring (S) (\z. one_minus_constx complex_ring (I z)) = poly_mul complex_ring (one_minus_constx complex_ring y) (poly_product complex_ring ((S) DELETE y) (\z. one_minus_constx complex_ring (I z)))` [series_complex;IN;I_THM] THEN
    have `FINITE (S DELETE (y:complex))` [FINITE_DELETE] THEN
    subgoal `~(poly_eval complex_ring (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv = Cx(&0))` THENL [
      simp[eval_poly_product;in_complex_ring;one_minus_constx_poly;eval_one_minus_constx;I_THM;complex_ring_clauses;ring_sub_complex] THEN
      intro THEN
      have `ring_product complex_ring (S DELETE y) (\a. Cx (&1) - a * yinv) = ring_0 complex_ring` [complex_ring_clauses] THEN
      choose `a:complex` `a IN S DELETE y /\ Cx (&1) - a * yinv = ring_0 complex_ring` [INTEGRAL_DOMAIN_PRODUCT_EQ_0;integral_domain_complex] THEN
      have `Cx(&1) - a*yinv = Cx(&0)` [complex_ring_clauses] THEN
      complex_field_fact `y*yinv = Cx(&1) ==> Cx(&1) - a*yinv = Cx(&0) ==> a = y` THEN
      qed[IN_DELETE]
    ; pass
    ] THEN
    have `~(complex_root (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv)` [complex_root] THEN
    have `ring_polynomial complex_ring (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z)))` [poly_product_poly;one_minus_constx_poly;in_complex_ring] THEN
    specialize[`poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))`;`yinv:complex`]poly_ord_unique_0 THEN
    have `poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv = 0` [] THEN
    have `poly_ord (one_minus_constx complex_ring y) yinv = 1` [poly_ord_one_minus_constx] THEN
    have `~(one_minus_constx complex_ring y = poly_0 complex_ring)` [nonzero_one_minus_constx;field;field_complex;in_complex_ring] THEN
    have `ring_polynomial complex_ring (one_minus_constx complex_ring y)` [one_minus_constx_poly;in_complex_ring] THEN
    have `ring_polynomial complex_ring (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z)))` [poly_product_poly;FINITE_DELETE;one_minus_constx_poly;in_complex_ring] THEN
    have `~(poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z)) = poly_0(complex_ring))` [poly_product_ring_product_x_poly;x_poly_use] THEN
    specialize[`one_minus_constx complex_ring y`;`poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))`;`yinv:complex`]poly_ord_mul THEN
    have `poly_ord (poly_product complex_ring (S) (\z. one_minus_constx complex_ring (I z))) yinv = poly_ord (poly_mul complex_ring (one_minus_constx complex_ring y) (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z)))) yinv` [] THEN
    have `poly_ord (poly_product complex_ring (S) (\z. one_minus_constx complex_ring (I z))) yinv = poly_ord (one_minus_constx complex_ring y) yinv + poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv` [] THEN
    have `poly_ord (poly_product complex_ring (S) (\z. one_minus_constx complex_ring (I z))) yinv = 1 + poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv` [] THEN
    qed[ARITH_RULE `1 + 0 = 1`]
  ; pass
  ] THEN
  subgoal `~(poly_eval complex_ring (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) yinv = Cx(&0))` THENL [
    simp[eval_poly_product;in_complex_ring;one_minus_constx_poly;eval_one_minus_constx;I_THM;complex_ring_clauses;ring_sub_complex] THEN
    intro THEN
    have `ring_product complex_ring (S) (\a. Cx (&1) - a * yinv) = ring_0 complex_ring` [complex_ring_clauses] THEN
    choose `a:complex` `a IN S /\ Cx (&1) - a * yinv = ring_0 complex_ring` [INTEGRAL_DOMAIN_PRODUCT_EQ_0;integral_domain_complex] THEN
    have `Cx(&1) - a*yinv = Cx(&0)` [complex_ring_clauses] THEN
    complex_field_fact `y*yinv = Cx(&1) ==> Cx(&1) - a*yinv = Cx(&0) ==> a = y` THEN
    qed[]
  ; pass
  ] THEN
  have `~(complex_root (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) yinv)` [complex_root] THEN
  have `ring_polynomial complex_ring (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z)))` [poly_product_poly;one_minus_constx_poly;I_THM;in_complex_ring] THEN
  qed[poly_ord_unique_0]
);;
```
### Informal statement
For all sets `S` of complex numbers, and complex numbers `y` and `yinv`, if `S` is finite and `y * yinv = 1`, then: the polynomial `poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))` is a polynomial over the complex ring, it is not the zero polynomial, and its order at `yinv` is 1 if `y` is in `S` and 0 if `y` is not in `S`.

### Informal sketch
The proof proceeds by induction on whether `y` is in `S`.

- Case 1: `y IN S`.
  - We use `poly_product_delete` to rewrite `poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))` as `poly_mul complex_ring (one_minus_constx complex_ring y) (poly_product complex_ring ((S) DELETE y) (\z. one_minus_constx complex_ring (I z)))`.
  - We need to show `~(poly_eval complex_ring (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv = Cx(&0))`. This is proven by contradiction.
  - We know that `~complex_root (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv`.
  - By `poly_ord_unique_0` we have `poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv = 0`.
  - Also `poly_ord (one_minus_constx complex_ring y) yinv = 1` by `poly_ord_one_minus_constx`.
  - Then by `poly_ord_mul` we have `poly_ord (poly_product complex_ring (S) (\z. one_minus_constx complex_ring (I z))) yinv = poly_ord (one_minus_constx complex_ring y) yinv + poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv`.
  - Therefore, `poly_ord (poly_product complex_ring (S) (\z. one_minus_constx complex_ring (I z))) yinv = 1 + 0 = 1`.

- Case 2: `~(y IN S)`.
  - We assume `poly_eval complex_ring (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) yinv = Cx(&0)` and derive a contradiction.
  - We show that `~complex_root (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) yinv`.
  - By `poly_ord_unique_0` we can conclude `poly_ord (poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))) yinv = 0`.

### Mathematical insight
The theorem relates the order of the polynomial `poly_product complex_ring S (\z. one_minus_constx complex_ring (I z))` at the inverse of a complex number `y` to whether `y` belongs to the set `S`. Essentially, it states that each element `y` in `S` contributes a factor of `(1 - y * x)`, and thus a root at `1/y`, of order 1 to the polynomial. If `y` is not in `S`, then `1/y` is not a root. The `I` function is used to convert a complex number to a real.

### Dependencies
- `nonzero_poly_product`
- `integral_domain_complex`
- `nonzero_one_minus_constx`
- `in_complex_ring`
- `integral_domain`
- `FINITE_DELETE`
- `eval_poly_product`
- `one_minus_constx_poly`
- `eval_one_minus_constx`
- `complex_ring_clauses`
- `ring_sub_complex`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `IN_DELETE`
- `complex_root`
- `poly_product_poly`
- `poly_ord_unique_0`
- `poly_ord_one_minus_constx`
- `field`
- `field_complex`
- `poly_ord_mul`
- `ARITH_RULE`

Categories:
- Series
  - `series_complex`
- Finiteness
  - `FINITE_DELETE`

### Porting notes (optional)
- The complex number field and its associated polynomial constructions would need to be available, as well as the notion of the "order" of a polynomial at a point. The interaction of finiteness and set deletion would need to be handled with care. HOL Light's classical automation may need to be replaced with manual constructions.


---

## ord_sum_product_one_minus_constx_I

### Name of formal statement
ord_sum_product_one_minus_constx_I

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ord_sum_product_one_minus_constx_I = prove(`
  !S y yinv.
  FINITE S ==>
  y * yinv = Cx(&1) ==>
  y IN S ==>
  (
    ring_polynomial complex_ring (
      poly_sum complex_ring S (\t.
        poly_product complex_ring (S DELETE t) (\z.
          one_minus_constx complex_ring (I z)
        )
      )
    ) /\
    ~(
      poly_sum complex_ring S (\t.
        poly_product complex_ring (S DELETE t) (\z.
          one_minus_constx complex_ring (I z)
        )
      ) = poly_0 complex_ring
    ) /\
    poly_ord (
      poly_sum complex_ring S (\t.
        poly_product complex_ring (S DELETE t) (\z.
          one_minus_constx complex_ring (I z)
        )
      )
    ) yinv
    = 0
  )
`,
  REPEAT GEN_TAC THEN REPEAT DISCH_TAC THEN
  have `!s. s IN S DELETE(y:complex) ==> s IN S` [IN_DELETE] THEN
  have `FINITE(S DELETE(y:complex))` [FINITE_DELETE] THEN
  have `!s. s IN S ==> ring_polynomial complex_ring (poly_product complex_ring (S DELETE s) (\z. one_minus_constx complex_ring (I z)))` [poly_product_poly;one_minus_constx_poly;in_complex_ring;FINITE_DELETE] THEN
  subgoal `!s. s IN S ==> ~(s = y) ==> poly_product complex_ring (S DELETE s) (\z. one_minus_constx complex_ring (I z)) = poly_0 complex_ring \/ 1 <= poly_ord (poly_product complex_ring (S DELETE s) (\z. one_minus_constx complex_ring (I z))) yinv` THENL [
    intro THEN
    have `y IN S DELETE(s:complex)` [IN_DELETE] THEN
    specialize[
      `S DELETE(s:complex)`
    ]ord_product_one_minus_constx_I THEN
    qed[ARITH_RULE `1 <= 1`;FINITE_DELETE]
  ; pass
  ] THEN
  have `~(poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z)) = poly_0 complex_ring)` [nonzero_poly_product;integral_domain_complex;nonzero_one_minus_constx;integral_domain;in_complex_ring] THEN
  specialize[
    `S DELETE(y:complex)`;
    `y:complex`;
    `yinv:complex`
  ]ord_product_one_minus_constx_I THEN
  have `~(y IN S DELETE(y:complex))` [IN_DELETE] THEN
  have `poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv < 1` [ARITH_RULE `0 < 1`] THEN
  specialize[
    `\t. poly_product complex_ring (S DELETE t) (\z. one_minus_constx complex_ring (I z))`;
    `yinv:complex`;
    `1`;
    `S:complex->bool`;
    `y:complex`
  ]poly_ord_sum_dominant THEN
  qed[]
);;
```
### Informal statement
For all sets `S` of complex numbers, and for all complex numbers `y` and `yinv`, if `S` is finite, `y * yinv = 1`, and `y` is in `S`, then:
1.  The sum, over all `t` in `S`, of the product, over all `z` in `S` excluding `t`, of `1 - z*x` is a polynomial;
2.  The sum, over all `t` in `S`, of the product, over all `z` in `S` excluding `t`, of `1 - z*x` is not the zero polynomial;
3.  The order of the sum, over all `t` in `S`, of the product, over all `z` in `S` excluding `t`, of `1 - z*x`, evaluated at `yinv`, is equal to 0.

### Informal sketch
The proof proceeds by induction and arithmetic reasoning.

- Assume `FINITE S`, `y * yinv = Cx(&1)` and `y IN S`.
- The goal is to prove that the sum, over all `t` in `S`, of the product, over all `z` in `S` excluding `t`, of `one_minus_constx complex_ring (I z)` is a nonzero polynomial and that the order of the sum at `yinv` is `0`.

- First, it's shown that for any `s IN S`, any `s` not equal to `y` and for any `yinv:complex` , it holds that `poly_product complex_ring (S DELETE s) (\z. one_minus_constx complex_ring (I z)) = poly_0 complex_ring \/ 1 <= poly_ord (poly_product complex_ring (S DELETE s) (\z. one_minus_constx complex_ring (I z))) yinv`. This relies on `ord_product_one_minus_constx_I` for the case `s = y` after showing `y IN S DELETE s`

- It is shown that `~(poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z)) = poly_0 complex_ring)` based on `nonzero_poly_product`, `integral_domain_complex`, `nonzero_one_minus_constx`, `integral_domain` and `in_complex_ring`.

- The lemma `ord_product_one_minus_constx_I` is specialized to the case of `S DELETE y`, `y` and `yinv` and combined with earlier results to get `poly_ord (poly_product complex_ring (S DELETE y) (\z. one_minus_constx complex_ring (I z))) yinv < 1`

- Finally, `poly_ord_sum_dominant` is applied to conclude the final goal.

### Mathematical insight
This theorem gives properties about the order of a specific sum of products of polynomials. The polynomials in question are `one_minus_constx complex_ring (I z)`. The theorem says that the polynomial `poly_sum complex_ring S (\t. poly_product complex_ring (S DELETE t) (\z. one_minus_constx complex_ring (I z)))` is not zero and its order at `yinv` is `0`. `yinv` is a multiplicative inverse of an element `y` of `S`.

### Dependencies
- `FINITE_DELETE`
- `IN_DELETE`
- `ord_product_one_minus_constx_I`
- `poly_ord_sum_dominant`
- `nonzero_poly_product`
- `integral_domain_complex`
- `nonzero_one_minus_constx`
- `integral_domain`
- `in_complex_ring`
- `one_minus_constx_poly`
- `poly_product_poly`


---

## transcendence_ord_revp

### Name of formal statement
transcendence_ord_revp

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_ord_revp = prove(`
  !P p y yinv.
  FINITE P ==>
  distinct_minpolys P ==>
  p IN P ==>
  y * yinv = Cx(&1) ==>
  (
    ring_polynomial complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring p) p) /\
    ~(x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_0 complex_ring) /\
    poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring p) p) yinv
    = if complex_root p y then 1 else 0
  )
`,
  intro THEN
  have `monic_vanishing_at complex_ring (complex_root p) I = p` [distinct_minpolys_monic_vanishing_at] THEN
  have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
  have `CARD(complex_root p) = poly_deg complex_ring p` [distinct_minpolys_card_root] THEN
  have `!z. z IN complex_root p ==> I z IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[`complex_ring`;`I:complex->complex`]x_truncreverse_monic_vanishing_at THEN
  have `x_truncreverse complex_ring (CARD(complex_root p)) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` [] THEN
  have `x_truncreverse complex_ring (poly_deg complex_ring p) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` [] THEN
  have `x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` [x_truncreverse_subring;subring_complex_QinC] THEN
  qed[ord_product_one_minus_constx_I;IN]
);;
```

### Informal statement
For any finite set `P` of complex polynomials where all polynomials have distinct minimal polynomials, if `p` is a polynomial in `P`, and `y * yinv` equals the complex number 1, then the polynomial order of the reverse truncation of `p` (with respect to the `QinC_ring`, the degree of `p`, and `p`) evaluated at `yinv` is 1 if `y` is a root of `p` and 0 otherwise.

### Informal sketch
The proof demonstrates how the polynomial order of a truncated and reversed polynomial at `yinv` relates to whether `y` is a root of the original polynomial `p`.

- The proof starts by introducing assumptions.
- It uses `distinct_minpolys_monic_vanishing_at` to show that the minimal polynomial of `complex_root p` is `p`.
- It uses `distinct_minpolys_finite_root` to show that `complex_root p` is finite.
- It uses `distinct_minpolys_card_root` to relate the cardinality of `complex_root p` to the degree of `p`.
- It uses `in_complex_ring` to show that I z is in the ring_carrier of complex_ring if z is in `complex_root p`.
- It uses `x_truncreverse_monic_vanishing_at` to compute `x_truncreverse` as a product involving `one_minus_constx`.
- It derives that `x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_product complex_ring (complex_root p) (\z. one_minus_constx complex_ring (I z))` using `x_truncreverse_subring` and `subring_complex_QinC`
- Finally the proof finishes by applying `ord_product_one_minus_constx_I` and `IN` to relate the polynomial order to whether y is a root of p.

### Mathematical insight
This theorem connects the concept of polynomial roots with polynomial truncation and reversal. It establishes a condition for determining whether a value `y` is a root of a polynomial by examining the polynomial order of transformed version of the same polynomial (truncation and reversal). Also connects the complex roots to the `QinC_ring`.

### Dependencies
- `distinct_minpolys_monic_vanishing_at`
- `distinct_minpolys_finite_root`
- `distinct_minpolys_card_root`
- `in_complex_ring`
- `x_truncreverse_monic_vanishing_at`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `ord_product_one_minus_constx_I`
- `IN`


---

## transcendence_ord_H

### Name of formal statement
transcendence_ord_H

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_ord_H = prove(`
  !P t H.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!q y yinv.
    q IN P ==>
    complex_root q y ==>
    y * yinv = Cx(&1) ==>
    poly_ord H yinv = 1
  )
`,
  intro THEN
  have `poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring q) q) yinv = 1` [transcendence_ord_revp] THEN
  have `!p. p IN P ==> ~(p = q) ==> poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring p) p) yinv = 0` [transcendence_ord_revp;distinct_minpolys_distinct_roots] THEN
  subgoal `poly_ord H yinv = nsum P (\s. poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring s) s) yinv)` THENL [
    specialize_assuming[`\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p`;`yinv:complex`;`P:((1->num)->complex)->bool`]poly_ord_product THEN
    have `!p. p IN P ==> ring_polynomial complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [x_truncreverse_poly;series_complex;x_truncreverse_subring;subring_complex_QinC] THEN
    have `!p. p IN P ==> ~(x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_0 complex_ring)` [distinct_minpolys_reverse_nonzero] THEN
    have `H = poly_product complex_ring P (\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [transcendence_H_product_complex_ring] THEN
    specialize[`\p. x_truncreverse QinC_ring (poly_deg complex_ring p) p`;`yinv:complex`;`P:((1->num)->complex)->bool`]poly_ord_product THEN
    qed[]
  ; pass
  ] THEN
  subgoal `nsum P (\s. poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring s) s) yinv) = nsum P (\s. if s = q then 1 else 0)` THENL [
    sufficesby NSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    qed[]
  ; pass
  ] THEN
  specialize[`1`;`P:((1->num)->complex)->bool`;`q:(1->num)->complex`](GEN `b:num` NSUM_DELTA) THEN
  qed[]
);;
```

### Informal statement
For any set of polynomials `P`, any natural number `t`, and any polynomial `H` over the complex numbers in `QinC_ring`, if `P` is finite, the minimal polynomials in `P` are distinct, `t` equals the sum over `P` of the degree of each polynomial `p` in `P`, `H` equals the `x_truncreverse` of the polynomial product of `P` with respect to `QinC_ring` and the identity polynomial `I` truncated at `t`, and, for any polynomial `q` in `P` and any elements `y`, `yinv` such that `y` is a complex root of `q` and `y * yinv` equals the complex number 1, then the polynomial order of `H` at `yinv` is 1.

### Informal sketch
The proof proceeds by induction and rewriting, making use of properties of the `poly_ord` function and the `x_truncreverse` function.
- Prove the lemma for all polynomials `p` in `P`, the polynomial order of `x_truncreverse` of `q` at `yinv` with degree of `q` is 1, using `transcendence_ord_revp`.
- Prove the lemma that for all `p` if `p` is in `P` and ~(`p = q`) then the polynomial order of the `x_truncreverse` of `p` with degree of `p` is 0. Use `transcendence_ord_revp` and `distinct_minpolys_distinct_roots`.
- Rewrite `poly_ord H yinv` to `nsum P (\s. poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring s) s) yinv)` use specialization of the theorem `poly_ord_product` and two lemmas to rewrite `H`.
- Rewrite `nsum P (\s. poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring s) s) yinv) = nsum P (\s. if s = q then 1 else 0)`.
- Specialize `GEN b NSUM_DELTA`.

### Mathematical insight
The theorem relates the polynomial order of a product of truncated and reversed minimal polynomials to the roots of its constituent minimal polynomials. It shows that the polynomial order of `H` at the inverse of a root `y` of a polynomial `q` in `P` is exactly 1. This is an important step in proving transcendence results, as it connects the roots of minimal polynomials to the polynomial order of a related polynomial `H`.

### Dependencies
- `transcendence_ord_revp`
- `distinct_minpolys_distinct_roots`
- `poly_ord_product`
- `x_truncreverse_poly`
- `series_complex`
- `x_truncreverse_subring`
- `subring_complex_QinC`
- `distinct_minpolys_reverse_nonzero`
- `transcendence_H_product_complex_ring`
- `NSUM_EQ`
- `BETA_THM`
- `GEN b NSUM_DELTA`


---

## transcendence_ord_Hk

### Name of formal statement
transcendence_ord_Hk

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_ord_Hk = prove(`
  !P t H k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!q y yinv.
    q IN P ==>
    complex_root q y ==>
    y * yinv = Cx(&1) ==>
    poly_ord (poly_pow complex_ring H k) yinv = k
  )
`,
  intro THEN
  have `ring_polynomial complex_ring (H:(1->num)->complex)` [transcendence_H_poly] THEN
  have `coeff 0 (H:(1->num)->complex) = Cx(&1)` [transcendence_H_botcoeff1] THEN
  have `~(H = poly_0 complex_ring:(1->num)->complex)` [coeff_poly_0;complex_ring_clauses;ring_1_0_complex] THEN
  specialize[`H:(1->num)->complex`;`k:num`;`yinv:complex`]poly_ord_pow THEN
  have `poly_ord H yinv = 1` [transcendence_ord_H] THEN
  qed[ARITH_RULE `k * 1 = k`]
);;
```

### Informal statement
For any finite set `P` of polynomials over the complex numbers, if the polynomials in `P` have distinct minimal polynomials, then for any natural number `t` equal to the sum over `P` of the degrees of the polynomials in `P`, and for any polynomial `H` equal to `x_truncreverse QinC_ring t` applied to the product over `P` of the polynomials in `P`, it holds that for any polynomial `q` in `P`, any complex root `y` of `q`, and any complex number `yinv` such that `y * yinv = Cx(&1)`, the order of `poly_pow complex_ring H k` at `yinv` is equal to `k`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Establish that `H` is a polynomial (using `transcendence_H_poly`).
- Establish that the coefficient of `x^0` in `H` is 1 (using `transcendence_H_botcoeff1`).
- Show that `H` is not the zero polynomial, using `coeff_poly_0`, `complex_ring_clauses`, and `ring_1_0_complex`.
- Apply `poly_ord_pow` to specialize the property of the polynomial power.
- Establish that `poly_ord H yinv = 1` (using `transcendence_ord_H`).
- Conclude that `poly_ord (poly_pow complex_ring H k) yinv = k` using the arithmetic rule `k * 1 = k`.

### Mathematical insight
This theorem relates the order of a polynomial that arises from truncating the reverse of a product of minimal polynomials, raised to the power of `k`, to the value `k` at the inverse of a root of one of the minimal polynomials. This is likely used in transcendence theory, where the order of a polynomial at a root of another polynomial is crucial.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `nsum`
- `poly_deg`
- `complex_ring`
- `x_truncreverse`
- `QinC_ring`
- `poly_product`
- `I`
- `complex_root`
- `Cx`
- `poly_ord`
- `poly_pow`
- `ring_polynomial`
- `coeff`
- `poly_0`
- `coeff_poly_0`
- `complex_ring_clauses`
- `ring_1_0_complex`
- `poly_ord_pow`
- `transcendence_H_poly`
- `transcendence_H_botcoeff1`
- `transcendence_ord_H`
- `ARITH_RULE`

### Porting notes (optional)
The main difficulty might be in finding equivalent theorems to `x_truncreverse` and `transcendence_H_poly`. One might also need to prove additional lemmas concerning polynomial arithmetic. Also, ensure that the ring structure on complex numbers is defined analogously.


---

## transcendence_ord_Hu

### Name of formal statement
transcendence_ord_Hu

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_ord_Hu = prove(`
  !P B t H u.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  (!q y yinv.
    q IN P ==>
    ~(B q = &0) ==>
    complex_root q y ==>
    y * yinv = Cx(&1) ==>
    (
      ring_polynomial complex_ring (poly_mul complex_ring H (series_from_coeffs u)) /\
      ~(poly_mul complex_ring H (series_from_coeffs u) = poly_0 complex_ring) /\
      poly_ord (poly_mul complex_ring H (series_from_coeffs u)) yinv = 0
    )
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  def `G:((1->num)->complex)->((1->num)->complex)` `\p. poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q)` THEN
  have `!p:(1->num)->complex. p IN P ==> G p = poly_product complex_ring (P DELETE p) (\q. x_truncreverse QinC_ring (poly_deg complex_ring q) q)` [] THEN
  def `e:num` `0` THEN
  def `k:num` `1` THEN
  have `e < k:num` [ARITH_RULE `0 < 1`] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `G:((1->num)->complex)->(1->num)->complex`;
    `u:num->complex`;
    `e:num`;
    `k:num`
  ]transcendence_newton_Hk_psum THEN
  subgoal `poly_mul complex_ring H (series_from_coeffs u) = poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs (\n. Cx (&(FACT e * binom (n,e))) * u (n - e)))` THENL [
    have `H = poly_pow complex_ring H k:(1->num)->complex` [poly_pow_1;series_complex] THEN
    subgoal `series_from_coeffs u = series_from_coeffs (\n. Cx (&(FACT e * binom (n,e))) * u (n - e))` THENL [
      sufficesby eq_coeff THEN
      rw[coeff_series_from_coeffs] THEN
      simp[FACT;binom;ARITH_RULE `d - 0 = d`;ARITH_RULE `1 * 1 = 1`;COMPLEX_MUL_LID]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_polynomial complex_ring (poly_pow complex_ring H (k - (e + 1))) /\ ~(poly_pow complex_ring H (k - (e + 1)) = poly_0 complex_ring) /\ poly_ord(poly_pow complex_ring H (k - (e + 1))) yinv = 0` THENL [
    have_rw `k - (e+1) = 0` [ARITH_RULE `1 - (0+1) = 0`] THEN
    rw[poly_pow_0;poly_ord_1]
  ; pass
  ] THEN
  def `Z:((1->num)->complex)->((1->num)->complex)` `\p. poly_mul complex_ring (poly_const complex_ring (complex_of_int (B p))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))` THEN
  subgoal `ring_polynomial complex_ring (Z q) /\ ~(Z q = poly_0 complex_ring) /\ poly_ord(Z(q:(1->num)->complex)) yinv = 0` THENL [
    subgoal `ring_polynomial complex_ring (poly_const complex_ring (complex_of_int (B q)):(1->num)->complex) /\ ~(poly_const complex_ring (complex_of_int (B(q:(1->num)->complex))) = poly_0 complex_ring:(1->num)->complex) /\ poly_ord(poly_const complex_ring (complex_of_int (B(q:(1->num)->complex)))) yinv = 0` THENL [
      have `~(complex_of_int (B(q:(1->num)->complex)) = Cx(&0))` [complex_of_int;CX_INJ;int_eq;REAL_OF_INT_CLAUSES] THEN
      qed[poly_ord_const]
    ; pass
    ] THEN
    subgoal `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root q) e) /\ ~(scaled_pow_newton_rightside complex_ring I (complex_root q) e = poly_0 complex_ring) /\ poly_ord(scaled_pow_newton_rightside complex_ring I (complex_root q) e) yinv = 0` THENL [
      rw[scaled_pow_newton_rightside] THEN
      simp[FACT;RING_OF_NUM_1;ARITH_RULE `0+1 = 1`;const_1_x_pow] THEN
      simp[POLY_MUL_LID;poly_pow_1;series_complex] THEN
      have `y IN complex_root q` [IN] THEN
      have `FINITE(complex_root q)` [distinct_minpolys_finite_root] THEN
      specialize[`complex_root q`;`y:complex`;`yinv:complex`]ord_sum_product_one_minus_constx_I THEN
      qed[]
    ; pass
    ] THEN
    subgoal `ring_polynomial complex_ring (poly_pow complex_ring (G(q:(1->num)->complex)) (e + 1)) /\ ~(poly_pow complex_ring (G(q:(1->num)->complex)) (e + 1) = poly_0 complex_ring) /\ poly_ord(poly_pow complex_ring (G(q:(1->num)->complex)) (e + 1)) yinv = 0` THENL [
      have `e + 1 = 1` [ARITH_RULE `0 + 1 = 1`] THEN
      rw[know `e + 1 = 1`] THEN
      simp[poly_pow_1;series_complex] THEN
      have `FINITE (P DELETE (q:(1->num)->complex))` [FINITE_DELETE] THEN
      have `!p:(1->num)->complex. p IN P DELETE q ==> p IN P` [IN_DELETE] THEN
      have `!p:(1->num)->complex. p IN P ==> ring_polynomial QinC_ring p` [distinct_minpolys] THEN
      have `!p:(1->num)->complex. p IN P ==> monic QinC_ring p` [distinct_minpolys] THEN
      have `!p:(1->num)->complex. p IN P ==> poly_deg QinC_ring p = poly_deg complex_ring p` [poly_deg_subring;subring_complex_QinC] THEN
      have `!p:(1->num)->complex. p IN P DELETE q ==> ring_polynomial QinC_ring (x_truncreverse QinC_ring (poly_deg QinC_ring p) p)` [x_truncreverse_poly;ring_polynomial] THEN
      have `!p:(1->num)->complex. p IN P DELETE q ==> ring_polynomial QinC_ring (x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [] THEN
      have `!p:(1->num)->complex. p IN P DELETE q ==> ring_polynomial complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring p) p)` [poly_complex_if_poly_QinC] THEN
      have `!p:(1->num)->complex. p IN P DELETE q ==> ~(x_truncreverse QinC_ring (poly_deg QinC_ring p) p = poly_0 QinC_ring)` [nonzero_if_x_truncreverse_monic;integral_domain;integral_domain_QinC] THEN
      have `!p:(1->num)->complex. p IN P DELETE q ==> ~(x_truncreverse QinC_ring (poly_deg complex_ring p) p = poly_0 complex_ring)` [poly_0_QinC_eq_poly_0_complex] THEN
      specialize[`\p:(1->num)->complex. x_truncreverse QinC_ring (poly_deg complex_ring p) p`;`yinv:complex`;`P DELETE (q:(1->num)->complex)`]poly_ord_product THEN
      simp[] THEN
      subgoal `nsum (P DELETE q) (\s. poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring s) s) yinv) = nsum (P DELETE q) (\s. 0)` THENL [
        sufficesby NSUM_EQ THEN
        intro THEN
        rw[BETA_THM] THEN
        have `(x:(1->num)->complex) IN P` [IN_DELETE] THEN
        have `~((x:(1->num)->complex) = q)` [IN_DELETE] THEN
        have `~complex_root x y` [distinct_minpolys_distinct_roots] THEN
        qed[transcendence_ord_revp]
      ; pass
      ] THEN
      qed[NSUM_0]
    ; pass
    ] THEN
    specialize_assuming_nosplit[`poly_pow complex_ring (G(q:(1->num)->complex)) (e + 1):(1->num)->complex`;`scaled_pow_newton_rightside complex_ring I (complex_root q) e`;`yinv:complex`]poly_ord_mul_0 THEN
    specialize_assuming_nosplit[`poly_pow complex_ring H (k - (e + 1)):(1->num)->complex`;`poly_mul complex_ring (poly_pow complex_ring (G(q:(1->num)->complex)) (e + 1):(1->num)->complex) (scaled_pow_newton_rightside complex_ring I (complex_root q) e)`;`yinv:complex`]poly_ord_mul_0 THEN
    specialize_assuming_nosplit[`poly_const complex_ring (complex_of_int (B(q:(1->num)->complex))):(1->num)->complex`;`poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1)):(1->num)->complex) (poly_mul complex_ring (poly_pow complex_ring (G(q:(1->num)->complex)) (e + 1):(1->num)->complex) (scaled_pow_newton_rightside complex_ring I (complex_root q) e))`;`yinv:complex`]poly_ord_mul_0 THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!p:(1->num)->complex. p IN P ==> ~(p = q) ==> (ring_polynomial complex_ring (Z p) /\ (Z p = poly_0 complex_ring \/ 1 <= poly_ord (Z p:(1->num)->complex) yinv))` THENL [
    GEN_TAC THEN REPEAT DISCH_TAC THEN
    have `ring_polynomial complex_ring (poly_const complex_ring (complex_of_int (B(p:(1->num)->complex))):(1->num)->complex)` [RING_POLYNOMIAL_CONST;in_complex_ring] THEN
    subgoal `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` THENL [
      rw[scaled_pow_newton_rightside] THEN
      simp[FACT;RING_OF_NUM_1;ARITH_RULE `0+1 = 1`;const_1_x_pow] THEN
      simp[POLY_MUL_LID;poly_pow_1;series_complex] THEN
      have `FINITE(complex_root p)` [distinct_minpolys_finite_root] THEN
      subgoal `!t. ring_polynomial complex_ring (poly_product complex_ring (complex_root p DELETE t) (\s. one_minus_constx complex_ring (I s)))` THENL [
        intro THEN
        qed[poly_product_poly;FINITE_DELETE;one_minus_constx_poly;in_complex_ring]
      ; pass
      ] THEN
      qed[poly_sum_poly]
    ; pass
    ] THEN
    subgoal `ring_polynomial complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1)) /\ 1 <= poly_ord(poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1)) yinv` THENL [
      have `e + 1 = 1` [ARITH_RULE `0 + 1 = 1`] THEN
      rw[know `e + 1 = 1`] THEN
      simp[poly_pow_1;series_complex] THEN
      have `FINITE(P DELETE(p:(1->num)->complex))` [FINITE_DELETE] THEN
      subgoal `!s. s IN P DELETE p ==> ring_polynomial complex_ring (x_truncreverse QinC_ring (poly_deg complex_ring s) s) /\ ~(x_truncreverse QinC_ring (poly_deg complex_ring s) s = poly_0 complex_ring)` THENL [
        intro THEN
        specialize_assuming[`P:((1->num)->complex)->bool`;`s:(1->num)->complex`;`y:complex`;`yinv:complex`]transcendence_ord_revp THEN
        qed[IN_DELETE]
      ; pass
      ] THEN
      intro THENL [
        specialize[`complex_ring`;`\s. x_truncreverse QinC_ring (poly_deg complex_ring s) s`]poly_product_poly THEN
        qed[FINITE_DELETE]
      ;
        simp[poly_ord_product] THEN
        have `q IN (P DELETE (p:(1->num)->complex))` [IN_DELETE] THEN
        specialize[`P:((1->num)->complex)->bool`;`q:(1->num)->complex`;`y:complex`;`yinv:complex`]transcendence_ord_revp THEN
        have `poly_ord (x_truncreverse QinC_ring (poly_deg complex_ring q) q) yinv = 1` [] THEN
        qed[term_le_nsum]
      ]
    ; pass
    ] THEN
    have `ring_polynomial complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1):(1->num)->complex)` [] THEN
    have `poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1) = poly_0 complex_ring \/ 1 <= poly_ord (poly_pow complex_ring (G p) (e + 1)) yinv` [] THEN
    have `ring_polynomial complex_ring (scaled_pow_newton_rightside complex_ring I (complex_root p) e)` [] THEN
    specialize[
      `poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1):(1->num)->complex`;
      `scaled_pow_newton_rightside complex_ring I (complex_root p) e`;
      `yinv:complex`;
      `1`
    ]poly_ord_mul_ge_ge0 THEN
    have `ring_polynomial complex_ring (poly_pow complex_ring H (k - (e + 1)):(1->num)->complex)` [] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))` [] THEN
    have `poly_mul complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e) = poly_0 complex_ring \/ 1 <= poly_ord (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)) yinv` [] THEN
    specialize[
      `poly_pow complex_ring H (k - (e + 1)):(1->num)->complex`;
      `poly_mul complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1):(1->num)->complex) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)`;
      `yinv:complex`;
      `1`
    ]poly_ord_mul_ge0_ge THEN
    have `ring_polynomial complex_ring (poly_const complex_ring (complex_of_int (B(p:(1->num)->complex))):(1->num)->complex)` [] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))` [] THEN
    have `poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)) = poly_0 complex_ring \/ 1 <= poly_ord (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))) yinv` [] THEN
    specialize[
      `poly_const complex_ring (complex_of_int (B(p:(1->num)->complex):int)):(1->num)->complex`;
      `poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1)):(1->num)->complex) (poly_mul complex_ring (poly_pow complex_ring (G(p:(1->num)->complex)) (e + 1):(1->num)->complex) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))`;
      `yinv:complex`;
      `1`
    ]poly_ord_mul_ge0_ge THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_polynomial complex_ring (poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring (complex_of_int (B p))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))) /\ ~(poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring (complex_of_int (B p))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e)))) = poly_0 complex_ring) /\ poly_ord(poly_sum complex_ring P (\p. poly_mul complex_ring (poly_const complex_ring (complex_of_int (B p))) (poly_mul complex_ring (poly_pow complex_ring H (k - (e + 1))) (poly_mul complex_ring (poly_pow complex_ring (G p) (e + 1)) (scaled_pow_newton_rightside complex_ring I (complex_root p) e))))) yinv = 0` THENL [
    have `!s:(1->num)->complex. s IN P ==> ring_polynomial complex_ring (Z s:(1->num)->complex)` [] THEN
    have `!s:(1->num)->complex. s IN P ==> ~(s = q) ==> Z s = poly_0 complex_ring \/ 1 <= poly_ord (Z s) yinv` [] THEN
    have `~(Z(q:(1->num)->complex) = poly_0 complex_ring:(1->num)->complex)` [] THEN
    have `poly_ord (Z(q:(1->num)->complex)) yinv < 1` [ARITH_RULE `0 < 1`] THEN
    specialize[`Z:((1->num)->complex)->((1->num)->complex)`;`yinv:complex`;`1`;`P:((1->num)->complex)->bool`;`q:(1->num)->complex`]poly_ord_sum_dominant THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For all `P`, `B`, `t`, `H`, and `u`, if `P` is a finite set of complex polynomials, `P` consists of distinct minimal polynomials, `t` is equal to the numerical sum over `P` of the degree of each polynomial `p` in `P`, `H` is equal to the truncated reverse of the polynomial, over the ring `QinC_ring`, which is `t` many terms of the product of the polynomials in `P` with the identity polynomial `I`, and for all `n`, `u(n)` is equal to the ring sum over `P` of `B(p)` times the complex root powersums of `p` at `n`, then for all `q`, `y`, and `yinv`, if `q` is an element of `P`, `B(q)` is not equal to 0, `y` is a complex root of `q`, and `y` times `yinv` is equal to the complex number 1, then the polynomial `poly_mul complex_ring H (series_from_coeffs u)` is a ring polynomial, it is not equal to the zero polynomial, and its order at `yinv` is 0.

### Informal sketch
The proof proceeds as follows:

- Assume `FINITE P`, `distinct_minpolys P`, define `t` as the numerical sum of polynomial degrees, `H` as the truncated reverse polynomial product, and define `u n` based on root powersums. Assume also `q IN P`, `~(B q = &0)`, `complex_root q y` and `y * yinv = Cx(&1)`. The goal is to prove that `poly_mul complex_ring H (series_from_coeffs u)` is a ring polynomial, not zero, and has order 0 at `yinv`.

- Define `G p` as the polynomial product over `P` excluding `p`, truncated. Then, specialize the theorem `transcendence_newton_Hk_psum` with `e=0` and `k=1`. This reduces the goal to proving facts about `poly_pow complex_ring H (k - (e + 1))` and a newly defined `Z(q)`.

- Establish that `poly_pow complex_ring H (k - (e + 1))` equals 1, and thus its order at `yinv` is 0.

- Define `Z p` involving `H`, `G p`, and a `scaled_pow_newton_rightside` term. To prove facts about `Z q`, split it into components. Specifically, consider the constant term `complex_of_int (B q)`, the term `scaled_pow_newton_rightside complex_ring I (complex_root q) e`, and the term `poly_pow complex_ring (G q) (e + 1)`.

  - Show that `poly_const complex_ring (complex_of_int (B q))` has order 0 at `yinv` because `B q` is nonzero.
  - Show that `scaled_pow_newton_rightside complex_ring I (complex_root q) e` also has order 0 at `yinv` using `ord_sum_product_one_minus_constx_I`.
  - Show that `poly_pow complex_ring (G q) (e + 1)` also has order 0 at `yinv`.  This involves using `poly_ord_product` and `transcendence_ord_revp`.

- Show that if `p IN P` and `p != q`, then either `Z p` is zero or its order at `yinv` is at least 1. This is based on similar arguments as the previous parts, involving `transcendence_ord_revp` and properties of `poly_ord_mul_ge0_ge`.

- Finally, use `poly_ord_sum_dominant` to show that the order of the sum is dominated by the term `Z q`, which has order 0, completing the proof.

### Mathematical insight
This theorem contributes to transcendence theory. It establishes a key property about the order of a certain polynomial construction (`poly_mul complex_ring H (series_from_coeffs u)`) at a specific value (`yinv`). This is likely used in the broader argument to prove that a given number is transcendental. The core idea is to decompose a complex polynomial expression into manageable parts and then apply lemmas about polynomial orders to show that a certain order relation is preserved throughout the decomposition.

### Dependencies
- `transcendence_newton_Hk_psum`
- `poly_pow_1`
- `series_complex`
- `coeff_series_from_coeffs`
- `FACT`
- `binom`
-`ARITH_RULE`
- `COMPLEX_MUL_LID`
- `poly_pow_0`
- `poly_ord_1`
- `scaled_pow_newton_rightside`
- `complex_of_int`
- `CX_INJ`
- `int_eq`
- `REAL_OF_INT_CLAUSES`
- `poly_ord_const`
- `IN`
- `distinct_minpolys_finite_root`
- `ord_sum_product_one_minus_constx_I`
- `FINITE_DELETE`
- `IN_DELETE`
- `distinct_minpolys`
- `poly_deg_subring`
- `subring_complex_QinC`
- `x_truncreverse_poly`
- `poly_complex_if_poly_QinC`
- `nonzero_if_x_truncreverse_monic`
- `integral_domain`
- `integral_domain_QinC`
- `poly_0_QinC_eq_poly_0_complex`
- `poly_ord_product`
- `NSUM_EQ`
- `distinct_minpolys_distinct_roots`
- `transcendence_ord_revp`
- `NSUM_0`
- `poly_ord_mul_0`
- `RING_POLYNOMIAL_CONST`
- `in_complex_ring`
- `poly_product_poly`
- `one_minus_constx_poly`
- `poly_sum_poly`
- `poly_ord_mul_ge_ge0`
- `poly_ord_mul_ge0_ge`
- `poly_ord_sum_dominant`

### Porting notes (optional)
- When porting, pay close attention to how `x_truncreverse` is defined and used.
- The handling of polynomial orders (`poly_ord`) is crucial. Ensure that the target system has equivalent functionality.
- The `distinct_minpolys` assumption signifies that the set `P` contains polynomials that are pairwise coprime. This property is used in many places. Ensure that your target theorem prover has similar constructs to reason about coprimality.


---

## transcendence_ord_Hku

### Name of formal statement
transcendence_ord_Hku

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_ord_Hku = prove(`
  !P B t H u k.
  FINITE P ==>
  distinct_minpolys P ==>
  t = nsum P (\p. poly_deg complex_ring p) ==>
  H = x_truncreverse QinC_ring t (poly_product QinC_ring P I) ==>
  (!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))) ==>
  1 <= k ==>
  (!q y yinv.
    q IN P ==>
    ~(B q = &0) ==>
    complex_root q y ==>
    y * yinv = Cx(&1) ==>
    (
      ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) /\
      ~(poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u) = poly_0 complex_ring) /\
      poly_ord (
        poly_mul complex_ring (
          poly_pow complex_ring H k
        ) (
          series_from_coeffs u
        )
      ) yinv = k-1
    )
  )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  num_linear_fact `1 <= k ==> k = (k-1)+1` THEN
  have `poly_pow complex_ring H k = poly_mul complex_ring (poly_pow complex_ring H (k-1)) (poly_pow complex_ring H 1):(1->num)->complex` [poly_pow_add;poly_pow_1;series_complex] THEN
  have `poly_pow complex_ring H k = poly_mul complex_ring (poly_pow complex_ring H (k-1)) H:(1->num)->complex` [poly_pow_1;series_complex] THEN
  subgoal `poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u) = poly_mul complex_ring (poly_pow complex_ring H (k-1)) (poly_mul complex_ring H (series_from_coeffs u))` THENL [
    specialize_assuming[`complex_ring`;`poly_pow complex_ring H (k-1):(1->num)->complex`;`H:(1->num)->complex`;`series_from_coeffs u:(1->num)->complex`]POLY_MUL_ASSOC THEN
    qed[series_complex]
  ; pass
  ] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->int`;
    `t:num`;
    `H:(1->num)->complex`;
    `u:num->complex`
  ]transcendence_ord_Hu THEN
  have `poly_ord (poly_pow complex_ring H (k-1)) yinv = k-1` [transcendence_ord_Hk] THEN
  have `ring_polynomial complex_ring (H:(1->num)->complex)` [transcendence_H_poly] THEN
  have `coeff 0 (H:(1->num)->complex) = Cx(&1)` [transcendence_H_botcoeff1] THEN
  have `~(H = poly_0 complex_ring:(1->num)->complex)` [coeff_poly_0;complex_ring_clauses;ring_1_0_complex] THEN
  have `ring_polynomial complex_ring (poly_pow complex_ring H (k - 1):(1->num)->complex)` [poly_pow_poly] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring H (series_from_coeffs u))` [] THEN
  have `~(poly_pow complex_ring H (k - 1) = poly_0 complex_ring:(1->num)->complex)` [nonzero_poly_pow;integral_domain_complex;series_complex] THEN
  have `~(poly_mul complex_ring H (series_from_coeffs u) = poly_0 complex_ring)` [] THEN
  specialize[`poly_pow complex_ring H (k-1):(1->num)->complex`;`poly_mul complex_ring H (series_from_coeffs u)`;`yinv:complex`]poly_ord_mul THEN
  have `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) yinv = poly_ord (poly_pow complex_ring H (k - 1)) yinv + poly_ord (poly_mul complex_ring H (series_from_coeffs u)) yinv` [] THEN
  have `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) yinv = (k-1) + poly_ord (poly_mul complex_ring H (series_from_coeffs u)) yinv` [] THEN
  have `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) yinv = (k-1) + 0` [] THEN
  qed[ARITH_RULE `(k-1)+0 = k-1`]
);;
```
### Informal statement
For all sets of polynomials `P`, integer-valued functions `B` on those polynomials, natural numbers `t`, polynomials `H`, functions `u` from natural numbers to complex numbers, and natural numbers `k`, if `P` is finite and `P` contains only distinct minimal polynomials and `t` is the sum over `P` of the degrees of the polynomials in `P` and `H` is the polynomial obtained by truncating the reverse polynomial `x^t * p(1/x)` of the product of polynomials in `P` to degree `t`, and for all `n`, `u(n)` is the sum over `P` of `B(p) * (complex_root_powersums p n)` where `complex_root_powersums p n` is the sum of the `n`-th powers of the complex roots of `p`, and `1 <= k`, and for all polynomials `q` if `q` is in `P`, the function `B` maps `q` to a nonzero integer, and `y` is a complex root of `q`, and `y * yinv = 1`, then the following conditions hold: the polynomial `(H^k) * (series_from_coeffs u)` is a polynomial, `(H^k) * (series_from_coeffs u)` is not the zero polynomial, and the order of `(H^k) * (series_from_coeffs u)` at `yinv` is `k-1`.

### Informal sketch
The theorem asserts properties about the order of a polynomial involving `H`, `u`, and `k` at the inverse of a root `yinv` of a polynomial `q` in a set of minimal polynomials `P`. The proof proceeds as follows:
- First, rewrite `H^k` as `H^(k-1) * H`.
- Apply the theorem `transcendence_ord_Hu`, specializing it with the given parameters `P`, `B`, `t`, `H`, and `u`.
- Import theorem `transcendence_ord_Hk` to get `poly_ord (poly_pow complex_ring H (k-1)) yinv = k-1`.
- Establish that `H` is a polynomial using `transcendence_H_poly` and that its constant coefficient is 1 using `transcendence_H_botcoeff1`.
- Prove that `H` is not the zero polynomial.
- By using the theorem `poly_pow_poly` derive `ring_polynomial complex_ring (poly_pow complex_ring H (k - 1):(1->num)->complex)`.
- Prove `ring_polynomial complex_ring (poly_mul complex_ring H (series_from_coeffs u))`.
- Prove `~(poly_pow complex_ring H (k - 1) = poly_0 complex_ring:(1->num)->complex)` using `nonzero_poly_pow`.
- Prove `~(poly_mul complex_ring H (series_from_coeffs u) = poly_0 complex_ring)`.
- Applying theorem `poly_ord_mul`, specialize it with polynomials `poly_pow complex_ring H (k-1:(1->num)->complex)`, `poly_mul complex_ring H (series_from_coeffs u)`, and `yinv` .
- Use `poly_ord_mul` to relate the order of the product to the sum of the orders.
- Show that `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) yinv = (k-1) + poly_ord (poly_mul complex_ring H (series_from_coeffs u)) yinv`.
- Prove that `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) yinv = (k-1) + 0`.
- Finally, simplify `(k-1)+0 = k-1` to conclude the proof using `ARITH_RULE`.

### Mathematical insight
This theorem is a step towards proving transcendence results. It establishes a relationship between the order of a polynomial involving a truncated polynomial `H`, a series derived from power sums of roots `u`, and a parameter `k`, at the inverse of a root of a polynomial in `P`. This relationship is crucial for bounding the order and ultimately proving that certain numbers are transcendental. The use of truncated polynomials and power sums is a common technique in transcendence theory.

### Dependencies
- `transcendence_ord_Hu`
- `transcendence_ord_Hk`
- `transcendence_H_poly`
- `transcendence_H_botcoeff1`
- `poly_pow_add`
- `poly_pow_1`
- `coeff_poly_0`
- `complex_ring_clauses`
- `ring_1_0_complex`
- `poly_pow_poly`
- `nonzero_poly_pow`
- `integral_domain_complex`
- `poly_ord_mul`
- `num_linear_fact`

### Porting notes (optional)
- The `REPEAT` tactic in HOL Light might correspond to iterative application or recursion in other proof assistants.
- The `DISCH_TAC` tactic discharges the hypothesis of the current goal by moving it into the assumptions. This is common in most proof assistants.
- The `GEN_TAC` tactic introduces a new assumption using the universal quantifier of the goal.
- The theorems beginning with names such as `_poly`, `complex_ring_clauses ` and `ring_1_0_complex` correspond to properties of polynomial rings and complex arithmetic; these are often found in standard libraries of other proof assistants.


---

## transcendence_pole_order_ne1

### Name of formal statement
transcendence_pole_order_ne1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_pole_order_ne1 = prove(`
  !U V e f g y yinv.
  y * yinv = Cx(&1) ==>
  ring_polynomial complex_ring e ==>
  ring_polynomial complex_ring f ==>
  ring_polynomial complex_ring g ==>
  ~(g = poly_0 complex_ring) ==>
  ~(e = poly_0 complex_ring) ==>
  poly_ord e yinv + 1 = poly_ord g yinv ==>
  poly_mul complex_ring g U = e ==>
  poly_mul complex_ring g V = f ==>
  poly_sub complex_ring (
    poly_sub complex_ring V (
      poly_mul complex_ring (x_pow complex_ring 1) V
    )
  ) (
    poly_mul complex_ring (x_pow complex_ring 2) (x_derivative complex_ring V)
  ) = U ==>
  F
`,
  intro THEN
  recall series_complex THEN
  have `x_derivative complex_ring f = poly_add complex_ring (poly_mul complex_ring (x_derivative complex_ring g) V) (poly_mul complex_ring g (x_derivative complex_ring V))` [x_derivative_mul] THEN
  subgoal `poly_mul complex_ring e g = poly_sub complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)) (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))))` THENL [
    subgoal `ring_mul (x_series complex_ring) e g = ring_sub (x_series complex_ring) (ring_mul (x_series complex_ring) (ring_sub (x_series complex_ring) (ring_1 (x_series complex_ring)) (x_pow complex_ring 1)) (ring_mul (x_series complex_ring) f g)) (ring_mul (x_series complex_ring) (x_pow complex_ring 2) (ring_sub (x_series complex_ring) (ring_mul (x_series complex_ring) (x_derivative complex_ring f) g) (ring_mul (x_series complex_ring) f (x_derivative complex_ring g))))` THENL [
      have `U IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `V IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `x_derivative complex_ring V IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `e IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `f IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `x_derivative complex_ring f IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `g IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `x_derivative complex_ring g IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `x_pow complex_ring 1 IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      have `x_pow complex_ring 2 IN ring_carrier(x_series complex_ring)` [x_series_use] THEN
      specialize_assuming[
        `x_series complex_ring`;
        `U:(1->num)->complex`;
        `V:(1->num)->complex`;
        `x_derivative complex_ring V:(1->num)->complex`;
        `e:(1->num)->complex`;
        `f:(1->num)->complex`;
        `x_derivative complex_ring f:(1->num)->complex`;
        `g:(1->num)->complex`;
        `x_derivative complex_ring g:(1->num)->complex`;
        `x_pow complex_ring 1`;
        `x_pow complex_ring 2`
      ](GENL[
        `r:R ring`;
        `U:R`;
        `V:R`;
        `V':R`;
        `e:R`;
        `f:R`;
        `f':R`;
        `g:R`;
        `g':R`;
        `x1:R`;
        `x2:R`
      ](RING_RULE `
        ring_mul(r:R ring) g U = e ==>
        ring_mul r g V = f ==>
        ring_sub r (ring_sub r V (ring_mul r x1 V)) (ring_mul r x2 V') = U ==>
        f' = ring_add r (ring_mul r g' V) (ring_mul r g V') ==>
        ring_mul r e g =
        ring_sub r (ring_mul r (ring_sub r (ring_1 r) x1) (ring_mul r f g)) (ring_mul r x2 (ring_sub r (ring_mul r f' g) (ring_mul r f g')))
      `)) THEN
      have `ring_mul (x_series complex_ring) g U = e` [x_series_use] THEN
      have `ring_mul (x_series complex_ring) g V = f` [x_series_use] THEN
      have `ring_sub (x_series complex_ring) (ring_sub (x_series complex_ring) V (ring_mul (x_series complex_ring) (x_pow complex_ring 1) V)) (ring_mul (x_series complex_ring) (x_pow complex_ring 2) (x_derivative complex_ring V)) = U` [x_series_use;x_series_sub_use] THEN
      have `x_derivative complex_ring f = ring_add (x_series complex_ring) (ring_mul (x_series complex_ring) (x_derivative complex_ring g) V) (ring_mul (x_series complex_ring) g (x_derivative complex_ring V))` [x_series_use] THEN
      qed[]
    ; pass
    ] THEN
    simp[x_series_use;x_series_sub_use]
  ; pass
  ] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring e g) /\ ~(poly_mul complex_ring e g = poly_0 complex_ring) /\ poly_ord (poly_mul complex_ring e g) yinv = poly_ord e yinv + poly_ord g yinv` [poly_ord_mul] THEN
  have `poly_ord (poly_mul complex_ring e g) yinv + 1 = 2 * poly_ord g yinv` [ARITH_RULE `E+1 = G ==> M = E+G ==> M+1 = 2*G`] THEN
  case `f = poly_0 complex_ring \/ poly_ord g yinv <= poly_ord f yinv` THENL [
    have `ring_polynomial complex_ring (poly_mul complex_ring f g) /\ (poly_mul complex_ring f g = poly_0 complex_ring \/ 2 * poly_ord g yinv <= poly_ord (poly_mul complex_ring f g) yinv)` [poly_ord_mul_ge_ge;LE_REFL;ARITH_RULE `a + a = 2*a`] THEN
    specialize_assuming[
      `poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)`;
      `poly_mul complex_ring f g:(1->num)->complex`;
      `yinv:complex`;
      `2 * poly_ord g yinv`
    ]poly_ord_mul_ge0_ge THEN
    have `ring_polynomial complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1))` [RING_POLYNOMIAL_SUB;x_pow_poly;RING_POLYNOMIAL_1] THEN
    have `poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g) = poly_0 complex_ring \/ 2 * poly_ord g yinv <= poly_ord (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)) yinv` [] THEN
    have `poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)) = poly_0 complex_ring \/ 2 * poly_ord g yinv <= poly_ord (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) yinv` [poly_ord_derivative_ge] THEN
    have `ring_polynomial complex_ring (x_pow complex_ring 2)` [x_pow_poly] THEN
    have `ring_polynomial complex_ring (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))` [RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_MUL;x_derivative_polynomial] THEN
    specialize[
      `x_pow complex_ring 2`;
      `poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))`;
      `yinv:complex`;
      `2 * poly_ord g yinv`
    ]poly_ord_mul_ge0_ge THEN
    subgoal `2 * poly_ord g yinv <= poly_ord (poly_mul complex_ring e g) yinv` THENL [
      have `ring_polynomial complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g))` [] THEN
      have `poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)) = poly_0 complex_ring \/ 2 * poly_ord g yinv <= poly_ord (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) yinv` [] THEN
      have `poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g) = poly_0 complex_ring \/ 2 * poly_ord g yinv <= poly_ord (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)) yinv` [] THEN
      specialize_assuming[
        `poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)`;
        `poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))`;
        `yinv:complex`;
        `2 * poly_ord g yinv`
      ]poly_ord_sub_ge THEN
      qed[]
    ; pass
    ] THEN
    num_linear_fact `2 * poly_ord g yinv <= poly_ord (poly_mul complex_ring e g) yinv ==> poly_ord (poly_mul complex_ring e g) yinv + 1 = 2 * poly_ord g yinv ==> poly_ord e yinv + 1 = poly_ord g yinv ==> F` THEN
    qed[]
  ; pass
  ] THEN
  have `poly_ord f yinv < poly_ord g yinv` [ARITH_RULE `~(a <= b) ==> b < a:num`] THEN
  have `ring_polynomial complex_ring (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) /\ ~(poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)) = poly_0 complex_ring) /\ poly_ord (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) yinv = (poly_ord f yinv + poly_ord g yinv) - 1` [poly_ord_derivative_pole] THEN
  have `ring_polynomial complex_ring (poly_mul complex_ring f g) /\ ~(poly_mul complex_ring f g = poly_0 complex_ring) /\ poly_ord (poly_mul complex_ring f g) yinv = poly_ord f yinv + poly_ord g yinv` [poly_ord_mul] THEN
  subgoal `ring_polynomial complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)) /\ (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g) = poly_0 complex_ring \/ poly_ord f yinv + poly_ord g yinv <= poly_ord (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)) yinv)` THENL [
    specialize_assuming[
      `poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)`;
      `poly_mul complex_ring f g:(1->num)->complex`;
      `yinv:complex`;
      `poly_ord f yinv + poly_ord g yinv`
    ]poly_ord_mul_ge0_ge THEN
    have `ring_polynomial complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1))` [RING_POLYNOMIAL_SUB;x_pow_poly;RING_POLYNOMIAL_1] THEN
    qed[LE_REFL]
  ; pass
  ] THEN
  subgoal `ring_polynomial complex_ring (x_pow complex_ring 2) /\ ~(x_pow complex_ring 2 = poly_0 complex_ring) /\ poly_ord (x_pow complex_ring 2) yinv = 0` THENL [
    complex_field_fact `y * yinv = Cx (&1) ==> ~(yinv = Cx(&0))` THEN
    qed[poly_ord_x_pow]
  ; pass
  ] THEN
  subgoal `ring_polynomial complex_ring ( poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) /\ ~(poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) = poly_0 complex_ring) /\ poly_ord (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) yinv = (poly_ord f yinv + poly_ord g yinv) - 1` THENL [
    specialize_assuming[
      `x_pow complex_ring 2`;
      `poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))`;
      `yinv:complex`
    ]poly_ord_mul THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) /\ ~(poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) = poly_0 complex_ring) /\ poly_ord (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) yinv = 0 + poly_ord (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) yinv` [] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) /\ ~(poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))) = poly_0 complex_ring) /\ poly_ord (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) yinv = 0 + (poly_ord f yinv + poly_ord g yinv) - 1` [] THEN
    qed[ARITH_RULE `0+d = d`]
  ; pass
  ] THEN
  subgoal `poly_ord (poly_mul complex_ring e g) yinv = (poly_ord f yinv + poly_ord g yinv) - 1` THENL [
    num_linear_fact `poly_ord e yinv + 1 = poly_ord g yinv ==> (poly_ord f yinv + poly_ord g yinv) - 1 < poly_ord f yinv + poly_ord g yinv` THEN
    specialize_assuming[
      `poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)`;
      `poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))`;
      `yinv:complex`;
      `poly_ord f yinv + poly_ord g yinv`
    ]poly_ord_sub_dominant THEN
    have `poly_ord (poly_sub complex_ring (poly_mul complex_ring (poly_sub complex_ring (poly_1 complex_ring) (x_pow complex_ring 1)) (poly_mul complex_ring f g)) (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g))))) yinv = poly_ord (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) yinv` [] THEN
    have `poly_ord (poly_mul complex_ring e g) yinv = poly_ord (poly_mul complex_ring (x_pow complex_ring 2) (poly_sub complex_ring (poly_mul complex_ring (x_derivative complex_ring f) g) (poly_mul complex_ring f (x_derivative complex_ring g)))) yinv` [] THEN
    qed[]
  ; pass
  ] THEN
  have `poly_ord e yinv + poly_ord g yinv = (poly_ord f yinv + poly_ord g yinv) - 1` [] THEN
  num_linear_fact `poly_ord e yinv + 1 = poly_ord g yinv ==> poly_ord e yinv + poly_ord g yinv = (poly_ord f yinv + poly_ord g yinv) - 1 ==> ~(poly_ord f yinv < poly_ord g yinv)` THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `y` and `yinv`, and for all polynomials `e`, `f`, and `g` in complex_ring, if `y * yinv = 1`, `g` is not the zero polynomial, `e` is not the zero polynomial, `poly_ord e yinv + 1 = poly_ord g yinv`, `poly_mul g U = e`, `poly_mul g V = f`, and `poly_sub (poly_sub V (poly_mul (x_pow 1) V)) (poly_mul (x_pow 2) (x_derivative V)) = U`, then False.

### Informal sketch
The theorem states that under certain conditions on complex polynomials `e`, `f`, and `g`, a contradiction `F` arises. The proof proceeds by contradiction, assuming all the hypotheses are true and deriving a contradiction.

- The proof begins by recalling the `series_complex` definition.
- It uses the `x_derivative_mul` theorem: `x_derivative f = poly_add ((x_derivative g) * V) (g * (x_derivative V))`, given that `f = g * V`.
- The main subgoal involves showing an equality of polynomials, which is then lifted to an equality of power series using `RING_RULE`. This involves showing that `U`, `V`, `x_derivative V`, `e`, `f`, `x_derivative f`, `g`, `x_derivative g`, `x_pow 1`, and `x_pow 2` are all elements of the carrier of the `x_series complex_ring` ring.
- After proving the main subgoal, the proof proceeds by simplifying using the definition of `x_series`.
- It uses the fact that if `e` and `g` are polynomials, then the polynomial order of `e*g` is the sum of the polynomial orders of `e` and `g` (using `poly_ord_mul`), and the fact that `poly_ord e yinv + 1 = poly_ord g yinv` to derive `poly_ord (e*g) yinv + 1 = 2 * poly_ord g yinv` via `ARITH_RULE`.
- The proof then splits into two cases based on whether `f=0` or `poly_ord g yinv <= poly_ord f yinv`.
  - In the first case (`f = 0 \/ poly_ord g yinv <= poly_ord f yinv`), the proof uses theorems related to the polynomial order of products and differences to show that `2 * poly_ord g yinv <= poly_ord (e*g) yinv` and eventually derives the contradiction `F` via `num_linear_fact`.
  - In the second case (`~(f = 0 \/ poly_ord g yinv <= poly_ord f yinv)`, simplified to `poly_ord f yinv < poly_ord g yinv`), the proof again manipulates inequalities involving polynomial orders and uses the assumption `poly_ord e yinv + 1 = poly_ord g yinv` to derives a contradiction `~(poly_ord f yinv < poly_ord g yinv)` via `num_linear_fact` and conclude the final goal.

### Mathematical insight
The theorem essentially states that if rational functions `U = e/g` and `V = f/g` satisfy the specified differential equation `U = V - xV - x^2 V'`, then `U` cannot have a pole of order 1 at any nonzero point. This arises because if `U` had a pole of order `1`, then relations between `U` and `V` (and its derivatives) would produce contradictions in pole orders.

### Dependencies
- Basic definitions from `series_complex`
- Theorems related to polynomial rings, polynomial multiplication (`poly_ord_mul`), derivatives (`x_derivative_mul`, `poly_ord_derivative_ge`, `poly_ord_derivative_pole`), `x_pow_poly`, polynomial order (`poly_ord_x_pow`, `poly_ord_sub_dominant`, `poly_ord_mul_ge0_ge`, `poly_ord_sub_ge`,`poly_ord_mul`), ring polynomials (`RING_POLYNOMIAL_SUB`, `RING_POLYNOMIAL_MUL`, `RING_POLYNOMIAL_1`),the `ARITH_RULE` tactic and `NUM_LINEAR_FACT`

### Porting notes (optional)
- The proof involves a significant amount of rewriting and arithmetic reasoning about polynomial orders. A proof assistant with good automation for polynomial algebra and arithmetic would be beneficial.
- The RING_RULE tactic may need to be replaced by more manual reasoning about ring operations, depending on the target proof assistant's capabilities.


---

## transcendence_mostly_0

### Name of formal statement
transcendence_mostly_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_mostly_0 = prove(`
  !P B q y.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  q IN P ==>
  ~(B q = &0) ==>
  complex_root q y ==>
  y = Cx(&0)
`,
  intro THEN
  def `t:num` `nsum P (\p. poly_deg complex_ring (p:(1->num)->complex))` THEN
  def `H:(1->num)->complex` `x_truncreverse QinC_ring t (poly_product QinC_ring P I):(1->num)->complex` THEN
  def `u:num->complex` `\n. ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n)` THEN
  have `!n. u n = (ring_sum complex_ring P (\p. (complex_of_int(B p)) * complex_root_powersums p n))` [] THEN
  def `v:num->complex` `\n. ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)` THEN
  have `!n. v n = ring_sum complex_ring (0..n) (\i. Cx(&(FACT(n-i) * binom(n,i))) * u i)` [] THEN
  case `~(y = Cx(&0))` THENL [
    def `yinv:complex` `inv y:complex` THEN
    have `y * yinv = Cx(&1)` [COMPLEX_MUL_RINV] THEN
    def `U:(1->num)->complex` `series_from_coeffs u:(1->num)->complex` THEN
    def `V:(1->num)->complex` `series_from_coeffs v:(1->num)->complex` THEN
    have `poly_sub complex_ring (poly_sub complex_ring (V) (poly_mul complex_ring (x_pow complex_ring 1) (V))) (poly_mul complex_ring (x_pow complex_ring 2) (x_derivative complex_ring (V))) = U` [transcendence_uv_diffeq] THEN
    specialize[
      `P:((1->num)->complex)->bool`;
      `B:((1->num)->complex)->int`;
      `t:num`;
      `H:(1->num)->complex`;
      `u:num->complex`;
      `v:num->complex`
    ]transcendence_Hv_poly THEN
    choose `k:num` `1 <= k /\ ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H k:(1->num)->complex) V)` [] THEN
    have `1 <= k` [] THEN
    specialize[
      `P:((1->num)->complex)->bool`;
      `B:((1->num)->complex)->int`;
      `t:num`;
      `H:(1->num)->complex`;
      `u:num->complex`;
      `k:num`
    ]transcendence_ord_Hku THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) /\ ~(poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u) = poly_0 complex_ring) /\ poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) (series_from_coeffs u)) yinv = k - 1` [] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) U:(1->num)->complex)` [] THEN
    have `ring_polynomial complex_ring (poly_mul complex_ring (poly_pow complex_ring H k) V:(1->num)->complex)` [] THEN
    have `ring_polynomial complex_ring (poly_pow complex_ring H k:(1->num)->complex)` [poly_pow_poly;transcendence_H_poly] THEN
    have `coeff 0 (H:(1->num)->complex) = Cx(&1)` [transcendence_H_botcoeff1] THEN
    have `~(H = poly_0 complex_ring:(1->num)->complex)` [coeff_poly_0;complex_ring_clauses;ring_1_0_complex] THEN
    have `~(poly_pow complex_ring H k = poly_0 complex_ring:(1->num)->complex)` [nonzero_poly_pow;integral_domain_complex;series_complex] THEN
    have `~(poly_mul complex_ring (poly_pow complex_ring H k) U = poly_0 complex_ring:(1->num)->complex)` [] THEN
    have `poly_ord (poly_pow complex_ring H k) yinv = k` [transcendence_ord_Hk] THEN
    have `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) U) yinv = k-1` [] THEN
    num_linear_fact `1 <= k ==> (k-1)+1 = k` THEN
    have `poly_ord (poly_mul complex_ring (poly_pow complex_ring H k) U) yinv + 1 = poly_ord (poly_pow complex_ring H k) yinv` [] THEN
    specialize[
      `U:(1->num)->complex`;
      `V:(1->num)->complex`;
      `poly_mul complex_ring (poly_pow complex_ring H k) U:(1->num)->complex`;
      `poly_mul complex_ring (poly_pow complex_ring H k) V:(1->num)->complex`;
      `poly_pow complex_ring H k:(1->num)->complex`;
      `y:complex`;
      `yinv:complex`
    ]transcendence_pole_order_ne1 THEN
    qed[]
  ;
    qed[]
  ]
);;
```

### Informal statement
For all sets `P` of complex polynomials, integers `B` indexed by `P`, complex polynomial `q`, and complex number `y`, if `P` is finite, all polynomials in `P` have distinct minimal polynomials, the sum over `P` of `B p` times the sum of exponentials of roots of `p` is 0, `q` is in `P`, `B q` is not 0, `y` is a root of `q`, then `y` must be 0.

### Informal sketch
The theorem states that under certain conditions, if `y` is a root of a polynomial `q` in the set `P` and `B q` is not zero, then `y` must be zero. The proof proceeds by contradiction, assuming `y` is not zero and then deriving a contradiction.

- Assume `y` is not zero, define `yinv` as the inverse of `y`.
- Define `U` and `V` as series derived from the `u` and `v` functions defined using power sums of polynomial roots.
- Use `transcendence_uv_diffeq` to relate `U` and `V` through a differential equation.
- Employ `transcendence_Hv_poly` and choose `k` such that `1 <= k` and `poly_mul (poly_pow H k) V` is a polynomial. Here `H` is a truncated product of polynomials in `P`.
- Apply `transcendence_ord_Hku` to establish polynomial properties and order relationships.
- Show that `poly_ord (poly_mul (poly_pow H k) U) yinv = k - 1` and `poly_ord (poly_pow H k) yinv = k`, using properties of `H`, `U`, and `k`.
- Use `transcendence_pole_order_ne1` to derive a contradiction, completing the proof.

### Mathematical insight
This theorem is a step towards proving the transcendence of `e`. The key idea is to relate exponential sums of algebraic numbers to polynomial equations. Constructing the auxiliary function `H` and series `U` and `V`, and then analyzing the order of poles at the inverse of `y` leads to a contradiction, proving that if conditions are met, the root must be zero.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ring_sum`
- `complex_ring`
- `complex_of_int`
- `cexp`
- `Cx`
- `complex_root`
- `nsum`
- `poly_deg`
- `QinC_ring`
- `x_truncreverse`
- `poly_product`
- `I`
- `complex_root_powersums`
- `FACT`
- `binom`
- `COMPLEX_MUL_RINV`
- `inv`
- `series_from_coeffs`
- `x_pow`
- `x_derivative`
- `transcendence_uv_diffeq`
- `transcendence_Hv_poly`
- `transcendence_ord_Hku`
- `poly_pow_poly`
- `transcendence_H_poly`
- `transcendence_H_botcoeff1`
- `coeff_poly_0`
- `complex_ring_clauses`
- `ring_1_0_complex`
- `nonzero_poly_pow`
- `integral_domain_complex`
- `series_complex`
- `transcendence_ord_Hk`
- `num_linear_fact`
- `transcendence_pole_order_ne1`


---

## transcendence_mostly_0_x

### Name of formal statement
transcendence_mostly_0_x

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_mostly_0_x = prove(`
  !P B q.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  q IN P ==>
  ~(B q = &0) ==>
  q = x_pow QinC_ring 1
`,
  intro THEN
  have `ring_polynomial QinC_ring (q:(1->num)->complex)` [distinct_minpolys] THEN
  have `ring_polynomial complex_ring (q:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(poly_deg complex_ring (q:(1->num)->complex) = 0)` [distinct_minpolys_deg_nonzero] THEN
  num_linear_fact `~(poly_deg complex_ring (q:(1->num)->complex) = 0) ==> 1 <= poly_deg complex_ring q` THEN
  choose `z:complex` `poly_eval complex_ring q z = Cx(&0)` [nonconstant_complex_root] THEN
  have `complex_root q z` [complex_root] THEN
  have `z = Cx(&0)` [transcendence_mostly_0] THEN
  qed[distinct_minpolys_zero_root]
);;
```

### Informal statement
For all sets `P` of minimal polynomials, all integers `B` indexed by minimal polynomials from `P`, and all minimal polynomials `q`, if `P` is finite and `P` contains distinct minimal polynomials, and the ring sum (in the complex numbers) over `P` of complex numbers obtained by multiplying `B(p)` with the ring sum (in the complex numbers) over the complex roots of `p` of the exponential function `cexp` is equal to the complex number `0`, and `q` is in `P`, and `B(q)` is not equal to `0`, then `q` is equal to the minimal polynomial of `1`, where `Q` is the ring of complex numbers.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `P` is finite, `P` contains distinct minimal polynomials, a particular ring sum involving `cexp` vanishes, `q` is in `P`, and `B(q)` is not zero.
- Show that `q` is a ring polynomial over the ring `QinC_ring` using `distinct_minpolys`.
- Show that `q` is a ring polynomial over the complex ring `complex_ring` using `poly_complex_if_poly_QinC`.
- Show that `q` has non-zero degree using `distinct_minpolys_deg_nonzero`.
- Show that `1 <= poly_deg complex_ring q` using `num_linear_fact`.
- Choose a complex number `z` such that `poly_eval complex_ring q z = Cx(&0)` using `nonconstant_complex_root`.
- Show `z` is in `complex_root q` using `complex_root`.
- Infer that `z = Cx(&0)` by `transcendence_mostly_0`.
- Conclude that `q` is the minimal polynomial of `1` by `distinct_minpolys_zero_root`.

### Mathematical insight
This theorem is related to transcendence theory, showing that under certain conditions, if a sum involving exponentials of algebraic numbers is zero, then a specific relationship must hold between the minimal polynomials of the algebraic numbers. The core idea is that if a specific sum involving the exponential function vanishes, where the sum quantifies over a set of minimal polynomials, and one of the coefficients in the sum is non-zero, then a particular minimal polynomial in the set must be the minimal polynomial of `1`.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ring_sum`
- `complex_ring`
- `complex_of_int`
- `Cx`
- `complex_root`
- `IN`
- `~`
- `x_pow`
- `QinC_ring`
- `intro`
- `ring_polynomial`
- `poly_complex_if_poly_QinC`
- `distinct_minpolys_deg_nonzero`
- `num_linear_fact`
- `choose`
- `poly_eval`
- `nonconstant_complex_root`
- `transcendence_mostly_0`
- `qed`
- `distinct_minpolys_zero_root`


---

## transcendence_all_0

### Name of formal statement
transcendence_all_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_all_0 = prove(`
  !P B.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. complex_of_int(B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!q. q IN P ==> B q = &0)
`,
  intro THEN
  case `q = x_pow QinC_ring 1` THENL [
    subgoal `ring_sum complex_ring P (\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring P (\p. if p = x_pow QinC_ring 1 then complex_of_int (B(x_pow QinC_ring 1)) * ring_sum complex_ring (complex_root(x_pow QinC_ring 1)) cexp else ring_0 complex_ring)` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      rw[BETA_THM] THEN
      proven_if `a = x_pow QinC_ring 1` [] THEN
      have `B(a:(1->num)->complex) = &0:int` [transcendence_mostly_0_x] THEN
      simp[complex_of_int;GSYM REAL_OF_INT_CLAUSES] THEN
      qed[COMPLEX_MUL_LZERO;complex_ring_clauses]
    ; pass
    ] THEN
    have `ring_sum complex_ring P (\p. if p = x_pow QinC_ring 1 then complex_of_int (B(x_pow QinC_ring 1)) * ring_sum complex_ring (complex_root(x_pow QinC_ring 1)) cexp else ring_0 complex_ring) = Cx(&0)` [] THEN
    specialize[
      `complex_ring`;
      `P:((1->num)->complex)->bool`;
      `x_pow QinC_ring 1`;
      `complex_of_int (B (x_pow QinC_ring 1)) * ring_sum complex_ring (complex_root (x_pow QinC_ring 1)) cexp`
    ]RING_SUM_DELTA THEN
    have `complex_of_int (B (x_pow QinC_ring 1)) * ring_sum complex_ring (complex_root (x_pow QinC_ring 1)) cexp = Cx(&0)` [in_complex_ring] THEN
    subgoal `ring_sum complex_ring (complex_root (x_pow QinC_ring 1)) cexp = Cx(&1)` THENL [
      rw[complex_root_x_pow;ARITH_RULE `~(1 = 0)`;RING_SUM_SING;in_complex_ring;CEXP_0]
    ; pass
    ] THEN
    have `complex_of_int (B (x_pow QinC_ring 1)) * Cx(&1) = Cx(&0)` [] THEN
    have `complex_of_int (B (x_pow QinC_ring 1)) = Cx(&0)` [COMPLEX_MUL_RID] THEN
    have `real_of_int (B (x_pow QinC_ring 1)) = &0` [complex_of_int;CX_INJ] THEN
    qed[REAL_OF_INT_CLAUSES]
  ; pass
  ] THEN
  qed[transcendence_mostly_0_x]
);;
```
### Informal statement
For any set `P` of functions from `(1->num)` to complex numbers, and any function `B` from `P` to the integers, if `P` is finite, `P` has distinct minimal polynomials and the ring sum over `P` of terms `complex_of_int(B p) * ring_sum (complex_root p) cexp` is equal to `Cx(&0)`, then for all `q` in `P`, `B(q)` equals `&0`.

### Informal sketch
The proof proceeds by induction on the case `q = x_pow QinC_ring 1`.
- Assume that `q = x_pow QinC_ring 1`. Then show that `ring_sum complex_ring P (\p. complex_of_int (B p) * ring_sum complex_ring (complex_root p) cexp)` is the same as `ring_sum complex_ring P (\p. if p = x_pow QinC_ring 1 then complex_of_int (B(x_pow QinC_ring 1)) * ring_sum complex_ring (complex_root(x_pow QinC_ring 1)) cexp else ring_0 complex_ring)`. This is proven by proving `B(a:(1->num)->complex) = &0:int` via applying `transcendence_mostly_0_x`.
- Using the reduction of the `ring_sum` and `Cx(&0)` allows to show that `complex_of_int (B (x_pow QinC_ring 1)) * ring_sum complex_ring (complex_root (x_pow QinC_ring 1)) cexp = Cx(&0)`. We know that `ring_sum complex_ring (complex_root (x_pow QinC_ring 1)) cexp = Cx(&1)`, so `complex_of_int (B (x_pow QinC_ring 1)) * Cx(&1) = Cx(&0)`.
- Finally, we show that `complex_of_int (B (x_pow QinC_ring 1)) = Cx(&0)` which implies `real_of_int (B (x_pow QinC_ring 1)) = &0` and therefore `B (x_pow QinC_ring 1)` equals `&0`.
- The case where `q != x_pow QinC_ring 1` is handled by `pass`.

### Mathematical insight
This theorem establishes a condition under which the coefficients `B(q)` associated with polynomials `q` in a finite set `P` must be zero, given a specific relationship involving the roots of these polynomials and the complex exponential function. It's a step towards transcendence results by linking algebraic and transcendental quantities.

### Dependencies
- `transcendence_mostly_0_x`
- `complex_root_x_pow`
- `REAL_OF_INT_CLAUSES`
- `COMPLEX_MUL_LZERO`
- `complex_ring_clauses`
- `COMPLEX_MUL_RID`
- `CX_INJ`
- `CEXP_0`

### Porting notes (optional)
The proof relies heavily on algebraic simplification with rewriting. Ensure the target proof assistant has comparable algebraic reasoning capabilities.
The use of `complex_of_int`, `real_of_int` and `Cx` might be tricky to translate depending on the target system's representation of complex numbers and its interaction with the integers and reals.


---

## transcendence_all_0_ZinC

### Name of formal statement
transcendence_all_0_ZinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_all_0_ZinC = prove(`
  !P B.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p. p IN P ==> B p IN ZinC) ==>
  ring_sum complex_ring P (\p. (B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p. p IN P ==> B p = Cx(&0))
`,
  intro THEN
  def `intB:((1->num)->complex)->int` `\p:(1->num)->complex. @i. B p = complex_of_int i` THEN
  subgoal `!q:(1->num)->complex. q IN P ==> B q = complex_of_int(intB q)` THENL [
    intro THEN
    simp[] THEN
    have `B(q:(1->num)->complex) IN ZinC` [] THEN
    qed[ZinC;IN_ELIM_THM]
  ; pass
  ] THEN
  subgoal `ring_sum complex_ring P (\p. complex_of_int (intB p) * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp)` THENL [
    sufficesby RING_SUM_EQ THEN
    qed[]
  ; pass
  ] THEN
  have `ring_sum complex_ring P (\p. complex_of_int (intB p) * ring_sum complex_ring (complex_root p) cexp) = Cx (&0)` [] THEN
  specialize_assuming[
    `P:((1->num)->complex)->bool`;
    `intB:((1->num)->complex)->int`
  ]transcendence_all_0 THEN
  have `intB(p:(1->num)->complex) = &0:int` [] THEN
  have `B(p:(1->num)->complex) = complex_of_int(&0)` [] THEN
  qed[complex_of_int;REAL_OF_INT_CLAUSES]
);;
```
### Informal statement
For all `P` and `B`, if `P` is a finite set of polynomials, `P` contains only distinct minimal polynomials, for all `p` in `P`, `B(p)` is in `ZinC` (where `ZinC` is the set of Gaussian integers), and the ring sum over `P` with respect to the complex ring of `B(p)` times the ring sum over the complex roots of `p` of `cexp` (the complex exponential) equals the complex number `0`, then for all `p` in `P`, `B(p)` equals the complex number `0`.

### Informal sketch
The goal is to prove that given a finite set `P` of distinct minimal polynomials such that for any `p` in `P`, `B(p)` is a Gaussian integer, and assuming that `ring_sum complex_ring P (\p. (B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0)`, then it must be the case that for any `p` in `P`, `B p` equals `Cx(&0)`.

- Introduce assumptions and define a function `intB` that maps polynomials `p` to an integer `i` such that `B p` equals the complex number constructed from `i`.
- Show `B(q)` is a Gaussian integer implies that `B q = complex_of_int(intB q)`.
- Show that `ring_sum complex_ring P (\p. complex_of_int (intB p) * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp)` using `RING_SUM_EQ`.
- Apply the theorem `transcendence_all_0` using `specialize_assuming`.
- Show `B(p) = complex_of_int(&0)` using `complex_of_int;REAL_OF_INT_CLAUSES`.

### Mathematical insight
This theorem is a step in the proof that `pi` is transcendental. It leverages the properties of minimal polynomials, finiteness, and Gaussian integers. Essentially, if a certain sum involving complex exponentials of roots of minimal polynomials and Gaussian integer coefficients is zero, then all the Gaussian integer coefficients must be zero. This is crucial for showing that `pi` cannot be the root of any non-zero polynomial with integer coefficients, and thus is transcendental.

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ZinC`
- `complex_ring`
- `complex_root`
- `cexp`
- `Cx`
- `ring_sum`
- `complex_of_int`
- `transcendence_all_0`
- `REAL_OF_INT_CLAUSES`
- `IN_ELIM_THM`
- `RING_SUM_EQ`


---

## transcendence_all_0_QinC

### Name of formal statement
transcendence_all_0_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_all_0_QinC = prove(`
  !P B.
  FINITE P ==>
  distinct_minpolys P ==>
  (!p. p IN P ==> B p IN QinC) ==>
  ring_sum complex_ring P (\p. (B p) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  (!p. p IN P ==> B p = Cx(&0))
`,
  intro THEN
  choose `d:num` `(~(d = 0) /\ !p:(1->num)->complex. p IN P ==> Cx(&d) * B p IN ZinC)` [multi_QinC_to_ZinC] THEN
  def `C:((1->num)->complex)->complex` `\p:(1->num)->complex. Cx(&d) * B p` THEN
  have `!p:(1->num)->complex. p IN P ==> C p IN ZinC` [] THEN
  subgoal `ring_sum complex_ring P (\p. C p * ring_sum complex_ring (complex_root p) cexp) = Cx(&0)` THENL [
    simp[GSYM COMPLEX_MUL_ASSOC] THEN
    simp[GSYM vsum_ring_sum_complex] THEN
    simp[VSUM_COMPLEX_LMUL] THEN
    simp[vsum_ring_sum_complex] THEN
    simp[COMPLEX_MUL_RZERO]
  ; pass
  ] THEN
  have `C(p:(1->num)->complex) = Cx(&0)` [transcendence_all_0_ZinC] THEN
  have `Cx(&d) * B(p:(1->num)->complex) = Cx(&0)` [] THEN
  have `~(&d = &0:real)` [REAL_OF_NUM_EQ] THEN
  have `~(Cx(&d) = Cx(&0))` [CX_INJ] THEN
  complex_field_fact `~(Cx(&d) = Cx(&0)) ==> Cx(&d) * B(p:(1->num)->complex) = Cx(&0) ==> B p = Cx(&0)` THEN
  qed[]
);;
```
### Informal statement
For all sets `P` (of polynomials), and all functions `B` (from polynomials to complex numbers), if `P` is finite, `P` has distinct minimal polynomials, for every polynomial `p` in `P`, `B(p)` is in `QinC` (algebraic integers divided by an integer), and the ring sum over `P` of the terms `B(p)` times the ring sum over the complex roots of `p` of the exponential function `cexp` is equal to the complex number `0`, then for every `p` in `P`, `B(p)` is equal to the complex number `0`.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent of the theorem, namely that `P` is finite, `P` has distinct minimal polynomials, for every polynomial `p` in `P`, `B(p)` is in `QinC`, and the ring sum over `P` of the terms `B(p)` times the ring sum over the complex roots of `p` of the exponential function `cexp` is equal to the complex number `0`.
- Choose a natural number `d` such that `d` is not zero and for all polynomials `p` in `P`, `Cx(&d) * B p IN ZinC`. This is justified by the fact that each `B p` is in `QinC`, and `QinC` consists of complex numbers of the form `z/d` where `z` is an algebraic integer.
- Define a function `C` such that `C p = Cx(&d) * B p`.
- Show that for all `p` in `P`, `C p IN ZinC`.
- Show that the ring sum over `P` of the terms `C(p)` times the ring sum over the complex roots of `p` of the exponential function `cexp` is equal to the complex number `0` by using `GSYM COMPLEX_MUL_ASSOC`, `GSYM vsum_ring_sum_complex`, `VSUM_COMPLEX_LMUL`,`vsum_ring_sum_complex` and `COMPLEX_MUL_RZERO` simplifications.
- Apply the theorem `transcendence_all_0_ZinC` to get that `C(p:(1->num)->complex) = Cx(&0)`.
- Show that `Cx(&d) * B(p:(1->num)->complex) = Cx(&0)`.
- Show that `~(&d = &0:real)` using `REAL_OF_NUM_EQ`.
- Show that `~(Cx(&d) = Cx(&0))` using `CX_INJ`.
- Apply the field fact `~(Cx(&d) = Cx(&0)) ==> Cx(&d) * B(p:(1->num)->complex) = Cx(&0) ==> B p = Cx(&0)` to conclude that `B p = Cx(&0)`.

### Mathematical insight
The theorem states that if a finite sum of complex exponentials, scaled by elements of `QinC` (algebraic integers divided by an integer), equals zero, then each scaling factor must be zero. This is a step towards proving results in transcendence theory. The use of `QinC` allows scaling by possibly rational values, requiring some scaling before `transcendence_all_0_ZinC`.

### Dependencies
- `multi_QinC_to_ZinC`
- `transcendence_all_0_ZinC`
- `COMPLEX_MUL_ASSOC`
- `vsum_ring_sum_complex`
- `VSUM_COMPLEX_LMUL`
- `COMPLEX_MUL_RZERO`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `complex_field_fact`

### Porting notes (optional)
- The main difficulty lies in porting the lemmas about sums (`vsum_ring_sum_complex`, `VSUM_COMPLEX_LMUL`) and the transcendence theorems like `transcendence_all_0_ZinC`. The presence of the type `complex` means that one may need to set up complex numbers and their arithmetic before porting. Also, the `field_fact` tactic could be difficult to emulate so this might need to be done in multiple steps.


---

## transcendence_all_0_QinC_weight1

### Name of formal statement
transcendence_all_0_QinC_weight1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_all_0_QinC_weight1 = prove(`
  !P.
  FINITE P ==>
  distinct_minpolys P ==>
  ring_sum complex_ring P (\p. ring_sum complex_ring (complex_root p) cexp) = Cx(&0) ==>
  P = {}
`,
  intro THEN
  def `B:((1->num)->complex)->complex` `\p:(1->num)->complex. Cx(&1)` THEN
  have `!p:(1->num)->complex. p IN P ==> B p IN QinC` [QinC_1] THEN
  subgoal `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring P (\p. ring_sum complex_ring (complex_root p) cexp)` THENL [
    sufficesby RING_SUM_EQ THEN
    qed[COMPLEX_MUL_LID]
  ; pass
  ] THEN
  have `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx(&0)` [] THEN
  have `!p:(1->num)->complex. p IN P ==> B p = Cx(&0)` [transcendence_all_0_QinC] THEN
  complex_field_fact `~(Cx(&1) = Cx(&0))` THEN
  have `!p:(1->num)->complex. ~(p IN P)` [] THEN
  qed[EMPTY;EXTENSION;IN]
);;
```

### Informal statement
For any set `P` of functions from numbers to complex numbers, if `P` is finite, the minimal polynomials in `P` are distinct, and the ring sum over `P` of the ring sum over the complex roots of `p` of the exponential function `cexp` is equal to the complex number `0`, then `P` is the empty set.

### Informal sketch
The proof proceeds as follows:
- Assume the hypothesis: `P` is finite, the minimal polynomials in `P` are distinct, and the ring sum over `P` of the ring sum over the complex roots of `p` of the exponential function `cexp` is equal to the complex number `0`.
- Define `B` as a function from functions from numbers to complex numbers, to complex numbers, that always returns the complex number `1`: `B p = Cx(&1)`.
- Show that for every function `p` in `P`, `B p` is in `QinC` (numbers of the form `a+bi`, where `a` and `b` are rationals). This relies on `QinC_1` which states that `Cx(a)` is in `QinC` when `a` is a rational number.
- Show that `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring P (\p. ring_sum complex_ring (complex_root p) cexp)` using `RING_SUM_EQ` and `COMPLEX_MUL_LID` (complex multiplication identity).
- Combine the previous results to infer that `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx(&0)`.
- Apply the theorem `transcendence_all_0_QinC` to deduce that for any function `p` in `P`, `B p = Cx(&0)`.
- Since `Cx(&1)` is not equal to `Cx(&0)`, conclude that no `p` can be in `P`.
- Use `EMPTY`, `EXTENSION`, and `IN` to prove the final result that `P` is the empty set.

### Mathematical insight
This theorem is a step towards proving the algebraic independence of complex exponentials. Given the finiteness and distinctness conditions, if a certain sum involving exponentials of roots of minimal polynomials equals zero, then the set of minimal polynomials involved must be empty. The proof cleverly introduces a weighting function `B` to connect the hypothesis with a previously established result (`transcendence_all_0_QinC`).

### Dependencies
- `FINITE`
- `distinct_minpolys`
- `ring_sum`
- `complex_ring`
- `complex_root`
- `cexp`
- `Cx`
- `QinC`
- `QinC_1`
- `RING_SUM_EQ`
- `COMPLEX_MUL_LID`
- `transcendence_all_0_QinC`
- `EMPTY`
- `EXTENSION`
- `IN`


---

## transcendence_all_0_QinC_monic_vanishing_at

### Name of formal statement
transcendence_all_0_QinC_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_all_0_QinC_monic_vanishing_at = prove(`
  !S c.
  FINITE S ==>
  ring_polynomial QinC_ring (monic_vanishing_at complex_ring S c) ==>
  ring_sum complex_ring S (\s:X. cexp(c s)) = Cx(&0) ==>
  S = {}
`,
  intro THEN
  have `monic complex_ring (monic_vanishing_at complex_ring S (c:X->complex))` [monic_vanishing_at_monic;in_complex_ring] THEN
  have `monic QinC_ring (monic_vanishing_at complex_ring S (c:X->complex))` [monic_subring;subring_complex_QinC] THEN
  recall field_QinC THEN
  specialize[
    `monic_vanishing_at complex_ring S (c:X->complex)`
  ]monic_factorization_distinct_minpolys THEN
  choose2 `P:((1->num)->complex)->bool` `e:((1->num)->complex)->num` `FINITE P /\ distinct_minpolys P /\ (!p. p IN P ==> ~(e p = 0)) /\ poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p)) = monic_vanishing_at complex_ring S (c:X->complex)` [] THEN
  have `!p:(1->num)->complex. Cx(&(e p)) IN QinC` [num_in_QinC] THEN
  subgoal `ring_sum complex_ring P (\p. Cx(&(e p)) * ring_sum complex_ring (complex_root p) cexp) = Cx(&0)` THENL [
    have `!z. poly_ord (monic_vanishing_at complex_ring S c) z = CARD {s:X | s IN S /\ z = c s:complex}` [poly_ord_monic_vanishing_at] THEN
    have `!z. poly_ord (poly_product QinC_ring P (\p:(1->num)->complex. poly_pow QinC_ring p (e p))) z = nsum P (\p. if complex_root p z then e p else 0)` [ord_product_distinct_minpolys] THEN
    have `!z. CARD {s:X | s IN S /\ z = c s:complex} = nsum P (\p. if complex_root p z then e p else 0)` [] THEN
    set_fact `!z. {s:X | s IN S /\ c s = z:complex} = {s:X | s IN S /\ z = c s:complex}` THEN
    subgoal `!z. FINITE {s:X | s IN S /\ c s = z:complex}` THENL [
      intro THEN
      specialize[
        `S:X->bool`;
        `\s:X. c s = z:complex`
      ]FINITE_RESTRICT THEN
      qed[]
    ; pass
    ] THEN
    have `FINITE(IMAGE (c:X->complex) S)` [FINITE_IMAGE] THEN
    subgoal `ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. ring_sum complex_ring P (\p. Cx(&(if complex_root p z then e p else 0)) * cexp z)) = Cx(&0)` THENL [
      subgoal `ring_sum complex_ring (IMAGE c S) (\z. Cx(&(CARD {x:X | x IN S /\ c x = z})) * cexp z) = Cx(&0)` THENL [
        specialize[
          `complex_ring`;
          `c:X->complex`;
          `\s:X. cexp (c s)`;
          `S:X->bool`;
        ]RING_SUM_IMAGE_GEN THEN
        have `ring_sum complex_ring (IMAGE c S) (\y. ring_sum complex_ring {x | x IN S /\ c x = y} (\s:X. cexp (c s))) = Cx(&0)` [] THEN
        subgoal `ring_sum complex_ring (IMAGE c S) (\y. ring_sum complex_ring {x | x IN S /\ c x = y} (\s:X. cexp (c s))) = ring_sum complex_ring (IMAGE c S) (\y. ring_sum complex_ring {x | x IN S /\ c x = y} (\s:X. cexp y))` THENL [
          sufficesby RING_SUM_EQ THEN
          rw[BETA_THM] THEN
          intro THEN
          sufficesby RING_SUM_EQ THEN
          rw[IN_ELIM_THM] THEN
          qed[]
        ; pass
        ] THEN
        have `ring_sum complex_ring (IMAGE c S) (\y. ring_sum complex_ring {x | x IN S /\ c x = y} (\s:X. cexp y)) = Cx(&0)` [] THEN
        subgoal `ring_sum complex_ring (IMAGE c S) (\z. Cx(&(CARD {x | x IN S /\ c x = z})) * cexp z) = ring_sum complex_ring (IMAGE c S) (\y. ring_sum complex_ring {x | x IN S /\ c x = y} (\s:X. cexp y))` THENL [
          sufficesby RING_SUM_EQ THEN
          rw[BETA_THM] THEN
          intro THEN
          have `FINITE {x:X | x IN S /\ c x = a:complex}` [] THEN
          have `cexp a IN ring_carrier complex_ring` [in_complex_ring] THEN
          specialize[
            `complex_ring`;
            `cexp a`;
            `{x:X | x IN S /\ c x = a:complex}`
          ]ring_sum_const THEN
          qed[ring_of_num_complex;complex_of_num;complex_ring_clauses]
        ; pass
        ] THEN
        simporqed
      ; pass
      ] THEN
      subgoal `ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. Cx(&(nsum P (\p. if complex_root p z then e p else 0))) * cexp z) = Cx(&0)` THENL [
        subgoal `ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. Cx(&(nsum P (\p. if complex_root p z then e p else 0))) * cexp z) = ring_sum complex_ring (IMAGE c S) (\z. Cx(&(CARD {x:X | x IN S /\ c x = z})) * cexp z)` THENL [
          sufficesby RING_SUM_EQ THEN
          simporqed
        ; pass
        ] THEN
        simporqed
      ; pass
      ] THEN
      subgoal `ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. Cx(&(nsum P (\p. if complex_root p z then e p else 0))) * cexp z) = ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. ring_sum complex_ring P (\p. Cx(&(if complex_root p z then e p else 0)) * cexp z))` THENL [
        sufficesby RING_SUM_EQ THEN
        rw[BETA_THM] THEN
        intro THEN
        simp[GSYM vsum_ring_sum_complex] THEN
        simp[VSUM_COMPLEX_RMUL] THEN
        simp[vsum_ring_sum_complex] THEN
        rw[GSYM complex_of_num] THEN
        rw[GSYM ring_of_num_complex] THEN
        simp[ring_sum_num]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. ring_sum complex_ring P (\p. Cx(&(if complex_root p z then e p else 0)) * cexp z)) = ring_sum complex_ring P (\p. ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. Cx(&(if complex_root p z then e p else 0)) * cexp z))` THENL [
      specialize_assuming[
        `complex_ring`;
        `\z p. Cx (&(if complex_root p z then e p else 0)) * cexp z`;
        `IMAGE (c:X->complex) S`;
        `P:((1->num)->complex)->bool`
      ]RING_SUM_SWAP THEN
      qed[in_complex_ring]
    ; pass
    ] THEN
    have `ring_sum complex_ring P (\p. ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. Cx(&(if complex_root p z then e p else 0)) * cexp z)) = Cx(&0)` [] THEN
    subgoal `ring_sum complex_ring P (\p. ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. Cx(&(if complex_root p z then e p else 0)) * cexp z)) = ring_sum complex_ring P (\p. ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. if z IN complex_root p then Cx(&(e p)) * cexp z else ring_0 complex_ring))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM;IN] THEN
      intro THEN
      rw[complex_ring_clauses] THEN
      qed[COMPLEX_MUL_LZERO]
    ; pass
    ] THEN
    have `ring_sum complex_ring P (\p. ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. if z IN complex_root p then Cx(&(e p)) * cexp z else ring_0 complex_ring)) = Cx(&0)` [] THEN
    subgoal `ring_sum complex_ring P (\p. ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. if z IN complex_root p then Cx(&(e p)) * cexp z else ring_0 complex_ring)) = ring_sum complex_ring P (\p. ring_sum complex_ring {z | z IN IMAGE (c:X->complex) S /\ z IN complex_root p} (\z. Cx(&(e p)) * cexp z))` THENL [
      sufficesby RING_SUM_EQ THEN
      simp[RING_SUM_RESTRICT_SET]
    ; pass
    ] THEN
    have `ring_sum complex_ring P (\p. ring_sum complex_ring {z | z IN IMAGE (c:X->complex) S /\ z IN complex_root p} (\z. Cx(&(e p)) * cexp z)) = Cx(&0)` [] THEN
    subgoal `!p. p IN P ==> {z | z IN IMAGE (c:X->complex) S /\ z IN complex_root p} = complex_root p` THENL [
      intro THEN
      rw[EXTENSION;IN_ELIM_THM;IN_IMAGE] THEN
      intro THEN
      splitiff THENL [
        qed[]
      ;
        intro THEN
        have `FINITE(P:((1->num)->complex)->bool)` [] THEN
        specialize[
          `\p. if complex_root p x then e p else 0`;
          `P:((1->num)->complex)->bool`;
          `p:(1->num)->complex`
        ]term_le_nsum THEN
        have `e(p:(1->num)->complex) <= nsum P (\p. if complex_root p x then e p else 0)` [IN] THEN
        have `~(nsum P (\p. if complex_root p x then e p else 0) = 0)` [ARITH_RULE `~(e = 0) ==> e <= n ==> ~(n = 0)`] THEN
        have `~(CARD {s:X | s IN S /\ x = c s:complex} = 0)` [] THEN
        specialize[
          `S:X->bool`;
          `\s:X. x = c s:complex`
        ]FINITE_RESTRICT THEN
        have `~({s:X | s IN S /\ x = c s:complex} = {})` [CARD_EQ_0] THEN
        ASM SET_TAC[]
      ]
    ; pass
    ] THEN
    subgoal `ring_sum complex_ring P (\p. ring_sum complex_ring {z | z IN IMAGE (c:X->complex) S /\ z IN complex_root p} (\z. Cx (&(e p)) * cexp z)) = ring_sum complex_ring P (\p. Cx(&(e p)) * ring_sum complex_ring (complex_root p) cexp)` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      simp[] THEN
      have `FINITE(complex_root a)` [distinct_minpolys_finite_root] THEN
      simp[GSYM vsum_ring_sum_complex] THEN
      simp[VSUM_COMPLEX_LMUL]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize_assuming[
    `P:((1->num)->complex)->bool`;
    `\p:(1->num)->complex. Cx(&(e p))`
  ]transcendence_all_0_QinC THEN
  have `!p:(1->num)->complex. p IN P ==> Cx (&(e p)) = Cx (&0)` [] THEN
  have `!p:(1->num)->complex. p IN P ==> &(e p) = &0:real` [CX_INJ] THEN
  have `!p:(1->num)->complex. p IN P ==> e p = 0` [REAL_OF_NUM_EQ] THEN
  subgoal `poly_product QinC_ring P (\p:(1->num)->complex. poly_pow QinC_ring p (e p)) = poly_1 QinC_ring` THENL [
    subgoal `poly_product QinC_ring P (\p:(1->num)->complex. poly_pow QinC_ring p (e p)) = poly_product QinC_ring P (\p. poly_1 QinC_ring)` THENL [
      sufficesby poly_product_eq THEN
      qed[poly_pow_0]
    ; pass
    ] THEN
    specialize[
      `QinC_ring`;
      `P:((1->num)->complex)->bool`
    ]poly_product_1 THEN
    qed[]
  ; pass
  ] THEN
  have `monic_vanishing_at complex_ring S (c:X->complex) = poly_1 QinC_ring` [] THEN
  have `poly_deg complex_ring (monic_vanishing_at complex_ring S (c:X->complex)) = CARD S` [deg_monic_vanishing_at;ring_1_0_complex;in_complex_ring] THEN
  have `poly_deg complex_ring (poly_1 QinC_ring:(1->num)->complex) = 0` [poly_1_QinC_eq_poly_1_complex;POLY_DEG_1] THEN
  have `CARD(S:X->bool) = 0` [] THEN
  qed[CARD_EQ_0]
);;
```

### Informal statement
For all sets `S` and functions `c` from a type `X` to the complex numbers, if `S` is finite and `monic_vanishing_at complex_ring S c` is a ring polynomial over the QinC ring, and the ring sum over `S` of `cexp(c s)` is equal to 0, then `S` is the empty set.

### Informal sketch
The proof proceeds by contradiction, assuming that S is not empty.

- First, it is shown that `monic_vanishing_at complex_ring S c` is monic by `monic_vanishing_at_monic` and `in_complex_ring`. Then it is shown to be monic over the `QinC_ring` using `monic_subring` and `subring_complex_QinC`.
- Using `monic_factorization_distinct_minpolys`, we factor `monic_vanishing_at complex_ring S c` into a product of minimal polynomials (`poly_product QinC_ring P (\p. poly_pow QinC_ring p (e p))`). `P` is a finite set of polynomials, each with distinct minimal polynomials, and each `e p` is a non-zero natural number, which is the exponent to which `p` is raised in the factorization.
- It is shown that `Cx(&(e p))` is in `QinC` by `num_in_QinC`.
- We then aim to show that the ring sum over `P` of `Cx(&(e p)) * ring_sum complex_ring (complex_root p) cexp` is equal to `Cx(&0)`.
- A series of simplifications involving `poly_ord`, `ord_product_distinct_minpolys`, and manipulations involving the definition of `FINITE_RESTRICT` leads to simplifying terms.
- `FINITE_IMAGE` is used to show finiteness of image.
- This gives the goal of showing `ring_sum complex_ring (IMAGE (c:X->complex) S) (\z. ring_sum complex_ring P (\p. Cx(&(if complex_root p z then e p else 0)) * cexp z)) = Cx(&0)`.
- Several manipulations using `RING_SUM_IMAGE_GEN` and other ring sum theorems are used.
- `transcendence_all_0_QinC` is specialized to `P` and `\p:(1->num)->complex. Cx(&(e p))`.
- `CX_INJ` and `REAL_OF_NUM_EQ` are used to turn complex equality into real equality and real equality into numeric equality.
- Finally, the theorem `CARD_EQ_0` results in proving that S is the empty set.

### Mathematical insight
This theorem is a step towards proving the transcendence of `e`. It states that if a finite set `S` has the property that the sum of `exp(c*s)` over `s` in `S` is zero, where `c` is a constant and the minimal polynomial of the set vanishes over the QinC ring, then the set `S` must be empty. This result is used in the broader context of proving algebraic independence results.

### Dependencies
- `FINITE`
- `ring_polynomial`
- `QinC_ring`
- `monic_vanishing_at`
- `complex_ring`
- `ring_sum`
- `cexp`
- `Cx`
- `monic_vanishing_at_monic`
- `in_complex_ring`
- `monic_subring`
- `subring_complex_QinC`
- `field_QinC`
- `monic_factorization_distinct_minpolys`
- `num_in_QinC`
- `poly_ord_monic_vanishing_at`
- `ord_product_distinct_minpolys`
- `FINITE_RESTRICT`
- `FINITE_IMAGE`
- `RING_SUM_IMAGE_GEN`
- `RING_SUM_EQ`
- `BETA_THM`
- `IN_ELIM_THM`
- `ring_of_num_complex`
- `complex_of_num`
- `complex_ring_clauses`
- `IN`
- `ARITH_RULE`
- `CARD_EQ_0`
- `transcendence_all_0_QinC`
- `CX_INJ`
- `REAL_OF_NUM_EQ`
- `poly_product_eq`
- `poly_pow_0`
- `poly_product_1`
- `deg_monic_vanishing_at`
- `ring_1_0_complex`
- `poly_1_QinC_eq_poly_1_complex`
- `POLY_DEG_1`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification within the complex ring structure. A proof assistant with good support for algebraic simplification will be beneficial.
- The tactic `choose2` introduces existential variables, which may need to be handled explicitly in other systems.
- The result `transcendence_all_0_QinC` is assumed as an axiom in the proof, meaning care must be taken so that the axiom or its translation is correct.


---

## transcendence_weighted_QinC_monic_vanishing_at

### Name of formal statement
transcendence_weighted_QinC_monic_vanishing_at

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendence_weighted_QinC_monic_vanishing_at = prove(`
  !S:X->bool b:X->complex c:Y->complex f:X->(Y->bool).
  FINITE S ==>
  (!s. s IN S ==> b s IN QinC) ==>
  (!s. s IN S ==> FINITE(f s)) ==>
  (!s. s IN S ==> ring_polynomial QinC_ring (monic_vanishing_at complex_ring (f s) c)) ==>
  ring_sum complex_ring S (\s. b s * ring_sum complex_ring (f s) (cexp o c)) = Cx(&0) ==>
  (!a. ring_sum complex_ring S (\s. b s * Cx(&(numpreimages c (f s) a))) = Cx(&0))
`,
  intro THEN
  have `!s:X. s IN S ==> monic complex_ring (monic_vanishing_at complex_ring (f s) (c:Y->complex))` [monic_vanishing_at_monic;in_complex_ring] THEN
  have `!s:X. s IN S ==> monic QinC_ring (monic_vanishing_at complex_ring (f s) (c:Y->complex))` [monic_subring;subring_complex_QinC] THEN
  have `!s:X. s IN S ==> ring_polynomial QinC_ring (monic_vanishing_at complex_ring (f s) (c:Y->complex))` [monic_vanishing_at_poly] THEN
  recall field_QinC THEN
  specialize[
    `S:X->bool`;
    `\s:X. monic_vanishing_at complex_ring (f s) (c:Y->complex)`
  ]multi_monic_factorization_distinct_minpolys THEN
  choose2 `P:((1->num)->complex)->bool` `e:X->((1->num)->complex)->num` `FINITE P /\ distinct_minpolys P /\ (!s:X. s IN S ==> poly_product QinC_ring P (\p. poly_pow QinC_ring p (e s p)) = monic_vanishing_at complex_ring (f s) (c:Y->complex))` [] THEN
  def `B:((1->num)->complex)->complex` `\p:(1->num)->complex. ring_sum complex_ring S (\s:X. b s * Cx(&(e s p)))` THEN
  subgoal `!p:(1->num)->complex. p IN P ==> B p IN QinC` THENL [
    simp[] THEN
    rw[GSYM QinC_ring_clauses] THEN
    rw[GSYM subring_complex_QinC] THEN
    intro THEN
    sufficesby ring_sum_in_subring THEN
    rw[BETA_THM] THEN
    intro THEN
    sufficesby RING_MUL THEN
    rw[subring_complex_QinC] THEN
    rw[QinC_ring_clauses] THEN
    qed[num_in_QinC]
  ; pass
  ] THEN
  have `FINITE(P:((1->num)->complex)->bool)` [] THEN
  have `distinct_minpolys P` [] THEN
  subgoal `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx (&0)` THENL [
    simp[] THEN
    simp[GSYM vsum_ring_sum_complex] THEN
    simp[GSYM VSUM_COMPLEX_RMUL] THEN
    specialize_assuming[
      `\p s:X. (b s * Cx(&(e s p))) * ring_sum complex_ring (complex_root p) cexp`;
      `P:((1->num)->complex)->bool`;
      `S:X->bool`
    ]VSUM_SWAP THEN
    simp[] THEN
    rw[GSYM COMPLEX_MUL_ASSOC] THEN
    simp[VSUM_COMPLEX_LMUL] THEN
    subgoal `!s:X. s IN S ==> vsum P (\p. (Cx (&(e s p))) * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring (f s:Y->bool) (cexp o c)` THENL [
      simp[vsum_ring_sum_complex] THEN
      intro THEN
      have `FINITE(f(s:X):Y->bool)` [] THEN
      have `poly_product QinC_ring P (\p. poly_pow QinC_ring p (e s p)) = monic_vanishing_at complex_ring (f(s:X):Y->bool) c` [] THEN
      specialize[
        `P:((1->num)->complex)->bool`;
        `f(s:X):Y->bool`;
        `e(s:X):((1->num)->complex)->num`;
        `c:Y->complex`;
        `cexp`
      ]sum_root_decomposition_if_monic_vanishing_at_factorization THEN
      qed[]
    ; pass
    ] THEN
    simp[] THEN
    qed[vsum_ring_sum_complex]
  ; pass
  ] THEN
  subgoal `!p:(1->num)->complex. p IN P ==> B p = Cx(&0)` THENL [
    specialize_assuming[
      `P:((1->num)->complex)->bool`;
      `B:((1->num)->complex)->complex`
    ]transcendence_all_0_QinC THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!s:X. s IN S ==> numpreimages c (f s:Y->bool) a = nsum P (\p. if complex_root p a then e s p else 0)` THENL [
    intro THEN
    specialize_assuming[
      `P:((1->num)->complex)->bool`;
      `e(s:X):((1->num)->complex)->num`;
      `a:complex`
    ]ord_product_distinct_minpolys THEN
    have `FINITE(f(s:X):Y->bool)` [] THEN
    specialize[
      `f(s:X):Y->bool`;
      `c:Y->complex`;
      `a:complex`
    ]poly_ord_monic_vanishing_at_numpreimages THEN
    qed[]
  ; pass
  ] THEN
  case `!p:(1->num)->complex. p IN P ==> ~complex_root p a` THENL [
    subgoal `!s:X. s IN S ==> nsum P (\p. if complex_root p a then e s p else 0) = nsum P (\p. 0)` THENL [
      intro THEN
      sufficesby NSUM_EQ THEN
      qed[]
    ; pass
    ] THEN
    have `!s:X. s IN S ==> numpreimages c (f s:Y->bool) (a:complex) = 0` [NSUM_0] THEN
    subgoal `ring_sum complex_ring S (\s:X. b s * Cx (&(numpreimages c (f s:Y->bool) (a:complex)))) = ring_sum complex_ring S (\s. Cx(&0))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      have `numpreimages c (f(a':X):Y->bool) (a:complex) = 0` [] THEN
      simp[] THEN
      qed[COMPLEX_MUL_RZERO]
    ; pass
    ] THEN
    simp[] THEN
    rw[GSYM complex_ring_clauses] THEN
    rw[RING_SUM_0]
  ; pass
  ] THEN
  simp[] THEN
  choose `q:(1->num)->complex` `q IN P /\ complex_root q a` [] THEN
  have_rw `Cx(&0) = B(q:(1->num)->complex)` [] THEN
  have_rw `B(q:(1->num)->complex) = ring_sum complex_ring S (\s:X. b s * Cx(&(e s q)))` [] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  subgoal `nsum P (\p. if complex_root p a then e a' p else 0) = nsum P (\p. if p = q then e(a':X) q else 0)` THENL [
    sufficesby NSUM_EQ THEN
    qed[distinct_minpolys_distinct_roots]
  ; pass
  ] THEN
  simp[NSUM_DELTA]
);;
```
### Informal statement
Given:
- A finite set `S` of type `X->bool`.
- A function `b` from `X` to complex numbers such that for every `s` in `S`, `b s` is in `QinC` (the field of complex numbers algebraic over the rationals).
- A function `f` from `X` to sets of elements of type `Y`, such that for every `s` in `S`, `f s` is a finite set.
- For every `s` in `S`, the monic polynomial `monic_vanishing_at complex_ring (f s) c` (where `c` is a function from `Y` to complex numbers) with coefficients in the complex number ring, is also a polynomial in the ring of polynomials over `QinC`.
- The weighted sum over `S`, where each element `s` is weighted by `b s`, of the sum of `cexp (c y)` (where `cexp` is the exponential function) over the set `f s`, equals the complex number 0.

Then, for every complex number `a`, the weighted sum over `S`, where each element `s` is weighted by `b s`, of the number of preimages of `a` under `c` restricted to `f s`, also equals the complex number 0.

### Informal sketch

The proof proceeds as follows:
- Start with the assumption that the weighted sum of exponential functions is zero.
- Use `multi_monic_factorization_distinct_minpolys` to factorize each `monic_vanishing_at complex_ring (f s) c` into a product of powers of distinct monic irreducible polynomials `p` over `QinC`, where `P` is the finite set of these polynomials. The exponent of `p` in the factorization of `monic_vanishing_at complex_ring (f s) c` is denoted by `e s p`.
- Define `B p` as the weighted sum over `S` of `b s * Cx(&(e s p))`. Show that `B p` is in `QinC` for each `p` in `P`.
- Show that the weighted sum over `P` of `B p * ring_sum complex_ring (complex_root p) cexp` equals zero, using `sum_root_decomposition_if_monic_vanishing_at_factorization`.
- Apply `transcendence_all_0_QinC` to conclude that `B p = Cx(&0)` for all `p` in `P`.
- Show that `numpreimages c (f s) a = nsum P (\p. if complex_root p a then e s p else 0)` using `ord_product_distinct_minpolys` and `poly_ord_monic_vanishing_at_numpreimages`.
- Consider two cases: either there is no `q` in `P` such that `complex_root q a` holds, or there is such a `q`.
    - If there is no such `q`, then `numpreimages c (f s) a = 0` for all `s` in `S`, and hence the weighted sum of `numpreimages` is zero.
    - If there is such a `q`, then `q` is unique because the polynomials in `P` have distinct minimal polynomials. From `B q = 0`, it can be shown that the weighted sum of `numpreimages` is zero.

### Mathematical insight
This theorem relates the transcendence of the exponential function to the number of preimages of a complex number under a function `c` restricted to finite subsets `f s`. It uses the fact that if a sum of exponentials of algebraic numbers equals zero, then a related sum involving the number of preimages must also equal zero. The core idea is to use a factorization of polynomials to relate the exponential sums to the preimages, relying on the algebraic independence of roots of distinct minimal polynomials.

### Dependencies
- `FINITE`
- `in_complex_ring`
- `monic_vanishing_at_monic`
- `monic_subring`
- `subring_complex_QinC`
- `monic_vanishing_at_poly`
- `field_QinC`
- `multi_monic_factorization_distinct_minpolys`
- `GSYM`
- `complex_ring`
- `QinC_ring_clauses`
- `BETA_THM`
- `RING_MUL`
- `transcendence_all_0_QinC`

### Porting notes (optional)
- The tactic `choose2` is used to obtain two functions, `P` and `e`, simultaneously. This might need to be emulated using separate `choose` tactics in other proof assistants.
- The subring structure on `QinC` and the properties inherited from `complex` are used extensively. If the target proof assistant does not automatically handle subrings in the same way, it may be necessary to explicitly coerce elements into the relevant rings.
- The theorem `sum_root_decomposition_if_monic_vanishing_at_factorization` encapsulate a potentially complex mathematical argument. Its equivalent may need to be separately proven.


---

## e_is_irrational

### Name of formal statement
e_is_irrational

### Type of the formal statement
theorem

### Formal Content
```ocaml
let e_is_irrational = prove(`
  ~(cexp(Cx(&1)) IN QinC)
`,
  intro THEN
  def `P:((1->num)->complex)->bool` `IMAGE (\n. x_minus_const QinC_ring (Cx(&n))) (0..1)` THEN
  have `FINITE(P:((1->num)->complex)->bool)` [FINITE_IMAGE;FINITE_NUMSEG] THEN
  subgoal `distinct_minpolys P` THENL [
    rw[distinct_minpolys] THEN
    REPEAT GEN_TAC THEN
    REPEAT DISCH_TAC THEN
    choose `n:num` `n IN (0..1) /\ p = x_minus_const QinC_ring(Cx(&n))` [IN_IMAGE] THEN
    have `Cx(&n) IN QinC` [num_in_ZinC;ZinC_in_QinC] THEN
    qed[irred_x_minus_const;field_QinC;QinC_ring_clauses]
  ; pass
  ] THEN
  def `B:((1->num)->complex)->complex` `\p:(1->num)->complex. if p = x_minus_const QinC_ring (Cx(&0)) then -- cexp(Cx(&1)) else Cx(&1)` THEN
  subgoal `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx (&0)` THENL [
    subgoal `!m n. x_minus_const QinC_ring (Cx(&m)) = x_minus_const QinC_ring (Cx(&n)) ==> m = n` THENL [
      intro THEN
      have `coeff 0 (x_minus_const QinC_ring (Cx(&m))) = coeff 0 (x_minus_const QinC_ring (Cx(&n)))` [] THEN
      have `coeff 0 (x_minus_const QinC_ring (Cx(&m))) = ring_neg QinC_ring (Cx(&n))` [coeff_x_minus_const;num_in_ZinC;ZinC_in_QinC;QinC_ring_clauses;ARITH_RULE `~(0 = 1)`] THEN
      have `ring_neg QinC_ring (Cx(&m)) = ring_neg QinC_ring (Cx(&n))` [coeff_x_minus_const;num_in_ZinC;ZinC_in_QinC;QinC_ring_clauses;ARITH_RULE `~(0 = 1)`] THEN
      have `Cx(&m) = Cx(&n)` [RING_NEG_EQ;num_in_ZinC;ZinC_in_QinC;QinC_ring_clauses] THEN
      have `&m = &n:real` [CX_INJ] THEN
      qed[REAL_OF_NUM_CLAUSES]
    ; pass
    ] THEN
    have `!m n. m IN (0..1) ==> n IN (0..1) ==> x_minus_const QinC_ring (Cx(&m)) = x_minus_const QinC_ring (Cx(&n)) ==> m = n` [] THEN
    specialize[
      `complex_ring`;
      `\n. x_minus_const QinC_ring (Cx(&n))`;
      `\p:(1->num)->complex. B p * ring_sum complex_ring (complex_root p) cexp`;
      `(0..1)`
    ]RING_SUM_IMAGE THEN
    have_rw `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring (0..1) ((\p. B p * ring_sum complex_ring (complex_root p) cexp) o (\n. x_minus_const QinC_ring (Cx (&n))))` [] THEN
    rw[RING_SUM_CLAUSES_NUMSEG;ARITH_RULE `1 = SUC 0`;in_complex_ring;ARITH_RULE `0 <= SUC 0`;o_THM] THEN
    rw[ARITH_RULE `SUC 0 = 1`] THEN
    have_rw `complex_root (x_minus_const QinC_ring (Cx (&0))) = {Cx(&0)}` [complex_root_x_minus_const;x_minus_const_QinC_eq_x_minus_const_complex] THEN
    have_rw `complex_root (x_minus_const QinC_ring (Cx (&1))) = {Cx(&1)}` [complex_root_x_minus_const;x_minus_const_QinC_eq_x_minus_const_complex] THEN
    rw[RING_SUM_SING;in_complex_ring] THEN
    have_rw `B (x_minus_const QinC_ring (Cx (&0))) = --cexp(Cx(&1))` [] THEN
    have_rw `B (x_minus_const QinC_ring (Cx (&1))) = Cx(&1)` [ARITH_RULE `~(0 = 1)`] THEN
    rw[complex_ring_clauses;CEXP_0] THEN
    CONV_TAC COMPLEX_FIELD
  ; pass
  ] THEN
  subgoal `!p:(1->num)->complex. p IN P ==> B p IN QinC` THENL [
    intro THEN
    have `--cexp(Cx(&1)) IN QinC` [neg_in_QinC] THEN
    have `Cx(&1) IN QinC` [QinC_1] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->complex`
  ]transcendence_all_0_QinC THEN
  have `x_minus_const QinC_ring(Cx(&0)) IN P` [IN_NUMSEG_0;ARITH_RULE `0 <= 1`;IN_IMAGE] THEN
  have `--cexp(Cx(&1)) = Cx(&0)` [] THEN
  complex_field_fact `--cexp(Cx(&1)) = Cx(&0) ==> cexp(Cx(&1)) = Cx(&0)` THEN
  qed[CEXP_NZ]
);;
```

### Informal statement
It is not the case that the complex number `cexp(Cx(&1))`, which represents *e* (Euler's number), is an element of the field `QinC` of complex numbers with rational real and imaginary parts.

### Informal sketch
The proof demonstrates the irrationality of *e* by contradiction, using a transcendence argument.

- It starts by assuming that *e* is in `QinC`.
- We define `P` as the image of the set `{0, 1}` under the map that sends `n` to the polynomial `x_minus_const QinC_ring (Cx(&n))`. The elements of `P` are therefore `x - 0` and `x - 1`, with coefficients in `QinC`.
- Show that the minimal polynomials in `P` are distinct.
- The function `B` maps `x` to `-cexp(Cx(&1))` if `x = x_minus_const QinC_ring (Cx(&0))` and to `Cx(&1)` otherwise.
- Show that the sum, over the polynomials `p` in `P`, of `B p * ring_sum complex_ring (complex_root p) cexp` is equal to `Cx(&0)`. This involves manipulating sums over roots and using the definition of `B`.
- Show that for all `p` in `P`, `B p` is in `QinC`.
- Apply the theorem `transcendence_all_0_QinC`, which states that if the roots of a polynomial are in `QinC` implies that all `B p` are also in `QinC`, we can conclude that the number is not transcendental.
- This contradicts a known fact that *e* is transcendental, specifically `CEXP_NZ` is used to show `cexp(Cx(&1)) /= Cx(&0)`.

### Mathematical insight
The theorem demonstrates a classical result that the exponential of 1, i.e., *e*, is not rational. This fact is an instance of Gelfond's theorem, which states that if *a* and *b* are algebraic numbers with *a* not equal to 0 or 1, and *b* is not rational, then *a*^*b* is transcendental.

### Dependencies
- `intro`
- `def`
- `FINITE_IMAGE`
- `FINITE_NUMSEG`
- `rw`
- `distinct_minpolys`
- `REPEAT`
- `GEN_TAC`
- `DISCH_TAC`
- `choose`
- `n IN (0..1) /\ p = x_minus_const QinC_ring(Cx(&n))`
- `IN_IMAGE`
- `num_in_ZinC`
- `ZinC_in_QinC`
- `irred_x_minus_const`
- `field_QinC`
- `QinC_ring_clauses`
- `pass`
- `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx (&0)`
- `!m n. x_minus_const QinC_ring (Cx(&m)) = x_minus_const QinC_ring (Cx(&n)) ==> m = n`
- `coeff 0 (x_minus_const QinC_ring (Cx(&m))) = coeff 0 (x_minus_const QinC_ring (Cx(&n)))`
- `coeff 0 (x_minus_const QinC_ring (Cx(&m))) = ring_neg QinC_ring (Cx(&n))`
- `coeff_x_minus_const`
- `ARITH_RULE`
- `ring_neg QinC_ring (Cx(&m)) = ring_neg QinC_ring (Cx(&n))`
- `Cx(&m) = Cx(&n)`
- `RING_NEG_EQ`
- `&m = &n:real`
- `CX_INJ`
- `REAL_OF_NUM_CLAUSES`
- `!m n. m IN (0..1) ==> n IN (0..1) ==> x_minus_const QinC_ring (Cx(&m)) = x_minus_const QinC_ring (Cx(&n)) ==> m = n`
- `RING_SUM_IMAGE`
- `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring (0..1) ((\p. B p * ring_sum complex_ring (complex_root p) cexp) o (\n. x_minus_const QinC_ring (Cx (&n))))`
- `RING_SUM_CLAUSES_NUMSEG`
- `1 = SUC 0`
- `in_complex_ring`
- `0 <= SUC 0`
- `o_THM`
- `SUC 0 = 1`
- `complex_root (x_minus_const QinC_ring (Cx (&0))) = {Cx(&0)}`
- `complex_root_x_minus_const`
- `x_minus_const_QinC_eq_x_minus_const_complex`
- `complex_root (x_minus_const QinC_ring (Cx (&1))) = {Cx(&1)}`
- `RING_SUM_SING`
- `B (x_minus_const QinC_ring (Cx (&0))) = --cexp(Cx(&1))`
- `B (x_minus_const QinC_ring (Cx (&1))) = Cx(&1)`
- `complex_ring_clauses`
- `CEXP_0`
- `CONV_TAC COMPLEX_FIELD`
- `!p:(1->num)->complex. p IN P ==> B p IN QinC`
- `--cexp(Cx(&1)) IN QinC`
- `neg_in_QinC`
- `Cx(&1) IN QinC`
- `transcendence_all_0_QinC`
- `x_minus_const QinC_ring(Cx(&0)) IN P`
- `IN_NUMSEG_0`
- `0 <= 1`
- `--cexp(Cx(&1)) = Cx(&0)`
- `complex_field_fact `--cexp(Cx(&1)) = Cx(&0) ==> cexp(Cx(&1)) = Cx(&0)`
- `CEXP_NZ`

### Porting notes (optional)
The core idea involves demonstrating a contradiction, establishing transcendence. Porting to other systems will require:

- Ensure complex arithmetic is correctly set up, including the definition of `cexp`, `Cx`, and the field `QinC`.
- `transcendence_all_0_QinC` needs to be defined and proved, or you need to find a relevant transcendence theorem in another proof assistant.


---

## e_is_transcendental

### Name of formal statement
e_is_transcendental

### Type of the formal statement
theorem

### Formal Content
```ocaml
let e_is_transcendental = prove(`
  ~(algebraic_number(cexp(Cx(&1))))
`,
  rw[algebraic_number] THEN
  intro THEN
  def `d:num` `poly_deg ZinC_ring (p:(1->num)->complex)` THEN
  have `d = poly_deg complex_ring (p:(1->num)->complex)` [poly_deg_subring;subring_complex_empty] THEN
  def `P:((1->num)->complex)->bool` `IMAGE (\n. x_minus_const QinC_ring (Cx(&n))) (0..d)` THEN
  have `FINITE(P:((1->num)->complex)->bool)` [FINITE_IMAGE;FINITE_NUMSEG] THEN
  subgoal `distinct_minpolys P` THENL [
    rw[distinct_minpolys] THEN
    REPEAT GEN_TAC THEN
    REPEAT DISCH_TAC THEN
    choose `n:num` `p' = x_minus_const QinC_ring(Cx(&n))` [IN_IMAGE] THEN
    have `Cx(&n) IN QinC` [num_in_ZinC;ZinC_in_QinC] THEN
    qed[irred_x_minus_const;field_QinC;QinC_ring_clauses]
  ; pass
  ] THEN
  subgoal `!m n. x_minus_const QinC_ring (Cx(&m)) = x_minus_const QinC_ring (Cx(&n)) ==> m = n` THENL [
    intro THEN
    have `coeff 0 (x_minus_const QinC_ring (Cx(&m))) = coeff 0 (x_minus_const QinC_ring (Cx(&n)))` [] THEN
    have `coeff 0 (x_minus_const QinC_ring (Cx(&m))) = ring_neg QinC_ring (Cx(&n))` [coeff_x_minus_const;num_in_ZinC;ZinC_in_QinC;QinC_ring_clauses;ARITH_RULE `~(0 = 1)`] THEN
    have `ring_neg QinC_ring (Cx(&m)) = ring_neg QinC_ring (Cx(&n))` [coeff_x_minus_const;num_in_ZinC;ZinC_in_QinC;QinC_ring_clauses;ARITH_RULE `~(0 = 1)`] THEN
    have `Cx(&m) = Cx(&n)` [RING_NEG_EQ;num_in_ZinC;ZinC_in_QinC;QinC_ring_clauses] THEN
    have `&m = &n:real` [CX_INJ] THEN
    qed[REAL_OF_NUM_CLAUSES]
  ; pass
  ] THEN
  def `B:((1->num)->complex)->complex` `\q:(1->num)->complex. coeff (@n. q = x_minus_const QinC_ring (Cx(&n))) (p:(1->num)->complex)` THEN
  subgoal `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx (&0)` THENL [
    have `!m n. m IN (0..d) ==> n IN (0..d) ==> x_minus_const QinC_ring (Cx(&m)) = x_minus_const QinC_ring (Cx(&n)) ==> m = n` [] THEN
    specialize[
      `complex_ring`;
      `\n. x_minus_const QinC_ring (Cx(&n))`;
      `\p:(1->num)->complex. B p * ring_sum complex_ring (complex_root p) cexp`;
      `(0..d)`
    ]RING_SUM_IMAGE THEN
    have_rw `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = ring_sum complex_ring (0..d) ((\p. B p * ring_sum complex_ring (complex_root p) cexp) o (\n. x_minus_const QinC_ring (Cx (&n))))` [] THEN
    subgoal `poly_eval complex_ring p (cexp(Cx(&1))) = ring_sum complex_ring (0..d) ((\p. B p * ring_sum complex_ring (complex_root p) cexp) o (\n. x_minus_const QinC_ring (Cx (&n))))` THENL [
      have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_ZinC] THEN
      have `p IN ring_carrier(x_poly complex_ring)` [x_poly_use] THEN
      have `p IN ring_carrier(poly_ring complex_ring (:1))` [x_poly] THEN
      specialize_assuming[`complex_ring`;`cexp(Cx(&1))`;`p:(1->num)->complex`]POLY_EVAL_EXPAND THEN
      have_rw `poly_eval complex_ring p (cexp (Cx (&1))) = ring_sum complex_ring (0..d) (\i. ring_mul complex_ring (p (\v. i)) (ring_pow complex_ring (cexp (Cx (&1))) i))` [in_complex_ring] THEN
      sufficesby RING_SUM_EQ THEN
      intro THEN
      rw[BETA_THM;o_THM] THEN
      rw[complex_ring_clauses;ring_pow_complex] THEN
      rw[complex_root_x_minus_const;x_minus_const_QinC_eq_x_minus_const_complex] THEN
      rw[GSYM CEXP_N;COMPLEX_MUL_RID] THEN
      have `B (x_minus_const QinC_ring (Cx (&a))) = coeff a p:complex` [] THEN
      have `B (x_minus_const QinC_ring (Cx (&a))) = p (\v:1. a):complex` [coeff;x_monomial] THEN
      have `B (x_minus_const complex_ring (Cx (&a))) = p (\v:1. a):complex` [x_minus_const_QinC_eq_x_minus_const_complex] THEN
      qed[RING_SUM_SING;in_complex_ring]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!q:(1->num)->complex. q IN P ==> B q IN QinC` THENL [
    intro THEN
    have `ring_polynomial QinC_ring (p:(1->num)->complex)` [poly_QinC_if_poly_ZinC] THEN
    qed [coeff_poly_in_ring;QinC_ring_clauses]
  ; pass
  ] THEN
  specialize[
    `P:((1->num)->complex)->bool`;
    `B:((1->num)->complex)->complex`
  ]transcendence_all_0_QinC THEN
  have `~(coeff d p = Cx(&0))` [topcoeff_nonzero;ZinC_ring_clauses] THEN
  have `x_minus_const QinC_ring (Cx(&d)) IN P` [IN_IMAGE;IN_NUMSEG_0;ARITH_RULE `d <= d:num`] THEN
  have `B(x_minus_const QinC_ring (Cx(&d))) = Cx(&0)` [] THEN
  have `B(x_minus_const QinC_ring (Cx(&d))) = coeff d p:complex` [] THEN
  qed[]
);;
```

### Informal statement
The number `exp(1)` is not an algebraic number. That is, `exp(1)` does not satisfy any non-zero polynomial with coefficients in the field of algebraic numbers.

### Informal sketch
The proof shows that `exp(1)` is transcendental by contradiction, assuming `exp(1)` is algebraic, meaning it is a root of some polynomial `p` with coefficients in the field of algebraic numbers `QinC`.

- Assume that `exp(1)` is algebraic, this is equivalent to `~(algebraic_number(cexp(Cx(&1))))`.
- Let `d` be the degree of the polynomial `p`.
- Define `P` as the image of the set `{0, ..., d}` under the function mapping `n` to the polynomial `x - n`.
- Show that `P` is a finite set whose elements can be written as `x_minus_const QinC_ring (Cx(&n))` where `n` ranges from 0 to d
    - Show that the polynomials in `P` have distinct minimal polynomials. This part relies on `irred_x_minus_const`, `field_QinC` and `QinC_ring_clauses` to ensure irreducibility of `x-n` and the properties of the field of algebraic complexes.
    - Show that if `x - m = x - n` then `m = n`.
- Define `B q` as the coefficient of the monomial `x^n` in `p` where `q = x - n`. In other words, `B` maps a polynomial of the form `x - n` to the coefficient of `x^n` in the polynomial `p` (where the polynomial `p` is `(1->num)->complex`).
- Show that `ring_sum complex_ring P (\p. B p * ring_sum complex_ring (complex_root p) cexp) = Cx (&0)`. This part of the proof involves expanding the polynomial evaluation `poly_eval complex_ring p (cexp(Cx(&1)))`, using `POLY_EVAL_EXPAND`, and relating the coefficients and roots.
- Show that for all `q` in `P`, `B q` is in `QinC`. This means that the coefficients `B q` are algebraic complex numbers.
- Apply the theorem `transcendence_all_0_QinC`, which states that under certain conditions (satisfied by the previous steps), all the values `B q` must equal to zero.
- Show that the leading coefficient `coeff d p` (where `d` is the degree of `p`) is non-zero since it's a top coefficient.
- Show that all the `B(x_minus_const QinC_ring (Cx(&d))) = 0`.
- Obtain a contradiction because `B(x_minus_const QinC_ring (Cx(&d))) = coeff d p` which is non-zero, but according to the application of `transcendence_all_0_QinC`, it should be zero.

### Mathematical insight
The theorem is a fundamental result in number theory, demonstrating that the exponential of 1 is a transcendental number. The proof relies on constructing a polynomial related to the assumption that e is algebraic, and showing that this leads to a contradiction by analyzing its coefficients and roots using the properties of algebraic numbers.

### Dependencies
- Definitions: `algebraic_number`
- Theorems: `irred_x_minus_const`, `FINITE_IMAGE`, `FINITE_NUMSEG`, `CX_INJ`, `RING_NEG_EQ`, `POLY_EVAL_EXPAND`, `transcendence_all_0_QinC`
- Rings and relevant clause theorems: `algebraic_number`, `field_QinC`, `QinC_ring_clauses`, `complex_ring_clauses`, `ZinC_ring_clauses`

### Porting notes (optional)
- `transcendence_all_0_QinC` is a key ingredient, needing to either find the equivalent in the target proof assistant or prove it.
- Ensure that the target proof assistant has good support for algebraic numbers, complex numbers, polynomials and ring theory. Otherwise a lot of boilerplate may be required.


---

## algebraic_number_mul

### Name of formal statement
algebraic_number_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_mul = prove(`
  !y z.
  algebraic_number y ==>
  algebraic_number z ==>
  algebraic_number (y*z)
`,
  intro THEN
  choose `p:(1->num)->complex` `(ring_polynomial QinC_ring p /\ ~(p = poly_0 QinC_ring) /\ monic QinC_ring p /\ ring_irreducible(x_poly QinC_ring) p /\ poly_eval complex_ring p y = Cx(&0))` [algebraic_number_is_root_monic_irreducible_QinC_poly] THEN
  choose `q:(1->num)->complex` `(ring_polynomial QinC_ring q /\ ~(q = poly_0 QinC_ring) /\ monic QinC_ring q /\ ring_irreducible(x_poly QinC_ring) q /\ poly_eval complex_ring q z = Cx(&0))` [algebraic_number_is_root_monic_irreducible_QinC_poly] THEN
  have `!e. complex_root_powersums p e IN QinC` [complex_root_powersums_QinC_monic_irreducible_QinC] THEN
  have `!e. complex_root_powersums q e IN QinC` [complex_root_powersums_QinC_monic_irreducible_QinC] THEN
  def `pq:(1->num)->complex` `monic_vanishing_at complex_ring (complex_root p CROSS complex_root q) (\(y,z). y*z)` THEN
  have `FINITE (complex_root p)` [distinct_minpolys_finite_root_simple] THEN
  have `FINITE (complex_root q)` [distinct_minpolys_finite_root_simple] THEN
  have `FINITE (complex_root p CROSS complex_root q)` [FINITE_CROSS] THEN
  have `y IN complex_root p` [complex_root;IN] THEN
  have `z IN complex_root q` [complex_root;IN] THEN
  have `(y,z) IN complex_root p CROSS complex_root q` [IN_CROSS] THEN
  subgoal `ring_polynomial QinC_ring (pq:(1->num)->complex)` THENL [
    have `ring_hasQ (subring_generated complex_ring QinC)` [ring_hasQ_QinC;subring_complex_QinC] THEN
    subgoal `!d. ring_sum complex_ring (complex_root p CROSS complex_root q) (\s. ring_pow complex_ring ((\(y,z). y * z) s) d) IN ring_carrier (subring_generated complex_ring QinC)` THENL [
      intro THEN
      rw[subring_complex_QinC] THEN
      rw[GSYM complex_ring_clauses] THEN
      rw[LAMBDA_PAIR] THEN
      simp[RING_MUL_POW;in_complex_ring] THEN
      rw[GSYM LAMBDA_PAIR] THEN
      have `!x. x IN complex_root p ==> ring_pow complex_ring x d IN ring_carrier complex_ring` [in_complex_ring] THEN
      have `!y. y IN complex_root q ==> ring_pow complex_ring y d IN ring_carrier complex_ring` [in_complex_ring] THEN
      specialize[
        `complex_ring`;
        `complex_root p`;
        `complex_root q`;
        `\x. ring_pow complex_ring x d`;
        `\y. ring_pow complex_ring y d`
      ]ring_sum_cross_mul THEN
      simp[] THEN
      rw[ring_pow_complex;complex_ring_clauses;GSYM complex_root_powersums;QinC_ring_clauses] THEN
      qed[mul_in_QinC]
    ; pass
    ] THEN
    specialize_assuming[
      `complex_ring`;
      `QinC`;
      `complex_root p CROSS complex_root q`;
      `\(y,z). y * z:complex`
    ]poly_subring_if_powersums_subring THEN
    qed[in_complex_ring;subring_complex_QinC]
  ; pass
  ] THEN
  have `algebraic_number ((\(y,z). y*z) (y,z))` [algebraic_number_if_monic_vanishing_at_QinC] THEN
  havetac `((\(y,z). y*z) (y,z)) = y*z:complex` (rw[]) THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `y` and `z`, if `y` is an algebraic number and `z` is an algebraic number, then the product `y*z` is an algebraic number.

### Informal sketch
The proof demonstrates that the product of two algebraic numbers is also an algebraic number.

- We start by assuming that `y` and `z` are algebraic numbers.
- We then use `algebraic_number_is_root_monic_irreducible_QinC_poly` to show that there exist polynomials `p` and `q` over `QinC` (the algebraic closure of rationals), which are monic and irreducible, such that `p(y) = 0` and `q(z) = 0`.
- We use `complex_root_powersums_QinC_monic_irreducible_QinC` to show that for all `e`, `complex_root_powersums p e` and `complex_root_powersums q e` are in `QinC`.
- We define a new polynomial `pq` as the monic polynomial `monic_vanishing_at complex_ring (complex_root p CROSS complex_root q) (\(y,z). y*z)` that vanishes at the product of the roots of `p` and `q`. This polynomial is constructed by considering all pairs of roots of `p` and `q`, multiplying them, and then constructing a monic polynomial whose roots are precisely these products.
- It's then shown that `pq` is actually a polynomial in `QinC`. This involves showing that the power sums of the roots of `pq` are in `QinC`. This is accomplished by expressing the power sums of the product of roots in terms of the power sums of the individual roots and using the fact that power sums of the individual roots are in `QinC`. The key steps involve using `ring_sum_cross_mul` and `poly_subring_if_powersums_subring`.
- Finally, since `pq` is a monic polynomial in `QinC` that vanishes at `y*z`, it is concluded with `algebraic_number_if_monic_vanishing_at_QinC` that `y*z` is an algebraic number.

### Mathematical insight
This theorem is a fundamental result in field theory. It demonstrates a crucial closure property: the set of algebraic numbers forms a field. This closure under multiplication, along with closure under addition (indicated in the comment), is essential to the well-behaved nature of algebraic numbers.

### Dependencies
- `algebraic_number_is_root_monic_irreducible_QinC_poly`
- `complex_root_powersums_QinC_monic_irreducible_QinC`
- `complex_root_powersums_QinC_monic_irreducible_QinC`
- `distinct_minpolys_finite_root_simple`
- `FINITE_CROSS`
- `algebraic_number_if_monic_vanishing_at_QinC`

The following were also used in subproofs:
- `ring_hasQ_QinC`
- `subring_complex_QinC`
- `in_complex_ring`
- `ring_sum_cross_mul`
- `poly_subring_if_powersums_subring`


---

## algebraic_number_neg

### Name of formal statement
algebraic_number_neg

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_neg = prove(`
  !z.
  algebraic_number z ==>
  algebraic_number (-- z)
`,
  intro THEN
  complex_field_fact `--z = (-- Cx(&1)) * z` THEN
  have `Cx(&1) IN ZinC` [ZinC_1] THEN
  have `-- Cx(&1) IN ZinC` [neg_in_ZinC] THEN
  have `algebraic_number (-- Cx(&1))` [algebraic_number_ZinC] THEN
  qed[algebraic_number_mul]
);;
```

### Informal statement
For all complex numbers `z`, if `z` is an algebraic number, then the additive inverse of `z` is also an algebraic number.

### Informal sketch
The proof proceeds as follows:
- Assume `z` is an algebraic number.
- Use the field fact `--z = (-- Cx(&1)) * z`.
- Show that `Cx(&1)` is in `ZinC`.
- Show that `-- Cx(&1)` is in `ZinC`.
- Show that `algebraic_number (-- Cx(&1))`.
- Apply `algebraic_number_mul` to conclude that `algebraic_number (-- z)`.

### Mathematical insight
This theorem demonstrates a key property of algebraic numbers: they are closed under negation (taking the additive inverse). This is important because it verifies that the set of algebraic numbers forms a subfield of the complex numbers (when combined with closure under addition, multiplication, and existence of multiplicative inverses). The proof relies on showing that the algebraic numbers contain -1 and are closed under multiplication.

### Dependencies
- Fact: `complex_field_fact`
- Theorem: `ZinC_1`
- Theorem: `neg_in_ZinC`
- Theorem: `algebraic_number_ZinC`
- Theorem: `algebraic_number_mul`


---

## algebraic_number_add

### Name of formal statement
algebraic_number_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_add = prove(`
  !y z.
  algebraic_number y ==>
  algebraic_number z ==>
  algebraic_number (y+z)
`,
  intro THEN
  choose `p:(1->num)->complex` `(ring_polynomial QinC_ring p /\ ~(p = poly_0 QinC_ring) /\ monic QinC_ring p /\ ring_irreducible(x_poly QinC_ring) p /\ poly_eval complex_ring p y = Cx(&0))` [algebraic_number_is_root_monic_irreducible_QinC_poly] THEN
  choose `q:(1->num)->complex` `(ring_polynomial QinC_ring q /\ ~(q = poly_0 QinC_ring) /\ monic QinC_ring q /\ ring_irreducible(x_poly QinC_ring) q /\ poly_eval complex_ring q z = Cx(&0))` [algebraic_number_is_root_monic_irreducible_QinC_poly] THEN
  have `!e. complex_root_powersums p e IN QinC` [complex_root_powersums_QinC_monic_irreducible_QinC] THEN
  have `!e. complex_root_powersums q e IN QinC` [complex_root_powersums_QinC_monic_irreducible_QinC] THEN
  def `pq:(1->num)->complex` `monic_vanishing_at complex_ring (complex_root p CROSS complex_root q) (\(y,z). y+z)` THEN
  have `FINITE (complex_root p)` [distinct_minpolys_finite_root_simple] THEN
  have `FINITE (complex_root q)` [distinct_minpolys_finite_root_simple] THEN
  have `FINITE (complex_root p CROSS complex_root q)` [FINITE_CROSS] THEN
  have `y IN complex_root p` [complex_root;IN] THEN
  have `z IN complex_root q` [complex_root;IN] THEN
  have `(y,z) IN complex_root p CROSS complex_root q` [IN_CROSS] THEN
  subgoal `ring_polynomial QinC_ring (pq:(1->num)->complex)` THENL [
    have `ring_hasQ (subring_generated complex_ring QinC)` [ring_hasQ_QinC;subring_complex_QinC] THEN
    subgoal `!d. ring_sum complex_ring (complex_root p CROSS complex_root q) (\s. ring_pow complex_ring ((\(y,z). y + z) s) d) IN ring_carrier (subring_generated complex_ring QinC)` THENL [
      intro THEN
      rw[GSYM complex_ring_clauses] THEN
      rw[LAMBDA_PAIR] THEN
      simp[RING_MUL_POW;in_complex_ring] THEN
      rw[GSYM LAMBDA_PAIR] THEN
      simp[RING_BINOMIAL_THEOREM;in_complex_ring] THEN
      specialize_assuming[
        `complex_ring`;
        `\(x,y) k. ring_mul complex_ring (ring_of_num complex_ring (binom (d,k))) (ring_mul complex_ring (ring_pow complex_ring x k) (ring_pow complex_ring y (d - k)))`;
        `complex_root p CROSS complex_root q`;
        `0..d`
      ]RING_SUM_SWAP THEN
      subgoal `ring_sum complex_ring (complex_root p CROSS complex_root q)
          (\(x,y).
               ring_sum complex_ring (0..d)
               (\k.
                     ring_mul complex_ring
                     (ring_of_num complex_ring (binom (d,k)))
                     (ring_mul complex_ring (ring_pow complex_ring x k)
                     (ring_pow complex_ring y (d - k)))))
               =
               ring_sum complex_ring (complex_root p CROSS complex_root q)
          (\i.
               ring_sum complex_ring (0..d)
               ((\(x,y) k.
                     ring_mul complex_ring
                     (ring_of_num complex_ring (binom (d,k)))
                     (ring_mul complex_ring (ring_pow complex_ring x k)
                     (ring_pow complex_ring y (d - k))))
               i))`
               THENL [
        sufficesby RING_SUM_EQ THEN
        rw[BETA_THM;LAMBDA_PAIR]
      ; pass
      ] THEN
      have `ring_sum complex_ring (complex_root p CROSS complex_root q) (\i. ring_sum complex_ring (0..d) ((\(x,y) k. ring_mul complex_ring (ring_of_num complex_ring (binom (d,k))) (ring_mul complex_ring (ring_pow complex_ring x k) (ring_pow complex_ring y (d - k)))) i)) = ring_sum complex_ring (0..d) (\j. ring_sum complex_ring (complex_root p CROSS complex_root q) (\i. (\(x,y) k. ring_mul complex_ring (ring_of_num complex_ring (binom (d,k))) (ring_mul complex_ring (ring_pow complex_ring x k) (ring_pow complex_ring y (d - k)))) i j))` [in_complex_ring;FINITE_NUMSEG] THEN
      simp[] THEN
      sufficesby ring_sum_in_subring THEN
      intro THEN
      rw[BETA_THM;LAMBDA_PAIR] THEN
      rw[GSYM LAMBDA_PAIR] THEN
      subgoal `ring_sum complex_ring (complex_root p CROSS complex_root q) (\(x,y). ring_mul complex_ring (ring_of_num complex_ring (binom (d,s))) (ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s)))) = ring_mul complex_ring (ring_of_num complex_ring (binom (d,s))) (ring_sum complex_ring (complex_root p CROSS complex_root q) (\(x,y). ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s))))` THENL [
        specialize_assuming[
          `complex_ring`;
          `\(x,y). ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s))`;
          `ring_of_num complex_ring (binom(d,s))`;
          `complex_root p CROSS complex_root q`
        ]RING_SUM_LMUL THEN
        have `ring_sum complex_ring (complex_root p CROSS complex_root q) (\x. ring_mul complex_ring (ring_of_num complex_ring (binom (d,s))) ((\(x,y). ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s))) x)) = ring_mul complex_ring (ring_of_num complex_ring (binom (d,s))) (ring_sum complex_ring (complex_root p CROSS complex_root q) (\(x,y). ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s))))` [in_complex_ring] THEN
        subgoal `ring_sum complex_ring (complex_root p CROSS complex_root q) (\x. ring_mul complex_ring (ring_of_num complex_ring (binom (d,s))) ((\(x,y). ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s))) x)) = ring_sum complex_ring (complex_root p CROSS complex_root q) (\(x,y). ring_mul complex_ring (ring_of_num complex_ring (binom (d,s))) (ring_mul complex_ring (ring_pow complex_ring x s) (ring_pow complex_ring y (d - s))))` THENL [
          sufficesby RING_SUM_EQ THEN
          rw[BETA_THM;LAMBDA_PAIR]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      simp[] THEN
      have `!x. x IN complex_root p ==> ring_pow complex_ring x s IN ring_carrier complex_ring` [in_complex_ring] THEN
      have `!y. y IN complex_root q ==> ring_pow complex_ring y (d - s) IN ring_carrier complex_ring` [in_complex_ring] THEN
      specialize_assuming[
        `complex_ring`;
        `complex_root p`;
        `complex_root q`;
        `\x. ring_pow complex_ring x s`;
        `\y. ring_pow complex_ring y (d - s)`
      ]ring_sum_cross_mul THEN
      simp[] THEN
      rw[ring_of_num_complex;ring_pow_complex;complex_ring_clauses;GSYM complex_root_powersums;QinC_ring_clauses;subring_complex_QinC] THEN
      qed[mul_in_QinC;num_in_QinC;complex_of_num]
    ; pass
    ] THEN
    specialize_assuming[
      `complex_ring`;
      `QinC`;
      `complex_root p CROSS complex_root q`;
      `\(y,z). y + z:complex`
    ]poly_subring_if_powersums_subring THEN
    qed[in_complex_ring;subring_complex_QinC]
  ; pass
  ] THEN
  have `algebraic_number ((\(y,z). y+z) (y,z))` [algebraic_number_if_monic_vanishing_at_QinC] THEN
  havetac `((\(y,z). y+z) (y,z)) = y+z:complex` (rw[]) THEN
  qed[]
);;
```

### Informal statement
For all complex numbers `y` and `z`, if `y` is an algebraic number and `z` is an algebraic number, then `y + z` is an algebraic number.

### Informal sketch
The proof demonstrates that the sum of two algebraic numbers is also an algebraic number.
- It starts by assuming that `y` and `z` are algebraic numbers. Thus, there exist monic irreducible polynomials `p` and `q` with coefficients in `QinC` (the field of complex numbers with rational real and imaginary parts) such that `p(y) = 0` and `q(z) = 0`, using `algebraic_number_is_root_monic_irreducible_QinC_poly`.
- It leverages `complex_root_powersums_QinC_monic_irreducible_QinC` to declare that power sums of roots of both `p`, and `q` are in `QinC`.
- A polynomial `pq` is defined as `monic_vanishing_at complex_ring (complex_root p CROSS complex_root q) (\(y,z). y+z)`, which is the monic polynomial vanishing at the set of sums of roots of `p` and `q`.
- The goal is to show that `pq` is a polynomial with coefficients in `QinC`. This is achieved by showing that for all `d`, the sum of `(y+z)^d` over all pairs `(y, z)` in `complex_root p CROSS complex_root q` is in `QinC`. This is done by using the binomial theorem and swapping the order of summation. The fact that sums and products of elements in `QinC` are in `QinC` is key.
- It's then shown that the polynomial `pq` vanishes at `y + z`. This is because `y` is a root of `p` and `z` is a root of `q`, so `(y, z)` belongs to `complex_root p CROSS complex_root q`. Therefore, `pq(y + z) = 0`.
- Finally, the theorem `algebraic_number_if_monic_vanishing_at_QinC` is applied to conclude that `y + z` is an algebraic number.

### Mathematical insight
The theorem establishes a fundamental property of algebraic numbers: the set of algebraic numbers forms a field (closed under addition). The core idea is to construct a polynomial with coefficients in `QinC` that has `y + z` as a root. The polynomial is built using the roots of the minimal polynomials of `y` and `z`.

### Dependencies
- `algebraic_number_is_root_monic_irreducible_QinC_poly`
- `complex_root_powersums_QinC_monic_irreducible_QinC`
- `distinct_minpolys_finite_root_simple`
- `FINITE_CROSS`
- `algebraic_number_if_monic_vanishing_at_QinC`
- `ring_hasQ_QinC`
- `subring_complex_QinC`
- `mul_in_QinC`
- `num_in_QinC`
- `complex_of_num`
- `poly_subring_if_powersums_subring`

### Porting notes (optional)
- The proof relies on the properties of complex numbers and polynomials over them, particularly the binomial theorem and summation manipulations.
- The concept of `QinC` and related lemmas about it need to be carefully ported using the corresponding representation of rational complex numbers in the target proof assistant.
- Lemmas involving `ring_sum`, `ring_mul`, and `ring_pow` might require adjustments based on the target system's treatment of rings and fields.


---

## algebraic_number_subring

### Name of formal statement
algebraic_number_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_subring = prove(`
  algebraic_number subring_of complex_ring
`,
  rw[subring_of] THEN
  rw[complex_ring_clauses;IN;SUBSET] THEN
  qed[IN_UNIV;IN;algebraic_number_ZinC;ZinC_0;ZinC_1;algebraic_number_neg;algebraic_number_add;algebraic_number_mul]
);;
```

### Informal statement
The set of algebraic complex numbers forms a subring of the complex numbers.

### Informal sketch
To prove that the algebraic numbers form a subring of the complex numbers, we show that the set of algebraic numbers satisfies the subring axioms with respect to the complex numbers.

- First, we use `subring_of`, which unfolds the definition of a subring. This reduces the goal to showing that the algebraic numbers are a subset of the complex numbers, and that they contain 0 and 1, are closed under negation, addition, and multiplication.
- Then `complex_ring_clauses;IN;SUBSET` simplifies the goal to checking properties pertaining to the subset only, namely the subring properties listed in the previous step.
- Finally, we proceed to show that:
  - Every complex number which is in the universe is in the set of algebraic numbers (`IN_UNIV;IN`).
  - 0 is an algebraic complex number (`algebraic_number_ZinC;ZinC_0`).
  - 1 is an algebraic complex number (`ZinC_1`).
  - The negation of an algebraic complex number is an algebraic complex number (`algebraic_number_neg`).
  - The sum of two algebraic complex numbers is an algebraic complex number (`algebraic_number_add`).
  - The product of two algebraic complex numbers is an algebraic complex number (`algebraic_number_mul`).

### Mathematical insight
This theorem establishes that the algebraic numbers, a subset of the complex numbers, inherit the ring structure. This is important because it allows us to apply ring-theoretic results to algebraic numbers. The algebraic numbers, together with the ring operations inherited from the complex numbers, forms a ring structure. This is a fundamental result in algebra and number theory.

### Dependencies
- `subring_of`
- `complex_ring_clauses`
- `IN_UNIV`
- `IN`
- `algebraic_number_ZinC`
- `ZinC_0`
- `ZinC_1`
- `algebraic_number_neg`
- `algebraic_number_add`
- `algebraic_number_mul`

### Porting notes (optional)
In other proof assistants, it might be necessary to explicitly define the complex numbers and the algebraic numbers first, along with suitable definitions for the ring operations. The proof strategy remains the same: verify that the algebraic numbers satisfy the subring axioms. Depending on the automation available, some of the steps (e.g., proving that 0 and 1 are algebraic) may require more manual intervention.


---

## algebraic_number_sum

### Name of formal statement
algebraic_number_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let algebraic_number_sum = prove(`
  !f S.
  FINITE S ==>
  (!s:X. s IN S ==> algebraic_number (f s)) ==>
  algebraic_number (ring_sum complex_ring S f)
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;complex_ring_clauses] THEN
    qed[algebraic_number_ZinC;num_in_ZinC]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[RING_SUM_CLAUSES;in_complex_ring] THEN
    rw[complex_ring_clauses] THEN
    qed[algebraic_number_add]
  ]
);;
```
### Informal statement
For all functions `f` and sets `S`, if `S` is finite and for all `s` in `S`, `f(s)` is an algebraic number, then the sum of `f(s)` over `S` (denoted `ring_sum complex_ring S f`) is also an algebraic number.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- **Base Case:** If `S` is empty, then `ring_sum complex_ring S f` is zero, so we must show that zero is an algebraic number. This uses `algebraic_number_ZinC` and `num_in_ZinC`.
- **Inductive Step:** Given an element `x` and a set `S`, assume `S` is finite, and for all `s` in `x INSERT S`, `f(s)` is an algebraic number. Also assume that for any subset `T` of `S`, if for all `t` in `T`, `f(t)` is algebraic, then `ring_sum complex_ring T f` is algebraic. We want to show that `ring_sum complex_ring (x INSERT S) f` is algebraic. By definition of `ring_sum`, `ring_sum complex_ring (x INSERT S) f` is equivalent to `f(x) + ring_sum complex_ring S f`. Since `f(x)` is algebraic by the assumption `(!s:X. s IN S ==> algebraic_number (f s))`, and `ring_sum complex_ring S f` is algebraic by the inductive hypothesis, and addition of algebraic numbers is algebraic (using `algebraic_number_add`), the sum is algebraic.

### Mathematical insight
This theorem establishes that the algebraic numbers form a ring, specifically that they are closed under finite sums. This is a fundamental property of algebraic numbers and is essential in many algebraic arguments.

### Dependencies
- `FINITE`
- `algebraic_number`
- `ring_sum`
- `complex_ring`
- `algebraic_number_ZinC`
- `num_in_ZinC`
- `algebraic_number_add`
- `RING_SUM_CLAUSES`
- `complex_ring_clauses`

### Porting notes (optional)
The main challenge might be in adapting the `ring_sum` construction, which may have different counterparts in other proof assistants. The `FINITE_INDUCT_STRONG` tactic may need to be emulated using an appropriate induction principle. The automation present in `GEN_TAC` may need manual expansion.


---

## expformal

### Name of formal statement
expformal

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let expformal = new_definition `
  expformal (c:complex)
  = series_from_coeffs (\n. c pow n / Cx(&(FACT n)))
`;;
```
### Informal statement
The exponential function `expformal` of a complex number `c` is defined as the power series whose coefficients are given by the sequence where the n-th term is `c` raised to the power `n` divided by the factorial of `n`.

### Informal sketch
The definition of `expformal` is given directly by the power series representation of the exponential function. It involves defining `expformal c` as the series formed from the coefficient sequence `(\n. c pow n / Cx(&(FACT n)))`. This does not involve a proof but rather the introduction of a new definition binding the identifier `expformal` to this series.

### Mathematical insight
This definition provides a formal way to define the exponential function for complex numbers as an infinite sum represented by a power series. This definition is important as it allows one to reason formally about the exponential function using the properties of power series and complex numbers. This definition can be used to derive important properties of `expformal`, such as its derivative, its relationship to trigonometric functions (Euler's formula), and its role in defining other complex functions.

### Dependencies
- Definitions:
  - `series_from_coeffs`
  - `pow`
  - `Cx`
  - `FACT`


---

## mul_expformal

### Name of formal statement
mul_expformal

### Type of the formal statement
theorem

### Formal Content
```ocaml
let mul_expformal = prove(`
  !u v.
  poly_mul complex_ring (expformal u) (expformal v)
  = expformal (u+v)
`,
  intro THEN
  sufficesby eq_coeff THEN
  intro THEN
  rw[coeff_poly_mul_oneindex;expformal;coeff_series_from_coeffs] THEN
  rw[GSYM ring_pow_complex;GSYM complex_ring_clauses] THEN
  simp[RING_BINOMIAL_THEOREM;in_complex_ring] THEN
  simp[GSYM vsum_ring_sum_complex;FINITE_NUMSEG] THEN
  rw[complex_div] THEN
  simp[GSYM VSUM_COMPLEX_RMUL;FINITE_NUMSEG] THEN
  rw[GSYM complex_div] THEN
  sufficesby VSUM_EQ THEN
  intro THEN
  rw[BETA_THM] THEN
  have `x <= d:num` [IN_NUMSEG] THEN
  num_linear_fact `x <= d:num ==> (d-x)+x = d` THEN
  have `FACT(d-x) * FACT x * binom(d,x) = FACT d` [BINOM_FACT] THEN
  have `&(FACT(d-x)) * &(FACT x) * &(binom(d,x)) = &(FACT d):real` [REAL_OF_NUM_MUL] THEN
  have `Cx(&(FACT(d-x))) * Cx(&(FACT x)) * Cx(&(binom(d,x))) = Cx(&(FACT d))` [CX_MUL] THEN
  rw[complex_ring_clauses;ring_pow_complex] THEN
  rw[ring_of_num_complex;complex_of_num] THEN
  have `~(Cx(&(FACT d)) = Cx(&0))` [CX_INJ;REAL_OF_NUM_EQ;FACT_NZ] THEN
  complex_field_fact `
    ~(Cx(&(FACT d)) = Cx(&0)) ==>
    Cx(&(FACT(d-x))) * Cx(&(FACT x)) * Cx(&(binom(d,x))) = Cx(&(FACT d)) ==>
    u pow x / Cx (&(FACT x)) * v pow (d - x) / Cx (&(FACT (d - x))) = (Cx (&(binom (d,x))) * u pow x * v pow (d - x)) / Cx (&(FACT d))` THEN
  qed[]
);;
```
### Informal statement
For all complex numbers `u` and `v`, the polynomial multiplication of `expformal u` and `expformal v` in the complex ring is equal to `expformal (u+v)`.

### Informal sketch
The proof shows that the multiplication of two exponential formal power series `poly_mul complex_ring (expformal u) (expformal v)` results in another exponential formal power series `expformal (u+v)`.

- The proof starts by introducing the universal quantifiers for `u` and `v`.
- It suffices to show that corresponding coefficients are equal (`eq_coeff`).
- The proof rewrites using `coeff_poly_mul_oneindex`, `expformal`, and `coeff_series_from_coeffs` to express the coefficients of the polynomial multiplication.
- Rewrites with `GSYM ring_pow_complex` and `GSYM complex_ring_clauses` are applied for simplification.
- Simplification using `RING_BINOMIAL_THEOREM` and `in_complex_ring` follows.
- Simplification steps are performed using `GSYM vsum_ring_sum_complex` and `FINITE_NUMSEG`.
- `GSYM complex_div` rewrites are done.
- Simplifies using `GSYM VSUM_COMPLEX_RMUL` and `FINITE_NUMSEG`.
- Another `GSYM complex_div` rewrite is applied.
- It then suffices to show equality using `VSUM_EQ`.
- Introduction is performed to work with particular terms in the summation.
- The proof proceeds by applying `BETA_THM`.
- The fact `x <= d:num` is established within the numerical segment (`IN_NUMSEG`).
- Using `num_linear_fact`, we derive `(d-x)+x = d`.
- The combinatorial identity `FACT(d-x) * FACT x * binom(d,x) = FACT d` is invoked via `BINOM_FACT`.
- Next, `REAL_OF_NUM_MUL` proves `&(FACT(d-x)) * &(FACT x) * &(binom(d,x)) = &(FACT d):real`.
- `CX_MUL` is used to show `Cx(&(FACT(d-x))) * Cx(&(FACT x)) * Cx(&(binom(d,x))) = Cx(&(FACT d))`.
- Rewriting with `complex_ring_clauses` and `ring_pow_complex` occurs.
- `ring_of_num_complex` and `complex_of_num` are used for rewriting.
- Finally, `CX_INJ`,`REAL_OF_NUM_EQ` and `FACT_NZ` along with field facts relating multiplication and division of complex numbers, i.e., `complex_field_fact`, are used to complete the argument.

### Mathematical insight
This theorem establishes that the formal power series representing `exp(u) * exp(v)` is indeed `exp(u+v)`, where `expformal` constructs the formal power series representation `1 + u/1! + u^2/2! + ...`. The proof relies on the binomial theorem and careful manipulation of complex numbers and factorials.

### Dependencies
- `coeff_poly_mul_oneindex`
- `expformal`
- `coeff_series_from_coeffs`
- `ring_pow_complex`
- `complex_ring_clauses`
- `RING_BINOMIAL_THEOREM`
- `in_complex_ring`
- `vsum_ring_sum_complex`
- `FINITE_NUMSEG`
- `complex_div`
- `VSUM_COMPLEX_RMUL`
- `VSUM_EQ`
- `BETA_THM`
- `IN_NUMSEG`
- `num_linear_fact`
- `BINOM_FACT`
- `REAL_OF_NUM_MUL`
- `CX_MUL`
- `ring_of_num_complex`
- `complex_of_num`
- `CX_INJ`
- `REAL_OF_NUM_EQ`
- `FACT_NZ`
- `complex_field_fact`

### Porting notes (optional)
- The invocation of field facts (`complex_field_fact`) will need to be adapted based on the target proof assistant's field tactic or rewriting capabilities.
- The handling of numerical reasoning (e.g., `num_linear_fact`) and combinatorial identities (`BINOM_FACT`) might require specific libraries or theorems in the new environment.


---

## expformal_0

### Name of formal statement
expformal_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let expformal_0 = prove(`
  expformal(Cx(&0)) = poly_1 complex_ring
`,
  sufficesby eq_coeff THEN
  rw[expformal;coeff_series_from_coeffs;coeff_poly_1;complex_ring_clauses] THEN
  rw[COMPLEX_POW_ZERO] THEN
  intro THEN
  case `d = 0` THENL [
    simp[FACT] THEN
    CONV_TAC COMPLEX_FIELD
  ;
    simp[] THEN
    CONV_TAC COMPLEX_FIELD
  ]
);;
```
### Informal statement
The exponential formal power series `expformal` applied to the formal power series consisting of the constant complex number 0 (i.e., `Cx(&0)`) is equal to the formal power series `poly_1` over the complex numbers.

### Informal sketch
The proof proceeds as follows:
- First, the goal is transformed into proving the equality of coefficients using `eq_coeff`.
- Then, the definitions of `expformal`, `coeff_series_from_coeffs`, `coeff_poly_1`, and `complex_ring_clauses` are rewritten. The rewrite of the clauses of the `complex_ring` likely unfolds definitions related to the complex number field.
- Next, `COMPLEX_POW_ZERO` is rewritten.
- An introduction is performed. This likely introduces a variable `d` representing a natural number, corresponding to the index of the coefficient being considered.
- A case split is performed on whether `d` is equal to 0.
  - If `d = 0`, simplification with `FACT` (probably discharging an assumption that `d=0`) is performed. Then, the goal is solved using `COMPLEX_FIELD`, which presumably uses field arithmetic to establish the result.
  - If `d != 0`, simplification is performed. The goal is then solved using `COMPLEX_FIELD`.

### Mathematical insight
This theorem states that the exponential of the zero formal power series is the formal power series `poly_1`, which is the series whose 0-th coefficient is 1 and all other coefficients are 0. This corresponds to the fact that e^0 = 1. This is a fundamental property of the exponential function and its formal power series representation.

### Dependencies
- `expformal`
- `coeff_series_from_coeffs`
- `coeff_poly_1`
- `complex_ring_clauses`
- `COMPLEX_POW_ZERO`
- `eq_coeff`
- `COMPLEX_FIELD`


---

## pow_expformal

### Name of formal statement
pow_expformal

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_expformal = prove(`
  !u n.
  poly_pow complex_ring (expformal u) n
  = expformal (Cx(&n)*u)
`,
  GEN_TAC THEN INDUCT_TAC THENL [
    rw[poly_pow_0;COMPLEX_MUL_LZERO;expformal_0]
  ;
    rw[ARITH_RULE `SUC n = n + 1`] THEN
    simp[poly_pow_add;series_complex;poly_pow_1] THEN
    simp[GSYM REAL_OF_NUM_ADD;CX_ADD;COMPLEX_ADD_RDISTRIB;COMPLEX_MUL_LID;mul_expformal]
  ]
);;
```

### Informal statement
For all complex numbers `u` and natural numbers `n`, the `poly_pow` operation applied to `expformal u` with exponent `n` in the complex ring is equal to `expformal (Cx(real_of_num n) * u)`.

### Informal sketch
The proof proceeds by induction on `n`.

- Base case: `n = 0`. We need to show that `poly_pow complex_ring (expformal u) 0 = expformal (Cx(&0)*u)`. This follows directly from the definition of `poly_pow_0` which states `poly_pow ring x 0 = ring_one ring`, `COMPLEX_MUL_LZERO` which simplifies `Cx(&0)*u` to `Cx(&0)` and `expformal_0` which states that `expformal 0` is `Cx(&1)`.

- Inductive step: Assume `poly_pow complex_ring (expformal u) n = expformal (Cx(&n)*u)`. We want to show `poly_pow complex_ring (expformal u) (n + 1) = expformal (Cx(&(n + 1))*u)`. By rewriting the LHS using `ARITH_RULE` and `poly_pow_add`, we have `poly_pow complex_ring (expformal u) (SUC n) = poly_pow complex_ring (expformal u) n * expformal u`. Applying the induction hypothesis, we replace `poly_pow complex_ring (expformal u) n` with `expformal (Cx(&n)*u)`. Thus, we have `expformal (Cx(&n)*u) * expformal u`. Using the definition and simplification rules related to complex number operations (`series_complex`, `REAL_OF_NUM_ADD`, `CX_ADD`, `COMPLEX_ADD_RDISTRIB`, `COMPLEX_MUL_LID`) and the property `mul_expformal`, we obtain the desired result `expformal (Cx(&(n + 1))*u)`.

### Mathematical insight
The theorem relates the polynomial power of the exponential formal power series to the exponential formal power series of a scaled argument. It establishes that exponentiating the formal power series `expformal u` to the power `n` is equivalent to computing `expformal` on the scaled argument `n*u`, where `n` is treated as a complex number. This reflects a fundamental property of the exponential function.

### Dependencies
- `poly_pow_0`
- `COMPLEX_MUL_LZERO`
- `expformal_0`
- `poly_pow_add`
- `series_complex`
- `poly_pow_1`
- `REAL_OF_NUM_ADD`
- `CX_ADD`
- `COMPLEX_ADD_RDISTRIB`
- `COMPLEX_MUL_LID`
- `mul_expformal`


---

## product_expformal

### Name of formal statement
product_expformal

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_expformal = prove(`
  !c S.
  FINITE S ==>
  poly_product complex_ring S (\s:X. expformal (c s))
  = expformal (ring_sum complex_ring S c)
`,
  GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[poly_product_empty;RING_SUM_CLAUSES] THEN
    rw[expformal_0;complex_ring_clauses]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[poly_product_insert;RING_SUM_CLAUSES;in_complex_ring;series_complex] THEN
    qed[mul_expformal;complex_ring_clauses]
  ]
);;
```
### Informal statement
For all complex-valued functions `c` and all finite sets `S` of type `X`, the product of the `expformal` of `c s` over all `s` in `S` (using the `poly_product` function with respect to the `complex_ring` structure) is equal to the `expformal` of the sum of `c s` over all `s` in `S` (using the `ring_sum` function with respect to the `complex_ring` structure).

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: When `S` is empty, the product is the multiplicative identity (1), and the sum is the additive identity (0). The theorem follows directly from definition of `poly_product_empty`,  `RING_SUM_CLAUSES`, `expformal_0` and the ring properties (`complex_ring_clauses`).
- Inductive step: Assume the theorem holds for all subsets of `S`. We need to prove it for `INSERT x S`, where `x` is an element not in `S`. By definition, `poly_product complex_ring (INSERT x S) (\s. expformal (c s))` is equal to `expformal (c x) * poly_product complex_ring S (\s. expformal (c s))`. Similarly, `ring_sum complex_ring (INSERT x S) c = c x + ring_sum complex_ring S c`. Using the induction hypothesis `poly_product complex_ring S (\s. expformal (c s)) = expformal (ring_sum complex_ring S c)` and the theorem `mul_expformal` which says that `expformal (x + y) = expformal x * expformal y`. The goal `expformal (c x) * expformal (ring_sum complex_ring S c) = expformal (c x + ring_sum complex_ring S c)` can be proved.

### Mathematical insight
This theorem relates the exponential function of a sum to the product of exponentials, a fundamental property of exponentials over a ring. The `expformal` function represents a formal power series representation of the exponential, and this theorem demonstrates that this representation respects the expected algebraic properties.

### Dependencies
- `FINITE`
- `poly_product`
- `complex_ring`
- `expformal`
- `ring_sum`
- `poly_product_empty`
- `RING_SUM_CLAUSES`
- `expformal_0`
- `complex_ring_clauses`
- `poly_product_insert`
- `in_complex_ring`
- `series_complex`
- `mul_expformal`

### Porting notes (optional)
The main challenge for porting this theorem will be ensuring that the complex number library and the formal power series representation of the exponential function `expformal` are adequately defined in the target proof assistant. Also, the port should ensure that the `FINITE` predicate, the `poly_product` and `ring_sum` functions are defined and their properties are adequately supported in the target proof assistant.


---

## product_expformal_I

### Name of formal statement
product_expformal_I

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_expformal_I = prove(`
  !S.
  FINITE S ==>
  poly_product complex_ring S expformal
  = expformal (ring_sum complex_ring S I)
`,
  simp[GSYM product_expformal] THEN
  simp[I_THM] THEN
  intro THEN
  sufficesby poly_product_eq THEN
  qed[]
);;
```
### Informal statement
For any set `S`, if `S` is finite, then the product of `expformal` over `S` with respect to the `complex_ring` is equal to `expformal` applied to the sum of `I` over `S` with respect to the `complex_ring`.

### Informal sketch
The proof proceeds as follows:
- First, use `GSYM product_expformal` to rewrite the goal using the symmetric version of the theorem `product_expformal`. This likely transforms a sum into a product.
- Then, simplify using `I_THM`. This replaces `I` with the identity element of addition, namely 0.
- Introduce the universally quantified variable `S`.
- Suffice to show that the remaining equality holds using `poly_product_eq`.
- Finally, close the proof using `qed[]`.

### Mathematical insight
The theorem `product_expformal_I` relates the product of the formal exponential function `expformal` evaluated at the elements of a finite set `S` with the formal exponential function evaluated at the formal sum of the identity function `I` over the same set `S`. In essence, it states a formal analogue of the familiar exponential identity: exp(sum) = product(exp).

### Dependencies
- `product_expformal`
- `complex_ring`
- `FINITE`
- `I`
- `poly_product`
- `ring_sum`
- `I_THM`
- `poly_product_eq`


---

## expformal_powersums_QinC

### Name of formal statement
expformal_powersums_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let expformal_powersums_QinC = prove(`
  !S c:X->complex.
  FINITE S ==>
  (!n. ring_sum complex_ring S (\s:X. (c s) pow n) IN QinC) ==>
  ring_powerseries QinC_ring (poly_sum complex_ring S (\s:X. expformal (c s)))
`,
  GEN_TAC THEN GEN_TAC THEN DISCH_TAC THEN
  rw[coeff_series_in_ring] THEN
  simp[coeff_poly_sum;series_complex;expformal;coeff_series_from_coeffs;QinC_ring_clauses] THEN
  simp[GSYM vsum_ring_sum_complex] THEN
  rw[complex_div] THEN
  simp[VSUM_COMPLEX_RMUL] THEN
  rw[GSYM complex_div] THEN
  intro THEN
  have `~(FACT d = 0)` [FACT_NZ] THEN
  have `~(&(FACT d) = &0:real)` [REAL_OF_NUM_EQ] THEN
  have `~(Cx(&(FACT d)) = Cx(&0))` [CX_INJ] THEN
  have `Cx(&(FACT d)) IN QinC` [num_in_QinC] THEN
  qed[div_in_QinC]
);;
```

### Informal statement
For all sets `S` of type `X` and all functions `c` from `X` to the complex numbers, if `S` is finite and for all natural numbers `n`, the ring sum over `S` of `c(s)` raised to the power of `n` is in `QinC` (the field of complex numbers algebraic over the rationals), then the ring power series `poly_sum` over `S` of `expformal(c(s))` is in `QinC_ring`.

### Informal sketch
The proof aims to show that under the given conditions, the ring power series resulting from summing `expformal(c s)` over the set `S` is an element of `QinC_ring`.
- First, rewrite the goal using `coeff_series_in_ring`, reducing the problem to showing that the coefficients of the power series are in `QinC`.
- Simplify using `coeff_poly_sum`, `series_complex`, `expformal`, `coeff_series_from_coeffs`, and `QinC_ring_clauses`. This involves expanding the definitions and relating coefficients.
- Simplify using `GSYM vsum_ring_sum_complex`, essentially switching the order of summation.
- Apply `complex_div`, exposing the real and imaginary parts of the quotient.
- Simplify using `VSUM_COMPLEX_RMUL`, which relates to scalar multiplication.
- Apply `GSYM complex_div` to rewrite the division.
- Introduce a new assumption based on the denominator, and then proceed to show the denominator isn't equal to zero.
- Show `Cx(&(FACT d)) IN QinC` utilizing `num_in_QinC`. This asserts that the real number constructed from a natural number coerced to a complex number lies in `QinC`. This leverages that rational numbers are algebraic and contained in `QinC`.
- Finally, use `div_in_QinC` to conclude that the division resides within `QinC`.

### Mathematical insight
This theorem connects the algebraic properties of complex numbers, specifically belonging to the field of complex algebraic numbers `QinC`, with the summability of exponential functions. It proves that if certain power sums all lie inside `QinC`, then a power series formed by summing formal exponentials will also have components inside `QinC`. This is valuable in complex analysis and algebraic number theory, where characterizing fields and rings of power series is essential. The theorem demonstrates that algebraic closure is preserved under certain power series operations.

### Dependencies
- `coeff_series_in_ring`
- `coeff_poly_sum`
- `series_complex`
- `expformal`
- `coeff_series_from_coeffs`
- `QinC_ring_clauses`
- `GSYM vsum_ring_sum_complex`
- `complex_div`
- `VSUM_COMPLEX_RMUL`
- `GSYM complex_div`
- `num_in_QinC`
- `div_in_QinC`
- `CX_INJ`

### Porting notes (optional)
- When porting to a system with dependent types, ensure that the types are inferred appropriately or made explicit in the definition of `QinC` and `QinC_ring`.
- Pay close attention to how the system handles coercions between natural numbers, real numbers, and complex numbers. The proof relies on these conversions.
- The division by a constant involving complex numbers may require explicit handling in some systems.


---

## pow_expformal_powersums_QinC

### Name of formal statement
pow_expformal_powersums_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pow_expformal_powersums_QinC = prove(`
  !S m.
  FINITE S ==>
  (!n. ring_sum complex_ring S (\z. z pow n) IN QinC) ==>
  ring_powerseries QinC_ring (
    poly_sum complex_ring S (\z.
      poly_pow complex_ring (expformal z) m
    )
  )
`,
  intro THEN
  subgoal `!n. ring_sum complex_ring S (\z. (Cx(&m) * z) pow n) IN QinC` THENL [
    rw[COMPLEX_POW_MUL] THEN
    simp[GSYM vsum_ring_sum_complex] THEN
    simp[VSUM_COMPLEX_LMUL] THEN
    simp[vsum_ring_sum_complex] THEN
    intro THEN
    have `Cx(&m) IN QinC` [num_in_QinC] THEN
    have `Cx(&m) pow n IN QinC` [ring_pow_QinC;RING_POW;QinC_ring_clauses] THEN
    qed[mul_in_QinC]
  ; pass
  ] THEN
  rw[pow_expformal] THEN
  specialize[
    `S:complex->bool`;
    `\z:complex. Cx(&m) * z`
  ]expformal_powersums_QinC THEN
  qed[]
);;
```
### Informal statement
For any set `S` of complex numbers, and any natural number `m`, if `S` is finite and for all natural numbers `n`, the ring sum of `z pow n` for `z` in `S` is in `QinC`, then the ring powerseries with coefficients given by the polynomial sum over `S` of `(expformal z) pow m` is also in `QinC`.

### Informal sketch
The proof proceeds as follows:
- First, we prove the subgoal `!n. ring_sum complex_ring S (\z. (Cx(&m) * z) pow n) IN QinC`.
  - Rewrite `(Cx(&m) * z) pow n` as `Cx(&m) pow n * z pow n` using `COMPLEX_POW_MUL`.
  - Simplify using properties of `vsum_ring_sum_complex` and `VSUM_COMPLEX_LMUL`.
  - Show that `Cx(&m)` and therefore `Cx(&m) pow n` are in `QinC` using `num_in_QinC`, `ring_pow_QinC` and `RING_POW`; where `QinC` is the ring of complex numbers with rational real and imaginary parts. Also uses `QinC_ring_clauses` to ensure that `QinC` forms a ring.
  - Conclude that `Cx(&m) pow n * z pow n` is in `QinC` using `mul_in_QinC`.
- Then, rewrite `pow_expformal` with the appropriate instantiation of `S` and `\z:complex. Cx(&m) * z`.
- Lastly, close the goal using `qed[]`.

### Mathematical insight
The theorem relates the powers of the formal exponential series (`expformal`) to sums over finite sets of complex numbers. The condition `ring_sum complex_ring S (\z. z pow n) IN QinC` represents a constraint on the set `S`, ensuring that sums of powers of elements in `S` have rational real and imaginary parts. This property is then lifted to the polynomial ring generated by `expformal(z)` with appropriate modification to z based on m, preserving the `QinC` containment.

### Dependencies
- `COMPLEX_POW_MUL`
- `GSYM vsum_ring_sum_complex`
- `VSUM_COMPLEX_LMUL`
- `vsum_ring_sum_complex`
- `num_in_QinC`
- `ring_pow_QinC`
- `RING_POW`
- `QinC_ring_clauses`
- `mul_in_QinC`
- `pow_expformal`
- `QinC`
- `QinC_ring`
- `ring_sum`
- `complex_ring`
- `poly_sum`
- `poly_pow`
- `expformal`

### Porting notes (optional)
- The definition of `QinC` and theorems like `_in_QinC` might need to be recreated from scratch, depending on the target proof assistant's library.
- Tactics like `specialize` and `rw` may need adjustment to match the target proof assistant's rewriting and instantiation mechanisms.


---

## carrier_QinC_series_subring_generated_refl

### Name of formal statement
carrier_QinC_series_subring_generated_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let carrier_QinC_series_subring_generated_refl = prove(`
  ring_carrier(subring_generated
    (x_series complex_ring)
    (ring_carrier(x_series QinC_ring))
  )
  = ring_carrier(x_series QinC_ring)
`,
  sufficesby CARRIER_SUBRING_GENERATED_SUBRING THEN
  rw[subring_of] THEN
  rw[GSYM x_series_use] THEN
  intro THENL [
    rw[SUBSET;GSYM x_series_use] THEN
    qed[series_complex_if_series_QinC]
  ;
    qed[poly_0_QinC_eq_poly_0_complex;RING_POWERSERIES_0]
  ;
    qed[poly_1_QinC_eq_poly_1_complex;RING_POWERSERIES_1]
  ;
    qed[poly_neg_QinC_eq_poly_neg_complex;RING_POWERSERIES_NEG]
  ;
    qed[poly_add_QinC_eq_poly_add_complex;RING_POWERSERIES_ADD]
  ;
    qed[poly_mul_QinC_eq_poly_mul_complex;RING_POWERSERIES_MUL]
  ]
);;
```

### Informal statement
The carrier of the subring generated by the carrier of the formal power series ring with coefficients in QinC (quotient integers modulo c) within the formal power series ring with complex coefficients is equal to the carrier of the formal power series ring with coefficients in QinC.

### Informal sketch
The proof proceeds as follows:
- It suffices to show that the carrier of the formal power series ring with coefficients in QinC is a subring of the formal power series ring with complex coefficients. This is achieved by using `CARRIER_SUBRING_GENERATED_SUBRING`.
- The goal is rewritten to prove that the carrier of the formal power series ring with coefficients in QinC is a subset of the carrier of the formal power series ring with complex coefficients, and that 0, 1, negation, addition, and multiplication on the carrier of the formal power series ring with coefficients in QinC are the 0, 1, negation, addition, and multiplication operations when viewed as operations within the formal power series ring with complex coefficients.
- First, it is shown that the carrier of the formal power series with QinC coefficients is a subset of the carrier of the formal power series with complex coefficients by `series_complex_if_series_QinC`.
- It is then shown that the zero series of QinC is equal to that of complex using `poly_0_QinC_eq_poly_0_complex` and `RING_POWERSERIES_0`.
- Similarly for the unit series, using `poly_1_QinC_eq_poly_1_complex` and `RING_POWERSERIES_1`.
- Similarly for the negation operation, using `poly_neg_QinC_eq_poly_neg_complex` and `RING_POWERSERIES_NEG`.
- Similarly for the addition operation, using `poly_add_QinC_eq_poly_add_complex` and `RING_POWERSERIES_ADD`.
- Similarly for the multiplication operation, using `poly_mul_QinC_eq_poly_mul_complex` and `RING_POWERSERIES_MUL`.

### Mathematical insight
This theorem essentially states that any formal power series with `QinC` coefficients can also be viewed as a formal power series with complex coefficients and that restricting the subring generated to elements from `QinC` does not change the ring. The subring generated by the ring carrier of `x_series QinC_ring` is the same as the ring carrier of `x_series QinC_ring` itself. This justifies treating a formal power series over `QinC` as a subring inside the formal power series ring over the complexes. This is helpful because complex numbers have better analytic properties.

### Dependencies
- `CARRIER_SUBRING_GENERATED_SUBRING`
- `subring_of`
- `GSYM x_series_use`
- `SUBSET;GSYM x_series_use`
- `series_complex_if_series_QinC`
- `poly_0_QinC_eq_poly_0_complex`
- `RING_POWERSERIES_0`
- `poly_1_QinC_eq_poly_1_complex`
- `RING_POWERSERIES_1`
- `poly_neg_QinC_eq_poly_neg_complex`
- `RING_POWERSERIES_NEG`
- `poly_add_QinC_eq_poly_add_complex`
- `RING_POWERSERIES_ADD`
- `poly_mul_QinC_eq_poly_mul_complex`
- `RING_POWERSERIES_MUL`

### Porting notes (optional)
When porting, ensure that the ring structures and the notion of a subring generated are defined appropriately in the target proof assistant. The tactics used can be translated into corresponding proof strategies or commands in other proof assistants. The properties relating operations on series with `QinC` coefficients to those with complex coefficients are crucial and should be verified carefully.


---

## symfun_expformal_powersums_QinC

### Name of formal statement
symfun_expformal_powersums_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symfun_expformal_powersums_QinC = prove(`
  !S m.
  FINITE S ==>
  (!n. ring_sum complex_ring S (\z. z pow n) IN QinC) ==>
  poly_sum complex_ring
    {U | U SUBSET S /\ CARD U = m}
    (\U. poly_product complex_ring U expformal)
  IN ring_carrier(x_series QinC_ring)
`,
  intro THEN
  rw[poly_product] THEN
  rw[poly_sum] THEN
  recall ring_hasQ_subring_series_complex THEN
  have `!s. s IN S ==> expformal s IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  subgoal `!d. ring_sum (x_series complex_ring) S (\s. ring_pow (x_series complex_ring) (expformal s) d) IN ring_carrier (subring_generated (x_series complex_ring) (ring_carrier (x_series QinC_ring)))` THENL [
    intro THEN
    have `ring_powerseries QinC_ring (poly_sum complex_ring S (\z. poly_pow complex_ring (expformal z) d))` [pow_expformal_powersums_QinC] THEN
    have `ring_sum(x_series complex_ring) S (\z. poly_pow complex_ring (expformal z) d) IN ring_carrier(x_series QinC_ring)` [x_series_use;poly_sum] THEN
    have `ring_carrier(x_series QinC_ring) SUBSET ring_carrier(x_series complex_ring)` [x_series_use;series_complex_if_series_QinC;SUBSET] THEN
    have `ring_carrier(x_series QinC_ring) SUBSET ring_carrier (subring_generated (x_series complex_ring) (ring_carrier(x_series QinC_ring)))` [SUBSET_CARRIER_SUBRING_GENERATED;SUBSET_REFL] THEN
    rw[GSYM x_series_use_pow] THEN
    qed[SUBSET]
  ; pass
  ] THEN
  specialize[
    `x_series complex_ring`;
    `ring_carrier(x_series QinC_ring)`;
    `S:complex->bool`;
    `expformal`;
    `m:num`
  ]symfun_subring_if_powersums_subring THEN
  qed[carrier_QinC_series_subring_generated_refl]
);;
```
### Informal statement
For any finite set `S` of complex numbers, if for all natural numbers `n`, the sum of the `n`-th powers of the elements of `S` is a formal power series with coefficients in `QinC`, then the sum, over all subsets `U` of `S` of cardinality `m`, of the product of `expformal` applied to the elements of `U`, is a formal power series with coefficients in `QinC`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions: `S` is finite, and for any `n`, the sum of the `n`-th powers of elements in `S` are formal power series with coefficients in `QinC`.
- Rewrite the goal using the definitions of `poly_product` and `poly_sum`.
- Recall that `QinC` is a subring of the complex numbers.
- Show that for any `s` in `S`, `expformal s` is a formal power series with complex coefficients, using `series_complex` and `x_series_use`.
- Prove that the sum of the ring powers (in the ring of formal power series over the complex numbers) of `expformal s` to `d`, where `s` ranges over `S`, is in the subring generated by the formal power series with coefficients in `QinC`. This involves:
    - Introducing the assumption that this sum is in the carrier.
    - Showing that the ring powerseries of `QinC_ring` which takes the sum of the polynomial powers of `expformal z` to `d` for `z IN S` holds, using `pow_expformal_powersums_QinC`.
    - Showing the desired sum is in `ring_carrier(x_series QinC_ring)` using hypotheses and the substitution rule for `poly_sum`.
    - Proving `ring_carrier(x_series QinC_ring) SUBSET ring_carrier(x_series complex_ring)` using `x_series_use`, `series_complex_if_series_QinC` and `SUBSET`.
    - Showing `ring_carrier(x_series QinC_ring) SUBSET ring_carrier (subring_generated (x_series complex_ring) (ring_carrier(x_series QinC_ring)))` using `SUBSET_CARRIER_SUBRING_GENERATED` and `SUBSET_REFL`.
    - Rewriting using `x_series_use_pow` and completing the proof.
- Specialize the theorem `symfun_subring_if_powersums_subring` with the appropriate arguments.
- Complete the proof using `carrier_QinC_series_subring_generated_refl`.

### Mathematical insight
This theorem relates the symmetric functions formed by powersums to symmetric functions formed by elementary symmetric polynomials applied to `expformal`. It essentially states that if the power sums of a set of complex numbers have coefficients in `QinC`, then the elementary symmetric functions applied to `expformal` of those numbers also have coefficients in `QinC`. The importance stems from the study of symmetric functions and their relationship to ring properties.

### Dependencies
- `poly_product`
- `poly_sum`
- `ring_hasQ_subring_series_complex`
- `series_complex`
- `x_series_use`
- `pow_expformal_powersums_QinC`
- `x_series_use_pow`
- `series_complex_if_series_QinC`
- `SUBSET`
- `SUBSET_CARRIER_SUBRING_GENERATED`
- `SUBSET_REFL`
- `symfun_subring_if_powersums_subring`
- `carrier_QinC_series_subring_generated_refl`

### Porting notes (optional)
The notion of subrings and ring carriers require precise translation with potentially different naming conventions in other proof assistants. The `IN` operator corresponding to element membership will need to be handled according to the conventions in the respective theorem prover. The definition of `expformal` should be present.


---

## symfun_expformal_powersums_QinC_v2

### Name of formal statement
symfun_expformal_powersums_QinC_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symfun_expformal_powersums_QinC_v2 = prove(`
  !S m.
  FINITE S ==>
  (!n. ring_sum complex_ring S (\z. z pow n) IN QinC) ==>
  poly_sum complex_ring
    {U | U SUBSET S /\ CARD U = m}
    (\U. expformal (ring_sum complex_ring U I))
  IN ring_carrier(x_series QinC_ring)
`,
  intro THEN
  subgoal `poly_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. poly_product complex_ring U expformal) = poly_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. expformal (ring_sum complex_ring U I))` THENL [
    sufficesby poly_sum_eq THEN
    rw[IN_ELIM_THM] THEN
    intro THEN
    qed[FINITE_SUBSET;product_expformal_I]
  ; pass
  ] THEN
  qed[symfun_expformal_powersums_QinC]
);;
```
### Informal statement
For all sets `S` and natural numbers `m`, if `S` is finite and for all natural numbers `n`, the ring sum of `z pow n` over `S` is in `QinC`, then the poly sum over the set of `U` such that `U` is a subset of `S` and the cardinality of `U` is `m`, of `expformal` applied to the ring sum of `U` scaled by `I` is in the carrier of the `x_series` ring `QinC_ring`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite the goal by showing that `poly_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. poly_product complex_ring U expformal)` is equal to `poly_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. expformal (ring_sum complex_ring U I))`.
 - This is done by reducing the proof to showing that `poly_product complex_ring U expformal = expformal (ring_sum complex_ring U I)` for sets `U` that are finite subsets.
  - The condition `U SUBSET S /\ CARD U = m` ensures that `U` is necessarily finite so that we can simply invoke `FINITE_SUBSET` to establish finiteness and then `product_expformal_I` to establish the product-to-sum identity.
- Then, the proof concludes by invoking `symfun_expformal_powersums_QinC`.

### Mathematical insight
This theorem relates the ring sum of powers of elements in a set `S` with the poly sum of `expformal` applied to subsets of `S` scaled by `I`, with cardinality `m`, showing that it resides within the carrier of a specific `x_series` ring. This represents a relationship between symmetric functions and exponential formal power series.

### Dependencies
- `FINITE_SUBSET`
- `product_expformal_I`
- `symfun_expformal_powersums_QinC`
- `poly_sum_eq`
- `IN_ELIM_THM`


---

## symfun_expformal_powersums_QinC_v3

### Name of formal statement
symfun_expformal_powersums_QinC_v3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symfun_expformal_powersums_QinC_v3 = prove(`
  !S m d.
  FINITE S ==>
  (!n. ring_sum complex_ring S (\z. z pow n) IN QinC) ==>
  ring_sum complex_ring
    {U | U SUBSET S /\ CARD U = m}
    (\U. (ring_sum complex_ring U I) pow d)
  IN QinC
`,
  intro THEN
  have `poly_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. expformal (ring_sum complex_ring U I)) IN ring_carrier(x_series QinC_ring)` [symfun_expformal_powersums_QinC_v2] THEN
  have `coeff d (poly_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. expformal (ring_sum complex_ring U I))) IN QinC` [x_series_use;coeff_series_in_ring;QinC_ring_clauses] THEN
  specialize_assuming[
    `complex_ring`;
    `\U. expformal (ring_sum complex_ring U I)`;
    `d:num`;
    `{U:complex->bool | U SUBSET S /\ CARD U = m}`
  ]coeff_poly_sum THEN
  have `FINITE {U:complex->bool | U SUBSET S /\ CARD U = m}` [finite_subsets_card] THEN
  have `ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. coeff d (expformal (ring_sum complex_ring U I))) IN QinC` [series_complex] THEN
  subgoal `ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. coeff d (expformal (ring_sum complex_ring U I))) = ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d)))` THENL [
    sufficesby RING_SUM_EQ THEN
    qed[coeff_series_from_coeffs;expformal]
  ; pass
  ] THEN
  have `ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d))) IN QinC` [] THEN
  have `Cx(&(FACT d)) IN QinC` [num_in_QinC] THEN
  have `Cx(&(FACT d)) * ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d))) IN QinC` [mul_in_QinC] THEN
  have `Cx(&(FACT d)) * vsum {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d))) IN QinC` [vsum_ring_sum_complex] THEN
  subgoal `Cx(&(FACT d)) * vsum {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d))) = vsum {U | U SUBSET S /\ CARD U = m} (\U. Cx(&(FACT d)) * ((ring_sum complex_ring U I) pow d / Cx (&(FACT d))))` THENL [
    simp[VSUM_COMPLEX_LMUL]
  ; pass
  ] THEN
  have `vsum {U | U SUBSET S /\ CARD U = m} (\U. Cx(&(FACT d)) * ((ring_sum complex_ring U I) pow d / Cx (&(FACT d)))) IN QinC` [] THEN
  subgoal `vsum {U | U SUBSET S /\ CARD U = m} (\U. Cx (&(FACT d)) * ring_sum complex_ring U I pow d / Cx (&(FACT d))) = vsum {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I pow d)` THENL [
    sufficesby VSUM_EQ THEN
    intro THEN
    rw[BETA_THM] THEN
    have `~(FACT d = 0)` [FACT_NZ] THEN
    have `~(&(FACT d) = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&(FACT d)) = Cx(&0))` [CX_INJ] THEN
    complex_field_fact `~(Cx(&(FACT d)) = Cx(&0)) ==> Cx (&(FACT d)) * ring_sum complex_ring x I pow d / Cx (&(FACT d)) = ring_sum complex_ring x I pow d` THEN
    qed[]
  ; pass
  ] THEN
  qed[vsum_ring_sum_complex]
);;
```
### Informal statement
For any finite set `S` of complex numbers, if for all natural numbers `n`, the sum of the `n`-th powers of elements in `S` is a complex number in `QinC`, then for any natural numbers `m` and `d`, the sum of `d`-th powers of the sums of elements in all `m`-element subsets of `S` is also a complex number in `QinC`.

### Informal sketch
The proof proceeds by induction and leverages properties of formal power series.

- First, it's established that the polynomial sum of formal exponentials of sums over m-element subsets of `S` is in the ring carrier of `x_series QinC_ring` by appealing to `symfun_expformal_powersums_QinC_v2`.

- The coefficient of degree `d` of this polynomial sum is then shown to be in `QinC`. This relies on `x_series_use`, `coeff_series_in_ring`, and `QinC_ring_clauses`. It also involves specializing `coeff_poly_sum` appropriately and using the fact that the set of `m`-element subsets of `S` is finite (`finite_subsets_card`).

- Then, it's shown that the ring sum of these coefficients is in `QinC`, using `series_complex`.

- A crucial step involves relating the coefficient of the exponential series to the power. Specifically, it's proven that the ring sum of the coefficients `coeff d (expformal (ring_sum complex_ring U I))` is equal to `(ring_sum complex_ring U I) pow d / Cx (&(FACT d))`. This simplification relies on the fact that `coeff_series_from_coeffs` and `expformal` are properly linked.

- With this equivalence the ring sum of `(ring_sum complex_ring U I) pow d / Cx (&(FACT d))` is inferred to be in `QinC` for all `m`-element subsets `U` of `S`.

- Since `Cx(&(FACT d))` is in `QinC` by `num_in_QinC`, it logically follows that `Cx(&(FACT d)) * ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d)))` is in `QinC`.

- Next, the proof uses `vsum_ring_sum_complex` to convert this expression into `Cx(&(FACT d)) * vsum {U | U SUBSET S /\ CARD U = m} (\U. (ring_sum complex_ring U I) pow d / Cx (&(FACT d))) IN QinC`.

- After that `VSUM_COMPLEX_LMUL` is used to rewrite the expression such that it can be simplified using a field fact: i.e. the constants `Cx(&(FACT d))` can be divided from the `ring_sum`.

- Finally, the step applies `vsum_ring_sum_complex` once more to complete the linkage.

### Mathematical insight
This theorem connects the sums of powers of elements in a set to sums of powers of sums of subsets. The condition "in QinC" likely refers to some algebraic or number-theoretic property and the theorem provides constraints under which the `QinC` property is maintained when passing from sets to sums over subsets. The usage of formal power series (`expformal`) is a common technique in combinatorics and algebra to encode and manipulate sums of this type.

### Dependencies
- Theorems: `symfun_expformal_powersums_QinC_v2`, `coeff_series_in_ring`, `FACT_NZ`, `REAL_OF_NUM_EQ`, `CX_INJ`
- Definitions: `FINITE`, `SUBSET`, `CARD`, `ring_sum`, `QINC`, `I`, `pow`, `complex_ring`, `x_series`, `expformal`, `coeff`, `num_in_QinC`, `vsum`,
- Tactics: `intro`, `specialize_assuming`, `sufficesby`, `qed`, `pass`, `simp`, `rw`, `complex_field_fact`
- HOL Light lemmas: `finite_subsets_card`, `series_complex`, `VSUM_COMPLEX_LMUL`, `VSUM_EQ`, `coeff_series_from_coeffs`, `BETA_THM`, `CX_INJ`, `FACT_NZ`, `REAL_OF_NUM_EQ`, `vsum_ring_sum_complex`, `mul_in_QinC`, `num_in_QinC`
- Ring clauses:`QinC_ring_clauses`

### Porting notes (optional)
- The theorem relies on the definition and properties of `QinC`, a concept related to the complex numbers
- The definitions of `ring_sum` and other ring-theoretic notions need to be available when porting this.
- A key step involves reasoning about coefficients of formal power series; make sure that the target proof assistant has similar functionality.
- Specifically implementing `expformal` and `coeff` would need to capture the properties of formal power series.
- The proof involves rewriting using the BETA_THM, which may have different names or conventions in other proof assistants.
- Pay attention to how finiteness is handled in the target system in regards to `FINITE S` and `finite_subsets_card`


---

## resolvent_if_powersums_QinC

### Name of formal statement
resolvent_if_powersums_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let resolvent_if_powersums_QinC = prove(`
  !S m.
  FINITE S ==>
  (!n. ring_sum complex_ring S (\z. z pow n) IN QinC) ==>
  ring_polynomial QinC_ring (
    monic_vanishing_at complex_ring
      {U | U SUBSET S /\ CARD U = m}
      (\U. ring_sum complex_ring U I)
  )
`,
  intro THEN
  have `ring_hasQ (subring_generated complex_ring QinC)` [ring_hasQ_QinC;subring_complex_QinC] THEN
  specialize[`S:complex->bool`;`m:num`]finite_subsets_card THEN
  have `!s. s IN {U | U SUBSET S /\ CARD U = m} ==> ring_sum complex_ring s I IN ring_carrier complex_ring` [in_complex_ring] THEN
  subgoal `!d. ring_sum complex_ring {U | U SUBSET S /\ CARD U = m} (\s. ring_pow complex_ring (ring_sum complex_ring s I) d) IN ring_carrier (subring_generated complex_ring QinC)` THENL [
    rw[ring_pow_complex] THEN
    qed[symfun_expformal_powersums_QinC_v3;QinC_ring_clauses;subring_complex_QinC]
  ; pass
  ] THEN
  specialize[
    `complex_ring`;
    `QinC`;
    `{U:complex->bool | U SUBSET S /\ CARD U = m}`;
    `\U. ring_sum complex_ring U I`
  ]poly_subring_if_powersums_subring THEN
  qed[subring_complex_QinC]
);;
```
### Informal statement
For any set `S` of complex numbers and any natural number `m`, if `S` is finite and the sum of the `n`-th powers of the elements of `S` is in `QinC` (the field of rationals extended with the imaginary unit) for all natural numbers `n`, then the polynomial whose roots are the sums of all `m`-element subsets of `S` is a polynomial over `QinC`. More precisely, the monic polynomial vanishing at the set of sums of all `m`-element subsets of `S` has coefficients in `QinC`.

### Informal sketch
The proof proceeds as follows:

- Start with the assumptions that `S` is a finite set of complex numbers and that for all `n`, the sum of the `n`-th powers of elements in `S` is in `QinC`. We also have `ring_hasQ (subring_generated complex_ring QinC)` to assure that `QinC` has the `Q` property as being a subring generated.
- Show that if `s` is an `m`-element subset of `S`, then the sum of its elements is in the carrier of the complex ring.
- The key step is to prove by induction on `d` that the sum of the `d`-th powers of the sums of all `m`-element subsets of `S` is in the ring carrier of the subring generated by `QinC`. The base case `d = 0` is trivial and requires `ring_pow_complex` to rewrite the power. The inductive step uses `symfun_expformal_powersums_QinC_v3`, which states that the sums of powers of elementary symmetric functions lie in `QinC` if the formal power sums do. We also use `QinC_ring_clauses` to show that `QinC` is a ring and use `subring_complex_QinC` to show that any element of `QinC` lies within the carrier of `complex_ring`.
- Apply `poly_subring_if_powersums_subring`, where we specialize the complex ring, `QinC` subring, the set of `m`-element subsets of `S`, and the function that sums the `m`-element subsets.
- Finally, we discharge the subring goal using `subring_complex_QinC`.

### Mathematical insight
This theorem connects the algebraic property of `QinC` with the symmetric sums of powers of elements in a finite set. It essentially states that if the power sums of the elements of a finite set `S` lie in `QinC`, then the elementary symmetric functions of these elements (specifically, the sums of all `m`-element subsets) also determine a polynomial with coefficients in `QinC`. This is useful in Galois theory, where the roots of a polynomial determine the field extension generated by these roots.

### Dependencies
- `ring_hasQ_QinC`
- `subring_complex_QinC`
- `finite_subsets_card`
- `in_complex_ring`
- `ring_pow_complex`
- `symfun_expformal_powersums_QinC_v3`
- `QinC_ring_clauses`
- `poly_subring_if_powersums_subring`

### Porting notes (optional)
- The theorem uses higher-order features (set comprehension, lambda abstraction).
- The arithmetic simplification and rewriting in the proof relies on the underlying algebraic structure defined through `ring_theory`.
- The `symfun_expformal_powersums_QinC_v3` theorem is particularly important and might require a substantial effort to port.


---

## resolvent_if_poly_QinC

### Name of formal statement
resolvent_if_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let resolvent_if_poly_QinC = prove(`
  !S m.
  FINITE S ==>
  ring_polynomial QinC_ring (
    monic_vanishing_at complex_ring S I
  ) ==>
  ring_polynomial QinC_ring (
    monic_vanishing_at complex_ring
      {U | U SUBSET S /\ CARD U = m}
      (\U. ring_sum complex_ring U I)
  )
`,
  intro THEN
  subgoal `!n. ring_sum complex_ring S (\z. z pow n) IN QinC` THENL [
    intro THEN
    specialize_assuming[
      `complex_ring`;
      `QinC`;
      `S:complex->bool`;
      `I:complex->complex`;
      `n:num`
    ]powersums_subring_if_poly_subring THEN
    have `!n. coeff n (monic_vanishing_at complex_ring S I) IN ring_carrier(subring_generated complex_ring QinC)` [subring_complex_QinC;coeff_poly_in_ring] THEN
    have `ring_sum complex_ring S (\s. ring_pow complex_ring (I s) n) IN ring_carrier (subring_generated complex_ring QinC)` [in_complex_ring] THEN
    subgoal `ring_sum complex_ring S (\s. ring_pow complex_ring (I s) n) = ring_sum complex_ring S (\z. z pow n)` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM;I_THM;ring_pow_complex]
    ; pass
    ] THEN
    qed[subring_complex_QinC;QinC_ring_clauses]
  ; pass
  ] THEN
  qed[resolvent_if_powersums_QinC]
);;
```

### Informal statement
For any finite set `S` of complex numbers, if the monic polynomial `monic_vanishing_at complex_ring S I` vanishes on `S` and has all its coefficients in `QinC`, then the monic polynomial `monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I)` vanishes on the set of sums of `m`-sized subsets of `S` and has all its coefficients in `QinC`.

### Informal sketch
The proof proceeds by induction and builds on the theorem `resolvent_if_powersums_QinC`. The core idea is to show that if power sums of elements in `S` are in `QinC`, then the coefficients of the polynomial `monic_vanishing_at` constructed from sums of m-sized subsets of `S` will also be in `QinC`.

- Intro: Introduce assumptions.
- Subgoal: Prove that `ring_sum complex_ring S (\z. z pow n)` is in `QinC` for any `n`.
  - Intro: Introduce additional assumptions.
  - Specialize `powersums_subring_if_poly_subring` with specific arguments.
  - Obtain `!n. coeff n (monic_vanishing_at complex_ring S I) IN ring_carrier(subring_generated complex_ring QinC)` from `subring_complex_QinC` and `coeff_poly_in_ring`.
  - Obtain `ring_sum complex_ring S (\s. ring_pow complex_ring (I s) n) IN ring_carrier (subring_generated complex_ring QinC)` from `in_complex_ring`.
    - Show that `ring_sum complex_ring S (\s. ring_pow complex_ring (I s) n) = ring_sum complex_ring S (\z. z pow n)`:
      - Rewrite using `BETA_THM`, `I_THM` and `ring_pow_complex`.
  - Conclude using `subring_complex_QinC` and `QinC_ring_clauses`.
- Conclude using `resolvent_if_powersums_QinC`

### Mathematical insight
This theorem provides a condition under which the resolvent polynomial (the polynomial whose roots are sums of subsets of the roots of another polynomial) has coefficients in a set `QinC` where `QinC` is a subring of the complex numbers. This is useful in algebraic number theory where we care about properties like integrality of algebraic numbers.

### Dependencies
- ring_sum
- complex_ring
- QinC_ring
- monic_vanishing_at
- resolvent_if_powersums_QinC
- powersums_subring_if_poly_subring
- subring_complex_QinC
- ring_pow_complex
- in_complex_ring
- I_THM


---

## prod_resolvent_if_poly_QinC_lemma

### Name of formal statement
prod_resolvent_if_poly_QinC_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let prod_resolvent_if_poly_QinC_lemma = prove(`
  !S.
  FINITE S ==>
  monic_vanishing_at complex_ring
    {U | U SUBSET S}
    (\U. ring_sum complex_ring U I)
  =
  poly_product complex_ring (0..CARD S) (\m.
    monic_vanishing_at complex_ring
      {U | U SUBSET S /\ CARD U = m}
      (\U. ring_sum complex_ring U I)
  )
`,
  intro THEN
  rw[poly_product;monic_vanishing_at] THEN
  have `IMAGE CARD {U:complex->bool | U SUBSET S} = (0..CARD S)` [image_card_powerset] THEN
  have `FINITE {A | A SUBSET S:complex->bool}` [FINITE_POWERSET] THEN
  specialize[
    `x_series complex_ring`;
    `CARD:(complex->bool)->num`;
    `\s. x_minus_const complex_ring (ring_sum complex_ring s I)`;
    `{U:complex->bool | U SUBSET S}`
  ]RING_PRODUCT_IMAGE_GEN THEN
  simp[] THEN
  sufficesby RING_PRODUCT_EQ THEN
  intro THEN
  rw[BETA_THM] THEN
  set_fact `{x:complex->bool | x IN {U | U SUBSET S} /\ CARD x = a} = {U | U SUBSET S /\ CARD U = a}` THEN
  qed[]
);;
```

### Informal statement
For any finite set `S` of complex numbers, the monic polynomial that vanishes precisely on the sets of numbers, each of which is the sum of the elements of a subset `U` of `S` (where `I` is the identity element in the complex ring), is equal to the product of polynomials ranging from `0` to the cardinality of `S`, where each factor in this product is the monic polynomial that vanishes precisely on the sums `ring_sum complex_ring U I` for subsets `U` of `S` with a fixed cardinality `m`.

### Informal sketch
The proof proceeds as follows:
- Start with the goal and rewrite using the definitions of `poly_product` and `monic_vanishing_at`.
- Prove that the image of the cardinality function applied to the set of subsets of S is equal to the range from 0 to the cardinality of `S`, using the lemma `image_card_powerset`.
- Derive that the set of subsets of S is finite, using `FINITE_POWERSET`.
- Use `RING_PRODUCT_IMAGE_GEN` to rewrite the product. The rewriting involves specializing `x_series complex_ring`, `CARD:(complex->bool)->num`, `\s. x_minus_const complex_ring (ring_sum complex_ring s I)`, and `{U:complex->bool | U SUBSET S}`.
- Simplify.
- It suffices to prove an equality condition for ring products (`RING_PRODUCT_EQ`).
- Introduce a hypothesis.
- Apply BETA reduction and set `{x:complex->bool | x IN {U | U SUBSET S} /\ CARD x = a} = {U | U SUBSET S /\ CARD x = a}`.
- Conclude the proof.

### Mathematical insight
This theorem relates the monic polynomial vanishing on the sums of subsets of a finite set `S` to a product of monic polynomials each vanishing on sums of subsets of `S` with the same cardinality. This decomposition may express a critical property of resolvents or other computations.

### Dependencies
- `FINITE_POWERSET`
- `image_card_powerset`
- `RING_PRODUCT_IMAGE_GEN`
- `RING_PRODUCT_EQ`
- `poly_product`
- `monic_vanishing_at`
- `BETA_THM`

### Porting notes (optional)
The `RING_PRODUCT_IMAGE_GEN` theorem is crucial, and its analogue would be needed in other systems. Also, the handling of finiteness conditions may vary between provers.


---

## prod_resolvent_if_poly_QinC

### Name of formal statement
prod_resolvent_if_poly_QinC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let prod_resolvent_if_poly_QinC = prove(`
  !S.
  FINITE S ==>
  ring_polynomial QinC_ring (
    monic_vanishing_at complex_ring S I
  ) ==>
  ring_polynomial QinC_ring (
    monic_vanishing_at complex_ring
      {U | U SUBSET S}
      (\U. ring_sum complex_ring U I)
  )
`,
  intro THEN
  simp[prod_resolvent_if_poly_QinC_lemma] THEN
  have `FINITE (0..CARD(S:complex->bool))` [FINITE_NUMSEG] THEN
  have `!m. m IN 0..CARD S ==> ring_polynomial QinC_ring (monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I))` [resolvent_if_poly_QinC] THEN
  have `poly_product complex_ring (0..CARD S) (\m. monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I)) = poly_product QinC_ring (0..CARD S) (\m. monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I))` [subring_complex_QinC;poly_product_subring;ring_polynomial] THEN
  simp[] THEN
  qed[poly_product_poly]
);;
```

### Informal statement
For all sets `S` of complex numbers, if `S` is finite, and the ring polynomial over the QinC ring `monic_vanishing_at complex_ring S I` (i.e., the monic polynomial vanishing at `S` with variable `I`) holds, then the ring polynomial over the QinC ring `monic_vanishing_at complex_ring {U | U SUBSET S} (\U. ring_sum complex_ring U I)` holds, where the variable is the ring sum over `U` i.e., the monic-vanishing polynomial vanishes on the set of all sums of subsets of `S` is a ring polynomial over QinC.

### Informal sketch
The proof proceeds as follows:
- Introduce the hypothesis and simplify using `prod_resolvent_if_poly_QinC_lemma`.
- Establish that the range of `0..CARD(S)` is finite using `FINITE_NUMSEG`.
- Prove the statement `!m. m IN 0..CARD S ==> ring_polynomial QinC_ring (monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I))` using `resolvent_if_poly_QinC`. This establishes that we have a polynomial for each subset of `S` of size `m`.
- Show that `poly_product complex_ring (0..CARD S) (\m. monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I)) = poly_product QinC_ring (0..CARD S) (\m. monic_vanishing_at complex_ring {U | U SUBSET S /\ CARD U = m} (\U. ring_sum complex_ring U I))` using the theorems `subring_complex_QinC`, `poly_product_subring`, and `ring_polynomial`.  This shows that the product of the polynomials over complex numbers is equal to the product of the polynomials over the `QinC` ring.
- Simplify the current goal.
- Finally, derive the conclusion using `poly_product_poly`.

### Mathematical insight
The theorem establishes that if a monic polynomial vanishing at all elements of a finite set `S` is a ring polynomial over `QinC`, then so is the monic polynomial vanishing at the sums of all subsets of `S`. The proof relies on establishing that the product of monic polynomials vanishing at subsets of `S` of a given size `m` is a ring polynomial over `QinC`.

### Dependencies
- Theorems:
    - `prod_resolvent_if_poly_QinC_lemma`
    - `FINITE_NUMSEG`
    - `resolvent_if_poly_QinC`
    - `subring_complex_QinC`
    - `poly_product_subring`
    - `ring_polynomial`
    - `poly_product_poly`


---

## pi_is_transcendental

### Name of formal statement
pi_is_transcendental

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pi_is_transcendental = prove(`
  ~(algebraic_number(Cx pi))
`,
  intro THEN
  recall algebraic_number_ii THEN
  have `algebraic_number (ii * Cx pi)` [algebraic_number_mul] THEN
  choose `f:(1->num)->complex` `ring_polynomial QinC_ring f /\ ~(f = poly_0 QinC_ring) /\ monic QinC_ring f /\ ring_irreducible(x_poly QinC_ring) f /\ poly_eval complex_ring f (ii * Cx pi) = Cx(&0)` [algebraic_number_is_root_monic_irreducible_QinC_poly] THEN
  recall CEXP_II_PI THEN
  complex_field_fact `cexp (ii * Cx pi) = --Cx (&1) ==> Cx(&1) + cexp(ii * Cx pi) = Cx(&0)` THEN
  have `complex_root f (ii * Cx pi)` [complex_root] THEN
  have `FINITE (complex_root f)` [distinct_minpolys_finite_root_simple] THEN
  subgoal `ring_product complex_ring (complex_root f) (\z. Cx(&1) + cexp z) = Cx(&0)` THENL [
    specialize_assuming[
      `complex_ring`;
      `complex_root f`;
      `ii * Cx pi`;
      `\z. Cx(&1) + cexp z`
    ]ring_product_delete THEN
    have `ring_product complex_ring (complex_root f) (\z. Cx (&1) + cexp z) = ring_mul complex_ring (Cx (&1) + cexp (ii * Cx pi)) (ring_product complex_ring (complex_root f DELETE (ii * Cx pi)) (\z. Cx (&1) + cexp z))` [IN;in_complex_ring] THEN
    simp[complex_ring_clauses;COMPLEX_MUL_LZERO]
  ; pass
  ] THEN
  subgoal `ring_product complex_ring (complex_root f) (\z. Cx(&1) + cexp z) = ring_sum complex_ring {S | S SUBSET complex_root f} (\S. ring_product complex_ring S cexp)` THENL [
    rw[GSYM complex_ring_clauses] THEN
    specialize_assuming[
      `complex_ring`;
      `cexp`;
      `complex_root f`
    ]ring_product_1_plus_expand THEN
    qed[in_complex_ring]
  ; pass
  ] THEN
  have `ring_sum complex_ring {S | S SUBSET complex_root f} (\S. ring_product complex_ring S cexp) = Cx(&0)` [] THEN
  subgoal `ring_sum complex_ring {S | S SUBSET complex_root f} (\S. ring_product complex_ring S cexp) = ring_sum complex_ring {S | S SUBSET complex_root f} (\S. cexp (ring_sum complex_ring S I))` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;IN_ELIM_THM] THEN
    intro THEN
    have `FINITE(a:complex->bool)` [FINITE_SUBSET] THEN
    simp[GSYM vsum_ring_sum_complex;GSYM cproduct_ring_product_complex;CEXP_VSUM;I_THM]
  ; pass
  ] THEN
  have `ring_sum complex_ring {S | S SUBSET complex_root f} (\S. cexp (ring_sum complex_ring S I)) = Cx(&0)` [] THEN
  have `monic_vanishing_at complex_ring (complex_root f) I = f` [distinct_minpolys_monic_vanishing_at_simple] THEN
  have `ring_polynomial QinC_ring (monic_vanishing_at complex_ring (complex_root f) I)` [] THEN
  specialize[`complex_root f`]prod_resolvent_if_poly_QinC THEN
  have `ring_polynomial complex_ring (monic_vanishing_at complex_ring (complex_root f) I)` [monic_vanishing_at_poly;in_complex_ring] THEN
  have `~(monic_vanishing_at complex_ring (complex_root f) I = poly_0 complex_ring)` [monic_vanishing_at_monic;monic_poly_0;ring_1_0_complex;in_complex_ring] THEN
  have `FINITE(complex_root f)` [complex_root_le_deg] THEN
  specialize[`complex_root f`]FINITE_POWERSET THEN
  specialize[
    `{U | U SUBSET complex_root f}`;
    `\U. ring_sum complex_ring U I`
  ]transcendence_all_0_QinC_monic_vanishing_at THEN
  ASM SET_TAC[]
);;
```
### Informal statement
It is not the case that `pi` is an algebraic number as a complex number.

### Informal sketch
The proof proceeds by contradiction. We assume that `Cx pi` is algebraic.

*   Then `ii * Cx pi` is algebraic, where `ii` is the imaginary unit.
*   This means there exists a monic, irreducible polynomial `f` in `QinC_ring` (a ring of polynomials) such that `f(ii * Cx pi) = 0`.
*   Since `cexp (ii * Cx pi) = -1`, therefore `1 + cexp (ii * Cx pi) = 0`.
*   We consider the polynomial `f`, and `complex_root f` is a finite set.
*   We consider the product `ring_product complex_ring (complex_root f) (\z. Cx(&1) + cexp z)`. A key step involves deleting `ii * Cx pi` from `complex_root f`. This vanishes to zero since it contains a zero factor.
*   We also expand the product  `ring_product complex_ring (complex_root f) (\z. Cx(&1) + cexp z)` into a sum `ring_sum complex_ring {S | S SUBSET complex_root f} (\S. ring_product complex_ring S cexp)`.
*   We rewrite the inner product to have the form `cexp (ring_sum complex_ring S I)`.
*   We use `monic_vanishing_at complex_ring (complex_root f) I = f`, and we obtain contradictions based on the fact that `f` does not equal to `poly_0 complex_ring`.
*   Then we specialize `transcendence_all_0_QinC_monic_vanishing_at`.
*   We arrive at a contradiction, thus `Cx pi` is not an algebraic number.

### Mathematical insight
This theorem formalizes the fact that `pi` is a transcendental number, meaning it is not a root of any non-zero polynomial equation with rational coefficients. The proof involves constructing a contradiction based on the assumption that if `pi` were algebraic, then a related complex exponential expression would also need to satisfy certain algebraic constraints which ultimately leads to a contradiction.

### Dependencies
Key theorems and definitions used in the proof include:

*   `algebraic_number_ii`
*   `algebraic_number_mul`
*   `algebraic_number_is_root_monic_irreducible_QinC_poly`
*   `CEXP_II_PI`
*   `complex_field_fact`
*   `complex_root`
*   `distinct_minpolys_finite_root_simple`
*   `complex_ring_clauses`
*   `COMPLEX_MUL_LZERO`
*   `complex_ring_clauses`
*   `transcendence_all_0_QinC_monic_vanishing_at`
*   `FINITE_SUBSET`
*   `vsum_ring_sum_complex`
*   `cproduct_ring_product_complex`
*   `CEXP_VSUM`
*   `I_THM`
*   `distinct_minpolys_monic_vanishing_at_simple`
*   `monic_vanishing_at_poly`
*   `in_complex_ring`
*   `monic_vanishing_at_monic`
*   `monic_poly_0`
*   `ring_1_0_complex`
*   `complex_root_le_deg`
*   `prod_resolvent_if_poly_QinC`

### Porting notes (optional)
*   The proof relies heavily on HOL Light's algebraic simplification and rewriting capabilities, especially `ring_sum`, `ring_product`, `QinC_ring`, and complex number arithmetic. Ensure the target proof assistant has comparable algebraic and complex number support.
*   The handling of complex root sets and their finiteness (`FINITE (complex_root f)`) is important. Make sure the target assistant has suitable set theory support.
*   The `transcendence_all_0_QinC_monic_vanishing_at` is a crucial step. Its definition and associated theorems need to be available or translated carefully.
*   The tactic `ASM SET_TAC[]` might need to be translated to another contradiction finding tool.


---

## monomial_pow

### Name of formal statement
monomial_pow

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let monomial_pow = new_definition `
  monomial_pow (m:V->num) (e:num)
  = (\v. e * m v)
`;;
```
### Informal statement
The function `monomial_pow` takes a monomial `m` (which is a function from variables of type `V` to numbers) and a number `e`, and returns a new monomial. The new monomial maps each variable `v` to the value `e * m v`, where `e * m v` is the product of the number `e` and the value of the original monomial `m` at variable `v`.

### Informal sketch
- The definition `monomial_pow` defines the pointwise multiplication of a monomial by a scalar. It takes a monomial `m` and a scalar `e` as inputs.
- The function returns a new monomial which, when evaluated at `v`, is equal to the product of `e` and the value of the original monomial `m` evaluated at `v`.
- This is definitional and hence does not require a proof.

### Mathematical insight
This definition provides a way to scale monomials, which is a fundamental operation when dealing with polynomials. It takes a monomial (represented as a function from variables to coefficients) and multiplies each coefficient by a scalar `e`. This operation is essential for manipulating and simplifying polynomial expressions.

### Dependencies
None


---

## monomial_product

### Name of formal statement
monomial_product

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let monomial_product = new_definition `
  monomial_product (S:X->bool) (m:X->V->num)
  = (\v. nsum S (\x. m x v))
`;;
```
### Informal statement
The `monomial_product` of a set `S` of type `X->bool` and a function `m` of type `X->V->num` is defined as the function that maps a value `v` of type `V` to the numerical sum of `m x v` for all `x` in `S`. In other words, it's a function from `V` to `num` obtained by summing `m x v` over all `x` that satisfy `S x`.

### Informal sketch
The definition introduces a term `monomial_product` as the sum of a function `m x v` across a set `S`.

- The definition uses `nsum S (\x. m x v)` which represents the sum of the numerical values `m x v` as `x` ranges over the elements of the set `S`.
- The outer lambda abstraction `(\v. ...)` ensures that the result is a function that accepts an argument `v` of type `V`.

### Mathematical insight
The `monomial_product` definition formalizes the concept of summing a function over a set, representing a generalized product. This is useful when you want to treat a family of terms as a single aggregated term in subsequent steps, for example, when defining polynomials.

### Dependencies
- `nsum`


---

## finite_monomial_vars_permutation

### Name of formal statement
finite_monomial_vars_permutation

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_monomial_vars_permutation = prove(`
  !m:V->num f:V->V.
  f permutes (:V) ==>
  (
    FINITE(monomial_vars (m o f)) <=>
    FINITE(monomial_vars m)
  )
`,
  rw[monomial_vars] THEN
  rw[permutes;IN_UNIV] THEN
  intro THEN
  subgoal `{i | ~(m i = 0)} = IMAGE (f:V->V) {i | ~((m o f) i = 0)}` THENL [
    rw[EXTENSION;in_image_vw;IN_ELIM_THM;o_DEF] THEN
    qed[]
  ; pass
  ] THEN
  choose `g:V->V` `(!y:V. f(g y) = y) /\ (!x:V. g(f x) = x)` [BIJECTIVE_LEFT_RIGHT_INVERSE] THEN
  subgoal `{i | ~((m o f) i = 0)} = IMAGE (g:V->V) {i | ~(m i = 0)}` THENL [
    rw[EXTENSION;in_image_vw;IN_ELIM_THM;o_DEF] THEN
    qed[]
  ; pass
  ] THEN
  qed[FINITE_IMAGE]
);;
```
### Informal statement
For all functions `m` from `V` to the natural numbers `num` and all functions `f` from `V` to `V`, if `f` permutes the set `V`, then the set of variables in the monomial `m` composed with `f` is finite if and only if the set of variables in the monomial `m` is finite.

### Informal sketch
The proof proceeds as follows:
- Start by rewriting `monomial_vars` to its definition. Then, use that `f` permutes `V` to rewrite the statement using `permutes` and `IN_UNIV`. This reduces the problem to proving the equivalence of two statements.
- Introduce the assumption `f` permutes `V`.
- Show that the set `{i | ~(m i = 0)}` is equal to the image of the set `{i | ~((m o f) i = 0)}` under the function `f`.  This is done by showing containment in both directions. The proof involves rewriting using `EXTENSION`, `in_image_vw`, `IN_ELIM_THM`, and the definition of function composition `o_DEF`.
- Since `f` permutes `V` there exists function `g` such that `f(g y) = y` and `g(f x) = x`.
- Show that the set `{i | ~((m o f) i = 0)}` is equal to the image of the set `{i | ~(m i = 0)}` under the function `g`. The proof involves rewriting using `EXTENSION`, `in_image_vw`, `IN_ELIM_THM`, and the definition of function composition `o_DEF`.
- Conclude the proof using the theorem stating that the image of a finite set is finite (`FINITE_IMAGE`).

### Mathematical insight
This theorem states that permuting the variables of a monomial does not affect the finiteness of the set of variables appearing in the monomial. This is a fundamental property used when reasoning about monomial orderings and finiteness conditions in polynomial rings. It shows that finiteness is invariant under variable renaming via a permutation.

### Dependencies
- `monomial_vars`
- `permutes`
- `BIJECTIVE_LEFT_RIGHT_INVERSE`
- `FINITE_IMAGE`
- `EXTENSION`
- `in_image_vw`
- `IN_ELIM_THM`
- `o_DEF`
- `IN_UNIV`


---

## finite_monomial_vars_swap

### Name of formal statement
finite_monomial_vars_swap

### Type of the formal statement
theorem

### Formal Content
```ocaml
let finite_monomial_vars_swap = prove(`
  !m:num->num i.
  FINITE(monomial_vars (m o swap(i,i+1))) <=>
  FINITE(monomial_vars m)
`,
  qed[PERMUTES_SWAP;IN_UNIV;finite_monomial_vars_permutation]
);;
```
### Informal statement
For all functions `m` from numbers to numbers and for all numbers `i`, the set of variables of the monomial obtained by composing `m` with the swap function `swap(i, i+1)` is finite if and only if the set of variables of the monomial `m` is finite.

### Informal sketch
The proof establishes the equivalence between the finiteness of the variables of a monomial `m` and the finiteness of the variables of the monomial `m o swap(i, i+1)`. The proof proceeds as follows:

*   The theorem relies on the fact that `FINITE` is preserved under permutation.
*   It is shown that `monomial_vars (m o swap(i, i+1))` is a permutation of `monomial_vars m`.
*   The `PERMUTES_SWAP` theorem, which states that swapping two elements is a permutation, is employed.
*   The `IN_UNIV` theorem, which states that anything is in the universe, to justify the application of permutation.
*   The `finite_monomial_vars_permutation` theorem is employed which directly states that if a set is finite, then any permutation of that set is also finite.

### Mathematical insight
This theorem is important because it shows that swapping adjacent variables in a monomial does not affect the finiteness of the set of variables in the monomial. The set of monomial variables are preserved under permutation. This is a useful result for reasoning about polynomials and their properties, especially when working with symmetric polynomials or when simplifying expressions involving monomials.

### Dependencies
- Theorems: `PERMUTES_SWAP`, `IN_UNIV`, `finite_monomial_vars_permutation`


---

## monomial_eq_swap

### Name of formal statement
monomial_eq_swap

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_eq_swap = prove(`
  !m:V->num i j.
  m o swap(i,j) = m <=>
  m i = m j
`,
  rw[swap;o_DEF;FUN_EQ_THM] THEN
  qed[]
);;
```
### Informal statement
For all functions `m` from a type `V` to numbers, and all `i` and `j` of type `V`, `m` composed with `swap(i, j)` is equal to `m` if and only if `m i` is equal to `m j`.

### Informal sketch
The proof proceeds as follows:
- First rewrite using the definition of `swap` and function composition `o_DEF`, using `rw[swap;o_DEF;FUN_EQ_THM]`.
- Then perform automatic theorem proving using `qed[]`.

### Mathematical insight
This theorem states that if applying a swap operation to the input of a function `m` does not change the function, then `m` must have the same value at the two swapped points. This essentially captures the symmetry of `m` with respect to interchanging `i` and `j`. This result can be useful in simplifying expressions where there are symmetries or relating the behavior of a function under permutations of its arguments.

### Dependencies
- Definitions: `swap`, `o_DEF`
- Theorems: `FUN_EQ_THM`


---

## monomial_le_swap

### Name of formal statement
monomial_le_swap

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_le_swap = prove(`
  !m:num->num i.
  FINITE(monomial_vars m) ==>
  ( monomial_le (<=) (m o swap(i,i+1)) m <=>
    m i <= m(i+1)
  )
`,
  intro THEN
  simp[MONOMIAL_LE_TOSET;TOSET_num;FLD_num] THEN
  simp[monomial;SUBSET_UNIV;finite_monomial_vars_swap] THEN
  rw[monomial_eq_swap] THEN
  rw[properly_le;swap;o_DEF] THEN
  splitiff THENL [
    intro THENL [
      ASM_ARITH_TAC
    ;
      case `i' < i+1` THENL [
        num_linear_fact `~(i+1 = i)` THEN
        have `m i = m(i+1):num` [] THEN
        qed[LE_REFL]
      ; pass
      ] THEN
      case `i' = i+1` THENL [
        num_linear_fact `~(i+1 = i)` THEN
        have `m(i:num):num < m(i+1)` [] THEN
        qed[LT_IMP_LE]
      ; pass
      ] THEN
      num_linear_fact `~(i' < i+1) ==> ~(i' = i+1) ==> ~(i' = i)` THEN
      qed[LT_REFL]
    ]
  ;
    intro THEN
    proven_if `m(i):num = m(i+1)` [] THEN
    num_linear_fact `~(m(i):num = m(i+1)) ==> m i <= m(i+1) ==> m i < m(i+1)` THEN
    simp[] THEN
    witness `i+1` THEN
    num_linear_fact `~(i + 1 = i)` THEN
    simp[] THEN
    intro THEN
    num_linear_fact `i+1 < j ==> ~(j = i)` THEN
    num_linear_fact `i+1 < j ==> ~(j = i+1)` THEN
    qed[]
  ]
);;
```

### Informal statement
For any function `m` from natural numbers to natural numbers and any natural number `i`, if the set of variables on which `m` depends is finite, then `monomial_le` with respect to the less than or equal to relation (`<=`) holds between the function `m` composed with `swap(i, i+1)` and the function `m` if and only if `m(i)` is less than or equal to `m(i+1)`.

### Informal sketch
The proof proceeds as follows:
- Assume `FINITE(monomial_vars m)`.
- Simplify using definitions: `MONOMIAL_LE_TOSET`, `TOSET_num`, `FLD_num`,`monomial`, `SUBSET_UNIV`, and `finite_monomial_vars_swap`.
- Rewrite using `monomial_eq_swap` which expands the definition in terms of equality.
- Rewrite using `properly_le;swap;o_DEF` introducing the less than or equal relation and the definitions of function composition `o_DEF` and `swap`.
- Split the if and only if into two implications.
    - For the first implication:
        - Assume `monomial_le (<=) (m o swap(i,i+1)) m` holds.
        - We consider three cases for `i'`. Where `i'` represents the index of the location where `(m o swap(i, i+1)) j < m j` could evaluate to true.
            - If `i' < i+1` then prove `m i = m(i+1):num`. This is proved by contradiction using ARITH tactic.
            - If `i' = i+1` then prove `m (i:num):num < m(i+1)`. This is proved by contradiction using ARITH tactic..
            - Else `i' = i` and thus `i' < i+1` and `i' = i+1` are false.
            - Apply `<` refl
    - For the second implication:
        - Assume `m i <= m(i+1)`.
        - First we prove the case for when `m(i):num = m(i+1)`.
        - For contrary case: `~(m(i):num = m(i+1)) ==> m i <= m(i+1) ==> m i < m(i+1)`
        - Witness the number `(i+1)`.
        - Given that `~(i + 1 = i)`
        - We have a contradiction given `i+1 < j ==> ~(j = i)` and `i+1 < j ==> ~(j = i+1)`

### Mathematical insight
This theorem formalizes the condition under which swapping adjacent elements in a monomial-like function preserves the `monomial_le` relation. It states that comparing `m o swap(i, i+1)` to `m` using `monomial_le` depends directly on the relationship between `m(i)` and `m(i+1)`. If `m(i) <= m(i+1)`, then the monomial is less than or equal after the swap, mirroring the standard intuition about comparing sequences.

### Dependencies
- `MONOMIAL_LE_TOSET`
- `TOSET_num`
- `FLD_num`
- `monomial`
- `SUBSET_UNIV`
- `finite_monomial_vars_swap`
- `monomial_eq_swap`
- `properly_le`
- `swap`
- `o_DEF`
- `LE_REFL`
- `LT_IMP_LE`
- `LT_REFL`

### Porting notes (optional)
- The proof relies heavily on arithmetic reasoning, so a proof assistant with good arithmetic automation will be beneficial.
- The handling of the FINITE set condition will need careful consideration, as different assistants may have different ways of formalizing finiteness.
- The tactic `ASM_ARITH_TAC` plays a crucial role in discharging arithmetic goals. Ensure that an equivalent tactic/method is available in the target proof assistant.


---

## monomial_induction

### Name of formal statement
monomial_induction

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_induction = prove(`
  !P:(num->num)->bool.
  (!n. (!m. monomial_lt (<=) m n ==> P m) ==> P n) ==>
  (!n. P n)
`,
  once_rw[GSYM MONOMIAL_LT_PROPERLY] THEN
  simp[properly_le] THEN
  intro THEN
  have `WF ((<):num->num->bool)` [WF_num] THEN
  have `WF (monomial_lt ((<):num->num->bool))` [WF_MONOMIAL_LT] THEN
  qed[WF_IND]
);;
```
### Informal statement
For any property `P` of natural numbers, if for every natural number `n`, the assumption that `P` holds for all `m` such that `m` is properly less than `n` in the monomial order implies that `P` holds for `n`, then `P` holds for all natural numbers `n`.

### Informal sketch
The proof proceeds by induction using the well-foundedness of the monomial order on natural numbers.
- First, the theorem `MONOMIAL_LT_PROPERLY` which states that `monomial_lt` is the same as properly less than, is rewritten.
- Then, the `properly_le` relation is simplified.
- Next, the universally quantified variable `P` is introduced as an assumption.
- The well-foundedness of the usual less-than relation `<` on natural numbers is asserted using `WF_num`.
- The well-foundedness of the monomial less-than relation `monomial_lt` (defined using the properly less-than relation `<`) follows from the well-foundedness of `<` and is asserted using `WF_MONOMIAL_LT`.
- Finally, the result follows by well-founded induction, using the theorem `WF_IND`.

### Mathematical insight
This theorem establishes the principle of well-founded induction for the monomial order on natural numbers. This principle allows us to prove properties about natural numbers by showing that if a property holds for all numbers less than a given number in the monomial order, then it holds for that number as well. The monomial order essentially compares pairs of natural numbers lexicographically; it is a well-ordering and is often useful in termination arguments.

### Dependencies
- Theorem: `GSYM MONOMIAL_LT_PROPERLY`
- Theorem: `properly_le`
- Theorem: `WF_num`
- Theorem: `WF_MONOMIAL_LT`
- Theorem: `WF_IND`


---

## monomial_le_mul2_eq

### Name of formal statement
monomial_le_mul2_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_le_mul2_eq = prove(`
  !m n M N:num->num.
  monomial_le (<=) m M ==>
  monomial_le (<=) n N ==>
  monomial_mul m n = monomial_mul M N ==>
  ( m = M /\ n = N )
`,
  REPEAT GEN_TAC THEN
  REPEAT DISCH_TAC THEN
  case `~(m = M:num->num)` THENL [
    have `monomial_lt (<=) m (M:num->num)` [monomial_lt] THEN
    have `monomial_lt (<=) (monomial_mul m n) (monomial_mul M N:num->num)` [MONOMIAL_LTE_MUL2;POSET_num] THEN
    qed[monomial_lt]
  ; pass
  ] THEN
  case `~(n = N:num->num)` THENL [
    have `monomial_lt (<=) n (N:num->num)` [monomial_lt] THEN
    have `monomial_lt (<=) (monomial_mul m n) (monomial_mul M N:num->num)` [MONOMIAL_LET_MUL2;POSET_num] THEN
    qed[monomial_lt]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For all functions `m`, `n`, `M`, and `N` from numbers to numbers, if `m` is less than or equal to `M` in the monomial order, and `n` is less than or equal to `N` in the monomial order, and the monomial multiplication of `m` and `n` equals the monomial multiplication of `M` and `N`, then `m` equals `M` and `n` equals `N`.

### Informal sketch
The proof proceeds by contradiction. The goal is to prove that if `monomial_le (<=) m M`, `monomial_le (<=) n N`, and `monomial_mul m n = monomial_mul M N`, then `m = M` and `n = N`. The proof first assumes the negation of `m = M`, then derives a contradiction. It then assumes the negation of `n = N`, again deriving a contradiction.

- Assume `~(m = M)`. Since `monomial_le (<=) m M` holds, it follows that `monomial_lt (<=) m M` holds.
- Apply `MONOMIAL_LTE_MUL2` and `POSET_num`: this yields `monomial_lt (<=) (monomial_mul m n) (monomial_mul M N)`.
- This contradicts the assumption `monomial_mul m n = monomial_mul M N`, so we have a contradiction.

- Assume `~(n = N)`. Since `monomial_le (<=) n N` holds, it follows that `monomial_lt (<=) n N` holds.
- Apply `MONOMIAL_LET_MUL2` and `POSET_num`: this yields `monomial_lt (<=) (monomial_mul m n) (monomial_mul M N)`.  *Note the typo `MONOMIAL_LET_MUL2` in the original HOL Light script; it most likely meant `MONOMIAL_LTE_MUL2`*.
- This contradicts the assumption `monomial_mul m n = monomial_mul M N`, so we have a contradiction.

- Thus, `m = M` and `n = N` must hold.

### Mathematical insight
The theorem asserts that the monomial multiplication is injective with respect to the monomial ordering. In other words, if the product of two monomials is equal to the product of two other monomials, and each of the first monomials is less than or equal to the respective second monomials, then the monomials must be pairwise equal. This is a useful property for reasoning about monomials and their ordering. The formalization uses proof by contradiction, which underscores the reliance on the properties of the monomial ordering being a partial order.

### Dependencies
- `monomial_le`
- `monomial_lt`
- `monomial_mul`
- `MONOMIAL_LTE_MUL2`
- `POSET_num`


---

## monomial_pow_0

### Name of formal statement
monomial_pow_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_pow_0 = prove(`
  !m:V->num.
  monomial_pow m 0 = monomial_1
`,
  rw[monomial_pow;monomial_1;FUN_EQ_THM] THEN
  ARITH_TAC
);;
```
### Informal statement
For all functions `m` from a type `V` to the type of numbers `num`, raising the monomial `m` to the power of 0 yields the monomial `monomial_1`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definitions of `monomial_pow`, `monomial_1` and `FUN_EQ_THM`.
- Applying arithmetic tactics to complete the proof.

### Mathematical insight
This theorem establishes a fundamental property of monomials: any monomial raised to the power of 0 is equal to the identity monomial, `monomial_1`, which maps every variable to 1. It is analogous to the algebraic identity x^0 = 1.

### Dependencies
- Definitions: `monomial_pow`, `monomial_1`, `FUN_EQ_THM`
- Theorems: none
- Tactics: `rw`, `ARITH_TAC`


---

## monomial_pow_1

### Name of formal statement
monomial_pow_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_pow_1 = prove(`
  !m:V->num.
  monomial_pow m 1 = m
`,
  rw[monomial_pow;FUN_EQ_THM] THEN
  ARITH_TAC
);;
```
### Informal statement
For all `m` of type `V->num`, `monomial_pow m 1 = m`. That is, raising a monomial `m` to the power of 1 results in the original monomial `m`.

### Informal sketch
The proof proceeds by rewriting the definition of `monomial_pow` and then applying arithmetic simplification.
- First, the definition of `monomial_pow` is rewritten. Namely, `monomial_pow m 1` is rewritten to `lambda v. (m v) pow 1`.
- Then, the theorem that `FUN_EQ_THM` stating that two functions are equal if they are equal at all points, is applied.
- Finally, arithmetic simplification is used to reduce `(m v) pow 1` to `m v`.

### Mathematical insight
This theorem expresses a fundamental property of exponentiation, specifically that raising any quantity to the power of 1 yields the quantity itself. In the context of monomials (functions from variables to numeric values), this means if we take a monomial and raise it to the power of 1, we are left with the same monomial. This is an important sanity check and a building block for more complex results involving `monomial_pow`.

### Dependencies
- Definitions: `monomial_pow`
- Theorems: `FUN_EQ_THM`


---

## monomial_pow_add

### Name of formal statement
monomial_pow_add

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_pow_add = prove(`
  !m:V->num d e.
  monomial_pow m (d+e)
  = monomial_mul (monomial_pow m d) (monomial_pow m e)
`,
  rw[monomial_pow;monomial_mul] THEN
  rw[RIGHT_ADD_DISTRIB]
);;
```
### Informal statement
For all functions `m` from variable names to numbers, and for all numbers `d` and `e`, the function `monomial_pow m (d+e)` is equal to the function `monomial_mul (monomial_pow m d) (monomial_pow m e)`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definitions of `monomial_pow` and `monomial_mul`.
- Applying the right distributivity of multiplication over addition.

### Mathematical insight
This theorem states that raising a monomial to the power of a sum is equivalent to multiplying the monomial raised to each summand's power. This is a fundamental property of exponentiation, and it is crucial for manipulating monomials in algebraic expressions.

### Dependencies
- Definitions: `monomial_pow`, `monomial_mul`
- Theorems: `RIGHT_ADD_DISTRIB`


---

## monomial_1_le

### Name of formal statement
monomial_1_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_1_le = prove(`
  !m.
  monomial (:num) m ==>
  monomial_le (<=) monomial_1 m
`,
  simp[MONOMIAL_LE_TOSET;TOSET_num;FLD_num;MONOMIAL_1] THEN
  rw[properly_le;monomial_1;monomial;SUBSET_UNIV;monomial_vars] THEN
  intro THEN
  case `{i:num | ~(m i = 0)} = {}` THENL [
    DISJ1_TAC THEN
    rw[FUN_EQ_THM] THEN
    ASM SET_TAC[]
  ;
    DISJ2_TAC THEN
    pass
  ] THEN
  specialize[`{i:num | ~(m i = 0)}`]max_finite THEN
  choose `i:num` `i IN {i:num | ~(m i = 0)} /\ (!j. i < j ==> ~(j IN {i | ~(m i = 0)}))` [] THEN
  witness `i:num` THEN
  intro THENL [
    have `i IN {i:num | ~(m i = 0)}` [] THEN
    set_fact `i IN {i:num | ~(m i = 0)} ==> ~(m i = 0)` THEN
    qed[ARITH_RULE `~(x = 0) ==> 0 < x`]
  ;
    have `~(j IN {i:num | ~(m i = 0)})` [] THEN
    set_fact `~(j IN {i:num | ~(m i = 0)}) ==> m j = 0` THEN
    qed[]
  ]
);;
```

### Informal statement
For all `m`, if `m` is a monomial of type `num -> num`, then the monomial `monomial_1` is less than or equal to `m` with respect to the monomial order defined by `<=`.

### Informal sketch
The proof proceeds as follows:

- First, rewrite the goal using the definitions of `monomial_le`, `TOSET_num`, `FLD_num`, and `MONOMIAL_1`.
- Then, rewrite using the definitions of `properly_le`, `monomial_1`, `monomial`, and `SUBSET_UNIV`, reducing the problem to showing that the set of variables (indices) where the function `monomial_1` is non-zero is a subset of the set of variables where `m` is non-zero.
- Introduce the assumption that `m` is a monomial.
- Perform case analysis on whether the set `{i:num | ~(m i = 0)}` is empty.
  - If the set is empty, then `m i = 0` for all `i`. Consequently, `m` is the zero monomial, contradicting the assumption that `m` is a monomial (a monomial must have at least one non-zero coefficient).
  - If the set is non-empty, we proceed.
- Specialize the theorem `max_finite` with the set `{i:num | ~(m i = 0)}` to obtain a maximal element `i`.
- Choose an `i` such that `i` is in the set `{i:num | ~(m i = 0)}` and for all `j`, if `i < j`, then `j` is not in the set `{i:num | ~(m i = 0)}`.
- We need to show two things: `0 < m i` and `m j = 0` for all `j > i`.
  - Since `i` is in the set `{i:num | ~(m i = 0)}`, we have `~(m i = 0)`, which implies `0 < m i` by arithmetic reasoning.
  - If `j` is such that `i < j`, then `j` is not in the set `{i:num | ~(m i = 0)}`, so `m j = 0`.

### Mathematical insight
The theorem states that the monomial `monomial_1` is the smallest monomial with respect to componentwise ordering. This is a fundamental property useful in polynomial algebra. The heart of the proof relies on defining a suitable ordering on monomials and applying a maximality argument to find a smallest element.

### Dependencies
- Definitions: `MONOMIAL_LE_TOSET`, `TOSET_num`, `FLD_num`, `MONOMIAL_1`,`properly_le`, `monomial`, `SUBSET_UNIV`, `monomial_vars`
- Theorems: `FUN_EQ_THM`
- Rules: `ARITH_RULE`


---

## monomial_product_empty

### Name of formal statement
monomial_product_empty

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_product_empty = prove(`
  monomial_product ({}:X->bool) (m:X->V->num)
  = monomial_1
`,
  rw[monomial_product;monomial_1] THEN
  rw[NSUM_CLAUSES]
);;
```
### Informal statement
For any type `X`, vector space `V` over the real numbers, and a boolean-valued function on `X`, if the boolean function is everywhere false (i.e., the set is empty), then the monomial product indexed by the empty set is the monomial equal to 1. Formally, if the boolean filter is always false, then `monomial_product` indexed by this empty set, is `monomial_1`.

### Informal sketch
The proof proceeds by using the definition of `monomial_product`.
- The definition of `monomial_product` reduces the product to a finite summation using `NSUM_CLAUSES`.
- When the set `({}:X->bool)` is empty, the finite summation is zero.
- By definition this gives `monomial_1`.

### Mathematical insight
The theorem expresses the natural property that the monomial product over an empty set is the multiplicative identity for monomials, which is `monomial_1`. This is analogous to the product of no numbers being 1, or the sum of no numbers being 0.

### Dependencies
- Definitions:
  - `monomial_product`
  - `monomial_1`
- Theorems:
  - `NSUM_CLAUSES`


---

## monomial_product_insert

### Name of formal statement
monomial_product_insert

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomial_product_insert = prove(`
  !(S:X->bool) (m:X->V->num) t.
  FINITE S ==>
  ~(t IN S) ==>
  monomial_product (t INSERT S) m
  = monomial_mul (m t) (monomial_product S m)
`,
  rw[monomial_product;monomial_mul] THEN
  simp[NSUM_CLAUSES]
);;
```
### Informal statement
For all sets `S` of type `X`, all functions `m` from `X` to numeric-valued functions of type `V`, and all `t` of type `X`, if `S` is finite and `t` is not in `S`, then `monomial_product (t INSERT S) m` is equal to `monomial_mul (m t) (monomial_product S m)`.

### Informal sketch
The proof proceeds by:
- Rewriting using the definitions of `monomial_product` and `monomial_mul`.
- Simplifying using the clauses for `NSUM`, the summation operator. This likely involves expanding the summation over `t INSERT S` and separating out the term corresponding to `t`.

### Mathematical insight
This theorem describes how the monomial product changes when a new element `t` is inserted into the set `S`. It states that the monomial product over the set `t INSERT S` is equivalent to multiplying the monomial associated with `t` (i.e., `m t`) with the monomial product over the original set `S`. This is a fundamental property for manipulating and reasoning about monomial products.

### Dependencies
- Definitions: `monomial_product`, `monomial_mul`
- Theorems: `NSUM_CLAUSES`


---

## support_lt

### Name of formal statement
support_lt

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let support_lt = new_definition `
  support_lt (r:R ring) (p:(num->num)->R) (M:num->num)
  <=> (!m. ~(p m = ring_0 r) ==> monomial_lt (<=) m M)
`;;
```

### Informal statement
For a ring `r` of type `R ring`, a function `p` from `num -> num` to `R`, and a function `M` from `num` to `num`, the statement `support_lt r p M` holds if and only if for all `m`, if `p m` is not equal to the zero element of the ring `r`, then `monomial_lt (<=) m M` holds. The relation `<=` is the usual less-than-or-equal-to relation on natural numbers.

### Informal sketch
The definition `support_lt` introduces a constraint on the monomials for which the polynomial `p` has non-zero coefficients with respect to a bound `M`. The definition states that for every monomial `m`, if the coefficient of `m` in `p` is non-zero, then `m` must be strictly less than `M` in some monomial order. No proof is required since it introduces a definition.

### Mathematical insight
The purpose of this definition is to formalize the notion of support for a polynomial. The support of a polynomial consists of the set of monomials that have non-zero coefficients. This definition is useful in the context of defining well-foundedness or termination arguments related to polynomials, where we want to reason about the monomials that actually appear in a polynomial.

### Dependencies
- `ring_0`
- `monomial_lt`


---

## support_le

### Name of formal statement
support_le

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let support_le = new_definition `
  support_le (r:R ring) (p:(num->num)->R) (M:num->num)
  <=> (!m. ~(p m = ring_0 r) ==> monomial_le (<=) m M)
`;;
```

### Informal statement
For a ring `r` of type `R`, a function `p` from `num->num` to `R`, and a function `M` from `num` to `num`, `support_le r p M` is defined to be true if and only if for all `m`, if `p m` is not equal to the ring zero `ring_0 r`, then `monomial_le (<=) m M` holds.

### Informal sketch
The definition `support_le` introduces a concept relating a function `p` (presumably representing a polynomial) and another function `M` (presumably representing a bound on the monomials in the support of `p`). The definition states that the support of `p` is bounded by `M` if all monomials `m` in the support of `p` (i.e., where `p m` is non-zero) satisfy `monomial_le (<=) m M`.

*   The definition uses `ring_0 r` to represent the zero element of the ring `r`.
*   It utilizes `monomial_le (<=) m M` to express that monomial `m` is less than or equal to `M` according to some ordering relation `<=`.

### Mathematical insight
This definition is likely used in the context of polynomial rings or related algebraic structures. It provides a way to formally define the notion of bounding the support of a polynomial by another function. The `support_le` definition provides a formal way to link polynomials and monomials through the concept of polynomial support and an ordering relation over monomials.

### Dependencies
*   `ring_0`
*   `monomial_le`


---

## support_le1

### Name of formal statement
support_le1

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let support_le1 = new_definition `
  support_le1 (r:R ring) (p:(num->num)->R) (M:num->num)
  <=> ( support_le r p M /\ p M = ring_1 r )
`;;
```
### Informal statement
For any ring `r` of type `R ring`, any function `p` from `num->num` to `R`, and any function `M` from `num` to `num`, `support_le1 r p M` is true if and only if `support_le r p M` is true and `p M` is equal to the ring one `ring_1 r` in `r`.

### Informal sketch
The definition `support_le1` is defined based on `support_le` and an equality check. The intent is to refine the notion of support such that the function `p` maps the argument `M` to the multiplicative identity in the associated ring.

### Mathematical insight
The definition `support_le1` likely represents a refinement or specific case of a more general `support_le` definition that characterizes the `support` of a function `p`. This further condition states that the element `M` is mapped to `1` by `p`. This could be used in contexts where one wants to ensure that outside the "support," the function takes the value `1`, which is mathematically relevant for various types of transforms and analysis.

### Dependencies
- Definition: `support_le`
- Definition: `ring_1`


---

## poly_first_monomial

### Name of formal statement
poly_first_monomial

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_first_monomial = prove(`
  !(r:R ring) p:(num->num)->R.
  ring_polynomial r p ==>
  ~(p = poly_0 r) ==>
  (?t. ~(p t = ring_0 r) /\ support_le r p t)
`,
  intro THEN
  rw[support_le] THEN
  def `M:(num->num)->bool` `{m:num->num | ~(p m = ring_0(r:R ring))}` THEN
  have `FINITE (M:(num->num)->bool)` [ring_polynomial] THEN
  subgoal `~(M = {}:(num->num)->bool)` THENL [
    rw[EMPTY;EXTENSION;IN_ELIM_THM] THEN
    intro THEN
    subgoal `p = poly_0 r:(num->num)->R` THENL [
      rw[poly_0;poly_const;FUN_EQ_THM;COND_ID] THEN
      ASM SET_TAC[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  have `toset (monomial_le ((<=):num->num->bool))` [TOSET_MONOMIAL_LE;FLD_num;TOSET_num] THEN
  subgoal `M SUBSET fld (monomial_le ((<=):num->num->bool))` THENL [
    simp[FLD_MONOMIAL_LE;monomial;SUBSET;IN_ELIM_THM;IN_UNIV] THEN
    qed[ring_polynomial;ring_powerseries;INFINITE]
  ; pass
  ] THEN
  specialize[
    `monomial_le ((<=):num->num->bool)`;
    `M:(num->num)->bool`
  ]TOSET_MAX THEN
  choose `t:num->num` `t IN M /\ (!m:num->num. m IN M ==> monomial_le (<=) m t)` [] THEN
  witness `t:num->num` THEN
  ASM SET_TAC[]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any polynomial `p` from `num` to `num` over `R`, if `p` is a ring polynomial over `r` and `p` is not the zero polynomial over `r`, then there exists a term `t` such that `p t` is not equal to the zero element of the ring `r`, and `t` is the maximal element of the support of `p` with respect to pointwise comparison.

### Informal sketch
The proof proceeds as follows:
- We start with the assumptions that `p` is a ring polynomial and that `p` is not the zero polynomial.
- The theorem `support_le` provides a characterization of the support of a polynomial.
- We define `M` as the set of terms `m` such that `p m` is not the zero element of the ring `r`. Formally: `{m:num->num | ~(p m = ring_0(r:R ring))}`.
- We prove that `M` is non-empty, using the assumption that `p` is not the zero polynomial. We proceed by contradiction, assuming `M` is empty, i.e. `p m = ring_0 r` for all `m`. Then `p` is the zero polynomial over `r` which contradicts the assumption.
- By `TOSET_MONOMIAL_LE`, `monomial_le` is a toset.
- We show that `M` is a subset of the field of `monomial_le`.  
- We apply `TOSET_MAX` to find the maximum element `t` in `M` with respect to monomial ordering. In other words, `t IN M /\ (!m:num->num. m IN M ==> monomial_le (<=) m t)`.
- We conclude by witnessing that `t` satisfies the desired property.

### Mathematical insight
This theorem asserts the existence of a "first" (or top) monomial in a polynomial, given a well-ordering on monomials. Specifically, if we consider the set of monomials with non-zero coefficients, this theorem guarantees that under the given monomial ordering, there exists a largest monomial. This is a crucial property for algorithms involving polynomials, for example polynomial division or Grobner basis computations.

### Dependencies
- `ring_polynomial`
- `support_le`
- `poly_0`
- `poly_const`
- `FUN_EQ_THM`
- `COND_ID`
- `EMPTY`
- `EXTENSION`
- `IN_ELIM_THM`
- `TOSET_MONOMIAL_LE`
- `FLD_num`
- `TOSET_num`
- `FLD_MONOMIAL_LE`
- `monomial`
- `SUBSET`
- `IN_UNIV`
- `INFINITE`

### Porting notes (optional)
- Recreating the toset structure might require significant effort in proof assistants lacking similar typeclass mechanisms.
- Depending on existing libraries, defining monomial ordering and proving totality/well-ordering could require some work.


---

## support_le_0

### Name of formal statement
support_le_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_0 = prove(`
  !(r:R ring).
  support_le r (poly_0 r) monomial_1
`,
  rw[support_le;poly_0;poly_const;COND_ID]
);;
```
### Informal statement
For every ring `r` of type `R ring`, the support of the polynomial `poly_0 r` is less than or equal to `monomial_1`.
Here, the support is defined with respect to the ordering `support_le`. `poly_0 r` represents the zero polynomial over the ring `r`, and `monomial_1` represents the monomial where the coefficient of x^0 is 1.

### Informal sketch
The proof proceeds by rewriting the goal using the definitions of `support_le`, `poly_0`, and `poly_const`. The definition of `poly_0` expands into `poly_const (zero r)`, and then `support_le` compares the degree of the zero polynomial to the degree of `monomial_1`. The comparison then resolves to true by applying `COND_ID`, indicating that the condition for support inclusion is satisfied.

*   Expand `support_le r (poly_0 r) monomial_1` using the definition of `support_le`. The definition of `support_le` involves checking if for every coefficient of `poly_0 r` past a certain point, those coefficients must be zero.
*   Rewrite `poly_0 r` to `poly_const (zero r)` using the definition `poly_0`.
*   Rewrite `poly_const (zero r)` using the definition `poly_const`.
*   Simplify the resulting expression using `COND_ID` (conditional identity) to evaluate the condition to true.

### Mathematical insight
This theorem demonstrates that the support of the zero polynomial is less than or equal to that of the monomial `1` (a constant polynomial with value 1). This is essential since the support captures the non-zero coefficients of a polynomial, and here the zero polynomial consists entirely of zero coefficients from degree 1 onwards.

### Dependencies
- `support_le`
- `poly_0`
- `poly_const`
- `COND_ID`


---

## support_le_exists

### Name of formal statement
support_le_exists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_exists = prove(`
  !(r:R ring) p:(num->num)->R.
  ring_polynomial r p ==>
  ?t. support_le r p t
`,
  qed[support_le_0;poly_first_monomial]
);;
```
### Informal statement
For any ring `r` and any polynomial function `p` from numbers to `r`, if `p` is a ring polynomial over `r`, then there exists a natural number `t` such that the support of `p` is less than or equal to `t`.

### Informal sketch
The proof proceeds by assuming `ring_polynomial r p` and showing the existence of a bound `t` for the support of `p`.

- The proof starts by recalling `support_le_0`, which establishes that the support of a polynomial is less than or equal to 0 if and only if the polynomial is zero.
- It then uses `poly_first_monomial`, likely to extract or analyze the leading monomial of the polynomial `p`, to deduce the existence of the bound `t`.

### Mathematical insight
This theorem states that if a function from natural numbers to a ring is a polynomial over that ring, then the support of the polynomial (i.e., the set of indices where the polynomial's coefficients are non-zero) is bounded. This is a fundamental property of polynomials, ensuring that they have a finite number of non-zero coefficients. This theorem is useful for reasoning about the degree and other properties of polynomials in a formal setting.

### Dependencies
- Tactics: `qed`
- Theorems: `support_le_0`, `poly_first_monomial`


---

## support_le_mul

### Name of formal statement
support_le_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_mul = prove(`
  !(r:R ring) p q M N.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  support_le r p M ==>
  support_le r q N ==>
  support_le r (poly_mul r p q) (monomial_mul M N)
`,
  rw[support_le;poly_mul] THEN
  intro THEN
  case `!a. a IN {m1,m2 | monomial_mul m1 m2 = m:num->num} ==> (\(m1,m2). ring_mul r (p m1) (q m2)) a IN ring_carrier r ==> (\(m1,m2). ring_mul r (p m1) (q m2)) a = ring_0(r:R ring)` THENL [
    specialize[
      `r:R ring`;
      `(\(m1,m2). ring_mul(r:R ring) (p(m1:num->num)) (q(m2:num->num)))`;
      `{m1,m2 | monomial_mul m1 m2 = m:num->num}`
    ]RING_SUM_EQ_0 THEN
    qed[]
  ; pass
  ] THEN
  choose `a:(num->num)#(num->num)` `a IN {m1,m2 | monomial_mul m1 m2 = m:num->num} /\ (\(m1,m2). ring_mul r (p m1) (q m2)) a IN ring_carrier r /\ ~((\(m1,m2). ring_mul r (p m1) (q m2)) a = ring_0(r:R ring))` [] THEN
  subgoal `(FST a,SND a) IN {m1,m2 | monomial_mul m1 m2 = m:num->num} <=> monomial_mul (FST a) (SND a) = m` THENL [
    rw[IN_ELIM_PAIR_THM]
  ; pass
  ] THEN
  have `a IN {m1,m2 | monomial_mul m1 m2 = m:num->num}` [] THEN
  have `(FST a,SND a) IN {m1,m2 | monomial_mul m1 m2 = m:num->num}` [PAIR] THEN
  have `monomial_mul (FST a) (SND a) = m:num->num` [] THEN
  subgoal `(\(m1,m2). ring_mul r (p(m1:num->num)) (q(m2:num->num))) a = ring_mul(r:R ring) (p (FST a)) (q (SND a))` THENL [
    rw[LAMBDA_PAIR]
  ; pass
  ] THEN
  have `~(ring_mul(r:R ring) (p (FST a:num->num)) (q (SND a:num->num)) = ring_0 r)` [] THEN
  have `p (FST(a:(num->num)#(num->num))) IN ring_carrier(r:R ring)` [ring_polynomial;ring_powerseries] THEN
  have `q (SND(a:(num->num)#(num->num))) IN ring_carrier(r:R ring)` [ring_polynomial;ring_powerseries] THEN
  have `~(p (FST(a:(num->num)#(num->num))) = ring_0(r:R ring))` [RING_MUL_LZERO] THEN
  have `~(q (SND(a:(num->num)#(num->num))) = ring_0(r:R ring))` [RING_MUL_RZERO] THEN
  have `monomial_le (<=) (FST(a:(num->num)#(num->num))) M` [] THEN
  have `monomial_le (<=) (SND(a:(num->num)#(num->num))) N` [] THEN
  qed[MONOMIAL_LE_MUL2]
);;
```
### Informal statement
Given a ring `r` with ring carrier `ring_carrier r` and ring zero `ring_0 r`, and polynomials `p` and `q` over `r`, and monomials `M` and `N`, if `p` and `q` are ring polynomials, and the support of `p` is less than or equal to `M` and the support of `q` is less than or equal to `N`, then the support of the product `poly_mul r p q` is less than or equal to the product of the monomials `monomial_mul M N`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using `support_le` and `poly_mul` definitions.
- Introduce universal quantifiers.
- Perform a case split based on whether for all pairs of monomials `m1`, `m2` such that `monomial_mul m1 m2 = m`, the value `ring_mul r (p m1) (q m2)` either does not belong to the ring carrier of `r`, or equals the ring zero of `r`. The goal is to show that if `m` is outside `monomial_mul M N`, then the coefficient is zero. This is done to handle the sums that appear within the ring polynomial multiplication.
- In the first case where the sum is zero, we use a previously proven theorem `RING_SUM_EQ_0` after specializing it with the appropriate parameters.
- In the second case where the sum is non-zero, we show that the coefficient `ring_mul r (p (FST a)) (q (SND a))` is not equal to `ring_0 r`. Since product is nonzero, both `p (FST a)` and `q (SND a)` must be non-zero since the multiplication is occurring in the ring. So `FST a` must be less than or equal to `M`, and `SND a` must be less than or equal to `N`, by the assumptions about the support. The tactic `MONOMIAL_LE_MUL2` establishes that if `FST a <= M` and `SND a <= N`, then `monomial_mul (FST a) (SND a) <= monomial_mul M N`.

### Mathematical insight
This theorem states that the support of the product of two ring polynomials is bounded by the product of their support. This is a fundamental result in polynomial algebra which makes reasoning about the size of coefficients much easier.

### Dependencies
- `support_le`
- `poly_mul`
- `RING_SUM_EQ_0`
- `IN_ELIM_PAIR_THM`
- `LAMBDA_PAIR`
- `RING_MUL_LZERO`
- `RING_MUL_RZERO`
- `MONOMIAL_LE_MUL2`
- `ring_polynomial`
- `ring_powerseries`

### Porting notes (optional)
The definition of support, ring polynomial, and other ring properties will need to be available. The tactic `choose` may be non-trivial to port if the target proof assistant uses different methods for existential quantifier elimination.


---

## support_le_mul_top

### Name of formal statement
support_le_mul_top

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_mul_top = prove(`
  !(r:R ring) p q M N.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  support_le r p M ==>
  support_le r q N ==>
  (poly_mul r p q) (monomial_mul M N)
  = ring_mul r (p M) (q N)
`,
  rw[support_le;poly_mul] THEN
  intro THEN
  subgoal `ring_sum(r:R ring) {m1,m2 | monomial_mul m1 m2 = monomial_mul M N:num->num} (\(m1,m2). ring_mul r (p m1) (q m2)) = ring_sum r {m1,m2 | monomial_mul m1 m2 = monomial_mul M N} (\a. if a = M,N then ring_mul r (p (FST a)) (q (SND a)) else ring_0 r)` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;FORALL_PAIR_THM;PAIR_EQ;IN_ELIM_PAIR_THM] THEN
    intro THEN
    proven_if `p1 = M:num->num /\ p2 = N:num->num` [] THEN
    case `p(p1:num->num) = ring_0(r:R ring)` THENL [
      have `q(p2:num->num) IN ring_carrier(r:R ring)` [ring_polynomial;ring_powerseries] THEN
      qed[RING_MUL_LZERO]
    ; pass
    ] THEN
    case `q(p2:num->num) = ring_0(r:R ring)` THENL [
      have `p(p1:num->num) IN ring_carrier(r:R ring)` [ring_polynomial;ring_powerseries] THEN
      qed[RING_MUL_RZERO]
    ; pass
    ] THEN
    have `monomial_le (<=) p1 (M:num->num)` [] THEN
    have `monomial_le (<=) p2 (N:num->num)` [] THEN
    qed[monomial_le_mul2_eq]
  ; pass
  ] THEN
  simp[RING_SUM_DELTA;IN_ELIM_PAIR_THM] THEN
  qed[RING_MUL;ring_polynomial;ring_powerseries]
);;
```
### Informal statement
For any ring `r`, and any polynomials `p` and `q` over `r`, and any monomials `M` and `N`, if `p` is supported by `M` and `q` is supported by `N`, then the term of the polynomial `p * q` at the monomial `M * N` is equal to the ring product of the term of `p` at `M` and the term of `q` at `N`.

### Informal sketch
- The proof starts by rewriting with the definition of `support_le` and `poly_mul`.
- After introducing the premises, the goal becomes proving an equality between a ring sum and a specific value.
- This is achieved using `RING_SUM_EQ`. The condition to apply this theorem involves checking the equality of pairs of monomials `m1`, `m2` and `M`, `N`.
- We consider cases where either `p(p1)` or `q(p2)` equals `ring_0(r)`. If either is zero, the corresponding term in the product is zero, which simplifies to zero using `RING_MUL_LZERO` or `RING_MUL_RZERO`.
- If both are non-zero, then it can be proved that the monomial `p1` is less than or equal to `M` and `p2` is less than or equal to `N` using `monomial_le_mul2_eq`.
- Finally, the proof involves simplification using `RING_SUM_DELTA` and `IN_ELIM_PAIR_THM`, and concluding with `RING_MUL` and properties of `ring_polynomial` and `ring_powerseries`.

### Mathematical insight
This theorem establishes that the leading term of the product of two polynomials is the product of their leading terms, given that the supports of `p` and `q` are bounded. It reflects the general property of the degree or magnitude or support of products of polynomials being bounded by the sum of degrees or magnitudes or support of the individual polynomials.

### Dependencies
- `support_le`
- `poly_mul`
- `RING_SUM_EQ`
- `BETA_THM`
- `FORALL_PAIR_THM`
- `PAIR_EQ`
- `IN_ELIM_PAIR_THM`
- `RING_MUL_LZERO`
- `RING_MUL_RZERO`
- `monomial_le_mul2_eq`
- `RING_SUM_DELTA`
- `RING_MUL`
- `ring_polynomial`
- `ring_powerseries`

### Porting notes (optional)
The main challenge for porting may involve tactics such as `RING_SUM_EQ`, which relies on HOL Light's rewriting and simplification capabilities within ring theory. You will need to find counterparts for that automation in other proof assistants. The properties about the ring carrier will need to be explicitly specified during the porting.


---

## support_le1_mul

### Name of formal statement
support_le1_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_mul = prove(`
  !(r:R ring) p q M N.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  support_le1 r p M ==>
  support_le1 r q N ==>
  support_le1 r (poly_mul r p q) (monomial_mul M N)
`,
  rw[support_le1] THEN
  qed[support_le_mul;support_le_mul_top;RING_1;RING_MUL_LID]
);;
```
### Informal statement
For any ring `r`, ring polynomials `p` and `q` over `r`, and monomials `M` and `N`, if `p` is a ring polynomial over `r`, `q` is a ring polynomial over `r`, the support of `p` is less than or equal to `M`, and the support of `q` is less than or equal to `N`, then the support of the polynomial product `poly_mul r p q` is less than or equal to the monomial product `monomial_mul M N`.

### Informal sketch
The proof proceeds as follows:
- Start with the assumption that the support of `p` is less than or equal to `M` and the support of `q` is less than or equal to `N`, so `support_le1 r p M` and `support_le1 r q N`.
- Apply the lemma `support_le_mul` which states that the support of `poly_mul r p q` is less than or equal to the product of the supports of `p` and `q`.
- Apply `support_le_mul_top` which combines the assumption that `support_le1 r p M` and `support_le1 r q N` with `support_le_mul` to derive `support_le1 r (poly_mul r p q) (monomial_mul M N)`.
- Apply `RING_1` and `RING_MUL_LID` which are identities related to ring structure.

### Mathematical insight
This theorem states that if we have upper bounds on the monomials appearing in two polynomials, then we can compute an upper bound on the monomials appearing in their product. The monomial product of the bounds of the input polynomials is an upper bound on the monomials in the product of the input polynomials.

### Dependencies
- `support_le1`
- `support_le_mul`
- `support_le_mul_top`
- `RING_1`
- `RING_MUL_LID`


---

## support_le_poly_1

### Name of formal statement
support_le_poly_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_poly_1 = prove(`
  !(r:R ring) m.
  monomial (:num) m ==>
  support_le r (poly_1 r) m
`,
  rw[support_le;poly_1;poly_const] THEN
  qed[monomial_1_le]
);;
```
### Informal statement
For all rings `r` and monomials `m` over the ring `r`, if `m` is a monomial formed from a number, then the support of `r` acting on the polynomial `poly_1 r` is less than or equal to `m`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definitions of `support_le`, `poly_1` and `poly_const`.
- Then, apply the theorem `monomial_1_le`, which states that for any monomial `m`, `1 <= m`.

### Mathematical insight
This theorem establishes a basic property concerning the relationship between the monomial `1` and the support of polynomials. Specifically, it shows that if a monomial is constructed from the constant `1`, then it serves as an upper bound on the support of the polynomial `1`. This relationship can be key for bounding the complexity or size of polynomial expressions.

### Dependencies
- Definitions: `support_le`, `poly_1`, `poly_const`
- Theorems: `monomial_1_le`


---

## support_le1_poly_1

### Name of formal statement
support_le1_poly_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_poly_1 = prove(`
  !(r:R ring).
  support_le1 r (poly_1 r) monomial_1
`,
  simp[support_le1;support_le_poly_1;MONOMIAL_1] THEN
  rw[poly_1;poly_const]
);;
```
### Informal statement
For any `r` in the ring `R`, the support of the polynomial `poly_1 r` is less than or equal to 1 at `monomial_1`.

### Informal sketch
The proof proceeds as follows:
- First, simplify using the definitions of `support_le1`, `support_le_poly_1`, and `MONOMIAL_1`.
- Then, rewrite using the definitions of `poly_1` and `poly_const`. This simplification chain establishes the theorem.

### Mathematical insight
This theorem demonstrates a basic property of the polynomial `poly_1 r`, namely that its support is bounded by 1 at `monomial_1`. This is a simple but necessary step in reasoning about the support of polynomials.

### Dependencies
- Definitions:
  - `support_le1`
  - `support_le_poly_1`
  - `MONOMIAL_1`
  - `poly_1`
  - `poly_const`


---

## support_le1_pow

### Name of formal statement
support_le1_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) p M e.
  ring_polynomial r p ==>
  support_le1 r p M ==>
  support_le1 r (poly_pow r p e) (monomial_pow M e)
```

### Informal statement
For any ring `r`, polynomial `p` over `r`, monomial `M`, and natural number `e`, if `p` is a ring polynomial and the support of `p` is less than or equal to `M`, then the support of `p` raised to the power of `e` is less than or equal to `M` raised to the power of `e`.

### Informal sketch
The proof proceeds by induction on `e`.

- Base case: `e = 0`.
  We need to prove that the support of `p` to the power of 0 is less than or equal to `M` to the power of 0. This reduces to proving that the support of 1 is less than or equal to 1, which holds by `support_le1_poly_1`.

- Inductive step: Assume that the statement holds for `e`, i.e., the support of `p` to the power of `e` is less than or equal to the monomial `M` to the power of `e`. We want to prove that the statement holds for `e+1`.
  That is, we want to show that the support of `p` to the power of `e+1` is less than or equal to `M` to the power of `e+1`.
  We rewrite `e+1` as `e + 1`.  Then `p` to the power of `e+1` becomes `p` to the power of `e` times `p`.  Similarly, `M` to the power of `e+1` becomes `M` to the power of `e` times `M`.
  By the inductive hypothesis, the support of `p` to the power of `e` is less than or equal to `M` to the power of `e`.  Also, by assumption, the support of `p` is less than or equal to `M`.
  Using `support_le1_mul` and `poly_pow_poly`, we can conclude that the support of `p` to the power of `e+1` is less than or equal to `M` to the power of `e+1`.

### Mathematical insight
This theorem states that if the support of a polynomial `p` is bounded by a monomial `M`, then raising `p` to a power `e` results in a polynomial whose support is bounded by `M` raised to the same power `e`. This is an important result for bounding the complexity, particularly the support size, of polynomial computations.

### Dependencies
- `ring_polynomial`
- `support_le1`
- `poly_pow_0`
- `monomial_pow_0`
- `support_le1_poly_1`
- `poly_pow_add`
- `monomial_pow_add`
- `poly_pow_1`
- `monomial_pow_1`
- `support_le1_mul`
- `poly_pow_poly`


---

## support_le1_product

### Name of formal statement
support_le1_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_product = prove(`
  !(r:R ring) p M S.
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (p s)) ==>
  (!s:X. s IN S ==> support_le1 r (p s) (M s)) ==>
  support_le1 r (ring_product(poly_ring r (:num)) S p) (monomial_product S M)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;monomial_product_empty] THEN
    rw[POLY_RING;support_le1_poly_1]
  ;
    subgoal `!s:X. s IN x INSERT S ==> p s IN ring_carrier(poly_ring(r:R ring) (:num))` THENL [
      rw[POLY_RING;SUBSET_UNIV;IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[RING_PRODUCT_CLAUSES;monomial_product_insert] THEN
    rw[POLY_RING] THEN
    subgoal `ring_polynomial r (ring_product(poly_ring(r:R ring) (:num)) (S:X->bool) p)` THENL [
      have `ring_product(poly_ring(r:R ring) (:num)) (S:X->bool) p IN ring_carrier(poly_ring r (:num))` [RING_PRODUCT] THEN
      specialize[`r:R ring`;`(:num)`](CONJUNCT1 POLY_RING) THEN
      have `ring_product(poly_ring(r:R ring) (:num)) (S:X->bool) p IN {q | ring_polynomial r q /\ poly_vars r q SUBSET (:num)}` [] THEN
      set_fact `ring_product(poly_ring(r:R ring) (:num)) (S:X->bool) p IN {q | ring_polynomial r q /\ poly_vars r q SUBSET (:num)} ==> ring_polynomial r (ring_product(poly_ring(r:R ring) (:num)) (S:X->bool) p)` THEN
      qed[]
    ; pass
    ] THEN
    qed[support_le1_mul]
  ]
);;
```

### Informal statement
For any ring `r` (with carrier `R`), any set `S` of elements of type `X`, and any functions `p : X -> (polynomial over ring r)` and `M : X -> term`, if `S` is finite and for every `s` in `S`, `p s` is a ring polynomial over `r` and `support_le1 r (p s) (M s)` holds, then `support_le1 r (ring_product(poly_ring r (:num)) S p) (monomial_product S M)` holds. Here, `ring_product(poly_ring r (:num)) S p` is the product of the ring polynomials `p s` for `s IN S` with respect to the ring structure `poly_ring r (:num)`, and `monomial_product S M` is the product of the terms `M s` for `s IN S`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case (`S` is empty):  Show `support_le1 r (ring_product(poly_ring r (:num)) {} p) (monomial_product {} M)`. Simplify `ring_product(poly_ring r (:num)) {} p` to `poly_1` and `monomial_product {} M` to `1` (using `monomial_product_empty`). Then apply `support_le1_poly_1`.

- Inductive step (`S` is non-empty):  Assume `S` is finite and the result holds for all subsets of `S`. Let `x` be an element.  Show that if the hypothesis holds for all `s IN S ==> support_le1 r (p s) (M s)` and `FINITE S`, then it also holds for `x INSERT S`.
  - The goal is `support_le1 r (ring_product(poly_ring r (:num)) (x INSERT S) p) (monomial_product (x INSERT S) M)`.
  - Use `ring_product` and `monomial_product` lemmas dealing with `INSERT` to unfold the goal:
    `ring_product(poly_ring r (:num)) (x INSERT S) p = ring_product(poly_ring r (:num)) S p * p x` and `monomial_product (x INSERT S) M = M x * monomial_product S M`.
  - Apply `support_le1_mul`: `support_le1 r (ring_product(poly_ring r (:num)) S p * p x) (M x * monomial_product S M)`.
  - The required conditions are that `p s` are ring polynomials over `r`, which is proven using `POLY_RING`, and induction hypothesis on `S`
  
### Mathematical insight
This theorem extends the `support_le1` property to ring products of polynomials, ensuring that the support of a product of ring polynomials remains bounded if the supports of the individual polynomials are bounded. This is an important result for controlling the complexity of polynomials obtained through multiplication.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `monomial_product_empty`
- `POLY_RING`
- `support_le1_poly_1`
- `SUBSET_UNIV`
- `IN_ELIM_THM`
- `monomial_product_insert`
- `support_le1_mul`
- `FINITE_INDUCT_STRONG`


---

## support_le_cancel

### Name of formal statement
support_le_cancel

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_cancel = prove(`
  !(r:R ring) p q M.
  ring_polynomial r p ==>
  ring_polynomial r q ==>
  support_le r p M ==>
  support_le1 r q M ==>
  support_lt r (poly_sub r p (poly_mul r (poly_const r (p M)) q)) M
`,
  rw[support_le;support_le1;support_lt;poly_sub] THEN
  intro_genonly THEN
  DISCH_TAC THEN DISCH_TAC THEN
  subgoal `poly_mul(r:R ring) (poly_const r (p(M:num->num))) q = (\d:num->num. ring_mul r (p M) (q d))` THENL [
    have `ring_powerseries r (q:(num->num)->R)` [ring_polynomial] THEN
    have `ring_powerseries r (p:(num->num)->R)` [ring_polynomial] THEN
    have `p(M:num->num) IN ring_carrier(r:R ring)` [ring_powerseries] THEN
    specialize[
      `r:R ring`;
      `p(M:num->num):R`;
      `q:(num->num)->R`
    ]poly_const_times THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  intro THEN
  case `m = M:num->num` THENL [
    have `q(m:num->num) = ring_1(r:R ring)` [] THEN
    have `ring_mul(r:R ring) (p(M:num->num)) (q(m:num->num)) = p M` [RING_MUL_RID;ring_polynomial;ring_powerseries] THEN
    have `ring_sub r (p m) (ring_mul(r:R ring) (p(M:num->num)) (q(m:num->num))) = ring_0 r` [RING_SUB_REFL;ring_polynomial;ring_powerseries] THEN
    qed[]
  ; pass
  ] THEN
  proven_if `monomial_le (<=) m (M:num->num)` [monomial_lt] THEN
  have `p(m:num->num) = ring_0(r:R ring)` [] THEN
  have `q(m:num->num) = ring_0(r:R ring)` [] THEN
  have `p(M:num->num) IN ring_carrier(r:R ring)` [ring_polynomial;ring_powerseries] THEN
  have `ring_mul(r:R ring) (p(M:num->num)) (q(m:num->num)) = ring_0 r` [RING_MUL_RZERO] THEN
  have `ring_sub r (ring_0 r) (ring_0(r:R ring)) = ring_0 r` [RING_SUB_REFL;RING_0] THEN
  have `ring_sub r (p(m:num->num)) (ring_0(r:R ring)) = ring_0 r` [] THEN
  have `ring_sub r (p m) (ring_mul(r:R ring) (p(M:num->num)) (q(m:num->num))) = ring_0 r` [] THEN
  qed[]
);;
```

### Informal statement
For any ring `r`, any polynomials `p` and `q` over `r`, and any function `M` from natural numbers to natural numbers, if `p` is a polynomial with support less than or equal to `M`, `q` is a polynomial with support less than or equal to 1 according to `M`, then the polynomial `p - (p(M) * q)` has support strictly less than `M`.

### Informal sketch
The proof proceeds as follows:
- Rewrite using definitions of `support_le`, `support_le1`, `support_lt` and `poly_sub`.
- Reduce the goal to proving `poly_mul r (poly_const r (p M)) q = (\d. ring_mul r (p M) (q d))`.
- Prove `ring_powerseries r q` and `ring_powerseries r p`.
- Prove that `p(M)` is in the carrier of the ring `r`.
- Specialize `poly_const_times`, which equates `poly_mul r (poly_const r c) p` with `\n. c * p n`.
- Simplify the goal.
- Consider the case where `m` equals `M`. Show that `q(m) = 1`. Then `p(M) * q(m) = p M`. Thus `p(m) - (p(M) * q(m)) = 0`.
- In the other case where `monomial_le (<=) m M`, show that `p(m) = 0`. Show that `q(m) = 0`. Then `p(M)` exists, `p(M)` times `q(m)` equals `0`. Thus `p(m) - (p(M) * q(m)) = 0`.

### Mathematical insight
This theorem is about cancelling the `M`-th monomial of polynomial `p` by subtracting a multiple of polynomial `q`. It is useful for induction-based polynomial manipulation. `support_le1 r q M` essentially means that polynomial `q` has value 1 at `M` and value 0 everywhere else in the domain where its coefficients matter.

### Dependencies
- `support_le`
- `support_le1`
- `support_lt`
- `poly_sub`
- `RING_MUL_RID`
- `RING_SUB_REFL`
- `RING_MUL_RZERO`
- `RING_0`
- `monomial_lt`
- `poly_const_times`


---

## elementary_sympoly_range

### Name of formal statement
elementary_sympoly_range

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let elementary_sympoly_range = new_definition `
  elementary_sympoly_range (r:R ring) n d
  = \m. if ?U. U SUBSET range n /\
               CARD U = d /\
               m = (\i. if i IN U then 1 else 0)
        then ring_1 r
        else ring_0 r
`;;
```
### Informal statement
For a ring `r`, natural number `n`, and natural number `d`, the function `elementary_sympoly_range r n d` is defined as follows: given a function `m` from natural numbers to the ring `r`, `elementary_sympoly_range r n d m` equals `ring_1 r` if there exists a set `U` which is a subset of the range of `n` (i.e., `{0, ..., n-1}`), the cardinality of `U` is `d`, and `m` maps elements in `U` to `1` and elements not in `U` to `0`; otherwise, `elementary_sympoly_range r n d m` equals `ring_0 r`.

### Informal sketch
The definition constructs a function that acts as an indicator for whether a given function `m` corresponds to the characteristic function of a `d`-sized subset of the range of `n`.

*   The definition checks the existence of a subset `U` of `range n` with cardinality `d` such that the input function `m` is the characteristic function of `U`.
*   If such a set `U` exists, the function returns `ring_1 r`; otherwise, it returns `ring_0 r`.

### Mathematical insight
This definition is fundamental in constructing elementary symmetric polynomials. The function `elementary_sympoly_range` essentially checks if a given function `m` represents a selection of `d` elements from the set `{0, 1, ..., n-1}` by mapping those selected elements to `1` and the rest to `0`. This construction is crucial because the elementary symmetric polynomial of degree `d` in `n` variables can be defined by summing over all such selections.

### Dependencies
- `ring_1`
- `ring_0`
- `range`
- `SUBSET`
- `CARD`
- `IN`


---

## elementary_sympoly_range_subring

### Name of formal statement
elementary_sympoly_range_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) G n d.
  elementary_sympoly_range(subring_generated r G) n d
  = elementary_sympoly_range r n d
```

### Informal statement
For any ring `r`, any set `G` of elements of `r`, any natural number `n`, and any natural number `d`, the range of the `n`-th elementary symmetric polynomial over subsets of size `d` of the subring generated by `G` in `r` is equal to the range of the `n`-th elementary symmetric polynomial over subsets of size `d` of the ring `r`.

### Informal sketch
- The proof proceeds by rewriting the left-hand side of the equation using the definition of `elementary_sympoly_range`.
- Then, the definition of `SUBRING_GENERATED` is applied to further simplify the expression, leading to the equality stated in the theorem. The key idea here is that the range computation only depends on the ring itself, not the generating set of some subring.

### Mathematical insight
This theorem states that the range of the elementary symmetric polynomials is independent of the generating set of a subring. It reflects the property that when evaluating the elementary symmetric polynomial over all sets of a specific size, the result will span the same range regardless of whether we are in the whole ring or just the subring generated by a specific set.

### Dependencies
- Definitions:
  - `elementary_sympoly_range`
  - `SUBRING_GENERATED`


---

## powerseries_elementary_sympoly_range

### Name of formal statement
powerseries_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powerseries_elementary_sympoly_range = prove(`
  !(r:R ring) n d.
  ring_powerseries r (elementary_sympoly_range r n d)
`,
  rw[ring_powerseries;elementary_sympoly_range;monomial_vars;INFINITE] THEN
  intro THENL [
    qed[RING_1;RING_0]
  ;
    subgoal `~(?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0))` THENL [
      rw[NOT_EXISTS_THM] THEN
      intro THEN
      subgoal `{i:num | ~(m i = 0)} = U` THENL [
        simp[] THEN
        SET_TAC[ARITH_RULE `~(1 = 0)`]
      ; pass
      ] THEN
      qed[FINITE_SUBSET;finite_range]
    ; pass
    ] THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r`, any natural numbers `n` and `d`, it holds that `elementary_sympoly_range r n d` is a ring powerseries over `r`.

### Informal sketch
The proof proceeds by:
- Showing that `elementary_sympoly_range r n d` satisfies the `ring_powerseries` predicate. This involves rewriting using the definitions of `ring_powerseries`, `elementary_sympoly_range`, and `monomial_vars`, and applying `INFINITE`.
- Then we introduce the hypothesis, and consider two cases:
  - The case where `d` is either `RING_1` or `RING_0`.
  - The case where it's not, we assume there exists a subset `U` of `range n` such that `CARD U = d` and `m` is the characteristic vector of `U`. We show this leads to a contradiction.
  - We rewrite using `NOT_EXISTS_THM` and introduce the universally quantified variables.
  - We prove that the set `{i:num | ~(m i = 0)} = U`. This involves simplifying and using arithmetic.
  - Finally, we show that `U` is a subset of `range n` and finite.

### Mathematical insight
The theorem states that the elementary symmetric polynomial of degree `d` with `n` variables, when represented as a powerseries, satisfies the conditions to be considered a ring powerseries. This is important because it establishes that these polynomials, which are defined over a specific range of variables, have the necessary properties to be treated as formal power series within the algebraic structure of rings. The condition of being a ring powerseries is important in defining algebraic operations on these polynomials.

### Dependencies
- `ring_powerseries`
- `elementary_sympoly_range`
- `monomial_vars`
- `INFINITE`
- `RING_1`
- `RING_0`
- `NOT_EXISTS_THM`
- `FINITE_SUBSET`
- `finite_range`


---

## polynomial_elementary_sympoly_range

### Name of formal statement
polynomial_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let polynomial_elementary_sympoly_range = prove(`
  !(r:R ring) n d.
  ring_polynomial r (elementary_sympoly_range r n d)
`,
  rw[ring_polynomial] THEN
  rw[powerseries_elementary_sympoly_range] THEN
  rw[elementary_sympoly_range] THEN
  intro THEN
  case `ring_1(r:R ring) = ring_0 r` THENL [
    simp[COND_ID] THEN
    qed[FINITE_EMPTY;EMPTY_GSPEC]
  ; pass
  ] THEN
  subgoal `{m | ~((if ?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0) then ring_1 r else ring_0 r) = ring_0(r:R ring))} = IMAGE (\U i. if i IN U then 1 else 0) {U | U SUBSET range n /\ CARD U = d}` THENL [
    rw[EXTENSION;in_image_vw;IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  have `FINITE(range n)` [finite_range] THEN
  specialize[`range n`;`d:num`]finite_subsets_card THEN
  qed[FINITE_IMAGE]
);;
```

### Informal statement
For any ring `r`, natural number `n`, and natural number `d`, the `elementary_sympoly_range r n d` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using `ring_polynomial`, `powerseries_elementary_sympoly_range`, and `elementary_sympoly_range` to unfold the definition of `ring_polynomial` and `powerseries_elementary_sympoly_range` and `elementary_sympoly_range`.
- Then, perform case analysis on whether `ring_1(r:R ring)` is equal to `ring_0 r`.
  - If `ring_1(r:R ring) = ring_0 r`, the goal simplifies, and it is discharged using `FINITE_EMPTY` and `EMPTY_GSPEC`.
  - Otherwise, a subgoal is introduced.
- The subgoal demonstrates that set of terms such that they are not equal to zero. The statement simplifies to show membership to the range of functions.
- This is then simplified and the relevant theorem about the finiteness of the range of function is applied. `finite_subsets_card` and `FINITE_IMAGE` are applied to complete the proof.

### Mathematical insight
This theorem states that the elementary symmetric polynomial, when restricted to a specific range, is a ring polynomial. This is a key result in the theory of polynomials over rings.

### Dependencies
- Definitions:
  - `ring_polynomial`
  - `powerseries_elementary_sympoly_range`
  - `elementary_sympoly_range`
- Theorems:
  - `FINITE_EMPTY`
  - `EMPTY_GSPEC`
  - `finite_subsets_card`
  - `FINITE_IMAGE`
  - `EXTENSION`
  - `in_image_vw`
  - `IN_ELIM_THM`


---

## elementary_sympoly_range_in_poly_ring

### Name of formal statement
elementary_sympoly_range_in_poly_ring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let elementary_sympoly_range_in_poly_ring = prove(`
  !(r:R ring) n d.
  elementary_sympoly_range r n d IN ring_carrier(poly_ring r (range n))
`,
  rw[POLY_RING;IN_ELIM_THM] THEN
  simp[polynomial_elementary_sympoly_range] THEN
  rw[poly_vars;UNIONS_SUBSET;IN_ELIM_THM;monomial_vars] THEN
  rw[SUBSET] THEN
  rw[elementary_sympoly_range] THEN
  intro THEN
  choose `U:num->bool` `U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0)` [] THEN
  set_fact `s = {i:num | ~(m i = 0)} ==> x IN s ==> ~(m x = 0)` THEN
  have `x:num IN U` [] THEN
  qed[SUBSET]
);;
```
### Informal statement
For any ring `r` and any natural numbers `n` and `d`, the elementary symmetric polynomial `elementary_sympoly_range r n d` is in the carrier of the polynomial ring `poly_ring r (range n)`.

### Informal sketch
The proof proceeds as follows:
- Expand `poly_ring r (range n)` and the `IN` relation using `POLY_RING` and `IN_ELIM_THM`, respectively.
- Simplify using `polynomial_elementary_sympoly_range`.
- Expand `poly_vars`, `UNIONS_SUBSET`, `IN_ELIM_THM`, and `monomial_vars`.
- Rewrite using `SUBSET`.
- Rewrite using the definition of `elementary_sympoly_range`.
- Introduce the variables `r`, `n` and `d`.
- Choose a function `U` from natural numbers to booleans such that `U` is a subset of `range n`, the cardinality of `U` is `d`, and `m` is a function that maps elements of `U` to 1 and other elements to 0.
- Set the fact that `s` contains elements `x` such that `m x` is not 0. If `x` is in `s`, then `m x` is not 0.
- Show that `x` is in `U`.
- Conclude the proof using `SUBSET`.

### Mathematical insight
The theorem states that elementary symmetric polynomials, when restricted to a specific range of variables, are members of the corresponding polynomial ring comprising those variables. This confirms that the construction of elementary symmetric polynomials is compatible with the structure of polynomial rings and that their components lie within the specified variable space.

### Dependencies
- `POLY_RING`
- `IN_ELIM_THM`
- `polynomial_elementary_sympoly_range`
- `poly_vars`
- `UNIONS_SUBSET`
- `monomial_vars`
- `SUBSET`
- `elementary_sympoly_range`


---

## eval_elementary_sympoly_range

### Name of formal statement
eval_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_elementary_sympoly_range = prove(`
  !(r:R ring) n d c.
  (!i. i < n ==> c i IN ring_carrier r) ==>
  poly_evaluate r (elementary_sympoly_range r n d) c
  = ring_sum r {U | U SUBSET range n /\ CARD U = d} (\U. ring_product r U c)
`,
  intro THEN
  rw[poly_evaluate;poly_extend;elementary_sympoly_range;I_THM] THEN
  case `ring_1(r:R ring) = ring_0 r` THENL [
    have `trivial_ring(r:R ring)` [TRIVIAL_RING_10] THEN
    have `ring_carrier(r:R ring) = {ring_0 r}` [trivial_ring] THEN
    have `ring_sum(r:R ring) {U | U SUBSET range n /\ CARD U = d} (\U. ring_product r U c) = ring_0 r` [RING_SUM;IN_SING] THEN
    qed[RING_SUM;IN_SING]
  ; pass
  ] THEN
  subgoal `{m | ~((if ?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0) then ring_1 r else ring_0 r) = ring_0(r:R ring))} = IMAGE (\U i. if i IN U then 1 else 0) {U | U SUBSET range n /\ CARD U = d}` THENL [
    rw[EXTENSION;in_image_vw;IN_ELIM_THM] THEN
    intro THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  subgoal `ring_sum(r:R ring) (IMAGE (\U i. if i IN U then 1 else 0) {U | U SUBSET range n /\ CARD U = d}) (\m. ring_mul r (if ?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0) then ring_1 r else ring_0 r) (ring_product r (monomial_vars m) (\i. ring_pow r (c i) (m i)))) = ring_sum r {U | U SUBSET range n /\ CARD U = d} ((\m. ring_mul r (if ?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0) then ring_1 r else ring_0 r) (ring_product r (monomial_vars m) (\i. ring_pow r (c i) (m i)))) o (\U i. if i IN U then 1 else 0))` THENL [
    subgoal `!X Y. X IN {U | U SUBSET range n /\ CARD U = d} ==> Y IN {U | U SUBSET range n /\ CARD U = d} ==> (\U i. if i IN U then 1 else 0) X = (\U i. if i IN U then 1 else 0) Y ==> X = Y` THENL [
      rw[IN_ELIM_THM;EXTENSION;FUN_EQ_THM;IN] THEN
      num_linear_fact `~(1 = 0)` THEN
      qed[]
    ; pass
    ] THEN
    specialize_assuming[
      `r:R ring`;
      `\U i:num. if i IN U then 1 else 0`;
      `(\m. ring_mul(r:R ring) (if ?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0) then ring_1 r else ring_0 r) (ring_product r (monomial_vars m) (\i. ring_pow r (c i) (m i))))`;
      `{U | U SUBSET range n /\ CARD U = d}`
    ]RING_SUM_IMAGE THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM;o_THM;IN_ELIM_THM;monomial_vars] THEN
  intro THEN
  have `?U. U SUBSET range n /\ CARD U = d /\ (\i. if i IN a then 1 else 0) = (\i. if i IN U then 1 else 0)` [] THEN
  subgoal `{i:num | ~((if i IN a then 1 else 0) = 0)} = a` THENL [
    SET_TAC[ARITH_RULE `~(1 = 0)`]
  ; pass
  ] THEN
  simp[RING_MUL_LID;RING_PRODUCT] THEN
  sufficesby RING_PRODUCT_EQ THEN
  qed[RING_POW_1;SUBSET;range_lt]
);;
```

### Informal statement
Let `r` be a ring.
Then for all natural numbers `n` and `d`, and for all functions `c` from natural numbers to the carrier of `r`, such that for all `i`, if `i` is less than `n`, then `c i` is in the carrier of `r`, it holds that evaluating the polynomial `elementary_sympoly_range r n d` at `c` using the ring `r` equals the ring sum over all sets `U` which are subsets of the range from 0 to `n` (exclusive) and have cardinality `d`, where the summand is the ring product over the elements in `U` of `c`.

### Informal sketch
The proof proceeds by induction on the assumption that `ring_1 r = ring_0 r`.

- **Case 1:** If `ring_1 r = ring_0 r`, then `r` is a trivial ring, meaning its carrier is just `{ring_0 r}`. Then `ring_sum r {U | U SUBSET range n /\ CARD U = d} (\U. ring_product r U c) = ring_0 r`.

- **Case 2:** If `ring_1 r != ring_0 r`, we can simplify the left-hand side using rewrites for `poly_evaluate`, `poly_extend`, `elementary_sympoly_range`, and `I_THM`.

- The next step is to show that the set `{m | ~((if ?U. U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0) then ring_1 r else ring_0 r) = ring_0(r:R ring))}` coincides with `IMAGE (\U i. if i IN U then 1 else 0) {U | U SUBSET range n /\ CARD U = d}`. Then, we simplify.

- Then, we rewrite the `ring_sum` over the image and transform it into a `ring_sum` over the original set. This step relies on proving the injectivity of the mapping `\U i. if i IN U then 1 else 0`.

- Finally, we simplify the expression, and show that the terms inside the summations are equal. It hinges on showing that if there exists a set `U` satisfying certain properties, then the set `{i:num | ~((if i IN a then 1 else 0) = 0)}` is equal to `a`. After further simplification using `RING_MUL_LID` and `RING_PRODUCT`, we use `RING_PRODUCT_EQ`, `RING_POW_1`, `SUBSET`, and `range_lt` to finish the proof.

### Mathematical insight
This theorem relates the evaluation of the `elementary_sympoly_range` polynomial to a direct sum of products of the input values over all subsets of a given size. It provides a combinatorial interpretation of the polynomial evaluation and relates it to elementary symmetric polynomials.

### Dependencies
- `poly_evaluate`
- `poly_extend`
- `elementary_sympoly_range`
- `I_THM`
- `TRIVIAL_RING_10`
- `trivial_ring`
- `RING_SUM`
- `IN_SING`
- `EXTENSION`
- `in_image_vw`
- `IN_ELIM_THM`
- `RING_SUM_IMAGE`
- `FUN_EQ_THM`
- `IN`
- `num_linear_fact`
- `RING_SUM_EQ`
- `BETA_THM`
- `o_THM`
- `monomial_vars`
- `ARITH_RULE`
- `RING_MUL_LID`
- `RING_PRODUCT`
- `RING_PRODUCT_EQ`
- `RING_POW_1`
- `SUBSET`
- `range_lt`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification. A proof assistant with strong automation in these areas will be helpful.
- The injectivity argument for `\U i. if i IN U then 1 else 0` may require explicit construction in some systems.



---

## eval_elementary_sympoly_range_coeff

### Name of formal statement
eval_elementary_sympoly_range_coeff

### Type of the formal statement
theorem

### Formal Content
```ocaml
let eval_elementary_sympoly_range_coeff = prove(`
  !(r:R ring) n d c.
  (!i. i < n ==> c i IN ring_carrier r) ==>
  d <= n ==>
  poly_evaluate r (elementary_sympoly_range r n d) c
  = ring_mul r (
    ring_pow r (ring_neg r (ring_1 r)) d
  ) (
    coeff (n - d) (monic_vanishing_at r (range n) c)
  )
`,
  intro THEN
  simp[eval_elementary_sympoly_range] THEN
  have `FINITE(range n)` [finite_range] THEN
  have `CARD(range n) = n` [card_range] THEN
  have `!i. i IN range n ==> c i IN ring_carrier(r:R ring)` [range_lt] THEN
  have `d <= CARD(range n)` [] THEN
  subgoal `coeff (CARD (range n) - d) (monic_vanishing_at(r:R ring) (range n) c) = ring_mul r (ring_pow r (ring_neg r (ring_1 r)) d) (ring_sum r {U | U SUBSET (range n) /\ CARD U = d} (\U. ring_product r U c))` THENL [
    specialize[
      `r:R ring`;
      `c:num->R`;
      `range n`
    ]coeff_monic_vanishing_at THEN
    qed[]
  ; pass
  ] THEN
  have `coeff (n - d) (monic_vanishing_at(r:R ring) (range n) c) = coeff (CARD (range n) - d) (monic_vanishing_at r (range n) c)` [] THEN
  simp[] THEN
  specialize[`r:R ring`;`n:num`]ring_pow_neg_1_mul_refl THEN
  simp[RING_MUL_ASSOC;RING_SUM;RING_POW;RING_NEG;RING_1;RING_MUL_LID]
);;
```
### Informal statement
For any ring `r` (satisfying the ring axioms in the type `R`), natural number `n`, natural number `d`, and function `c` from natural numbers to the carrier of the ring `r`, if for all `i` less than `n`, `c i` is in the carrier of `r`, and `d` is less than or equal to `n`, then the evaluation in ring `r` of the elementary symmetric polynomial over the range from `0` to `n-1` of degree `d` at `c` is equal to the ring multiplication in `r` of the ring power in `r` of (the ring negation in `r` of the ring one in `r`) to the power of `d` with the coefficient of degree `n - d` of the monic polynomial vanishing at `c` over the range from `0` to `n - 1`.

### Informal sketch
The proof proceeds by:
- Introduction.
- Simplifying using the definition of `eval_elementary_sympoly_range`.
- Proving that `range n` is finite with the theorem `finite_range`.
- Proving that the cardinality of `range n` is `n` with the theorem `card_range`.
- Proving that for all `i` in `range n`, `c i` is in the carrier of `r`.
- Concluding that `d` is less than or equal to the cardinality of `range n`.
- Showing that `coeff (CARD (range n) - d) (monic_vanishing_at r (range n) c)` is equal to `ring_mul r (ring_pow r (ring_neg r (ring_1 r)) d) (ring_sum r {U | U SUBSET (range n) /\ CARD U = d} (\U. ring_product r U c))` by specializing the theorem `coeff_monic_vanishing_at`.
- Showing that `coeff (n - d) (monic_vanishing_at r (range n) c)` is equal to `coeff (CARD (range n) - d) (monic_vanishing_at r (range n) c)`.
- Simplifying.
- Specializing and simplifying using the theorem `ring_pow_neg_1_mul_refl`.
- Simplifying using properties of ring operations.

### Mathematical insight
This theorem relates the evaluation of an elementary symmetric polynomial to the coefficients of the monic polynomial that vanishes at the given values. It connects two different representations of polynomial relationships: one based on symmetric polynomials and the other based on vanishing polynomials.

### Dependencies
- `eval_elementary_sympoly_range`
- `finite_range`
- `card_range`
- `coeff_monic_vanishing_at`
- `ring_pow_neg_1_mul_refl`
- `RING_MUL_ASSOC`
- `RING_SUM`
- `RING_POW`
- `RING_NEG`
- `RING_1`
- `RING_MUL_LID`

### Porting notes (optional)
- The `coeff_monic_vanishing_at` theorem is the core result. Ensure a compatible version exists in the target proof assistant.
- Ring axioms and properties should be adjusted to match the target system's ring theory.
- HOL Light's handling of subsets and cardinality might need adaptation based on the target proof assistant's library conventions.


---

## elementary_sympoly_range_o_permutes

### Name of formal statement
elementary_sympoly_range_o_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let elementary_sympoly_range_o_permutes = prove(`
  !(r:R ring) n d f m.
  f permutes range n ==>
  elementary_sympoly_range r n d (m o f)
  = elementary_sympoly_range r n d m
`,
  rw[elementary_sympoly_range] THEN
  intro THEN
  case `?U. U SUBSET range n /\ CARD U = d /\ (m:num->num) = (\i. if i IN U then 1 else 0)` THENL [
    choose `U:num->bool` `U SUBSET range n /\ CARD U = d /\ (m:num->num) = (\i. if i IN U then 1 else 0)` [] THEN
    def `V:num->bool` `(U:num->bool) o (f:num->num)` THEN
    subgoal `?V. V SUBSET range n /\ CARD V = d /\ (m:num->num) o f = (\i. if i IN V then 1 else 0)` THENL [
      witness `V:num->bool` THEN
      intro THENL [
        qed[o_permutes_subset]
      ;
        qed[card_o_permutes;FINITE_SUBSET;finite_range]
      ;
        rw[FUN_EQ_THM] THEN
        simp[IN;o_THM]
      ]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  case `?U. U SUBSET range n /\ CARD U = d /\ (m:num->num) o f = (\i. if i IN U then 1 else 0)` THENL [
    choose `U:num->bool` `U SUBSET range n /\ CARD U = d /\ (m:num->num) o f = (\i. if i IN U then 1 else 0)` [] THEN
    def `V:num->bool` `IMAGE (f:num->num) (U:num->bool)` THEN
    subgoal `?V. V SUBSET range n /\ CARD V = d /\ (m:num->num) = (\i. if i IN V then 1 else 0)` THENL [
      witness `V:num->bool` THEN
      intro THENL [
        qed[image_permutes_subset]
      ;
        qed[card_image_permutes;FINITE_SUBSET;finite_range]
      ;
        rw[FUN_EQ_THM] THEN
        intro THEN
        def `y:num` `inverse f (x:num):num` THEN
        have `f(y:num) = x:num` [PERMUTES_INVERSES] THEN
        have `m(x:num):num = (m o f)(y:num)` [o_THM] THEN
        case `y:num IN U` THENL [
          have `(m o (f:num->num))(y:num) = 1` [] THEN
          have `x:num IN V` [IN_IMAGE] THEN
          qed[]
        ; pass
        ] THEN
        have `(m o (f:num->num))(y:num) = 0` [] THEN
        subgoal `~(x:num IN V)` THENL [
          intro THEN
          choose `z:num` `z IN U /\ f(z:num) = x:num` [IN_IMAGE] THEN
          have `y = z:num` [PERMUTES_INJECTIVE] THEN
          qed[]
        ; pass
        ] THEN
        qed[]
      ]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
For any ring `R`, natural number `n`, natural number `d`, and function `f` from natural numbers to natural numbers, if `f` permutes the range from 0 to `n-1`, then for any function `m` from natural numbers to natural numbers, the `d`-th elementary symmetric polynomial over the range from 0 to `n-1` applied to `m o f` is equal to the `d`-th elementary symmetric polynomial over the range from 0 to `n-1` applied to `m`.

### Informal sketch
The proof proceeds by induction on the function `m`. The base cases are:

- Case 1: `m` is the characteristic function of a subset `U` of `range n` with cardinality `d`. We define `V` to be `U o f`, and then show that `V` is a subset of `range n` with cardinality `d` and that `m o f` is the characteristic function of `V`. The theorem then follows directly. The proof that `V` is a subset follows from `o_permutes_subset`. The proof that `CARD V = d` relies on `card_o_permutes`, `FINITE_SUBSET`, and `finite_range`.
- Case 2: `m o f` is the characteristic function of a subset `U` of `range n` with cardinality `d`. We define `V` to be the image of `U` under `f`. We need to show that `V` is a subset of `range n`, that `V` has cardinality `d`, and that `m` is the characteristic function of `V`. The proof that `V` is a subset follows from `image_permutes_subset`. The the proof that `CARD V = d` relies on `card_image_permutes`, `FINITE_SUBSET`, and `finite_range`. The function equality relies on showing that `m x = 1` if and only if `x IN V`. Using the definition of `V` as `IMAGE f U`, if `x IN V`, then there exists `y IN U` such that `f y = x`. Thus `m x = (m o f) y = 1`. Conversely, if `m x = 1`, then `(m o f) y = 1`. Thus `y IN U`, and `x = f y`, so `x IN IMAGE f U = V`.

### Mathematical insight
The theorem states that the elementary symmetric polynomial of a function `m` over a range remains invariant if the function's argument is transformed by a permutation. This is a direct consequence of the symmetric nature of the elementary symmetric polynomial. If we permute the inputs to `m`, that permutation is simply a rearrangement of the order of terms in the summation that defines the elementary symmetric polynomial.

### Dependencies
- Theorem: `o_permutes_subset`
- Theorem: `card_o_permutes`
- Theorem: `FINITE_SUBSET`
- Theorem: `finite_range`
- Theorem: `FUN_EQ_THM`
- Definition: `IN`
- Theorem: `o_THM`
- Theorem: `image_permutes_subset`
- Theorem: `card_image_permutes`
- Theorem: `PERMUTES_INVERSES`
- Theorem: `IN_IMAGE`
- Theorem: `PERMUTES_INJECTIVE`

### Porting notes (optional)
The core of the proof lies in reasoning about subsets, cardinality, and function composition. Proof assistants with strong support for set theory and combinatorics will likely facilitate a smooth port. Pay attention to how permutations are represented and manipulated. The use of `choose` tactics to introduce witnesses highlights the interplay between quantifiers and constructive existence.


---

## elementary_sympoly_range_le

### Name of formal statement
elementary_sympoly_range_le

### Type of the formal statement
theorem

### Formal Content
```ocaml
let elementary_sympoly_range_le = prove(`
  !(r:R ring) n d m.
  ~(elementary_sympoly_range r n d m = ring_0 r) ==>
  monomial_le (<=) m (\i. if n-d <= i /\ i < n then 1 else 0)
`,
  rw[elementary_sympoly_range] THEN
  intro THEN
  choose `U:num->bool` `U SUBSET range n /\ CARD U = d /\ m = (\i. if i IN U then 1 else 0)` [] THEN
  have `FINITE(range n)` [finite_range] THEN
  have `CARD(U:num->bool) <= CARD(range n)` [CARD_SUBSET] THEN
  have `d <= n:num` [card_range] THEN
  simp[MONOMIAL_LE_TOSET;TOSET_num;FLD_num] THEN
  simp[monomial;monomial_vars;SUBSET_UNIV] THEN
  rw[properly_le] THEN
  intro THENL [
    subgoal `{i:num | ~((if i IN U then 1 else 0) = 0)} = U` THENL [
      SET_TAC[ARITH_RULE `~(1 = 0)`]
    ; pass
    ] THEN
    qed[FINITE_SUBSET;finite_range]
  ;
    set_fact `{i:num | ~((if n-d <= i /\ i < n then 1 else 0) = 0)} SUBSET {i:num | i < n}` THEN
    qed[FINITE_SUBSET;FINITE_NUMSEG_LT]
  ; pass
  ] THEN
  specialize[`n-d:num`;`n:num`]finite_le_lt THEN
  have `FINITE({i:num | n-d <= i /\ i < n} DIFF U)` [FINITE_DIFF] THEN
  case `({i:num | n-d <= i /\ i < n} DIFF U) = {}` THENL [
    set_fact `({i:num | n-d <= i /\ i < n} DIFF U) = {} ==> {i:num | n-d <= i /\ i < n} SUBSET U` THEN
    specialize[`n-d:num`;`n:num`]card_le_lt THEN
    num_linear_fact `d <= n:num ==> n-(n-d) = d` THEN
    have `CARD {i:num | n-d <= i /\ i < n} = d` [] THEN
    have `FINITE(U:num->bool)` [FINITE_SUBSET] THEN
    have `{i:num | n-d <= i /\ i < n} = U` [CARD_SUBSET_EQ] THEN
    DISJ1_TAC THEN
    rw[FUN_EQ_THM] THEN
    ASM SET_TAC[]
  ; pass
  ] THEN
  specialize[`{i:num | n-d <= i /\ i < n} DIFF U`]max_finite THEN
  choose `i:num` `i IN {i:num | n-d <= i /\ i < n} DIFF U /\ (!j. i < j ==> ~(j IN {i:num | n-d <= i /\ i < n} DIFF U))` [] THEN
  DISJ2_TAC THEN
  witness `i:num` THEN
  have `~(i:num IN U)` [IN_DIFF] THEN
  have `i IN {i:num | n-d <= i /\ i < n}` [IN_DIFF] THEN
  set_fact `i IN {i:num | n-d <= i /\ i < n} ==> n-d <= i /\ i < n` THEN
  simp[ARITH_RULE `0 < 1`] THEN
  intro THEN
  have `~(j IN {i:num | n-d <= i /\ i < n} DIFF U)` [] THEN
  have `n-d <= i:num` [] THEN
  num_linear_fact `n-d <= i ==> i < j ==> n-d <= j:num` THEN
  case `j < n:num` THENL [
    set_fact `n - d <= j ==> j < n ==> j IN {i:num | n-d <= i /\ i < n}` THEN
    qed[IN_DIFF]
  ; pass
  ] THEN
  qed[SUBSET;range_lt]
);;
```
### Informal statement
For any ring `r`, natural number `n`, and natural numbers `d` and `m`, if the elementary symmetric polynomial `elementary_sympoly_range r n d m` is not equal to the zero element `ring_0 r` of the ring `r`, then `m` is less than or equal to (in the `monomial_le` ordering) the monomial which maps `i` to 1 if `n-d <= i` and `i < n`, and to 0 otherwise.

### Informal sketch
The proof proceeds as follows:
- Reduce to consideration of the set theoretic condition `monomial_le`.
- Assume `elementary_sympoly_range r n d m` is not zero, and choose a set `U` which is a subset of `range n` and has cardinality `d` such that `m` is the monomial which maps `i` to 1 if `i` is in `U` and 0 otherwise.
- Show `d <= n` by appealing to `CARD_SUBSET` and `card_range`.
- Simplify the `monomial_le` goal by unfolding definitions, resulting in a set comprehension comparison.
- Reduce the set comprehension comparison to establishing that `{i:num | ~((if i IN U then 1 else 0) = 0)}` is a subset of `{i:num | ~((if n-d <= i /\ i < n then 1 else 0) = 0)}`.
- Split the proof into two cases.
  - Case 1: elements in `U`
  - Case 2: elements in `{i:num | n-d <= i /\ i < n}`
- Specialize `finite_le_lt` to show the ranges are finite.
- Further split the proof based on whether the set difference `{i:num | n-d <= i /\ i < n} DIFF U` is empty.
  - If the set difference is empty, then `{i:num | n-d <= i /\ i < n}` is a subset of `U`. Then, use cardinality arguments and `CARD_SUBSET_EQ` to show the sets are equal, and conclude.
  - Otherwise, choose an element `i` from the set difference which is the maximum element such that `i IN {i:num | n-d <= i /\ i < n} DIFF U` and `(!j. i < j ==> ~(j IN {i:num | n-d <= i /\ i < n} DIFF U))`. Then, derive a contradiction.

### Mathematical insight
This theorem establishes an upper bound on the monomial exponents that appear in the elementary symmetric polynomial. This provides useful information when working with symmetric polynomials and can be used to constrain search spaces or simplify expressions.

### Dependencies
- `elementary_sympoly_range`
- `ring_0`
- `monomial_le`
- `monomial`
- `monomial_vars`
- `properly_le`
- `FINITE`
- `range`
- `CARD`
- `CARD_SUBSET`
- `FINITE_SUBSET`
- `FINITE_NUMSEG_LT`
- `SUBSET`
- `DIFF`



---

## support_le_elementary_sympoly_range

### Name of formal statement
support_le_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le_elementary_sympoly_range = prove(`
  !(r:R ring) n d.
  support_le r
    (elementary_sympoly_range r n d)
    (\i. if n-d <= i /\ i < n then 1 else 0)
`,
  rw[support_le] THEN
  qed[elementary_sympoly_range_le]
);;
```
### Informal statement
For all rings `r` and for all natural numbers `n` and `d`, the support of `elementary_sympoly_range r n d` is less than or equal to the lambda abstraction that maps `i` to 1 if `n-d <= i` and `i < n`, and to 0 otherwise.

### Informal sketch
The proof proceeds by:
- Rewriting using the definition of `support_le`.
- Applying the theorem `elementary_sympoly_range_le` to complete the proof.

### Mathematical insight
This theorem formally establishes an upper bound on the indices that can appear as non-zero coefficients in the `elementary_sympoly_range` function. This function generates elementary symmetric polynomials of degree `d` in `n` variables over the ring `r`. The theorem effectively states that the only monomials that could possibly appear in the polynomial generated by `elementary_sympoly_range r n d` are those corresponding to indices `i` where `n-d <= i < n`. This is because the elementary symmetric polynomials of degree `d` in `n` variables are formed by sums of products of d distinct variables chosen from the n variables. When generating a polynomial from an array, the index `i` represents the index of the array element used to construct that term, so this range specifies which portion of the input array may have non-zero coefficients in the resulting polynomial.

### Dependencies
- Definitions: `support_le`
- Theorems: `elementary_sympoly_range_le`


---

## support_le1_elementary_sympoly_range

### Name of formal statement
support_le1_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_elementary_sympoly_range = prove(`
  !(r:R ring) n d.
  d <= n ==>
  support_le1 r
    (elementary_sympoly_range r n d)
    (\i. if n-d <= i /\ i < n then 1 else 0)
`,
  rw[support_le1;support_le_elementary_sympoly_range] THEN
  rw[elementary_sympoly_range] THEN
  intro THEN
  subgoal `?U. U SUBSET range n /\ CARD U = d /\ (\i. if n - d <= i /\ i < n then 1 else 0) = (\i. if i IN U then 1 else 0)` THENL [
    witness `{i:num | n-d <= i /\ i < n}` THEN
    rw[IN_ELIM_THM;card_le_lt;range_set_lt] THEN
    num_linear_fact `d <= n:num ==> n-(n-d) = d` THEN
    ASM SET_TAC[]
  ; pass
  ] THEN
  simp[]
);;
```

### Informal statement
For all rings `r` (of type `R ring`), and for all natural numbers `n` and `d`, if `d` is less than or equal to `n`, then the `support_le1` property holds for the `elementary_sympoly_range` with ring `r`, numbers `n` and `d`, and a function that maps `i` to 1 if `n-d <= i` and `i < n`, and to 0 otherwise.

### Informal sketch
The proof proceeds as follows:
- Rewrite using `support_le1` and `support_le_elementary_sympoly_range` definitions.
- Rewrite using the definition of `elementary_sympoly_range`.
- Introduce the universal quantifiers `r`, `n`, and `d`.
- Reduce the goal to proving the existence of a set `U` such that `U` is a subset of the range from 0 to `n-1` (inclusive), the cardinality of `U` is equal to `d`, and the function that maps `i` to 1 if `n-d <= i` and `i < n`, and to 0 otherwise, is equal to the function that maps `i` to 1 if `i` is in `U` and 0 otherwise.
- Provide a witness for `U`, namely the set `{i:num | n-d <= i /\ i < n}`.
- Rewrite using `IN_ELIM_THM`, `card_le_lt`, and `range_set_lt`.
- Use the arithmetic fact that `d <= n` implies `n-(n-d) = d`.
- Apply the assumption that `d <= n`.
- Simplify to complete the proof.

### Mathematical insight
This theorem establishes that the elementary symmetric polynomial restricted to a range satisfies the `support_le1` property, meaning that the function associated with its support is bounded by 1. This is a technical lemma useful in bounding the support of polynomials related to symmetric functions. The core idea involves finding a suitable set `U` whose cardinality is `d` and matches the indicator function defined by the constraints `n-d <= i < n`.

### Dependencies
- `support_le1`
- `support_le_elementary_sympoly_range`
- `elementary_sympoly_range`
- `IN_ELIM_THM`
- `card_le_lt`
- `range_set_lt`

### Porting notes (optional)
The set comprehension notation `{i:num | n-d <= i /\ i < n}` might need adjustment depending on the target proof assistant's set theory implementation. The arithmetic reasoning might be handled differently based on the capabilities of the arithmetic decision procedures.


---

## support_le1_pow_elementary_sympoly_range

### Name of formal statement
support_le1_pow_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_pow_elementary_sympoly_range = prove(`
  !(r:R ring) n d e.
  d <= n ==>
  support_le1 r
    (poly_pow r (elementary_sympoly_range r n d) e)
    (\i. if n-d <= i /\ i < n then e else 0)
`,
  intro THEN
  specialize[`r:R ring`;`n:num`;`d:num`]support_le1_elementary_sympoly_range THEN
  have `ring_polynomial(r:R ring) (elementary_sympoly_range r n d)` [polynomial_elementary_sympoly_range] THEN
  specialize[
    `r:R ring`;
    `elementary_sympoly_range(r:R ring) n d`;
    `\i:num. if n - d <= i /\ i < n then 1 else 0`;
    `e:num`
  ]support_le1_pow THEN
  subgoal `monomial_pow (\i:num. if n - d <= i /\ i < n then 1 else 0) e = (\i. if n - d <= i /\ i < n then e else 0)` THENL [
    rw[monomial_pow;FUN_EQ_THM] THEN
    ARITH_TAC
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For any ring `r`, natural numbers `n`, `d`, and `e`, if `d` is less than or equal to `n`, then the `support_le1` of the polynomial power of the `elementary_sympoly_range` `r n d` to the power of `e` is equal to the function that maps `i` to `e` if `n - d` is less than or equal to `i` and `i` is less than `n`, and `0` otherwise.

### Informal sketch
- Introduce the ring `r`, natural numbers `n`, `d`, and `e`. Assume `d <= n`.
- Specialize the theorem `support_le1_elementary_sympoly_range` with `r`, `n`, and `d`.
- Establish that `elementary_sympoly_range r n d` is a polynomial using `polynomial_elementary_sympoly_range`.
- Specialize the theorem `support_le1_pow` with `r`, `elementary_sympoly_range(r:R ring) n d`, the function `\i:num. if n - d <= i /\ i < n then 1 else 0`, and `e`.
- Prove that the `monomial_pow` of the function `\i:num. if n - d <= i /\ i < n then 1 else 0` to the power of `e` is equal to the function `\i. if n - d <= i /\ i < n then e else 0`.
  - Rewrite using `monomial_pow` and `FUN_EQ_THM`.
  - Use arithmetic tactic `ARITH_TAC`.
- Conclude.

### Mathematical insight
This theorem shows how powering the elementary symmetric polynomial (represented by `elementary_sympoly_range`) affects its `support_le1` property, which specifies the values for which the coefficient is bounded by 1. In particular, `support_le1` when the input polynomial is raised to some power `e` is equivalent to a function that returns `e` when `n-d <=i < n` and `0` otherwise.

### Dependencies
**Theorems:**
- `support_le1_elementary_sympoly_range`
- `polynomial_elementary_sympoly_range`
- `support_le1_pow`
- `FUN_EQ_THM`

**Definitions:**
- `support_le1`
- `poly_pow`
- `elementary_sympoly_range`
- `monomial_pow`



---

## support_le1_product_pow_elementary_sympoly_range

### Name of formal statement
support_le1_product_pow_elementary_sympoly_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_product_pow_elementary_sympoly_range = prove(`
  !(r:R ring) n e.
  support_le1 r
    (ring_product(poly_ring r (:num))
      (1..n)
      (\d. poly_pow r (elementary_sympoly_range r n d) (e d))
    )
    (\i. nsum (1..n) (\d. if n-d <= i /\ i < n then e d else 0))
`,
  intro THEN
  have `FINITE (1..n)` [FINITE_NUMSEG] THEN
  have `!d. d IN 1..n ==> ring_polynomial(r:R ring) (poly_pow r (elementary_sympoly_range r n d) (e d))` [polynomial_elementary_sympoly_range;poly_pow_poly] THEN
  subgoal `!d. d IN 1..n ==> support_le1(r:R ring) (poly_pow r (elementary_sympoly_range r n d) (e d)) (\i. if n-d <= i /\ i < n then e d else 0)` THENL [
    intro THEN
    have `d <= n:num` [IN_NUMSEG] THEN
    specialize[
      `r:R ring`
    ]support_le1_pow_elementary_sympoly_range THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `r:R ring`;
    `\d. poly_pow r (elementary_sympoly_range(r:R ring) n d) (e d)`;
    `\d i:num. if n-d <= i /\ i < n then e d else 0`;
    `1..n`
  ]support_le1_product THEN
  subgoal `monomial_product (1..n) (\d i:num. if n - d <= i /\ i < n then e d else 0) = (\i. nsum (1..n) (\d. if n - d <= i /\ i < n then e d else 0))` THENL [
    rw[monomial_product]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For any ring `r`, natural number `n`, and function `e` from natural numbers to natural numbers, the support-one function applied to the product of `poly_pow r (elementary_sympoly_range r n d) (e d)` (where `d` ranges from 1 to `n`) equals the function that maps `i` to the sum (as `d` ranges from 1 to `n`) of `e d` if `n-d <= i` and `i < n`, and 0 otherwise.

### Informal sketch
The proof proceeds by induction.

- First, introduce the assumptions of the theorem.
- Prove that `1..n` is finite using `FINITE_NUMSEG`.
- Show that `poly_pow r (elementary_sympoly_range r n d) (e d)` is a polynomial for `d` belonging to `1..n` using `polynomial_elementary_sympoly_range` and `poly_pow_poly`.
- Show that the support-one function applied to `poly_pow r (elementary_sympoly_range r n d) (e d)` is equal to the function that maps `i` to `e d` if `n-d <= i` and `i < n`, and 0 otherwise, using `support_le1_pow_elementary_sympoly_range`.
- Apply `support_le1_product` to express the support of the product in terms of the monomial product along the range `1..n`.
- Prove that `monomial_product (1..n) (\d i:num. if n - d <= i /\ i < n then e d else 0) = (\i. nsum (1..n) (\d. if n - d <= i /\ i < n then e d else 0))` by rewriting with `monomial_product`.

### Mathematical insight
This theorem relates the support-one function of a product of polynomials to the sum of the supports of individual polynomials. In particular, it analyzes the support of a product of powers of elementary symmetric polynomials. The function `support_le1` computes the maximum coefficient in the polynomial, and the theorem helps to establish bounds on these coefficients. The `elementary_sympoly_range` generates elementary symmetric polynomials with a specific degree which are then raised to the power specified by function `e`.

### Dependencies
- `FINITE_NUMSEG`
- `polynomial_elementary_sympoly_range`
- `poly_pow_poly`
- `support_le1_pow_elementary_sympoly_range`
- `support_le1_product`
- `monomial_product`


---

## support_le1_product_pow_elementary_sympoly_range_v2

### Name of formal statement
support_le1_product_pow_elementary_sympoly_range_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let support_le1_product_pow_elementary_sympoly_range_v2 = prove(`
  !(r:R ring) n e.
  support_le1 r
    (ring_product(poly_ring r (:num))
      (1..n)
      (\d. poly_pow r (elementary_sympoly_range r n d) (e d))
    )
    (\i. if i < n then nsum (n-i..n) e else 0)
`,
  intro THEN
  subgoal `(\i. if i < n then nsum (n-i..n) e else 0) = (\i. nsum (1..n) (\d. if n-d <= i /\ i < n then e d else 0))` THENL [
    rw[FUN_EQ_THM] THEN
    intro THEN
    case `x < n:num` THENL [
      have `FINITE(1..n)` [FINITE_NUMSEG] THEN
      specialize[`\d. n-d <= x:num`;`1..n`;`e:num->num`](GSYM NSUM_RESTRICT_SET) THEN
      subgoal `(n-x..n) = {d | d IN 1..n /\ n-d <= x}` THENL [
        rw[EXTENSION;IN_NUMSEG;IN_ELIM_THM] THEN
        ASM_ARITH_TAC
      ; pass
      ] THEN
      simp[]
    ; pass
    ] THEN
    simp[NSUM_0]
  ; pass
  ] THEN
  qed[support_le1_product_pow_elementary_sympoly_range]
);;
```

### Informal statement
For any ring `r` and any natural numbers `n` and `e`, the support size `support_le1` of the product of powers of elementary symmetric polynomials `elementary_sympoly_range` is such that for all natural numbers `i`, the `i`-th coefficient of the support is less than or equal to the sum from `n-i` to `n` of `e(d)` if `i < n`, and 0 otherwise. Furthermore, this is equal to the sum from 1 to `n` of `e(d)` if `n-d <= i` and `i < n` and 0 otherwise.

### Informal sketch
The proof aims to show the equality of two expressions involving `nsum` and an indicator function.

- The goal is to prove `(\i. if i < n then nsum (n-i..n) e else 0) = (\i. nsum (1..n) (\d. if n-d <= i /\ i < n then e d else 0))`.
- It starts by introducing the variables `r`, `n`, and `e`.
- It rewrites the goal, so we need to prove the equality of the two lambda expression for any `i`.
- A case split is performed on `i < n`.
  - If `i < n`, the original summation range `(n-i..n)` is shown to be equivalent to restricting the range `(1..n)` to `d` such that `n-d <= i`. This involves demonstrating the equality of the sets involved.
  - If `i >= n`, `nsum (n-i..n) e` evaluates to 0 and we have `nsum (1..n) (\d. if n-d <= i /\ i < n then e d else 0)` = 0 since `i < n` is false anyway and `e d` is multiplied by 0.
- Finally, `support_le1_product_pow_elementary_sympoly_range` is used.

### Mathematical insight
This theorem relates the support size of a product of powers of elementary symmetric polynomials to a sum based on the exponents `e`. The theorem is useful for bounding the degrees of coefficients of polynomials.

### Dependencies
- `support_le1_product_pow_elementary_sympoly_range`
- `FUN_EQ_THM`
- `FINITE_NUMSEG`
- `NSUM_RESTRICT_SET`
- `EXTENSION`
- `IN_NUMSEG`
- `IN_ELIM_THM`
- `NSUM_0`


---

## symmetric_subring_if_poly_subring_lemma

### Name of formal statement
symmetric_subring_if_poly_subring_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symmetric_subring_if_poly_subring_lemma = prove(`
  !(r:R ring) G n c:num->R M p.
  (!i. i < n ==> c i IN ring_carrier r) ==>
  (!d. coeff d (monic_vanishing_at r (range n) c) IN ring_carrier(subring_generated r G)) ==>
  ring_polynomial(subring_generated r G) p ==>
  poly_vars r p SUBSET range n ==>
  (!f m. f permutes range n ==>
         p(m o f) = p(m)) ==>
  support_le r p M ==>
  poly_evaluate r p c IN ring_carrier(subring_generated r G)
`,
  GEN_TAC THEN GEN_TAC THEN
  GEN_TAC THEN GEN_TAC THEN
  sufficesby monomial_induction THEN
  intro THEN
  have `ring_polynomial r (p:(num->num)->R)` [ring_polynomial_if_subring] THEN
  case `p = poly_0(r:R ring):(num->num)->R` THENL [
    simp[POLY_EVALUATE_0] THEN
    qed[SUBRING_GENERATED;RING_0]
  ; pass
  ] THEN
  case `n = 0` THENL [
    have `range n = {}` [range_0] THEN
    have `poly_vars(r:R ring) (p:(num->num)->R) = {}` [SUBSET_EMPTY] THEN
    have `p:(num->num)->R = poly_const r (p monomial_1)` [poly_vars_empty] THEN
    have `p(monomial_1:num->num):R IN ring_carrier r` [ring_polynomial;ring_powerseries] THEN
    have `poly_evaluate r (p:(num->num)->R) c = p monomial_1` [POLY_EVALUATE_CONST] THEN
    qed[ring_polynomial;ring_powerseries]
  ; pass
  ] THEN
  choose `t:num->num` `~(p t = ring_0(r:R ring)) /\ support_le r p t` [poly_first_monomial] THEN
  case `monomial_lt ((<=):num->num->bool) t M` THENL [
    have `support_le(r:R ring) p t` [] THEN
    specialize[`t:num->num`](know(`!m:num->num. monomial_lt (<=) m M ==> (!p. (!i. i < n ==> c i IN ring_carrier(r:R ring)) ==> (!d. coeff d (monic_vanishing_at r (range n) c) IN ring_carrier (subring_generated r G)) ==> ring_polynomial(subring_generated r G) p ==> poly_vars r p SUBSET range n ==> (!f m. f permutes range n ==> p (m o f) = p m) ==> support_le r p m ==> poly_evaluate r p c IN ring_carrier (subring_generated r G))`)) THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!i:num. i+1 < n ==> t i <= t (i+1):num` THENL [
    intro THEN
    subgoal `swap(i,i+1) permutes range n` THENL [
      num_linear_fact `i+1 < n ==> i < n` THEN
      qed[swap_permutes_range]
    ; pass
    ] THEN
    have `p(t o (swap(i,i+1))) = p(t:num->num):R` [] THEN
    have `~(p((t:num->num) o (swap(i,i+1))) = ring_0(r:R ring))` [] THEN
    have `monomial_le (<=) (t o (swap(i,i+1))) (t:num->num)` [support_le] THEN
    have `FINITE(monomial_vars(t:num->num))` [ring_polynomial;ring_powerseries;INFINITE] THEN
    qed[monomial_le_swap]
  ; pass
  ] THEN
  def `e:num->num` `\i. if i = n then t 0 else t(n-i) - t(n-i-1):num` THEN
  subgoal `t = (\i:num. if i < n then nsum(n-i..n) e else 0)` THENL [
    rw[FUN_EQ_THM] THEN
    INDUCT_TAC THENL [
      num_linear_fact `~(n = 0) ==> 0 < n` THEN
      num_linear_fact `n-0 = n` THEN
      simp[NSUM_SING_NUMSEG]
    ;
      rw[ARITH_RULE `SUC x = x+1`] THEN
      case `x+1 < n` THENL [
        num_linear_fact `x+1 < n ==> n-(x+1)+1 = n-x` THEN
        num_linear_fact `n-(x+1) <= n` THEN
        specialize[
          `e:num->num`;
          `n-(x+1)`;
          `n:num`
        ]NSUM_CLAUSES_LEFT THEN
        havetac `nsum (n - (x + 1) + 1..n) e = nsum(n-x..n) e` (simp[]) THEN
        num_linear_fact `x + 1 < n ==> x < n` THEN
        havetac `nsum (n - (x + 1) + 1..n) e = t x` (simp[]) THEN
        subgoal `t(x+1) = e(n-(x+1)) + t x:num` THENL [
          num_linear_fact `x+1 < n ==> ~(n-(x+1) = n)` THEN
          have `e(n-(x+1)) = t(n-(n-(x+1))) - t(n-(n-(x+1))-1):num` [] THEN
          num_linear_fact `x+1 < n ==> n-(n-(x+1)) = x+1` THEN
          num_linear_fact `x+1 < n ==> n-(n-(x+1))-1 = x` THEN
          havetac `e(n-(x+1)) = t(x+1) - t(x):num` (simp[]) THEN
          have `t x <= t(x+1):num` [] THEN
          num_linear_fact `t x <= t(x+1):num ==> e (n - (x + 1)) = t (x + 1) - t x ==> t (x + 1) = e (n - (x + 1)) + t x` THEN
          qed[]
        ; pass
        ] THEN
        simp[]
      ; pass
      ] THEN
      have `~(x+1 IN range n)` [range_lt] THEN
      have `~(x+1 IN poly_vars(r:R ring) (p:(num->num)->R))` [SUBSET] THEN
      have `~(x+1 IN UNIONS {monomial_vars m | ~((p:(num->num)->R) m = ring_0 r)})` [poly_vars] THEN
      have `!v. v IN {monomial_vars m | ~((p:(num->num)->R) m = ring_0 r)} ==> ~(x+1 IN v)` [IN_UNIONS] THEN
      proven_if `t(x+1) = 0` [] THEN
      subgoal `x+1 IN monomial_vars t` THENL [
        rw[monomial_vars;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      subgoal `monomial_vars t IN {monomial_vars m | ~((p:(num->num)->R) m = ring_0 r)}` THENL [
        rw[IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ]
  ; pass
  ] THEN
  specialize[
    `r:R ring`;
    `n:num`;
    `e:num->num`
  ]support_le1_product_pow_elementary_sympoly_range_v2 THEN
  have `support_le1(r:R ring) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) t` [] THEN
  subgoal `ring_polynomial(r:R ring) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))` THENL [
    have `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN ring_carrier(poly_ring r (:num))` [RING_PRODUCT] THEN
    specialize[`r:R ring`;`(:num)`](CONJUNCT1 POLY_RING) THEN
    have `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET (:num)}` [] THEN
    set_fact `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET (:num)} ==> ring_polynomial(r:R ring) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))` THEN
    qed[]
  ; pass
  ] THEN
  have `support_le(r:R ring) p t` [] THEN
  specialize[
    `r:R ring`;
    `p:(num->num)->R`;
    `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))`;
    `t:num->num`
  ]support_le_cancel THEN
  def `s:(num->num)->R` `poly_sub(r:R ring) p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))` THEN
  have `ring_polynomial r (s:(num->num)->R)` [RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_CONST;ring_polynomial;ring_powerseries] THEN
  subgoal `poly_evaluate(r:R ring) (s:(num->num)->R) c IN ring_carrier(subring_generated r G)` THENL [
    case `s = poly_0 r:(num->num)->R` THENL [
      have `poly_evaluate(r:R ring) (s:(num->num)->R) c = ring_0 r` [POLY_EVALUATE_0] THEN
      have `ring_0(r:R ring) = ring_0(subring_generated r G)` [SUBRING_GENERATED] THEN
      have `poly_evaluate(r:R ring) (s:(num->num)->R) c = ring_0(subring_generated r G)` [] THEN
      qed[RING_0]
    ; pass
    ] THEN
    choose `S:num->num` `~(s S = ring_0(r:R ring)) /\ support_le r s S` [poly_first_monomial] THEN
    have `monomial_lt (<=) (S:num->num) t` [support_lt] THEN
    have `monomial_le (<=) (t:num->num) M` [support_le] THEN
    have `monomial_lt (<=) (S:num->num) M` [MONOMIAL_LTE_TRANS;POSET_num] THEN
    subgoal `ring_polynomial(subring_generated r G) (s:(num->num)->R)` THENL [
      intro THEN
      subgoal `s(m:num->num) = ring_sub(r:R ring) (p m) (ring_mul r (p t) ((ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) m))` THENL [
        once_rw[know(`s = poly_sub(r:R ring) p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))`)] THEN
        rw[poly_sub] THEN
        specialize_assuming[
          `r:R ring`;
          `p(t:num->num):R`;
          `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))`
        ]poly_const_times THEN
        qed[ring_polynomial;ring_powerseries]
      ; pass
      ] THEN
      have `!d. elementary_sympoly_range r n d = elementary_sympoly_range(subring_generated(r:R ring) G) n d` [elementary_sympoly_range_subring] THEN
      have `!d. ring_polynomial(subring_generated r G) (elementary_sympoly_range(subring_generated(r:R ring) G) n d)` [polynomial_elementary_sympoly_range] THEN
      have `!d. poly_pow(r:R ring) (elementary_sympoly_range(subring_generated r G) n d) (e d) = poly_pow (subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d)` [poly_pow_subring;ring_polynomial] THEN
      have `!d. ring_polynomial(subring_generated(r:R ring) G) (poly_pow (subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))` [poly_pow_poly] THEN
      have `FINITE(1..n)` [FINITE_NUMSEG] THEN
      specialize_assuming[
        `r:R ring`;
        `G:R->bool`;
        `\d. poly_pow (subring_generated(r:R ring) G) (elementary_sympoly_range(subring_generated r G) n d) (e d)`;
        `1..n`
      ]poly_product_subring_multi THEN
      subgoal `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) = ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow (subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))` THENL [
        sufficesby RING_PRODUCT_EQ THEN
        qed[]
      ; pass
      ] THEN
      have `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow (subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d)) = ring_product (poly_ring(subring_generated r G) (:num)) (1..n) (\d. poly_pow (subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))` [ring_polynomial] THEN
      have `s = poly_sub(r:R ring) p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring(subring_generated r G) (:num)) (1..n) (\d. poly_pow(subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))))` [] THEN
      have `poly_const r (p t) = poly_const(subring_generated r G) (p(t:num->num)):(num->num)->R` [poly_const_subring] THEN
      have `s = poly_sub(r:R ring) p (poly_mul r (poly_const(subring_generated r G) (p t)) (ring_product (poly_ring(subring_generated r G) (:num)) (1..n) (\d. poly_pow(subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))))` [] THEN
      have `ring_polynomial (subring_generated(r:R ring) G) (poly_const (subring_generated r G) (p(t:num->num)):(num->num)->R)` [RING_POLYNOMIAL_CONST;ring_polynomial;ring_powerseries] THEN
      have `ring_powerseries (subring_generated(r:R ring) G) (poly_const (subring_generated r G) (p(t:num->num)):(num->num)->R)` [ring_polynomial] THEN
      have `ring_powerseries (subring_generated(r:R ring) G) (ring_product (poly_ring (subring_generated r G) (:num)) (1..n) (\d. poly_pow (subring_generated r G) (elementary_sympoly_range (subring_generated r G) n d) (e d)))` [RING_PRODUCT;GSYM poly_use;ring_polynomial] THEN
      specialize[
        `r:R ring`;
        `G:R->bool`;
        `poly_const(subring_generated(r:R ring) G) (p(t:num->num)):(num->num)->R`;
        `ring_product (poly_ring(subring_generated(r:R ring) G) (:num)) (1..n) (\d. poly_pow(subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))`
      ]poly_mul_subring THEN
      have `s = poly_sub(r:R ring) p (poly_mul(subring_generated r G) (poly_const(subring_generated r G) (p t)) (ring_product (poly_ring(subring_generated r G) (:num)) (1..n) (\d. poly_pow(subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))))` [] THEN
      have `s = poly_sub(subring_generated(r:R ring) G) p (poly_mul(subring_generated r G) (poly_const(subring_generated r G) (p t)) (ring_product (poly_ring(subring_generated r G) (:num)) (1..n) (\d. poly_pow(subring_generated r G) (elementary_sympoly_range(subring_generated r G) n d) (e d))))` [poly_sub_subring] THEN
      qed[RING_POLYNOMIAL_SUB;RING_POLYNOMIAL_MUL;RING_POLYNOMIAL_CONST;poly_use;RING_PRODUCT]
    ; pass
    ] THEN
    subgoal `!m:num->num. s m IN ring_carrier(subring_generated(r:R ring) G)` THENL [
      qed[ring_polynomial;ring_powerseries]
    ; pass
    ] THEN
    subgoal `poly_vars r (s:(num->num)->R) SUBSET range n` THENL [
      have `!d. elementary_sympoly_range(r:R ring) n d IN ring_carrier(poly_ring r (range n))` [elementary_sympoly_range_in_poly_ring] THEN
      have `!d. d IN 1..n ==> poly_pow r (elementary_sympoly_range(r:R ring) n d) (e d) IN ring_carrier(poly_ring r (range n))` [poly_pow_in_poly_ring] THEN
      specialize_assuming[
        `r:R ring`;
        `\d. poly_pow(r:R ring) (elementary_sympoly_range r n d) (e d)`;
        `range n`;
        `1..n`
      ]poly_product_in_poly_ring THEN
      have `ring_product(poly_ring (r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN ring_carrier(poly_ring r (range n))` [FINITE_NUMSEG] THEN
      have `poly_const r (p(t:num->num)):(num->num)->R IN ring_carrier(poly_ring r (range n))` [POLY_CONST;ring_polynomial;ring_powerseries] THEN
      have `poly_mul r (poly_const r (p(t:num->num))) (ring_product(poly_ring (r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) IN ring_carrier(poly_ring r (range n))` [poly_mul_in_poly_ring] THEN
      subgoal `p:(num->num)->R IN ring_carrier(poly_ring r (range n))` THENL [
        rw[POLY_RING;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      have `s:(num->num)->R IN ring_carrier(poly_ring r (range n))` [poly_sub_in_poly_ring] THEN
      specialize[`r:R ring`;`range n`](CONJUNCT1 POLY_RING) THEN
      have `s:(num->num)->R IN {q | ring_polynomial r q /\ poly_vars r q SUBSET range n}` [] THEN
      ASM SET_TAC[]
    ; pass
    ] THEN
    subgoal `!f m:num->num. f permutes range n ==> s(m o f) = s m:R` THENL [
      intro THEN
      rw[know `s = poly_sub(r:R ring) p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))`] THEN
      rw[poly_sub_o_permutes] THEN
      have_rw `!m. p(m o f) = p(m:num->num):R` [] THEN
      subgoal `(\m:num->num. poly_mul(r:R ring) (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) (m o f)) = poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))` THENL [
        rw[FUN_EQ_THM] THEN
        intro THEN
        specialize[
          `r:R ring`;
          `poly_const(r:R ring) (p(t:num->num)):(num->num)->R`
        ]poly_mul_o_permutes THEN
        have_rw `poly_mul(r:R ring) (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) (x o f) = poly_mul r (\m:num->num. (poly_const r (p t)) (m o f)) (\m. (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) (m o f)) x` [] THEN
        have_rw `!m:num->num. poly_const r (p(t:num->num):R) (m o (f:num->num)) = poly_const r (p t) m` [poly_const_o_permutes] THEN
        subgoal `(\m:num->num. ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) (m o f)) = ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))` THENL [
          rw[FUN_EQ_THM] THEN
          intro THEN
          have `FINITE(1..n)` [FINITE_NUMSEG] THEN
          specialize[
            `r:R ring`;
            `\d. poly_pow(r:R ring) (elementary_sympoly_range r n d) (e d)`;
            `range n`;
            `f:num->num`;
            `1..n`
          ]poly_product_o_permutes THEN
          have `!s. s IN 1..n ==> ring_polynomial(r:R ring) (poly_pow r (elementary_sympoly_range r n s) (e s))` [poly_pow_poly;polynomial_elementary_sympoly_range] THEN
          specialize[
            `x':num->num`
          ](know `!m. f permutes range n ==> (!s. s IN 1..n ==> ring_polynomial(r:R ring) (poly_pow r (elementary_sympoly_range r n s) (e s))) ==> ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) (m o f) = ring_product (poly_ring r (:num)) (1..n) (\s m. poly_pow r (elementary_sympoly_range r n s) (e s) (m o f)) m`) THEN
          rw[know `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) (x' o f) = ring_product (poly_ring r (:num)) (1..n) (\s m. poly_pow r (elementary_sympoly_range r n s) (e s) (m o f)) x'`] THEN
          subgoal `(\s m:num->num. poly_pow(r:R ring) (elementary_sympoly_range r n s) (e s) (m o f)) = (\d. poly_pow r (elementary_sympoly_range r n d) (e d))` THENL [
            once_rw[FUN_EQ_THM] THEN
            rw[fun_eq_thm_v] THEN
            intro THEN
            have `ring_powerseries(r:R ring) (elementary_sympoly_range r n x'')` [powerseries_elementary_sympoly_range] THEN
            specialize[
              `r:R ring`;
              `elementary_sympoly_range(r:R ring) n x''`;
              `range n`;
              `f:num->num`;
              `e(x'':num):num`;
              `v:num->num`
            ]poly_pow_o_permutes THEN
            rw[know `poly_pow(r:R ring) (elementary_sympoly_range r n x'') (e x'') (v o (f:num->num)) = poly_pow r (\m. elementary_sympoly_range r n x'' (m o f)) (e x'') v`] THEN
            subgoal `(\m. elementary_sympoly_range(r:R ring) n x'' (m o f)) = elementary_sympoly_range r n x''` THENL [
              rw[FUN_EQ_THM] THEN
              qed[elementary_sympoly_range_o_permutes]
            ; pass
            ] THEN
            qed[]
          ; pass
          ] THEN
          qed[]
        ; pass
        ] THEN
        rw[know `(\m:num->num. ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) (m o f)) = ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))`] THEN
        subgoal `(\m. poly_const r (p t) m) = poly_const(r:R ring) (p(t:num->num)):(num->num)->R` THENL [
          rw[FUN_EQ_THM]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      rw[know `(\m:num->num. poly_mul(r:R ring) (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) (m o f)) = poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))`] THEN
      havetac `(p:(num->num)->R) = (\m. p m)` (rw[FUN_EQ_THM]) THEN
      qed[]
    ; pass
    ] THEN
    specialize[`S:num->num`](know(`!m:num->num. monomial_lt (<=) m M ==> (!p. (!i. i < n ==> c i IN ring_carrier(r:R ring)) ==> (!d. coeff d (monic_vanishing_at r (range n) c) IN ring_carrier (subring_generated r G)) ==> ring_polynomial(subring_generated r G) p ==> poly_vars r p SUBSET range n ==> (!f m. f permutes range n ==> p (m o f) = p m) ==> support_le r p m ==> poly_evaluate r p c IN ring_carrier (subring_generated r G))`)) THEN
    have `support_le(r:R ring) (s:(num->num)->R) S` [] THEN
    specialize[`s:(num->num)->R`](know(`!p. (!i. i < n ==> c i IN ring_carrier(r:R ring)) ==> (!d. coeff d (monic_vanishing_at r (range n) c) IN ring_carrier (subring_generated r G)) ==> ring_polynomial(subring_generated r G) p ==> poly_vars r p SUBSET range n ==> (!f m. f permutes range n ==> p (m o f) = p m) ==> support_le r p S ==> poly_evaluate r p c IN ring_carrier (subring_generated r G)`)) THEN
    qed[]
  ; pass
  ] THEN
  subgoal `poly_evaluate(r:R ring) s c = ring_sub r (poly_evaluate r p c) (ring_mul r (p t) (ring_product r (1..n) (\d. ring_pow r (poly_evaluate r (elementary_sympoly_range r n d) c) (e d))))` THENL [
    rw[know `s = poly_sub(r:R ring) p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))`] THEN
    have `ring_polynomial(r:R ring) (poly_const r (p(t:num->num)):(num->num)->R)` [RING_POLYNOMIAL_CONST;ring_polynomial;ring_powerseries] THEN
    specialize_assuming[
      `r:R ring`;
      `poly_const r (p(t:num->num)):(num->num)->R`;
      `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))`
    ]RING_POLYNOMIAL_MUL THEN
    have `ring_polynomial(r:R ring) (poly_mul r (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))` [] THEN
    specialize[
      `r:R ring`;
      `p:(num->num)->R`;
      `poly_mul(r:R ring) (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))`;
      `c:num->R`
    ]POLY_EVALUATE_SUB THEN
    rw[know `poly_evaluate(r:R ring) (poly_sub r p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))) c = ring_sub r (poly_evaluate r p c) (poly_evaluate r (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))) c)`] THEN
    subgoal `poly_evaluate(r:R ring) (poly_mul r (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))) c = ring_mul r (p t) (ring_product r (1..n) (\d. ring_pow r (poly_evaluate r (elementary_sympoly_range r n d) c) (e d)))` THENL [
      subgoal `!i. i IN poly_vars r (poly_const r (p(t:num->num))) UNION poly_vars r (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) ==> c i IN ring_carrier (r:R ring)` THENL [
        rw[IN_UNION;POLY_VARS_CONST;EMPTY;IN_ELIM_THM] THEN
        have `!d. elementary_sympoly_range(r:R ring) n d IN ring_carrier(poly_ring r (range n))` [elementary_sympoly_range_in_poly_ring] THEN
        have `!d. d IN 1..n ==> poly_pow r (elementary_sympoly_range(r:R ring) n d) (e d) IN ring_carrier(poly_ring r (range n))` [poly_pow_in_poly_ring] THEN
        specialize_assuming[
          `r:R ring`;
          `\d. poly_pow(r:R ring) (elementary_sympoly_range r n d) (e d)`;
          `range n`;
          `1..n`
        ]poly_product_in_poly_ring THEN
        have `ring_product(poly_ring (r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN ring_carrier(poly_ring r (range n))` [FINITE_NUMSEG] THEN
        specialize[`r:R ring`;`range n`](CONJUNCT1 POLY_RING) THEN
        have `ring_product(poly_ring (r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET range n}` [] THEN
        intro THEN
        set_fact `ring_product(poly_ring (r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)) IN {q | ring_polynomial r q /\ poly_vars r q SUBSET range n} ==> i IN poly_vars r (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) ==> i IN range n` THEN
        qed[range_lt]
      ; pass
      ] THEN
      specialize[
        `r:R ring`;
        `poly_const r (p(t:num->num)):(num->num)->R`;
        `ring_product (poly_ring(r:R ring) (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))`;
        `c:num->R`
      ]POLY_EVALUATE_MUL THEN
      rw[know `poly_evaluate(r:R ring) (poly_mul r (poly_const r (p(t:num->num))) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d)))) c = ring_mul r (poly_evaluate r (poly_const r (p t)) c) (poly_evaluate r (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) c)`] THEN
      have_rw `poly_evaluate r (poly_const r (p(t:num->num)):(num->num)->R) c = p t` [POLY_EVALUATE_CONST;ring_polynomial;ring_powerseries] THEN
      subgoal `poly_evaluate(r:R ring) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) c = ring_product r (1..n) (\d. ring_pow r (poly_evaluate r (elementary_sympoly_range r n d) c) (e d))` THENL [
        have `FINITE(1..n)` [FINITE_NUMSEG] THEN
        have `!v. v IN range n ==> c v IN ring_carrier(r:R ring)` [range_lt] THEN
        have `!s. s IN 1..n ==> poly_pow(r:R ring) (elementary_sympoly_range r n s) (e s) IN ring_carrier (poly_ring r (range n))` [poly_pow_in_poly_ring;elementary_sympoly_range_in_poly_ring] THEN
        specialize[
          `r:R ring`;
          `\d. poly_pow(r:R ring) (elementary_sympoly_range r n d) (e d)`;
          `c:num->R`;
          `range n`;
          `1..n`
        ]eval_poly_product_multi THEN
        rw[know `poly_evaluate(r:R ring) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) c = ring_product r (1..n) (\s.  poly_evaluate r (poly_pow r (elementary_sympoly_range r n s) (e s)) c)`] THEN
        sufficesby RING_PRODUCT_EQ THEN
        rw[BETA_THM] THEN
        intro THEN
        have `elementary_sympoly_range(r:R ring) n a IN ring_carrier (poly_ring r (range n))` [elementary_sympoly_range_in_poly_ring] THEN
        have `!v. v IN range n ==> c v IN ring_carrier(r:R ring)` [range_lt] THEN
        specialize[
          `r:R ring`;
          `elementary_sympoly_range (r:R ring) n a`;
          `c:num->R`;
          `range n`;
          `e(a:num):num`
        ]eval_poly_pow_multi THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `ring_mul(r:R ring) (p(t:num->num)) (ring_product r (1..n) (\d. ring_pow r (poly_evaluate r (elementary_sympoly_range r n d) c) (e d))) IN ring_carrier (subring_generated r G)` THENL [
    have `(p(t:num->num)) IN ring_carrier (subring_generated(r:R ring) G)` [ring_polynomial;ring_powerseries] THEN
    subgoal `ring_product(r:R ring) (1..n) (\d. ring_pow r (poly_evaluate r (elementary_sympoly_range r n d) c) (e d)) IN ring_carrier (subring_generated r G)` THENL [
      sufficesby ring_product_in_subring THEN
      rw[BETA_THM] THEN
      intro THEN
      subgoal `poly_evaluate r (elementary_sympoly_range(r:R ring) n s') c IN ring_carrier(subring_generated r G)` THENL [
        have `s' <= n:num` [IN_NUMSEG] THEN
        simp[eval_elementary_sympoly_range_coeff] THEN
        have `ring_1(r:R ring) IN ring_carrier(subring_generated r G)` [SUBRING_GENERATED;RING_1] THEN
        have `ring_neg(subring_generated(r:R ring) G) (ring_1 r) IN ring_carrier(subring_generated r G)` [RING_NEG] THEN
        have `ring_neg(r:R ring) (ring_1 r) IN ring_carrier(subring_generated r G)` [SUBRING_GENERATED] THEN
        have `ring_pow(subring_generated(r:R ring) G) (ring_neg r (ring_1 r)) s':R IN ring_carrier(subring_generated r G)` [RING_POW] THEN
        have `ring_pow r (ring_neg r (ring_1 r)) s':R IN ring_carrier(subring_generated r G)` [RING_POW_SUBRING_GENERATED] THEN
        have `(coeff (n - s') (monic_vanishing_at r (range n) c)) IN ring_carrier (subring_generated(r:R ring) G)` [] THEN
        have `ring_mul(subring_generated r G) (ring_pow r (ring_neg r (ring_1 r)) s':R) (coeff (n - s') (monic_vanishing_at r (range n) c)) IN ring_carrier (subring_generated(r:R ring) G)` [RING_MUL] THEN
        qed[SUBRING_GENERATED]
      ; pass
      ] THEN
      have `ring_pow(subring_generated(r:R ring) G) (poly_evaluate r (elementary_sympoly_range r n s') c) (e s') IN ring_carrier (subring_generated r G)` [RING_POW] THEN
      qed[RING_POW_SUBRING_GENERATED]
    ; pass
    ] THEN
    have `ring_mul(subring_generated(r:R ring) G) (p(t:num->num)) (ring_product r (1..n) (\d. ring_pow r (poly_evaluate r (elementary_sympoly_range r n d) c) (e d))) IN ring_carrier (subring_generated r G)` [RING_MUL] THEN
    qed[SUBRING_GENERATED]
  ; pass
  ] THEN
  qed[sub_in_subring;POLY_EVALUATE]
);;
```

### Informal statement
Let `r` be a ring. Let `G` be a subset of `R`. Let `n` be a natural number. Let `c` be a function from natural numbers to `R`. Let `M` be a function from natural numbers to natural numbers. Let `p` be a function from functions from natural numbers to natural numbers to `R`.
If for all `i` less than `n`, `c i` is in the carrier of the ring `r`, and if for all `d`, the coefficient of `d` in the polynomial `monic_vanishing_at r (range n) c` is in the carrier of the subring generated by `G` in `r`, and if `p` is a polynomial over the subring generated by `G` in `r`, and the polynomial variables of `p` with respect to `r` are a subset of the range of `n`, and for all functions `f` and `m`, if `f` permutes the range of `n`, then `p(m o f) = p(m)`, and the support of `p` with respect to `r` is less than or equal to `M`, then the evaluation of `p` at `c` with respect to `r` is in the carrier of the subring generated by `G` in `r`.

### Informal sketch
The proof proceeds by monomial induction.
- **Base Case:** If `p` is the zero polynomial, then `poly_evaluate r p c` is `ring_0 r`, which is in `ring_carrier (subring_generated r G)`.
- **Base Case:** If `n = 0`, then `range n = {}`, `poly_vars r p = {}`, and `p = poly_const r (p monomial_1)`. Also, `p monomial_1` is in `ring_carrier r`, and `poly_evaluate r p c = p monomial_1`.
- **Inductive Step:**
  - Choose `t` such that `~(p t = ring_0 r) /\ support_le r p t`.
  - Case 1: `monomial_lt ((<=):num->num->bool) t M`. Apply the inductive hypothesis.
  - Case 2: `~(monomial_lt ((<=):num->num->bool) t M)`.
    - Prove `!i:num. i+1 < n ==> t i <= t (i+1):num` by contradiction using `swap(i,i+1) permutes range n` and `monomial_le_swap`.
    - Define `e:num->num` to be `\i. if i = n then t 0 else t(n-i) - t(n-i-1):num`.
    - Prove `t = (\i:num. if i < n then nsum(n-i..n) e else 0)` by induction.
    - Use `support_le1_product_pow_elementary_sympoly_range_v2` to get `support_le1(r:R ring) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))) t`.
    - Use `support_le_cancel` to define `s:(num->num)->R` as `poly_sub(r:R ring) p (poly_mul r (poly_const r (p t)) (ring_product (poly_ring r (:num)) (1..n) (\d. poly_pow r (elementary_sympoly_range r n d) (e d))))`.
    - Show `ring_polynomial r (s:(num->num)->R)`.
    - Show `poly_evaluate(r:R ring) (s:(num->num)->R) c IN ring_carrier(subring_generated r G)` using the induction.

### Mathematical insight
This lemma states that if a polynomial `p` over a ring `r` with variables in the range of `n` is symmetric with respect to permutations of the range of `n`, and its support is bounded by `M`, and the evaluation of the coefficients of a monic polynomial vanishing on the range of `n` at `c` is in the subring generated by `G` in `r`, then the evaluation of `p` at `c` is in the subring generated by `G` in `r`.
It's a component of a broader result about symmetric polynomials and subrings, particularly when these polynomials are evaluated at values that generate the subring.

### Dependencies
#### Theorems
- `monomial_induction`
- `ring_polynomial_if_subring`
- `ring_powerseries`
- `swap_permutes_range`
- `monomial_le_swap`
- `support_le1_product_pow_elementary_sympoly_range_v2`
- `support_le_cancel`
- `elementary_sympoly_range_subring`
- `polynomial_elementary_sympoly_range`
- `poly_pow_subring`
- `eval_elementary_sympoly_range_coeff`
- `RING_POW_SUBRING_GENERATED`
- `eval_poly_pow_multi`
- `eval_poly_product_multi`

#### Definitions
- `ring`
- `ring_carrier`
- `subring_generated`
- `monic_vanishing_at`
- `ring_polynomial`
- `poly_vars`
- `permutes`
- `support_le`
- `poly_evaluate`
- `poly_0`
- `range`
- `SUBSET_EMPTY`
- `poly_const`
- `monomial_1`
- `POLY_EVALUATE_CONST`
- `poly_first_monomial`
- `monomial_lt`
- `FUNCTION_EQ`
- `ARITH_RULE`
- `NSUM_CLAUSES_LEFT`
- `elementary_sympoly_range`
- `poly_ring`
- `poly_pow`
- `poly_sub`
- `poly_mul`
- `support_lt`
- `poly_const_times`
- `RING_POLYNOMIAL_SUB`
- `RING_POLYNOMIAL_MUL`
- `RING_POLYNOMIAL_CONST`
- `poly_use`
- `poly_product_subring_multi`
- `poly_const_subring`
- `poly_mul_subring`
- `poly_sub_subring`
- `poly_sub_o_permutes`
- `poly_mul_o_permutes`
- `poly_const_o_permutes`
- `poly_product_o_permutes`
- `poly_pow_o_permutes`
- `elementary_sympoly_range_o_permutes`
- `sub_in_subring`

#### Inductive Rules
- `SUBRING_GENERATED`
- `RING_0`
- `RING_NEG`
- `RING_POW`

### Porting notes (optional)
The core challenge in porting is the tactic-heavy proof style. The key will be to identify the major mathematical steps and dependencies, then reconstruct the proof using the target proof assistant's idioms. The monomial induction and manipulation of symmetric polynomials may require some effort to automate in other systems.


---

## symmetric_subring_if_poly_subring_range

### Name of formal statement
symmetric_subring_if_poly_subring_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symmetric_subring_if_poly_subring_range = prove(`
  !(r:R ring) G n c:num->R p.
  (!i. i < n ==> c i IN ring_carrier r) ==>
  (!d. coeff d (monic_vanishing_at r (range n) c) IN ring_carrier(subring_generated r G)) ==>
  ring_polynomial(subring_generated r G) p ==>
  poly_vars r p SUBSET range n ==>
  (!f m. f permutes range n ==>
         p(m o f) = p(m)) ==>
  poly_evaluate r p c IN ring_carrier(subring_generated r G)
`,
  intro THEN
  have `ring_polynomial r (p:(num->num)->R)` [ring_polynomial_if_subring] THEN
  choose `M:num->num` `support_le r (p:(num->num)->R) M` [support_le_exists] THEN
  specialize[
    `r:R ring`;
    `G:R->bool`;
    `n:num`;
    `c:num->R`;
    `M:num->num`;
    `p:(num->num)->R`
  ]symmetric_subring_if_poly_subring_lemma THEN
  qed[]
);;
```
### Informal statement
Let `r` be a ring, `G` a set of ring elements, `n` a natural number, and `c` a function from natural numbers to the ring `r`. Suppose that for all `i` less than `n`, `c i` is in the carrier of the ring `r`. Also, suppose that for all `d`, the coefficient of `d` in the polynomial `monic_vanishing_at r (range n) c` is in the carrier of the subring generated by `G` over `r`. Suppose `p` is a polynomial over the subring generated by `G` over `r`. Suppose the variables of the polynomial `p` are a subset of the range of `n`. Suppose also that for all functions `f` and `m`, if `f` permutes the range of `n`, then `p(m o f) = p(m)`. Then the evaluation of `p` at `c` in the ring `r` is in the carrier of the subring generated by `G` over `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce all the assumptions of the theorem.
- Apply the theorem `ring_polynomial_if_subring` given that `ring_polynomial r (p:(num->num)->R)`.
- Choose a witness `M:num->num` such that `support_le r (p:(num->num)->R) M` using `support_le_exists`.
- Apply the theorem `symmetric_subring_if_poly_subring_lemma` by specializing it with the assumptions of the theorem.
- Close the proof.

### Mathematical insight
This theorem states that under certain symmetry conditions, polynomial evaluation within a ring yields results within a subring. The key idea is that if a polynomial `p` over a subring is symmetric with respect to permutations of its variables (which are indices in a specific range) and its coefficients formed from the vanishing polynomial are in the subring, then evaluating `p` at a function `c` also taking arguments in the same range, with values in the original ring, will result in an element within the subring. This builds upon the idea that ring operations preserve subring membership.

### Dependencies
- `ring_polynomial_if_subring`
- `support_le_exists`
- `symmetric_subring_if_poly_subring_lemma`


---

## poly_reindex

### Name of formal statement
- poly_reindex

### Type of the formal statement
- new_definition

### Formal Content
```ocaml
let poly_reindex = new_definition `
  poly_reindex (r:R ring) (q:(Y->num)->R) (f:X->Y) (A:X->bool) (B:Y->bool)
  = (\m. if monomial_vars m SUBSET A
         then q(\b. if b IN B
                    then m(@a:X. a IN A /\ f a = b)
                    else 0)
         else ring_0 r)
`;;
```
### Informal statement
- Let `poly_reindex` be a function that takes a ring structure `r`, a polynomial `q` mapping functions from `Y` to numbers to ring elements, a function `f` from `X` to `Y`, a boolean predicate `A` on `X`, and a boolean predicate `B` on `Y`. It returns a new polynomial that maps functions from `X` to numbers to ring elements. This new polynomial, when applied to a monomial `m`, returns the ring zero if the variables in `m` are not a subset of `A`. Otherwise, it returns the polynomial `q` applied to a function that maps an element `b` in `B` to the value of `m` at any `a` in `A` such that `f a = b`, or to zero if `b` is not in `B`.

### Informal sketch
- The definition of `poly_reindex` describes how to transform a polynomial by relabeling its variables according to a function `f: X -> Y`. The sets `A` and `B` restrict the domains of the original and new variables, respectively.
- The key idea is that a monomial `m` over `X` (represented as a function from `X` to natural numbers, indicating variable powers), is transformed into a monomial over `Y`.
- This transformation depends on `f`, `A`, and `B`. If the variables appearing in `m` are not all in `A`, the result is zero. Otherwise, for each `b` in `B`, the power of `b` in the new monomial is the power of `some` `a` in `A` such that `f a = b` in the original monomial `m`. If there is no `a` satisfying `f a = b`, the power of `b` is zero.
- The new monomial is then passed as an argument to the original polynomial `q`, effectively relabeling the variables. The check `b IN B` ensures that variables outside `B` will have a zero coefficient after reindexing, effectively restricting the new monomial to the variables in `B`.

### Mathematical insight
- The function `poly_reindex` is used to change the set of variables that a polynomial depends on. The mapping `f` describes how to map from the old indices in `X` used in the original polynomial to the new indices `Y` in the re-indexed polynomial. The sets, `A` and `B` restrict the domain of the mapping to only consider indices in `A` and `B` respectively. This would be useful when converting between polynomials of different variable domains.

### Dependencies
- `monomial_vars`
- `SUBSET`
- `ring_0`
- `IN`


---

## poly_vars_poly_reindex

### Name of formal statement
poly_vars_poly_reindex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_vars_poly_reindex = prove(`
  !(r:R ring) A B q f:X->Y.
  BIJ f A B ==>
  poly_vars r q SUBSET B ==>
  poly_vars r (poly_reindex r q f A B) SUBSET A
`,
  rw[poly_reindex] THEN
  rw[poly_vars;UNIONS_SUBSET;IN_ELIM_THM] THEN
  rw[monomial_vars;SUBSET;IN_ELIM_THM;EXTENSION] THEN
  qed[]
);;
```
### Informal statement
For any ring `r`, sets `A` and `B`, polynomial `q` over ring `r`, and function `f` from `X` to `Y`, if `f` is a bijection from `A` to `B` and the variables of the polynomial `q` are a subset of `B`, then the variables of the reindexed polynomial `poly_reindex r q f A B` are a subset of `A`.

### Informal sketch
The proof proceeds as follows:
- Expand the definition of `poly_reindex`.
- Expand `poly_vars` and use properties of `UNIONS_SUBSET` and `IN_ELIM_THM` to rewrite the goal.
- Expand `monomial_vars`, followed by simplifications using `SUBSET`, `IN_ELIM_THM`, and `EXTENSION` to complete the proof.

### Mathematical insight
This theorem states that reindexing a polynomial `q` (with variables in `B`) using a bijection `f` from `A` to `B` results in a polynomial whose variables are now in `A`. The key idea is that the `poly_reindex` function effectively maps variables from `B` appearing in `q` back to `A` using the inverse bijection `f`.

### Dependencies
- Definitions: `poly_reindex`, `poly_vars`, `monomial_vars`
- Theorems: `UNIONS_SUBSET`, `IN_ELIM_THM`, `EXTENSION`


---

## powerseries_poly_reindex

### Name of formal statement
powerseries_poly_reindex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let powerseries_poly_reindex = prove(`
  !(r:R ring) A B q f:X->Y.
  BIJ f A B ==>
  ring_powerseries r q ==>
  ring_powerseries r (poly_reindex r q f A B)
`,
  rw[poly_reindex] THEN
  rw[ring_powerseries;INFINITE;monomial_vars;SUBSET;IN_ELIM_THM] THEN
  intro THENL [
    qed[RING_0]
  ;
    case `!x:X. ~(m x = 0) ==> x IN A` THENL [
      subgoal `~FINITE {b:Y | ~((\b. if b IN B then m (@a:X. a IN A /\ f a = b) else 0) b = 0)}` THENL [
        rw[BETA_THM] THEN
        intro THEN
        subgoal `{b:Y | ~((if b IN B then m (@a. a IN A /\ f a = b) else 0) = 0)} = IMAGE f {a:X | ~(m a = 0)}` THENL [
          rw[EXTENSION;IN_IMAGE;IN_ELIM_THM] THEN
          intro THEN
          splitiff THENL [
            intro THEN
            have `x:Y IN B` [] THEN
            have `SURJ (f:X->Y) A B` [BIJ] THEN
            choose `a:X` `a:X IN A /\ f a = x:Y` [SURJ] THEN
            witness `a:X` THEN
            subgoal `(@a:X. a IN A /\ f a = x:Y) = a` THENL [
              sufficesby SELECT_UNIQUE THEN
              qed[BIJ;INJ]
            ; pass
            ] THEN
            qed[]
          ;
            intro THEN
            have `x':X IN A` [] THEN
            have `x:Y IN B` [BIJ;INJ] THEN
            subgoal `(@a:X. a IN A /\ f a = x:Y) = x'` THENL [
              sufficesby SELECT_UNIQUE THEN
              qed[BIJ;INJ]
            ; pass
            ] THEN
            qed[]
          ]
        ; pass
        ] THEN
        specialize_assuming[
          `f:X->Y`;
          `{a:X | ~(m a = 0)}`
        ]FINITE_IMAGE_INJ_EQ THEN
        subgoal `!i j:X. i IN {a | ~(m a = 0)} ==> j IN {a | ~(m a = 0)} ==> f i = f j:Y ==> i = j` THENL [
          rw[IN_ELIM_THM] THEN
          qed[BIJ;INJ]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ;
      qed[]
    ]
  ]
);;
```
### Informal statement
For any ring `r` with ring operations `q`, and any sets `A` and `B`, and any function `f` from `X` to `Y`, if `f` is a bijection from `A` to `B`, and `q` gives rise to a ring powerseries, then `poly_reindex r q f A B` also gives rise to a ring powerseries.

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definitions of `poly_reindex` and `ring_powerseries`. The rewrite simplifies the goal by expanding the definition of `poly_reindex` and `ring_powerseries` to express that the polynomial reindexing preserves the ring powerseries property.
- Introduce assumptions.
- Deal with the case where the ring is the zero ring by automatically discharging the goal (`RING_0` tactic).
- Consider now the case where the ring `r` is not the zero ring. We use the assumption that all non-zero coefficients are in the set `A`.
  - Prove that the set `{b:Y | ~((\b. if b IN B then m (@a:X. a IN A /\ f a = b) else 0) b = 0)}` is finite, given the hypothesis `!x:X. ~(m x = 0) ==> x IN A`.
    - Rewrite using `BETA_THM`. Introduce `b`.
    - Prove the equality `{b:Y | ~((if b IN B then m (@a. a IN A /\ f a = b) else 0) = 0)} = IMAGE f {a:X | ~(m a = 0)}`.
      - Use extensionality to prove set equality.
      - Split each direction of the `iff`.
        - In the forward direction, we assume that `x` is in the first set.  We then show it is in the second. We leverage the surjectivity of `f` from `A` to `B`, given the assumption `BIJ`, to find an a such that `a IN A /\ f a = x:Y`.  Then we discharge the goal using `SELECT_UNIQUE` in order to prove `(@a:X. a IN A /\ f a = x:Y) = a`.
        - Similarly, in the reverse direction, we assume `x'` is in `A` and `x` in `B` and show that the existential instantiation from `IMAGE` equals `x'`, leveraging `SELECT_UNIQUE`.
    - Specialize the theorem `FINITE_IMAGE_INJ_EQ` with appropriate variables to reuse finiteness of the image under injective functions. Use `BIJ` to show `f` is injective at `~(m a = 0)`.

### Mathematical insight
The theorem shows that re-indexing a polynomial using a bijection preserves the powerseries property. The re-indexing operation is defined such that coefficients are moved according to the bijection, and the theorem guarantees that this process doesn't destroy the fundamental properties needed to form a powerseries. This is important in situations where you might want to change the indexing of terms in a power series without altering its essential mathematical character.

### Dependencies
- `poly_reindex`
- `ring_powerseries`
- `INFINITE`
- `monomial_vars`
- `SUBSET`
- `IN_ELIM_THM`
- `RING_0`
- `BETA_THM`
- `EXTENSION`
- `IN_IMAGE`
- `BIJ`
- `INJ`
- `SURJ`
- `SELECT_UNIQUE`
- `FINITE_IMAGE_INJ_EQ`

### Porting notes (optional)
- The proof relies on rewriting and equational reasoning, which are generally well-supported across different proof assistants.
- The use of `SELECT_UNIQUE` will need attention during porting, as the formulation varies widely across proof assistants. Be aware of how the `choose` tactic works and adjust the equivalent expression according to target formalism.
- The tactic `specialize_assuming` usage with `FINITE_IMAGE_INJ_EQ` requires careful attention during porting. Be aware of variable scoping to avoid missing to correctly define `f` or the set `{a:X | ~(m a = 0)}`.


---

## monomials_poly_reindex

### Name of formal statement
monomials_poly_reindex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monomials_poly_reindex = prove(`
  !(r:R ring) A B q f:X->Y.
  BIJ f A B ==>
  ring_powerseries r q ==>
  poly_vars r q SUBSET B ==>
  {m | ~((poly_reindex r q f A B) m = ring_0 r)}
  = IMAGE
      (\m:Y->num. \a:X. if a IN A then m (f a) else 0)
      {m | ~(q m = ring_0 r)}
`,
  rw[poly_reindex] THEN
  rw[EXTENSION;in_image_vw;IN_ELIM_THM] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    witness `(\b:Y. if b IN B then x (@a:X. a IN A /\ f a = b) else 0)` THEN
    intro THENL [
      rw[fun_eq_thm_e] THEN
      intro THEN
      case `e:X IN A` THENL [
        subgoal `(@a:X. a IN A /\ f a = f e:Y) = e` THENL [
          sufficesby SELECT_UNIQUE THEN
          qed[BIJ;INJ]
        ; pass
        ] THEN
        qed[BIJ;INJ]
      ; pass
      ] THEN
      have `monomial_vars(x:X->num) SUBSET A` [] THEN
      have `~(e:X IN monomial_vars x)` [SUBSET] THEN
      have `~(e:X IN {i | ~(x i = 0)})` [monomial_vars] THEN
      set_fact `~(e:X IN {i | ~(x i = 0)}) ==> x e = 0` THEN
      qed[]
    ;
      qed[]
    ]
  ;
    intro THEN
    subgoal `monomial_vars(x:X->num) SUBSET A` THENL [
      rw[monomial_vars;SUBSET;IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `(\b:Y. if b IN B then x (@a:X. a IN A /\ f a = b) else 0) = v` THENL [
      rw[fun_eq_thm_e] THEN
      intro THEN
      case `e:Y IN B` THENL [
        have `SURJ (f:X->Y) A B` [BIJ] THEN
        choose `a:X` `a:X IN A /\ f a = e:Y` [SURJ] THEN
        subgoal `(@a:X. a IN A /\ f a = e:Y) = a` THENL [
          sufficesby SELECT_UNIQUE THEN
          qed[BIJ;INJ]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      subgoal `v(e:Y) = 0` THENL [
        proven_if `v(e:Y) = 0` [] THEN
        subgoal `e IN monomial_vars(v:Y->num)` THENL [
          rw[monomial_vars;IN_ELIM_THM] THEN
          qed[]
        ; pass
        ] THEN
        subgoal `e IN poly_vars r (q:(Y->num)->R)` THENL [
          rw[poly_vars;IN_UNIONS;IN_ELIM_THM] THEN
          qed[]
        ; pass
        ] THEN
        qed[SUBSET]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ]
);;
```

### Informal statement
Given a ring `r`, sets `A` and `B`, a function `f` from `X` to `Y`, and a function `q` from `Y` to ring `r` such that: 
1. `f` is a bijection between `A` and `B`,
2. `q` is a ring powerseries,
3. the variables of the polynomial `q` are a subset of `B`.

Then, the set of monomials `m` such that `(poly_reindex r q f A B) m` is not equal to the ring zero is equal to the image of the set of monomials `m` such that `q m` is not equal to the ring zero, under the function that maps a monomial `m` to a monomial which maps `a` to `m (f a)` if `a` is in `A`, and to 0 otherwise.

### Informal sketch
The proof proceeds by showing the equality of two sets, ` {m | ~((poly_reindex r q f A B) m = ring_0 r)}` and `IMAGE (\m:Y->num. \a:X. if a IN A then m (f a) else 0) {m | ~(q m = ring_0 r)}`. This is accomplished by showing that each set is a subset of the other.
- First, we show that if `m` is a monomial such that `(poly_reindex r q f A B) m` is non-zero, then it is in the image of monomials `v` such that `q v` is non-zero. This involves constructing a witness `v` such that `v` maps `b` to `x (@a:X. a IN A /\ f a = b)` if `b` is in `B`, and to `0` otherwise, and then showing that `(poly_reindex r q f A B) m = q v`. This step relies on the fact that f is a bijection.
- Second, we show that if `m` is in the image of monomials `v` such that `q v` is non-zero, then `(poly_reindex r q f A B) m` is non-zero.

The proof relies on the properties of `poly_reindex`, `ring_powerseries`, `poly_vars`, `bijection`, `surjection`, `injection`, and the definitions of `monomial_vars`.

### Mathematical insight
This theorem relates the monomials that appear in a polynomial after reindexing its variables to the monomials that appear in the original polynomial. The reindexing is done using a bijection `f` between the original variable set `A` and the new variable set `B`. The theorem shows that the monomials in the reindexed polynomial are essentially obtained by composing the original monomials with the bijection `f`. This is a crucial result for reasoning about polynomial transformations and variable substitutions.

### Dependencies
- Definitions: `poly_reindex`, `ring_powerseries`, `poly_vars`, `monomial_vars`
- Theorems: `EXTENSION`, `in_image_vw`, `IN_ELIM_THM`, `fun_eq_thm_e`, `BIJ`, `INJ`, `SURJ`, `SUBSET`

### Porting notes (optional)
- Porting this theorem requires careful consideration of how variable reindexing and monomial representation are handled in the target proof assistant. In particular, the treatment of monomials as functions from variables to numbers is key.
- The use of choice (`@`) might require equivalent axioms or constructions from the target proof assistant.
- The frequent use of rewriting and simplification suggests that a proof assistant with strong automation in these areas will be beneficial.


---

## polynomial_poly_reindex

### Name of formal statement
polynomial_poly_reindex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let polynomial_poly_reindex = prove(`
  !(r:R ring) A B q f:X->Y.
  BIJ f A B ==>
  ring_polynomial r q ==>
  poly_vars r q SUBSET B ==>
  ring_polynomial r (poly_reindex r q f A B)
`,
  rw[ring_polynomial] THEN
  intro THENL [
    qed[powerseries_poly_reindex]
  ; pass
  ] THEN
  specialize[
    `r:R ring`;
    `A:X->bool`;
    `B:Y->bool`;
  ]monomials_poly_reindex THEN
  qed[FINITE_IMAGE]
);;
```
### Informal statement
For any ring `r`, and any sets `A` and `B`, and any polynomial `q` over `r`, and any function `f` from `X` to `Y`, if `f` is a bijection from `A` to `B`, and `q` is a ring polynomial over `r`, and the variables of the polynomial `q` are a subset of `B`, then `poly_reindex r q f A B` is a ring polynomial over `r`.

### Informal sketch
The proof proceeds as follows:
- First, rewrite using the definition of `ring_polynomial`.
- Introduce assumptions: `r`, `A`, `B`, `q`, `f`, `BIJ f A B`, `ring_polynomial r q`, `poly_vars r q SUBSET B`.
- Apply `powerseries_poly_reindex`.
- Specialize the theorem `monomials_poly_reindex` with the ring `r`, the set `A`, and the set `B`.
- Finally, conclude using `FINITE_IMAGE`.

### Mathematical insight
This theorem establishes that reindexing the variables of a ring polynomial using a bijection results in another ring polynomial. This ensures that the property of being a ring polynomial is preserved under variable renaming.

### Dependencies
- Definitions: `ring_polynomial`, `poly_reindex`, `poly_vars`, `BIJ`
- Theorems: `powerseries_poly_reindex`, `monomials_poly_reindex`, `FINITE_IMAGE`

### Porting notes (optional)
The main difficulty might be related to automation and rewriting of definitions. Reindexing operations are likely to be slightly different across systems, so special care has to be taken during the `poly_reindex` translation.


---

## poly_reindex_permutes

### Name of formal statement
poly_reindex_permutes

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_reindex_permutes = prove(`
  !(r:R ring) A B q f:X->Y.
  BIJ f A B ==>
  ring_polynomial r q ==>
  (!h m. h permutes B ==>
         q(m o h) = q(m)) ==>
  (!g m. g permutes A ==>
         (poly_reindex r q f A B)(m o g)
         = (poly_reindex r q f A B)(m))
`,
  intro THEN
  rw[poly_reindex] THEN
  case `monomial_vars(m:X->num) SUBSET A` THENL [
    subgoal `monomial_vars(m:X->num o g:X->X) SUBSET A` THENL [
      rw[SUBSET;monomial_vars;IN_ELIM_THM;o_THM] THEN
      intro THEN
      set_fact `~(m(g(x:X):X) = 0) ==> g(x:X):X IN {i | ~(m i = 0)}` THEN
      have `g(x:X):X IN monomial_vars m` [monomial_vars] THEN
      have `g(x:X):X IN A` [SUBSET] THEN
      qed[PERMUTES_IN_IMAGE]
    ; pass
    ] THEN
    simp[] THEN
    def `h:Y->Y` `\y:Y. if y IN B then f(g(@x:X. x IN A /\ f x = y)) else y` THEN
    subgoal `h:Y->Y permutes B` THENL [
      have `!x y:X. x IN A ==> y IN A ==> f x = f y:Y ==> x = y` [BIJ;INJ] THEN
      subgoal `!a:X. a IN A ==> h(f a:Y) = f(g a)` THENL [
        intro THEN
        simp[o_THM] THEN
        subgoal `(@x:X. x IN A /\ f x = f a:Y) = a` THENL [
          sufficesby SELECT_UNIQUE THEN
          qed[]
        ; pass
        ] THEN
        qed[BIJ;INJ]
      ; pass
      ] THEN
      subgoal `!b:Y. ~(b IN IMAGE (f:X->Y) A) ==> h b = b` THENL [
        have `SURJ (f:X->Y) A B` [BIJ] THEN
        simp[image_surj]
      ; pass
      ] THEN
      specialize[
        `f:X->Y`;
        `g:X->X`;
        `h:Y->Y`;
        `A:X->bool`
      ]PERMUTES_TRANSFER THEN
      qed[BIJ;image_surj]
    ; pass
    ] THEN
    subgoal `(\b:Y. if b IN B then (m o g) (@a:X. a IN A /\ f a = b) else 0) = (\b. if b IN B then m (@a. a IN A /\ f a = b) else 0) o h` THENL [
      rw[fun_eq_thm_e;o_THM] THEN
      intro THEN
      case `e:Y IN B` THENL [
        have `h(e:Y):Y IN B` [PERMUTES_IN_IMAGE] THEN
        simp[] THEN
        have `SURJ (f:X->Y) A B` [BIJ] THEN
        choose `a:X` `a:X IN A /\ f a = e:Y` [SURJ] THEN
        subgoal `(@x:X. x IN A /\ f x = e:Y) = a` THENL [
          sufficesby SELECT_UNIQUE THEN
          qed[BIJ;INJ]
        ; pass
        ] THEN
        simp[] THEN
        subgoal `(@a':X. a' IN A /\ f a' = f (g a):Y) = g(a:X):X` THENL [
          sufficesby SELECT_UNIQUE THEN
          have `g(a:X):X IN A` [PERMUTES_IN_IMAGE] THEN
          qed[BIJ;INJ]
        ; pass
        ] THEN
        simp[]
      ;
        qed[]
      ]
    ; pass
    ] THEN
    qed[]
  ;
    subgoal `~(monomial_vars(m:X->num o g:X->X) SUBSET A)` THENL [
      rw[SUBSET;monomial_vars;IN_ELIM_THM;o_THM] THEN
      rw[NOT_FORALL_THM;NOT_IMP] THEN
      choose `a:X` `a IN monomial_vars m /\ ~(a:X IN A)` [SUBSET] THEN
      witness `a:X` THEN
      have `g(a:X) = a` [permutes] THEN
      have `a:X IN {i | ~(m i = 0)}` [monomial_vars] THEN
      set_fact `a:X IN {i | ~(m i = 0)} ==> ~(m a = 0)` THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r`, sets `A` and `B`, polynomial `q` of type `X -> num` (where `num` is the type of numbers), and bijective function `f` from `X` to `Y`, if `f` is a bijection between `A` and `B`, `q` is a ring polynomial, and `q(m o h) = q(m)` for all functions `h` permuting `B` and all `m : X -> num`, then for all functions `g` permuting `A` and all `m : X -> num`, `(poly_reindex r q f A B)(m o g) = (poly_reindex r q f A B)(m)`.

### Informal sketch
The proof shows that if a polynomial `q` is invariant under permutation of its domain `B`, then the reindexed polynomial `poly_reindex r q f A B` is invariant under permutations of `A`. The proof proceeds by cases based on whether the variables of the monomial `m` are a subset of `A`.

- **Case 1: `monomial_vars(m) SUBSET A`**:
    - Show that `monomial_vars(m o g) SUBSET A` by using the fact that `g permutes A`, thus the image of `monomial_vars(m)` under `g` is still a subset of `A`.
    - Define a function `h: Y -> Y` as follows: if `y IN B`, then `h(y) = f(g(the a such that a IN A /\ f(a) = y))`, otherwise `h(y) = y`.
    - Prove that `h` permutes `B` by showing `h(f a) = f(g a)` for `a IN A` and `h b = b` if `b` is not the image of any element in `A`. Then transfer permutation property.
    - Show `(\b:Y. if b IN B then (m o g) (@a:X. a IN A /\ f a = b) else 0) = (\b. if b IN B then m (@a. a IN A /\ f a = b) else 0) o h`. This uses the properties of `g` and `h` as permutations, and the bijectivity of `f` between `A` and `B`.

- **Case 2: `~(monomial_vars(m) SUBSET A)`**:
    - It is shown that `~(monomial_vars(m o g) SUBSET A)`. This case relies on the assumption that `g` permutes `A`, therefore if an element `a` is not in `A`, `g(a) = a`.

### Mathematical insight
This theorem states that reindexing a polynomial preserves its invariance under permutations. This is a crucial property when dealing with symmetries in polynomial rings, especially when considering group actions on variables. If a polynomial is symmetric with respect to permutations of a set of variables, its reindexing will also be symmetric with respect to correspondingly permuted variables in the target set.

### Dependencies
- `ring_polynomial`
- `BIJ`
- `SUBSET`
- `monomial_vars`
- `PERMUTES_IN_IMAGE`
- `INJ`
- `image_surj`
- `PERMUTES_TRANSFER`
- `SELECT_UNIQUE`
- `SURJ`
- `NOT_FORALL_THM`
- `NOT_IMP`
- `fun_eq_thm_e`
- `o_THM`
- `IN_ELIM_THM`
- `rw`
- `intro`
- `simp`
- `case`
- `subgoal`
- `THENL`
- `qed`
- `def`
- `set_fact`
- `have`
- `specialize`
- `witness`
- `PERMUTES_IN_IMAGE`

### Porting notes (optional)
- The definition of `poly_reindex` and `monomial_vars` must be available.
- The handling of choice functions (using `@`) may differ in other systems; it might be necessary to explicitly prove the existence and uniqueness conditions.
- The tactic `PERMUTES_TRANSFER` encapsulates a common permutation transfer argument; ensure the target system has a similar mechanism or spell out the argument explicitly.


---

## poly_evaluate_poly_reindex

### Name of formal statement
poly_evaluate_poly_reindex

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_evaluate_poly_reindex = prove(`
  !(r:R ring) A B q f:X->Y c:Y->R.
  BIJ f A B ==>
  ring_polynomial r q ==>
  poly_vars r q SUBSET B ==>
  poly_evaluate r (poly_reindex r q f A B) (c o f)
  = poly_evaluate r q c
`,
  rw[poly_evaluate;poly_extend] THEN
  intro THEN
  have `ring_powerseries r (q:(Y->num)->R)` [ring_polynomial] THEN
  specialize[
    `r:R ring`;
    `A:X->bool`;
    `B:Y->bool`;
    `q:(Y->num)->R`;
    `f:X->Y`
  ]monomials_poly_reindex THEN
  simp[] THEN
  subgoal `!x y:Y->num. x IN {m | ~(q m:R = ring_0 r)} ==> y IN {m | ~(q m = ring_0 r)} ==> (\a:X. if a IN A then x (f a) else 0) = (\a. if a IN A then y (f a) else 0) ==> x = y` THENL [
    rw[IN_ELIM_THM;fun_eq_thm_e] THEN
    intro THEN
    case `e:Y IN B` THENL [
      choose `a:X` `a:X IN A /\ f a = e:Y` [BIJ;SURJ] THEN
      qed[]
    ; pass
    ] THEN
    case `~(x(e:Y) = 0)` THENL [
      subgoal `e:Y IN monomial_vars x` THENL [
        rw[monomial_vars;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      subgoal `e IN poly_vars r (q:(Y->num)->R)` THENL [
        rw[poly_vars;IN_UNIONS;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      qed[SUBSET]
    ; pass
    ] THEN
    case `~(y(e:Y) = 0)` THENL [
      subgoal `e:Y IN monomial_vars y` THENL [
        rw[monomial_vars;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      subgoal `e IN poly_vars r (q:(Y->num)->R)` THENL [
        rw[poly_vars;IN_UNIONS;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      qed[SUBSET]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `r:R ring`;
    `\m a:X. if a IN A then m (f a:Y) else 0`;
    `\m:X->num. ring_mul(r:R ring) (I (poly_reindex r q (f:X->Y) A B m)) (ring_product r (monomial_vars m) (\i. ring_pow r ((c o f) i) (m i)))`;
    `{m:Y->num | ~(q m:R = ring_0 r)}`
  ]RING_SUM_IMAGE THEN
  simp[] THEN
  sufficesby ring_sum_eq_name_d THEN
  rw[BETA_THM;o_THM;I_THM;IN_ELIM_THM] THEN
  intro THEN
  subgoal `!x:Y. ~(d x = 0) ==> x IN B` THENL [
    intro THEN
    subgoal `x:Y IN monomial_vars d` THENL [
      rw[monomial_vars;IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `x IN poly_vars r (q:(Y->num)->R)` THENL [
      rw[poly_vars;IN_UNIONS;IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    qed[SUBSET]
  ; pass
  ] THEN
  subgoal `poly_reindex r q f A B (\a:X. if a IN A then d (f a:Y) else 0) = q d:R` THENL [
    rw[poly_reindex;monomial_vars;SUBSET;IN_ELIM_THM] THEN
    subgoal `(\b:Y. if b IN B then if (@a:X. a IN A /\ f a = b) IN A then d (f (@a. a IN A /\ f a = b)) else 0 else 0) = d` THENL [
      rw[FUN_EQ_THM] THEN
      intro THEN
      case `x:Y IN B` THENL [
        choose `a:X` `a:X IN A /\ f a = x:Y` [BIJ;SURJ] THEN
        subgoal `(@a:X. a IN A /\ f a = x:Y) = a` THENL [
          sufficesby SELECT_UNIQUE THEN
          qed[BIJ;INJ]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `monomial_vars (d:Y->num) = IMAGE f (monomial_vars (\a:X. if a IN A then d(f a) else 0))` THENL [
    rw[EXTENSION;in_image_vw;monomial_vars;IN_ELIM_THM] THEN
    intro THEN
    splitiff THENL [
      intro THEN
      choose `a:X` `a:X IN A /\ f a = x:Y` [BIJ;SURJ] THEN
      witness `a:X` THEN
      qed[]
    ;
      qed[]
    ]
  ; pass
  ] THEN
  simp[] THEN
  subgoal `!x y:X. x IN monomial_vars (\a. if a IN A then d (f a:Y) else 0) ==> y IN monomial_vars (\a:X. if a IN A then d (f a) else 0) ==> f x = f y ==> x = y` THENL [
    rw[IN_ELIM_THM;fun_eq_thm_e;monomial_vars] THEN
    intro THEN
    qed[BIJ;INJ]
  ; pass
  ] THEN
  specialize[
    `r:R ring`;
    `f:X->Y`;
    `\i:Y. ring_pow(r:R ring) (c i) (d i)`;
    `monomial_vars (\a:X. if a IN A then d (f a:Y) else 0)`
  ]RING_PRODUCT_IMAGE THEN
  simp[] THEN
  subgoal `ring_product r (monomial_vars (\a:X. if a IN A then d (f a:Y) else 0)) (\i. ring_pow r (c (f i):R) (if i IN A then d (f i) else 0)) = ring_product r (monomial_vars (\a. if a IN A then d (f a) else 0)) ((\i. ring_pow r (c i) (d i)) o f)` THENL [
    sufficesby RING_PRODUCT_EQ THEN
    rw[BETA_THM;o_THM;monomial_vars;IN_ELIM_THM] THEN
    qed[]
  ; pass
  ] THEN
  simp[]
);;
```

### Informal statement
Given a ring `r` and types `X` and `Y`, suppose that `A` and `B` are subsets of `X` and `Y` respectively. Suppose `f` is a bijection from `A` to `B`. Suppose `q` is a ring polynomial over `r`. Suppose the variables of the polynomial `q` are a subset of `B`. Then the evaluation of the reindexed polynomial `poly_reindex r q f A B` under `c o f` is equal to the evaluation of `q` under `c`, where `c` is a function from `Y` to the ring `R`.

### Informal sketch
The proof proceeds as follows:
- The theorem to be proven is `poly_evaluate r (poly_reindex r q f A B) (c o f) = poly_evaluate r q c`.
- Expand `poly_evaluate` using `poly_extend`.
- Introduce the assumptions of the theorem.
- Instantiate `monomials_poly_reindex` with the ring `r`, sets `A` and `B`, polynomial `q`, and function `f`.
- Simplify using basic rewrites.
- Prove the subgoal: `!x y:Y->num. x IN {m | ~(q m:R = ring_0 r)} ==> y IN {m | ~(q m = ring_0 r)} ==> (\a:X. if a IN A then x (f a) else 0) = (\a. if a IN A then y (f a) else 0) ==> x = y`
  - Rewrite using `IN_ELIM_THM` and `fun_eq_thm_e`.
  - Introduce the assumptions.
  - Perform case analysis on whether `e:Y IN B`.
    - If `e IN B`, choose `a:X` such that `a IN A /\ f a = e:Y` (using the bijection `BIJ` and `SURJ`) and complete the proof by simplification. 
    - Otherwise we proceed to the next case analysis.
  - Do case analysis on `~(x(e:Y) = 0)`.
    - if `~(x(e:Y) = 0)`, show that `e:Y IN monomial_vars x` and `e IN poly_vars r (q:(Y->num)->R)` and complete the proof using the subset assumption.
  - Do case analysis on `~(y(e:Y) = 0)`.
    - if `~(y(e:Y) = 0)`, show that `e:Y IN monomial_vars y` and `e IN poly_vars r (q:(Y->num)->R)` and complete the proof using the subset assumption.
  - Complete remaining cases by contradiction.
- Instantiate `RING_SUM_IMAGE` with `r`, `\m a:X. if a IN A then m (f a:Y) else 0`, `\m:X->num. ring_mul(r:R ring) (I (poly_reindex r q (f:X->Y) A B m)) (ring_product r (monomial_vars m) (\i. ring_pow r ((c o f) i) (m i)))`, `{m:Y->num | ~(q m:R = ring_0 r)}`.
- Simplify using basic rewrites.
- Prove using `ring_sum_eq_name_d`.
- Rewrite using `BETA_THM`, `o_THM`, `I_THM`, `IN_ELIM_THM`.
- Introduce the assumption.
- Prove the subgoal `!x:Y. ~(d x = 0) ==> x IN B`
  - Introduce the assumption.
  - show that `x:Y IN monomial_vars d` and `x IN poly_vars r (q:(Y->num)->R)`.
  - Conclude using the subset assumption.
- Prove the subgoal `poly_reindex r q f A B (\a:X. if a IN A then d (f a:Y) else 0) = q d:R`
  - Rewrite using `poly_reindex`, `monomial_vars`, `SUBSET`, `IN_ELIM_THM`.
  - Prove the subgoal `(\b:Y. if b IN B then if (@a:X. a IN A /\ f a = b) IN A then d (f (@a. a IN A /\ f a = b)) else 0 else 0) = d`.
    - Rewrite using `FUN_EQ_THM`.
    - Introduce `x:Y`.
    - Perform case analysis on `x:Y IN B`.
      - If `x IN B`, choose `a:X` such that `a IN A /\ f a = x:Y` (using the bijection `BIJ` and `SURJ`).
      - Show `(@a:X. a IN A /\ f a = x:Y) = a`
        - Show that the condition for `SELECT_UNIQUE` holds via `BIJ` and `INJ`.
      - Conclude the case
    - Conclude the remaining case.
- Prove the subgoal `monomial_vars (d:Y->num) = IMAGE f (monomial_vars (\a:X. if a IN A then d(f a) else 0))`
  - Rewrite using `EXTENSION`, `in_image_vw`, `monomial_vars`, `IN_ELIM_THM`.
  - Introduce assumptions
  - split iff
    - If there exists an element, conclude the result by choosing `a:X` such that `a IN A /\ f a = x:Y` using `BIJ` and `SURJ`.
- Simplify.
- Prove the subgoal `!x y:X. x IN monomial_vars (\a. if a IN A then d (f a:Y) else 0) ==> y IN monomial_vars (\a:X. if a IN A then d (f a) else 0) ==> f x = f y ==> x = y`
  - Rewrite using `IN_ELIM_THM`, `fun_eq_thm_e`, `monomial_vars`
  - Introduce assumptions.
  - Use `BIJ` and `INJ` to finalize the proof
- Instantiate `RING_PRODUCT_IMAGE` with `r`, `f:X->Y`, `\i:Y. ring_pow(r:R ring) (c i) (d i)`, `monomial_vars (\a:X. if a IN A then d (f a:Y) else 0)`.
- Simplify
- Prove the subgoal `ring_product r (monomial_vars (\a:X. if a IN A then d (f a:Y) else 0)) (\i. ring_pow r (c (f i):R) (if i IN A then d (f i) else 0)) = ring_product r (monomial_vars (\a. if a IN A then d (f a) else 0)) ((\i. ring_pow r (c i) (d i)) o f)`
  - Suffices to show that the ring product terms are equal.
  - Rewrite using `BETA_THM`, `o_THM`, `monomial_vars`, `IN_ELIM_THM`.
- Simplify.

### Mathematical insight
This theorem shows that evaluating a polynomial after reindexing its variables using a bijection is equivalent to evaluating the original polynomial, provided the evaluation function is adjusted to account for the reindexing. This is a critical result for manipulating polynomials in formal settings. Specifically, it allows us to reason about variable substitutions and transformations while preserving the polynomial's value.

### Dependencies
- `poly_evaluate`
- `poly_extend`
- `ring_polynomial`
- `monomials_poly_reindex`
- `RING_SUM_IMAGE`
- `ring_sum_eq_name_d`
- `poly_reindex`
- `RING_PRODUCT_IMAGE`
- `FUN_EQ_THM`
- `BETA_THM`
- `o_THM`
- `I_THM`
- `IN_ELIM_THM`
- `EXTENSION`
- `in_image_vw`
- `monomial_vars`
- `SUBSET`
- `BIJ`
- `SURJ`
- `INJ`
- `RING_PRODUCT_EQ`
### Porting notes (optional)
- The proof relies heavily on rewriting and simplification. Ensure the target proof assistant has similar capabilities.
- The use of `SELECT_UNIQUE` may require special attention depending on its precise definition and usage in the target system.
- The `RING_PRODUCT_IMAGE` and `RING_SUM_IMAGE` lemmas are used to manipulate summations and products over images; ensure that the target library has equivalents or that these are ported along with their relevant dependencies


---

## poly_reindex_subring

### Name of formal statement
poly_reindex_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_reindex_subring = prove(`
  !(r:R ring) G A B q f:X->Y.
  poly_reindex(subring_generated r G) q f A B
  = poly_reindex r q f A B
`,
  rw[poly_reindex] THEN
  rw[SUBRING_GENERATED]
);;
```
### Informal statement
For any ring `r` (of type `R ring`), set of generators `G`, sets `A` and `B`, function `q` from type `X` to type `Y`, and function `f` from type `X` to type `Y`, the polynomial reindexing of the subring generated by `G` with respect to ring `r`, function `q`, and function `f`, over sets `A` and `B`, is equal to the polynomial reindexing of ring `r` with respect to function `q` and function `f`, over sets `A` and `B`.

### Informal sketch
The proof proceeds by:
- Rewriting the left-hand side using the definition of `poly_reindex`.
- Rewriting further using the definition of `SUBRING_GENERATED`.
- This results in the left-hand side being identical to the right-hand side, thus proving the equality.

### Mathematical insight
This theorem states that when reindexing polynomials, we can replace a subring generated by a set `G` with the base ring `r` without affecting the result. This is because the subring is generated with respect to that base ring. This result could simplify calculations or reasoning when dealing with polynomial reindexing over generated subrings.

### Dependencies
- Definitions:
  - `poly_reindex`
  - `SUBRING_GENERATED`


---

## symmetric_subring_if_poly_subring

### Name of formal statement
symmetric_subring_if_poly_subring

### Type of the formal statement
theorem

### Formal Content
```ocaml
let symmetric_subring_if_poly_subring = prove(`
  !(r:R ring) G S c:X->R q.
  FINITE S ==>
  (!s. s IN S ==> c s IN ring_carrier r) ==>
  (!d. coeff d (monic_vanishing_at r S c) IN ring_carrier(subring_generated r G)) ==>
  ring_polynomial(subring_generated r G) q ==>
  poly_vars r q SUBSET S ==>
  (!f m. f permutes S ==>
         q(m o f) = q(m)) ==>
  poly_evaluate r q c IN ring_carrier(subring_generated r G)
`,
  intro THEN
  choose `f:num->X` `IMAGE f (range(CARD S)) = S:X->bool` [finite_ordering] THEN
  def `p:(num->num)->R` `poly_reindex (r:R ring) q (f:num->X) (range(CARD S)) (S:X->bool)` THEN
  subgoal `!i. i < CARD(S:X->bool) ==> c(f i:X) IN ring_carrier(r:R ring)` THENL [
    intro THEN
    have `i IN range(CARD(S:X->bool))` [range_lt] THEN
    have `f(i:num) IN (S:X->bool)` [IN_IMAGE] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!d. coeff d (monic_vanishing_at r (range(CARD(S:X->bool))) (\i:num. c(f i:X):R)) IN ring_carrier(subring_generated r G)` THENL [
    intro THEN
    have `(\i:num. c(f i:X):R) = c o f` [FUN_EQ_THM;o_THM] THEN
    specialize[
      `S:X->bool`;
      `f:num->X`
    ]injective_finite_ordering THEN
    have `!x y. x IN range(CARD(S:X->bool)) ==> y IN range(CARD S) ==> f x:X = f y ==> x = y` [range_lt] THEN
    specialize[
      `r:R ring`;
      `range(CARD(S:X->bool))`;
      `f:num->X`;
      `c:X->R`
    ]monic_vanishing_at_image THEN
    qed[]
  ; pass
  ] THEN
  have `p:(num->num)->R = poly_reindex(subring_generated r G) q (f:num->X) (range(CARD S)) S` [poly_reindex_subring] THEN
  have `poly_vars(subring_generated r G) (q:(X->num)->R) SUBSET S` [poly_vars_subring] THEN
  have `BIJ(f:num->X) (range(CARD S)) (S:X->bool)` [bij_finite_ordering] THEN
  have `ring_polynomial(subring_generated r G) (p:(num->num)->R)` [polynomial_poly_reindex] THEN
  specialize[
    `subring_generated (r:R ring) G`;
    `range(CARD(S:X->bool))`;
    `S:X->bool`;
    `q:(X->num)->R`;
    `f:num->X`
  ]poly_vars_poly_reindex THEN
  have `poly_vars r (p:(num->num)->R) SUBSET range(CARD(S:X->bool))` [poly_vars_subring] THEN
  specialize[
    `subring_generated (r:R ring) G`;
    `range(CARD(S:X->bool))`;
    `S:X->bool`;
    `q:(X->num)->R`;
    `f:num->X`
  ]poly_reindex_permutes THEN
  have `!f m:num->num. f permutes range (CARD(S:X->bool)) ==> p (m o f) = p m:R` [] THEN
  specialize[
    `r:R ring`;
    `G:R->bool`;
    `CARD(S:X->bool)`;
    `\i:num. c(f i:X):R`;
    `p:(num->num)->R`
  ]symmetric_subring_if_poly_subring_range THEN
  have `ring_polynomial r (q:(X->num)->R)` [ring_polynomial_if_subring] THEN
  specialize[
    `r:R ring`;
    `range(CARD(S:X->bool))`;
    `S:X->bool`;
    `q:(X->num)->R`;
    `f:num->X`;
    `c:X->R`
  ](GSYM poly_evaluate_poly_reindex) THEN
  simp[o_DEF] THEN
  qed[]
);;
```

### Informal statement
Let `r` be a ring, `G` be a subset of `R`, `S` be a finite set, and `c` be a function from `X` to `R`. Assume that for all `s` in `S`, `c(s)` is in the carrier of the ring `r`. Assume also that for all `d`, the coefficient of `d` in the polynomial `monic_vanishing_at r S c` is in the carrier of the subring generated by `G` in `r`. Furthermore, assume that `q` is a polynomial over the subring generated by `G` in `r`, and that the variables of `q` are a subset of `S`. Finally, assume that for any permutation `f` of `S` and any function `m` from `X` to numbers, `q(m o f) = q(m)`. Then, `poly_evaluate r q c` is in the carrier of the subring generated by `G` in `r`.

### Informal sketch
The goal is to prove that if `q` is a symmetric polynomial with variables in `S`, evaluated at `c`, then the result is in the subring generated by `G`. The proof unfolds as follows:
- First, define a re-indexed polynomial `p` using `poly_reindex`.
- Prove that for all `i < CARD(S)`, `c(f i)` is in the carrier of `r`, based on the assumption that `c s` is in the ring carrier for all `s` in `S`.
- Prove that for all `d`, the coefficient of `d` in `monic_vanishing_at r (range(CARD S)) (\i. c(f i))` is in the carrier of the subring generated by `G` in `r` using `monic_vanishing_at_image`.
- Establish that `p` is equal to `poly_reindex(subring_generated r G) q f (range(CARD S)) S` using `poly_reindex_subring`.
- Verify that the polynomial variables of `q` are a subset of `S` using `poly_vars_subring`.
- Show that `f` is a bijection from `range(CARD S)` to `S` using `bij_finite_ordering`.
- Prove that `p` is a ring polynomial using `polynomial_poly_reindex`.
- Demonstrate that `poly_vars r p SUBSET range(CARD S)` using `poly_vars_poly_reindex`.
- Show that for any permutation `f` of `range(CARD S)`, `p (m o f) = p m` using `poly_reindex_permutes`.
- Specialize `symmetric_subring_if_poly_subring_range` to obtain the result.
- Show that `q` is a ring polynomial, given that it is a polynomial over a subring using `ring_polynomial_if_subring`.
- Use `poly_evaluate_poly_reindex` to show the final result by simplifying with `o_DEF`.

### Mathematical insight
This theorem demonstrates that if we have a symmetric polynomial `q` (i.e., invariant under permutations of its variables) whose variables are within a *finite* set `S`, and it is evaluated at values `c(s)` for `s` in `S`, then under certain conditions, the result of the evaluation lies within a specific subring. The condition revolves around coefficients of `monic_vanishing_at r S c` belonging to `subring_generated r G`. This is useful because symmetric group actions naturally respect polynomial evaluation results.

### Dependencies
- `finite_ordering`
- `FUN_EQ_THM`
- `o_THM`
- `injective_finite_ordering`
- `monic_vanishing_at_image`
- `poly_reindex_subring`
- `poly_vars_subring`
- `bij_finite_ordering`
- `polynomial_poly_reindex`
- `poly_vars_poly_reindex`
- `poly_reindex_permutes`
- `symmetric_subring_if_poly_subring_range`
- `ring_polynomial_if_subring`
- `poly_evaluate_poly_reindex`
- `o_DEF`

### Porting notes (optional)
- The use of `choose` and `subgoal` can be translated in other proof assistants using appropriate tactics for introducing witnesses and managing proof states.
- Pay attention to the handling of finiteness conditions and the manipulation of sets and functions.
- The reindexing and permutation arguments may require careful attention to detail when porting.


---

## ring_ord

### Name of formal statement
ring_ord

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let ring_ord = new_definition `
  ring_ord (r:R ring) (p:R) (a:R)
  = @e:num. (
      ?u:R. (
        u IN ring_carrier r /\
        ~(ring_divides r p u) /\
        a = ring_mul r (ring_pow r p e) u
      )
    )
`;;
```

### Informal statement
For a ring `r` (of type `R ring`), an element `p` (of type `R`), and an element `a` (of type `R`), `ring_ord r p a` is the number `e` (of type `num`) such that there exists a unit `u` (of type `R`) in `r` (i.e., `u` is in the carrier of `r`), `p` does not divide `u` in `r` (i.e., `ring_divides r p u` is false), and `a` is equal to `u` times `p` raised to the power `e` in `r` (i.e., `a = ring_mul r (ring_pow r p e) u`).

### Informal sketch
The definition of `ring_ord r p a` works by finding the exponent `e` such that `a` can be expressed as the product of `p` raised to `e` and a unit `u`, where `p` does not divide `u`.
- Assert the existence of an exponent `e` (of type `num`) by using Hilbert choice operator `@` which picks such an `e` if it exists.
- Require that there exists a unit `u` (of type `R`) within the ring `r`
- Require the `u` is indeed a unit by ensuring that `ring_divides r p u` is false, which means `p` does not divide `u` in `r`
- Require that `a` is equal to `ring_mul r (ring_pow r p e) u` which means `a` is equal to `u` times `p` raised to the power `e` in `r`

### Mathematical insight
The definition `ring_ord r p a` defines the order (or valuation) of `a` with respect to `p` in the ring `r`. It finds the largest power of `p` that divides `a`. The integer `e` is the exponent to which `p` must be raised so that `a` is equal to `ring_mul r (ring_pow r p e) u`. The element `u` ensures that we pick the *largest* such power of `p`; otherwise, `e` would not be unique.

### Dependencies
- `ring`: Type `R ring`
- `ring_carrier`: membership within a ring
- `ring_divides`: the divides relation over a ring
- `ring_mul`: the multiplication operation in a ring
- `ring_pow`: the power operation in a ring


---

## ring_ord_1

### Name of formal statement
ring_ord_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_1 = prove(`
  !(r:R ring) p.
  p IN ring_carrier r ==>
  ~(ring_unit r p) ==>
  ring_ord r p (ring_1 r) = 0
`,
  intro THEN
  rw[ring_ord] THEN
  sufficesby SELECT_UNIQUE THEN
  rw[BETA_THM] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    proven_if `y = 0` [] THEN
    num_linear_fact `~(y = 0) ==> y = 1+(y-1)` THEN
    have `ring_pow(r:R ring) p y = ring_mul r (ring_pow r p 1) (ring_pow r p (y-1))` [RING_POW_ADD] THEN
    have `ring_1(r:R ring) = ring_mul r (ring_mul r p (ring_pow r p (y-1))) u` [RING_POW_1] THEN
    have `ring_1(r:R ring) = ring_mul r p (ring_mul r (ring_pow r p (y-1)) u)` [RING_MUL_ASSOC;RING_POW] THEN
    subgoal `ring_divides(r:R ring) p (ring_1 r)` THENL [
      rw[ring_divides] THEN
      simp[RING_MUL;RING_POW] THEN
      witness `ring_mul(r:R ring) (ring_pow r p (y-1)) u` THEN
      simp[RING_MUL;RING_POW] THEN
      RING_TAC
    ; pass
    ] THEN
    qed[ring_unit;ring_divides]
  ;
    intro THEN
    witness `ring_1(r:R ring)` THEN
    qed[RING_1;ring_unit;ring_divides;RING_POW_0;RING_MUL_LID]
  ]
);;
```

### Informal statement
For any ring `r` and any element `p` in the carrier of `r`, if `p` is not a unit in `r`, then the order of `p` with respect to `r` and the multiplicative identity `ring_1 r` is 0.

### Informal sketch
The proof proceeds by first introducing the assumptions and rewriting using the definition of `ring_ord`. Then, it suffices to show that 0 is the smallest non-negative integer `y` such that `ring_divides p (ring_pow p y)` is false. The proof splits into two cases: `y = 0` and `y != 0`.

- Case `y = 0`:
  - Show that if `y = 0`, then `ring_divides p (ring_pow p y (ring_1 r))` holds.
  - Then, make use of previously proved theorem that `y = 1 + (y - 1)` to rewrite `ring_pow p y`. And use the lemma `RING_POW_ADD` to rewrite `ring_pow p y` into `ring_mul r (ring_pow r p 1) (ring_pow r p (y-1))`.
  - After that, rewrite `ring_1 r` using `RING_POW_1`, then change multiplication order through associativity `RING_MUL_ASSOC` and `RING_POW`.
  - Now, show that `ring_divides p (ring_1 r)`. Use the definition `ring_divides` to exhibit a witness for the divisor, which is `ring_mul (ring_pow p (y-1)) u`
  - `RING_TAC` is used to close the goal. This is the final step in this case.

- Case `y != 0`:
  - Show that if `y != 0`, then `ring_divides p (ring_pow p y (ring_1 r))` is false.
  - Provide `ring_1 r` as the witness, use the definitions `RING_1`, `ring_unit`, `ring_divides`, `RING_POW_0`, `RING_MUL_LID`.
  - `RING_TAC` is used to close the goal. This is the final step of the proof.

### Mathematical insight
This theorem states that if an element `p` in a ring `r` is not a unit, then the order of `p` with respect to the multiplicative identity is 0. This is because `p` does not divide the multiplicative identity `ring_1 r`, hence the smallest power `y` is 0.

### Dependencies
- Definitions: `ring_ord`, `ring_1`, `ring_unit`, `ring_divides`
- Theorems: `RING_POW_ADD`, `RING_POW_1`, `RING_MUL_ASSOC`, `RING_POW`, `RING_1`, `RING_POW_0`, `RING_MUL_LID`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification. A proof assistant with strong automation for ring arithmetic will be beneficial.
- Ensure correct handling of ring properties and divisibility.
- The tactics `SELECT_UNIQUE` and `proven_if` might need equivalent strategies or manual decomposition in other systems.


---

## ring_ord_notdivides

### Name of formal statement
ring_ord_notdivides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_notdivides = prove(`
  !(r:R ring) p v.
  p IN ring_carrier r ==>
  v IN ring_carrier r ==>
  ~(ring_divides r p v) ==>
  ring_ord r p v = 0
`,
  intro THEN
  rw[ring_ord] THEN
  sufficesby SELECT_UNIQUE THEN
  rw[BETA_THM] THEN
  intro THEN
  have `~(ring_unit r (p:R))` [RING_UNIT_DIVIDES_ANY] THEN
  splitiff THENL [
    intro THEN
    proven_if `y = 0` [] THEN
    num_linear_fact `~(y = 0) ==> y = 1+(y-1)` THEN
    have `ring_pow(r:R ring) p y = ring_mul r (ring_pow r p 1) (ring_pow r p (y-1))` [RING_POW_ADD] THEN
    have `v:R = ring_mul r (ring_mul r p (ring_pow r p (y-1))) u` [RING_POW_1] THEN
    have `v:R = ring_mul r p (ring_mul r (ring_pow r p (y-1)) u)` [RING_MUL_ASSOC;RING_POW] THEN
    subgoal `ring_divides(r:R ring) p v` THENL [
      rw[ring_divides] THEN
      simp[RING_MUL;RING_POW] THEN
      witness `ring_mul(r:R ring) (ring_pow r p (y-1)) u` THEN
      simp[RING_MUL;RING_POW] THEN
      have `v IN ring_carrier(r:R ring)` [ring_unit] THEN
      RING_TAC
    ; pass
    ] THEN
    subgoal `ring_divides(r:R ring) v (ring_1 r)` THENL [
      rw[ring_divides] THEN
      qed[ring_unit;RING_1]
    ; pass
    ] THEN
    qed[]
  ;
    intro THEN
    witness `v:R` THEN
    intro THENL [
      qed[]
    ;
      qed[]
    ;
      qed[RING_POW_0;RING_MUL_LID]
    ]
  ]
);;
```
### Informal statement
For any ring `r`, and for any elements `p` and `v` in the carrier of `r`, if `p` does not divide `v` in the ring `r`, then the order of `p` in `v` with respect to `r` is 0.

### Informal sketch
The proof proceeds as follows:

- Introduce the quantifiers and the assumptions.
- Rewrite `ring_ord` to its definition.
- Reduce the problem to showing the uniqueness of an `x` satisfying the definition of `ring_ord`.
- Apply the beta reduction.
- Introduce the existential variable `x` and the assumptions.
- We need to show that if `p` does not divide `v`, then the smallest `y` such that `p^y` divides `v` (or `ring_unit r p`) is zero.
- Split the goal into two cases:
    - Prove that for all `y`, if `ring_pow r p y` divides `v` then `y` is equal to 0.
        - Assume `y` exists such that `ring_pow r p y` divides `v`.
        - If `y = 0`, we complete this case.
        - Otherwise, `y` can be written as `1 + (y-1)`.
        - Then `ring_pow r p y = ring_mul r (ring_pow r p 1) (ring_pow r p (y-1))`.
        - Then `v:R = ring_mul r (ring_mul r p (ring_pow r p (y-1))) u` where `u` is some carrier element.
        - Then `v:R = ring_mul r p (ring_mul r (ring_pow r p (y-1)) u)`.
        - The goal becomes `ring_divides(r:R ring) p v`.
        - After rewriting `ring_divides`, we want to show an element `w` exists such that `v = p * w`.
        - This holds for `w = ring_mul(r:R ring) (ring_pow r p (y-1)) u`.
        - Then `ring_divides(r:R ring) p v` because `p|v`. This contradicts the assumption that `p` does not divide `v`.
    - Prove that `ring_divides(r:R ring) v (ring_1 r)`.
        - By the definition of `ring_divides`, show that there exists `w` such that `ring_1 r = ring_mul r v w`.
        - This is always true when `v` is a unit in `r`.
- Pick `v:R`.
- Introduce assumptions from the existential quantification.
- Complete the existential case by proving that when `y ==0` then `ring_pow r p 0` divides `v` and proving that when y > 0 something contradicting is true.
- The proof concludes by using `RING_POW_0` and `RING_MUL_LID`.

### Mathematical insight
This theorem states a crucial property of the `ring_ord` function. If an element `p` does not divide `v` within a ring `r`, then the highest power of `p` that divides `v` is `p^0 = 1`. The motivation is that the `ring_ord` function is meant to capture the notion of the "multiplicity" of `p` in the prime factorization of `v`. If `p` is not a factor of `v` at all, then its multiplicity is zero.

### Dependencies
- Definitions: `ring_ord`, `ring_divides`, `ring_unit`, `ring_carrier`, `ring_pow`, `ring_mul`, `ring_1`
- Theorems: `RING_UNIT_DIVIDES_ANY`, `RING_POW_ADD`, `RING_POW_1`, `RING_MUL_ASSOC`, `RING_POW_0`, `RING_MUL_LID`

### Porting notes (optional)
- The proof relies heavily on rewriting and simplification in the ring structure. A proof assistant with strong algebraic simplification capabilities would be beneficial.
- The main challenge is correctly handling the quantifiers and implications, particularly when reasoning about divisibility.
- The use of tactics like `sufficesby` and `proven_if` indicate a proof style involving intermediate goals and conditional reasoning, which should be reflected in the target proof.


---

## ring_ord_unit

### Name of formal statement
ring_ord_unit

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_unit = prove(`
  !(r:R ring) p v.
  p IN ring_carrier r ==>
  ~(ring_unit r p) ==>
  ring_unit r v ==>
  ring_ord r p v = 0
`,
  intro THEN
  have `v:R IN ring_carrier r` [ring_unit] THEN
  have `~ring_divides r (p:R) v` [RING_UNIT_DIVISOR] THEN
  qed[ring_ord_notdivides]
);;
```
### Informal statement
For any ring `r` and elements `p` and `v`, if `p` is in the carrier of the ring `r`, `p` is not a unit in the ring `r`, and `v` is a unit in the ring `r`, then the order of `p` with respect to `v` in the ring `r` is 0.

### Informal sketch
The proof proceeds as follows:
- Assume that `p` is an element of the carrier of `r` and that `p` is not a unit in `r`, and `v` is a unit in `r`.
- Deduce that `v` is in the carrier of `r` given that `v` is a ring unit (using the theorem captured by the label `ring_unit`).
- Show that `p` does not divide `v` in `r` (`~ring_divides r p v`) using `RING_UNIT_DIVISOR`, which states that a non-unit does not divide a unit.
- Conclude that the order of `p` with respect to `v` is 0 by `ring_ord_notdivides`, which asserts that if `p` does not divide `v`, then the order of `p` with respect to `v` is 0.

### Mathematical insight
The theorem states a fundamental property of ring units and divisibility: if an element `p` of a ring `r` is not a unit, and another element `v` *is* a unit, then `p` cannot divide `v`. Consequently, the ring order of `p` with respect to `v` (defined as the smallest non-negative integer `n` such that `p^n` divides `v`) must be 0. This is because, by definition, `p^0` equals the ring unit, which always divides `v`.

### Dependencies
- `ring_unit`
- `RING_UNIT_DIVISOR`
- `ring_ord_notdivides`


---

## ring_ord_pow_refl

### Name of formal statement
ring_ord_pow_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_pow_refl = prove(`
  !(r:R ring) p e.
  integral_domain r ==>
  p IN ring_carrier r ==>
  ~(ring_unit r p) ==>
  ~(p = ring_0 r) ==>
  ring_ord r p (ring_pow r p e) = e
`,
  intro THEN
  rw[ring_ord] THEN
  sufficesby SELECT_UNIQUE THEN
  rw[BETA_THM] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    case `y < e:num` THENL [
      num_linear_fact `y < e:num ==> e = y+((e-1-y)+1)` THEN
      have `ring_pow r (p:R) e = ring_mul r (ring_pow r p y) (ring_pow r p ((e-1-y)+1))` [RING_POW_ADD] THEN
      have `ring_pow r (p:R) ((e-1-y)+1) = ring_mul r (ring_pow r p (e-1-y)) (ring_pow r p 1)` [RING_POW_ADD] THEN
      have `ring_pow r (p:R) 1 = p` [RING_POW_1] THEN
      havetac `ring_mul r (ring_pow r p y) u:R = ring_mul r (ring_pow r p y) (ring_mul r p (ring_pow r p (e-1-y)))` RING_TAC THEN
      subgoal `u:R = ring_mul r p (ring_pow r p (e - 1 - y))` THENL [
        specialize_assuming[
          `r:R ring`;
          `ring_pow r (p:R) y`;
          `u:R`;
          `ring_mul r (p:R) (ring_pow r p (e - 1 - y))`
        ]INTEGRAL_DOMAIN_MUL_LCANCEL THEN
        have `~(ring_pow r (p:R) y = ring_0 r)` [INTEGRAL_DOMAIN_POW_EQ_0] THEN
        qed[RING_MUL;RING_POW]
      ; pass
      ] THEN
      qed[ring_divides;RING_POW]
    ; pass
    ] THEN
    case `e < y:num` THENL [
      num_linear_fact `e < y:num ==> y = e+((y-1-e)+1)` THEN
      have `ring_pow r (p:R) y = ring_mul r (ring_pow r p e) (ring_pow r p ((y-1-e)+1))` [RING_POW_ADD] THEN
      have `ring_pow r (p:R) ((y-1-e)+1) = ring_mul r (ring_pow r p (y-1-e)) (ring_pow r p 1)` [RING_POW_ADD] THEN
      have `ring_pow r (p:R) 1 = p` [RING_POW_1] THEN
      havetac `ring_mul r (ring_pow r p e) (ring_1 r):R = ring_mul r (ring_pow r p e) (ring_mul r p (ring_mul r (ring_pow r p (y-1-e)) u))` RING_TAC THEN
      subgoal `(ring_1 r):R = ring_mul r p (ring_mul r (ring_pow r p (y-1-e)) u)` THENL [
        specialize_assuming[
          `r:R ring`;
          `ring_pow r (p:R) e`;
          `ring_1 r:R`;
          `ring_mul r (p:R) (ring_mul r (ring_pow r p (y - 1 - e)) u)`
        ]INTEGRAL_DOMAIN_MUL_LCANCEL THEN
        have `~(ring_pow r (p:R) e = ring_0 r)` [INTEGRAL_DOMAIN_POW_EQ_0] THEN
        qed[RING_MUL;RING_POW;RING_1]
      ; pass
      ] THEN
      qed[ring_unit;RING_MUL;RING_POW]
    ; pass
    ] THEN
    ASM_ARITH_TAC
  ;
    intro THEN
    witness `ring_1 r:R` THEN
    qed[RING_1;ring_unit;ring_divides;RING_MUL_RID;RING_POW]
  ]
);;
```

### Informal statement
For all rings `r` of type `R ring`, all ring elements `p` in the carrier of `r`, and all natural numbers `e`, if `r` is an integral domain, `p` is not a unit in `r`, and `p` is not the zero element of `r`, then the order of `p` in `r` with respect to `p` raised to the power of `e` is equal to `e`.

### Informal sketch
The proof proceeds by induction on the relationship between `y` and `e` where `y` is a potential order. We start by assuming that `r` is an integral domain, `p` is not a unit, and `p` is not zero. We wish to show that the order of `p` with respect to `ring_pow r p e` is `e`. In HOL Light, `ring_ord` is defined as the smallest `y` such that `ring_pow r p y` divides `ring_pow r p e`.

- The proof relies on simplifying the divides relation using the ring properties and properties of powers.
- The proof splits into three cases:
    - `y < e`: We use the property `ring_pow r p e = ring_mul r (ring_pow r p y) (ring_pow r p (e-y))` and cancellation laws of integral domains to show that `ring_pow r p y` divides `ring_pow r p e` is equivalent to showing that something divides `ring_pow r p (e-y)`, until we reach that `p` divides `ring_pow r p (e-1-y)`.
    - `e < y`:  We use the property `ring_pow r p y = ring_mul r (ring_pow r p e) (ring_pow r p (y-e))` and cancellation laws of integral domains to show that `ring_pow r p y` divides `ring_pow r p e` is equivalent to showing that something divides `ring_pow r p (y-e)`, until we reach that `ring_1 r` divides `ring_mul r p (ring_pow r p (y-1-e) u)` where `ring_pow r p y = ring_mul r (ring_pow r p e) u`.
    - `y = e`: We show that `ring_pow r p e` divides `ring_pow r p e`. We pick the witness `ring_1 r` such that `ring_pow r p e = ring_mul r (ring_pow r p e) (ring_1 r)`.

### Mathematical insight
The theorem captures a fundamental property of orders in integral domains.  If `p` is not a unit and not zero, raising it to a power `e` results in an element whose order with respect to `p` is exactly `e`. This reflects the fact that in integral domains, powers of non-units behave predictably with respect to divisibility, and the order formalizes the minimum power to which the element has to be raised to achieve a certain relation.

### Dependencies
- `ring_ord`
- `integral_domain`
- `ring_carrier`
- `ring_unit`
- `ring_0`
- `ring_pow`
- `RING_POW_ADD`
- `RING_POW_1`
- `INTEGRAL_DOMAIN_MUL_LCANCEL`
- `INTEGRAL_DOMAIN_POW_EQ_0`
- `ring_divides`
- `ring_1`
- `RING_MUL_RID`

### Porting notes (optional)
- The proof relies heavily on rewriting with algebraic properties of rings and integral domains. Other proof assistants will need similar lemmas about ring powers and cancellation laws.
- The tactic `SELECT_UNIQUE` may have no direct equivalent, and the effect is ensuring that we select the *smallest* `y` such that it divides `ring_pow r p e`.
- `ASM_ARITH_TAC` is a HOL Light specific tactic to perform arithmetic reasoning, so its logic has to be emulated in the target proof assistant.


---

## ring_ord_refl

### Name of formal statement
ring_ord_refl

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_refl = prove(`
  !(r:R ring) p.
  integral_domain r ==>
  p IN ring_carrier r ==>
  ~(ring_unit r p) ==>
  ~(p = ring_0 r) ==>
  ring_ord r p p = 1
`,
  qed[ring_ord_pow_refl;RING_POW_1]
);;
```
### Informal statement
For any ring `r` of type `R ring` and any element `p`, if `r` is an integral domain and `p` is in the carrier of `r`, and `p` is not a unit in `r` and `p` is not the zero element in `r`, then `ring_ord r p p = 1`.

### Informal sketch
The proof demonstrates that the order of an element `p` with respect to itself in a ring `r` is 1 under certain conditions.

- The proof starts by using the theorem `ring_ord_pow_refl`, which presumably establishes a relationship between `ring_ord`, the ring power operation, and equality when the power is equal to an element.
- The next step invokes `RING_POW_1`, a theorem related to powers in rings, likely stating that `p^1 = p`.
- These results are combined to show that `ring_ord r p p = 1` under the assumptions that the ring is an integral domain, `p` is a non-zero, non-unit element in the ring's carrier.

### Mathematical insight
This theorem characterizes the ring order of non-zero, non-unit elements in integral domains. Specifically, if `p` satisfies the given conditions, the smallest positive integer `n` such that `p^n = p` is 1. This reflects the fact that `p^1 = p` directly.

### Dependencies
- Theorems: `ring_ord_pow_refl`, `RING_POW_1`


---

## ring_ord_exists

### Name of formal statement
ring_ord_exists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_exists = prove(`
  !(r:R ring) p.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  p IN ring_carrier r ==>
  ~(ring_unit r p) ==>
  !a.
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  ?e u:R. (
    u IN ring_carrier r /\
    ~(ring_divides r p u) /\
    a = ring_mul r (ring_pow r p e) u
  )
`,
  intro_genonly THEN
  REPEAT DISCH_TAC THEN
  specialize[`r:R ring`]RING_DIVIDES_WF THEN
  specialize_forward[`\x y:R. ring_divides r x y /\ ~ring_divides r y x`](GEN `(<<):A->A->bool` WF_IND) THEN
  sufficesby (know `!P. (!x:R. (!y. ring_divides r y x ==> ~ring_divides r x y ==> P y) ==> P x) ==> (!x. P x)`) THEN
  intro THEN
  case `ring_divides r (p:R) a` THENL [
    choose `b:R` `b:R IN ring_carrier r /\ a = ring_mul r p b` [ring_divides] THEN
    have `ring_divides r (b:R) a` [ring_divides;RING_MUL_SYM] THEN
    have `~(b:R = ring_0 r)` [RING_MUL_RZERO] THEN
    subgoal `~ring_divides r (a:R) b` THENL [
      intro THEN
      have `ring_associates r (a:R) b` [ring_associates] THEN
      qed[INTEGRAL_DOMAIN_DIVIDES_ASSOCIATES_MUL_SELF]
    ; pass
    ] THEN
    have `b:R IN ring_carrier r` [] THEN
    specialize[`b:R`](know `!y:R. ring_divides r y a /\ ~ring_divides r a y ==> y IN ring_carrier r ==> ~(y = ring_0 r) ==> (?e u.  u IN ring_carrier r /\ ~ring_divides r p u /\ y = ring_mul r (ring_pow r p e) u)`) THEN
    choose2 `e:num` `u:R` `u:R IN ring_carrier r /\ ~ring_divides r p u /\ b = ring_mul r (ring_pow r p e) u` [] THEN
    witness `e+1` THEN
    witness `u:R` THEN
    intro THENL [
      qed[]
    ;
      qed[]
    ;
      have `b:R = ring_mul r (ring_pow r p e) u` [] THEN
      have `ring_pow r (p:R) (e+1) = ring_mul r (ring_pow r p e) (ring_pow r p 1)` [RING_POW_ADD] THEN
      have `ring_pow r (p:R) (e+1) = ring_mul r (ring_pow r p e) p` [RING_POW_1] THEN
      specialize_assuming[
        `ring_pow r (p:R) e`;
        `ring_pow r (p:R) (e+1)`;
      ](
        GENL[`E:R`;`E1:R`](
        RING_RULE `E1:R = ring_mul r E p ==> a = ring_mul r p b ==> b = ring_mul r E u ==> a = ring_mul r E1 u`
      )) THEN
      qed[RING_POW]
    ]
  ;
    witness `0` THEN
    witness `a:R` THEN
    qed[RING_POW_0;RING_MUL_LID]
  ]
);;
```

### Informal statement
For any ring `r` that is an integral domain and is either a noetherian ring or a unique factorization domain, and for any element `p` in the carrier of `r` that is not a unit in `r`, then for any non-zero element `a` in the carrier of `r`, there exist an exponent `e` (a natural number) and an element `u` in the carrier of `r` such that `u` is not divisible by `p` in `r` and `a` is equal to `p` raised to the power `e` times `u` in `r`.

### Informal sketch
The theorem states that in an integral domain `r` that satisfies a finiteness condition (Noetherian or UFD), any nonzero element `a` can be written as a power of a non-unit element `p` times a remainder `u` that is not divisible by `p`.

- The proof starts by induction using a well-foundedness argument on the `ring_divides` relation, showing that if the property holds for all divisors `y` of `a` such that `a` does not divide `y`, then it holds for `a`.
- In the case where `p` divides `a`, we get `a = p * b`. Then the proof aims to show that `p` does not divide `b`, in which case the hypothesis applies to `b`.
- If `p` divides `a`, then `a = p * b` and, if `a` associate `b`, then `p` must be a unit, which it is not, therefore `a` must not divide `b`.
- By the induction hypothesis, `b = (p^e) * u` for some `e` and `u`. Therefore, `a = p * (p^e) * u = p^(e+1) * u`.
- In the case where `p` does not divide `a`, take `e = 0` and `u = a`, then `a = (p^0) * a = 1 * a = a`.

### Mathematical insight
This theorem essentially states that in a suitable ring, one can decompose any element into a power of a specific non-unit element and a remainder that is not divisible by that element. Intuitively, it is a generalization of the prime factorization theorem for integers. The Noetherian or UFD condition ensures the process eventually terminates, guaranteeing the existence of such a decomposition.

### Dependencies
- `ring_carrier`
- `ring_unit`
- `ring_divides`
- `ring_0`
- `ring_mul`
- `ring_pow`
- `integral_domain`
- `noetherian_ring`
- `UFD`
- `RING_DIVIDES_WF`
- `ring_associates`
- `INTEGRAL_DOMAIN_DIVIDES_ASSOCIATES_MUL_SELF`
- `RING_MUL_RZERO`
- `RING_POW_ADD`
- `RING_POW_1`
- `RING_POW_0`
- `RING_MUL_LID`

### Porting notes (optional)
- The well-foundedness argument on `ring_divides` may need explicit construction depending on the target proof assistant.
- The arithmetic reasoning using `RING_RULE` might benefit from a more powerful automation system in other provers.


---

## ring_ord_unique_lemma

### Name of formal statement
ring_ord_unique_lemma

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_unique_lemma = prove(`
  !(r:R ring) p e f u v.
  integral_domain r ==>
  p IN ring_carrier r ==>
  u IN ring_carrier r ==>
  v IN ring_carrier r ==>
  ring_prime r p ==>
  ~(ring_divides r p v) ==>
  ring_mul r (ring_pow r p e) u
  = ring_mul r (ring_pow r p f) v
  ==> e <= f
`,
  intro THEN
  proven_if `e <= f:num` [] THEN
  num_linear_fact `~(e <= f) ==> e = f+(1+(e-1-f))` THEN
  subgoal `ring_pow r (p:R) e = ring_mul r (ring_pow r p f) (ring_mul r (ring_pow r p 1) (ring_pow r p (e-1-f)))` THENL [
    simp[GSYM RING_POW_ADD] THEN
    qed[]
  ; pass
  ] THEN
  have `ring_pow r (p:R) e = ring_mul r (ring_pow r p f) (ring_mul r p (ring_pow r p (e-1-f)))` [RING_POW_1] THEN
  subgoal `ring_mul r (ring_pow r p f:R) (ring_mul r p (ring_mul r (ring_pow r p (e - 1 - f)) u)) = ring_mul r (ring_pow r p f) v` THENL [
    specialize_assuming[
      `ring_pow r (p:R) e`;
      `ring_pow r (p:R) (e-1-f)`;
      `ring_pow r (p:R) f`;
    ](GENL[`E:R`;`E1F:R`;`X:R`](
      RING_RULE `ring_mul r (E:R) u = ring_mul r X v ==> E = ring_mul r X (ring_mul r p E1F) ==> ring_mul r X (ring_mul r p (ring_mul r E1F u)) = ring_mul r X v`
    )) THEN
    qed[RING_POW;RING_MUL]
  ; pass
  ] THEN
  subgoal `ring_mul r (p:R) (ring_mul r (ring_pow r p (e - 1 - f)) u) = v` THENL [
    specialize_assuming[
      `r:R ring`;
      `ring_pow r (p:R) f`;
      `ring_mul r (p:R) (ring_mul r (ring_pow r p (e - 1 - f)) u)`;
      `v:R`
    ]INTEGRAL_DOMAIN_MUL_LCANCEL THEN
    have `~(ring_pow r (p:R) f = ring_0 r)` [INTEGRAL_DOMAIN_POW_EQ_0;ring_prime] THEN
    qed[RING_MUL;RING_POW]
  ; pass
  ] THEN
  qed[ring_divides;RING_POW;RING_MUL]
);;
```
### Informal statement
For any ring `r` that is an integral domain, elements `p`, `u`, and `v` in the carrier of `r`, where `p` is a ring prime in `r`, and `p` does not divide `v` in `r`; if `ring_mul r (ring_pow r p e) u = ring_mul r (ring_pow r p f) v`, then `e <= f`.

### Informal sketch
The proof proceeds by contradiction. Assuming `~(e <= f)`, it follows that `e = f + (1 + (e - 1 - f))`. Then we show:
- `ring_pow r p e = ring_mul r (ring_pow r p f) (ring_mul r (ring_pow r p 1) (ring_pow r p (e-1-f)))` using `GSYM RING_POW_ADD`.
- `ring_pow r p e = ring_mul r (ring_pow r p f) (ring_mul r p (ring_pow r p (e-1-f)))` using `RING_POW_1`.
- `ring_mul r (ring_pow r p f:R) (ring_mul r p (ring_mul r (ring_pow r p (e - 1 - f)) u)) = ring_mul r (ring_pow r p f) v`. We specialize a ring rule (rearranging the equation via cancellation) to achieve this end using `RING_POW` and `RING_MUL`.
- `ring_mul r p (ring_mul r (ring_pow r p (e - 1 - f)) u) = v` by specializing `INTEGRAL_DOMAIN_MUL_LCANCEL`. We use `INTEGRAL_DOMAIN_POW_EQ_0` and `ring_prime` to ensure `~(ring_pow r p f = ring_0 r)`.

Finally, we reach a contradiction to our initial assumption using `ring_divides`, `RING_POW`, and `RING_MUL`.

### Mathematical insight
This theorem states that if `p^e * u = p^f * v` in an integral domain, where `p` is prime and does not divide `v`, then `e` must be less than or equal to `f`. This essentially says that the exponent of a prime factor in such a representation has a uniqueness property. This is useful in establishing unique factorization results in rings.

### Dependencies
- `ring_mul`
- `ring_pow`
- `integral_domain`
- `ring_prime`
- `ring_divides`
- `INTEGRAL_DOMAIN_MUL_LCANCEL`
- `INTEGRAL_DOMAIN_POW_EQ_0`
- `RING_POW_ADD`
- `RING_POW_1`
- `RING_POW`
- `RING_MUL`


---

## ring_ord_unique

### Name of formal statement
ring_ord_unique

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_unique = prove(`
  !(r:R ring) p e f u v.
  integral_domain r ==>
  p IN ring_carrier r ==>
  u IN ring_carrier r ==>
  v IN ring_carrier r ==>
  ring_prime r p ==>
  ~(ring_divides r p u) ==>
  ~(ring_divides r p v) ==>
  ring_mul r (ring_pow r p e) u
  = ring_mul r (ring_pow r p f) v
  ==> e = f
`,
  intro THEN
  have `e <= f:num` [ring_ord_unique_lemma] THEN
  have `f <= e:num` [ring_ord_unique_lemma] THEN
  ASM_ARITH_TAC
);;
```

### Informal statement
For any ring `r` that is an integral domain, any `p`, `u`, and `v` in the carrier of `r`, and any natural numbers `e` and `f`, if `p` is a prime element in `r`, and `p` does not divide `u` and `p` does not divide `v`, then if `(p^e) * u = (p^f) * v` in `r`, then `e = f`.

### Informal sketch
The proof proceeds by assuming the antecedent conditions and then showing that `e <= f` and `f <= e`. These inequalities are established using a helper lemma, `ring_ord_unique_lemma.` Finally, arithmetic tactics combine these inequalities to derive the equality `e = f`.
- The proof introduces all the assumptions.
- Two inequalities, `e <= f` and `f <= e`, are proven using `ring_ord_unique_lemma`.
- `ASM_ARITH_TAC` utilizes these two arithmetic inequalities to prove that `e = f`.

### Mathematical insight
This theorem states that if `p` is a prime element in an integral domain `r`, and `u` and `v` are elements not divisible by `p`, then the exponent of `p` in the product `(p^e) * u` uniquely determines `e`. It is a uniqueness result concerning the representation of elements in an integral domain with respect to multiplication by powers of a prime element. This theorem is fundamental to unique factorization domains.

### Dependencies
- `integral_domain`
- `ring_carrier`
- `ring_prime`
- `ring_divides`
- `ring_mul`
- `ring_pow`
- `ring_ord_unique_lemma`

### Porting notes (optional)
The main challenge will be porting the lemma `ring_ord_unique_lemma`. The automation relies on `ASM_ARITH_TAC`, which incorporates a decision procedure for arithmetic. A similar tactic or decision procedure will be needed in other proof assistants. You might need to manually unfold definitions if automation is weak. Make sure that `integral_domain` has the appropriate defintion in your target proof assistant.


---

## ring_ord_exists_unique

### Name of formal statement
ring_ord_exists_unique

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_exists_unique = prove(`
  !(r:R ring) p a.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  ?u:R. (
    u IN ring_carrier r /\
    ~(ring_divides r p u) /\
    a = ring_mul r (ring_pow r p (ring_ord r p a)) u
  )
`,
  intro_genonly THEN
  REPEAT DISCH_TAC THEN
  have `p:R IN ring_carrier r` [ring_prime] THEN
  have `~ring_unit r (p:R)` [ring_prime] THEN
  specialize[
    `r:R ring`;
    `p:R`
  ]ring_ord_exists THEN
  choose2 `e:num` `v:R` `v:R IN ring_carrier r /\ ~ring_divides r p v /\ a = ring_mul r (ring_pow r p e) v` [] THEN
  subgoal `(@e. ?u:R. u IN ring_carrier r /\ ~ring_divides r p u /\ a = ring_mul r (ring_pow r p e) u) = e` THENL [
    sufficesby SELECT_UNIQUE THEN
    qed[ring_ord_unique]
  ; pass
  ] THEN
  witness `v:R` THEN
  rw[ring_ord] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and elements `p`, `a` such that `r` is an integral domain, `r` is a Noetherian ring or a unique factorization domain (UFD), `p` is a prime element in `r`, `a` is in the carrier of `r`, and `a` is not the zero element of `r`, there exists a unique element `u` in the ring such that `u` is in the carrier of `r`, `p` does not divide `u` in `r`, and `a` equals the product of `p` raised to the power of the ring order of `a` with respect to `p`, and `u` in `r`.

### Informal sketch
The proof shows that under the assumptions that `r` is an integral domain which is also a Noetherian ring or a UFD, and `p` is a prime element of `r` and `a` is a non-zero element of `r`, there exist unique `e` and `v` values such that `v` belongs to the ring carrier, `p` does not divide `v`, and `a` is the product of `p` raised to the `e`-th power and `v`.

- First, introduce assumptions and utilize the hypothesis `ring_prime` to deduce that `p` is an element of the ring carrier and is not a ring unit.
- Apply `ring_ord_exists` to establish the existence of an exponent `e` and an element `v` satisfying the properties: `v` belongs to the ring carrier, `p` does not divide `v`, and `a` equals `p^e * v`. This step uses the `choose2` tactic to select the exponent `e` and the ring element `v`.
- Show the uniqueness of the exponent. Specialize the existentially quantified variable occurring in the ring order theorem to the exponent `e`.
- Prove, using `ring_ord_unique`, that `e` must be equal to the ring order of `a` with respect to `p`. This is achieved using the `SELECT_UNIQUE` tactic.
- Introduce `v` as witness.
- Apply simplification using the definition of `ring_ord`.
- Conclude that there exists a unique such `u`, where `u` is `v`.

### Mathematical insight
This theorem ensures the uniqueness of the "unit" `u` in the representation of an element `a` as a product of a power of a prime `p` and a unit `u` not divisible by `p`. It is a fundamental result for understanding the structure of rings, especially in unique factorization domains or Noetherian domains, where such decompositions are crucial for studying divisibility and factorization properties.

### Dependencies
- `ring_ord_exists`
- `ring_ord_unique`
- `ring_prime`
- `integral_domain`
- `noetherian_ring`
- `UFD`
- `ring_carrier`
- `ring_0`
- `ring_divides`
- `ring_mul`
- `ring_pow`
- `ring_ord`
- `ring_unit`

### Porting notes (optional)
- The proof relies heavily on the `ring_ord_exists` and `ring_ord_unique` theorems. These need to be available or proven in the target proof assistant.
- The `choose2` tactic might need to be replaced with equivalent functionality for selecting elements satisfying an existential property.
- The `SELECT_UNIQUE` tactic highlights the importance of having a tactic to automatically prove statements of uniqueness.


---

## divides_pow_ring_ord

### Name of formal statement
divides_pow_ring_ord

### Type of the formal statement
theorem

### Formal Content
```ocaml
let divides_pow_ring_ord = prove(`
  !(r:R ring) p a.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  ring_divides r (ring_pow r p (ring_ord r p a)) a
`,
  intro_gendisch THEN
  have `~ring_unit r (p:R)` [ring_prime] THEN
  specialize[
    `r:R ring`;
    `p:R`;
    `a:R`
  ]ring_ord_exists_unique THEN
  choose `u:R` `u:R IN ring_carrier r /\ ~ring_divides r p u /\ a = ring_mul r (ring_pow r p (ring_ord r p a)) u` [] THEN
  rw[ring_divides] THEN
  qed[RING_POW;ring_prime]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any elements `p` and `a` in the carrier of `r`, if `r` is an integral domain, and `r` is either a noetherian ring or a unique factorization domain, and `p` is a prime element in `r`, and `a` is a non-zero element in the carrier of `r`, then `ring_pow r p (ring_ord r p a)` divides `a` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce assumptions: `r` is a ring, `p` and `a` are elements in the carrier of `r`, `r` is an integral domain, `r` is either noetherian or a UFD, `p` is prime, and `a` is non-zero.
- Use the fact that `p` is prime to deduce that `p` is not a unit in `r`. HOL Light represents the "prime" property definitionally (via `ring_prime`) as explicitly including non-unit property. This step uses the pre-proved theorem that every prime is not a unit from the assumption `ring_prime`.
- Apply the theorem `ring_ord_exists_unique` (specialized to the ring `r`, element `p`, and element `a`) to obtain the existence and uniqueness of `ring_ord r p a`. Then choose an element `u` in the carrier of `r` such that `p` does not divide `u`, and `a = ring_mul r (ring_pow r p (ring_ord r p a)) u`.
- Rewrite using the definition of `ring_divides`.
- Conclude the proof using the theorems `RING_POW` and `ring_prime`.

### Mathematical insight
This theorem states that for a prime element `p` in a Noetherian or UFD integral domain `r`, the power of `p` raised to its order in `a` always divides `a`. The `ring_ord r p a` represents the highest power of `p` that divides `a` in the ring `r`, and this result confirms that such a power indeed divides `a`.

### Dependencies
- `integral_domain`
- `noetherian_ring`
- `UFD`
- `ring_prime`
- `ring_carrier`
- `ring_0`
- `ring_divides`
- `ring_pow`
- `ring_ord`
- `ring_unit`
- `ring_mul`
- `ring_ord_exists_unique`
- `RING_POW`

### Porting notes (optional)
The most challenging part of porting this theorem lies in ensuring that the definitions of `ring_ord`, `ring_prime`, `integral_domain`, `noetherian_ring` and `UFD` are consistent with those in HOL Light. Particular attention should be paid to the definition of `ring_ord` and the theorem `ring_ord_exists_unique`, as they are crucial to the proof. Recreating the `choose` tactic might require some attention depending on the target proof assistant. Specifically, one would need to verify that the assumption `~(a = ring_0 r)` is necessary for existence of `ring_ord`.


---

## divides_le_pow_ring_ord

### Name of formal statement
divides_le_pow_ring_ord

### Type of the formal statement
theorem

### Formal Content
```ocaml
let divides_le_pow_ring_ord = prove(`
  !(r:R ring) p a e.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  e <= ring_ord r p a ==>
  ring_divides r (ring_pow r p e) a
`,
  intro_gendisch THEN
  have `ring_divides r (ring_pow r p (ring_ord r p a)) (a:R)` [divides_pow_ring_ord] THEN
  qed[ring_divides_pow_pow;ring_prime;RING_DIVIDES_TRANS]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and for any `p`, `a` and `e`, the following holds: If `r` is an integral domain, and `r` is either a Noetherian ring or a unique factorization domain (UFD), and `p` is a prime element in `r`, and `a` is an element of the carrier of `r`, and `a` is not equal to the zero element of `r`, and `e` is less than or equal to the order of `a` with respect to `p` in `r`, then `(ring_pow r p e)` divides `a` in `r`.

### Informal sketch
*   The proof starts by introducing assumptions using `intro_gendisch`.
*   It uses a previously established theorem stating that `ring_divides r (ring_pow r p (ring_ord r p a)) (a:R)` named `divides_pow_ring_ord`.
*   Finally, the proof concludes using results `ring_divides_pow_pow`, `ring_prime`, and `RING_DIVIDES_TRANS`. The main idea here is that if `e` is less than or equal to the order, then `p^e` divides `a` due to transitivity of `ring_divides`.

### Mathematical insight
This theorem establishes a fundamental property relating the order of an element `a` with respect to a prime `p` in a ring `r` and the divisibility of `a` by powers of `p`. If `e` is no more than the order of `a` w.r.t. `p`, then `p^e` will divide `a`. This is a key result when analyzing the structure of elements in rings, especially in the context of unique factorization and Noetherian rings.

### Dependencies

*   Definitions:
    *   `integral_domain`
    *   `noetherian_ring`
    *   `UFD`
    *   `ring_prime`
    *   `ring_carrier`
    *   `ring_0`
    *   `ring_ord`
    *   `ring_pow`
    *   `ring_divides`
*   Theorems:
    *   `ring_divides_pow_pow`
    *   `ring_prime`
    *   `RING_DIVIDES_TRANS`


---

## nonzero_ring_ord_if_divides

### Name of formal statement
nonzero_ring_ord_if_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let nonzero_ring_ord_if_divides = prove(`
  !(r:R ring) p a.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  ~(a = ring_0 r) ==>
  ring_divides r p a ==>
  ~(ring_ord r p a = 0)
`,
  intro_gendisch THEN
  have `~ring_unit r (p:R)` [ring_prime] THEN
  have `p:R IN ring_carrier r` [ring_prime] THEN
  have `a:R IN ring_carrier r` [ring_divides] THEN
  specialize[
    `r:R ring`;
    `p:R`;
    `a:R`
  ]ring_ord_exists_unique THEN
  choose `u:R` `u:R IN ring_carrier r /\ ~ring_divides r p u /\ a = ring_mul r (ring_pow r p (ring_ord r p a)) u` [] THEN
  have `a = ring_mul r (ring_pow r p 0) u:R` [] THEN
  have `a = ring_mul r (ring_1 r) u:R` [RING_POW_0] THEN
  have `a = u:R` [RING_MUL_LID] THEN
  qed[]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and any elements `p` and `a` in `r`, if `r` is an integral domain, and `r` is either Noetherian or a unique factorization domain (UFD), and `p` is a ring prime in `r`, and `a` is not the zero element of `r`, and `p` divides `a` in `r`, then the ring order of `a` with respect to `p` in `r` is not equal to 0.

### Informal sketch
*   Assume that `r` is an integral domain, `r` is either a Noetherian ring or a UFD, `p` is a ring prime in `r`, `a` is not the zero element of `r`, and `p` divides `a` in `r`.
*   Establish that `p` is not a ring unit in `r` using the assumption that `p` is a `ring_prime`.
*   Establish that `p` is in the carrier of the ring `r` using the assumption that `p` is a `ring_prime`.
*   Establish that `a` is in the carrier of the ring `r` using the assumption that `ring_divides r p a`.
*   Apply the theorem `ring_ord_exists_unique` to obtain a unique element `u` in the carrier of `r` such that `p` does not divide `u` and `a = ring_mul r (ring_pow r p (ring_ord r p a)) u`. This step uses the properties of the ring order.
*   Assume, for the purpose of contradiction, that `ring_ord r p a = 0`. Then `a = ring_mul r (ring_pow r p 0) u:R `.
*   Simplify `ring_pow r p 0` to `ring_1 r` using `RING_POW_0`, yielding `a = ring_mul r (ring_1 r) u:R`.
*   Simplify `ring_mul r (ring_1 r) u` to `u` using `RING_MUL_LID`, which states that `ring_1 r` is the left identity for `ring_mul r`. Thus, `a = u:R`.
*   Conclude that if `ring_ord r p a = 0`, then `a = u`, which contradicts the initial assumptions.

### Mathematical insight
This theorem states that if an element `a` in an integral domain `r` is divisible by a prime element `p`, then the highest power of `p` that divides `a` (i.e., the ring order of `a` with respect to `p`) must be greater than zero. This is a basic property used in the study of unique factorization domains and Noetherian rings.

### Dependencies
*   Theorems: `ring_ord_exists_unique`, `RING_POW_0`, `RING_MUL_LID`
*   Definitions: `integral_domain`, `noetherian_ring`, `UFD`, `ring_prime`, `ring_divides`,`ring_0`,`ring_ord`,`ring_mul`, `ring_pow`, `ring_unit`, `ring_carrier`, `ring_1`


---

## ring_ord_mul

### Name of formal statement
ring_ord_mul

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_mul = prove(`
  !(r:R ring) p a b.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  b IN ring_carrier r ==>
  ~(b = ring_0 r) ==>
  ring_ord r p (ring_mul r a b)
  = (ring_ord r p a) + (ring_ord r p b)
`,
  intro_genonly THEN
  REPEAT DISCH_TAC THEN
  specialize[
    `r:R ring`;
    `p:R`;
    `a:R`
  ]ring_ord_exists_unique THEN
  choose `u:R` `u:R IN ring_carrier r /\ ~(ring_divides r p u) /\ a = ring_mul r (ring_pow r p (ring_ord r p a)) u` [] THEN
  specialize[
    `r:R ring`;
    `p:R`;
    `b:R`
  ]ring_ord_exists_unique THEN
  choose `v:R` `v:R IN ring_carrier r /\ ~(ring_divides r p v) /\ b = ring_mul r (ring_pow r p (ring_ord r p b)) v` [] THEN
  have `ring_mul r a b:R IN ring_carrier r` [RING_MUL] THEN
  have `~(ring_mul r a b:R = ring_0 r)` [integral_domain] THEN
  specialize[
    `r:R ring`;
    `p:R`;
    `ring_mul r (a:R) b`
  ]ring_ord_exists_unique THEN
  choose `w:R` `w:R IN ring_carrier r /\ ~(ring_divides r p w) /\ ring_mul r a b = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r a b))) w` [] THEN
  subgoal `ring_mul r (ring_pow r p (ring_ord r p a + ring_ord r p b)) (ring_mul r u v) = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r a b))) w:R` THENL [
    have `a:R = ring_mul r (ring_pow r p (ring_ord r p a)) u` [] THEN
    have `b:R = ring_mul r (ring_pow r p (ring_ord r p b)) v` [] THEN
    have `ring_mul r a b:R = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r a b))) w` [] THEN
    have `p:R IN ring_carrier r` [ring_prime] THEN
    simp[RING_POW_ADD] THEN
    RING_TAC
  ; pass
  ] THEN
  specialize_assuming[
    `r:R ring`;
    `p:R`;
    `ring_ord r (p:R) a + ring_ord r (p:R) b`;
    `ring_ord r (p:R) (ring_mul r a b)`;
    `ring_mul r u v:R`;
    `w:R`
  ]ring_ord_unique THEN
  qed[ring_prime;RING_MUL]
);;
```
### Informal statement
For any ring `r` that is an integral domain and either a Noetherian ring or a UFD, if `p` is a prime element of `r`, and `a` and `b` are nonzero elements in the carrier of `r`, then the ring order of `ring_mul r a b` with respect to `p` is equal to the sum of the ring orders of `a` and `b` with respect to `p`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `r` is an integral domain, `r` is either a Noetherian ring or a UFD, `p` is a prime element in `r`, `a` and `b` are nonzero elements in the carrier of `r`.
- Apply `ring_ord_exists_unique` three times to obtain unique elements `u`, `v`, and `w` in the carrier of `r` such that `a = ring_mul r (ring_pow r p (ring_ord r p a)) u`, `b = ring_mul r (ring_pow r p (ring_ord r p b)) v`, and `ring_mul r a b = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r a b))) w`, and `p` does not divide `u`, `v`, or `w`.
- Show that `ring_mul r (ring_pow r p (ring_ord r p a + ring_ord r p b)) (ring_mul r u v) = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r a b))) w`. This involves using the facts that `a = ring_mul r (ring_pow r p (ring_ord r p a)) u`, `b = ring_mul r (ring_pow r p (ring_ord r p b)) v`, `ring_mul r a b = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r a b))) w`, `p` is in the carrier of `r` and applying `RING_TAC`. `RING_TAC` uses rewriting with the characteristic ring laws to prove ring equalities.
- Apply `ring_ord_unique` to conclude that `ring_ord r p (ring_mul r a b) = (ring_ord r p a) + (ring_ord r p b)`. The hypothesis of `ring_ord_unique` requires that the arguments `ring_mul r u v` and `w` are not divisible by `p`.

### Mathematical insight
This theorem states a fundamental property of the ring order (or valuation) in integral domains that are either Noetherian or UFDs: the order of a product is the sum of the orders of the factors. This property is crucial in algebraic number theory and commutative algebra when dealing with factorization in rings.

### Dependencies
- `ring_ord_exists_unique`
- `ring_ord_unique`
- `ring_prime`
- `RING_MUL`
- `RING_POW_ADD`
- `integral_domain`


---

## ring_ord_pow

### Name of formal statement
ring_ord_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_pow = prove(`
  !(r:R ring) p a e.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  ring_ord r p (ring_pow r a e)
  = e * ring_ord r p a
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[RING_POW_0] THEN
    intro_gendisch THEN
    have `ring_ord r (p:R) (ring_1 r) = 0` [ring_ord_1;ring_prime] THEN
    ASM_ARITH_TAC
  ;
    rw[ARITH_RULE `SUC e = 1+e`] THEN
    intro_gendisch THEN
    simp[RING_POW_ADD] THEN
    subgoal `ring_ord r p (ring_mul r (ring_pow r a 1) (ring_pow r a e)) = ring_ord r p (ring_pow r a 1) + ring_ord r p (ring_pow r a e:R)` THENL [
      specialize_assuming[
        `r:R ring`;
        `p:R`;
        `ring_pow r (a:R) 1`;
        `ring_pow r (a:R) e`
      ]ring_ord_mul THEN
      qed[RING_POW;INTEGRAL_DOMAIN_POW_EQ_0]
    ; pass
    ] THEN
    simp[RING_POW_1] THEN
    ARITH_TAC
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, prime element `p` of `r`, element `a` in the carrier of `r` that is not the zero element of `r`, and natural number `e`, if `r` is an integral domain and either a Noetherian ring or a unique factorization domain, then the ring order of `ring_pow r a e` with respect to `p` is equal to `e` times the ring order of `a` with respect to `p`.

### Informal sketch
The proof proceeds by induction on `e`.
- Base case (`e = 0`):
  - We need to show that `ring_ord r p (ring_pow r a 0) = 0 * ring_ord r p a`.
  - Since `ring_pow r a 0 = ring_1 r`, we have `ring_ord r p (ring_1 r) = 0`. This follows from `ring_ord_1` and the fact that `p` is prime (`ring_prime`).
  - Finally, `0 = 0 * ring_ord r p a` holds by arithmetic.
- Inductive step:
  - Assume that `ring_ord r p (ring_pow r a e) = e * ring_ord r p a` holds.
  - We want to show `ring_ord r p (ring_pow r a (SUC e)) = (SUC e) * ring_ord r p a`.
  - Rewriting `SUC e` as `1 + e`, `ring_pow r a (1 + e)` is equal to `ring_mul r (ring_pow r a 1) (ring_pow r a e)`.
  - We need to show that `ring_ord r p (ring_mul r (ring_pow r a 1) (ring_pow r a e)) = ring_ord r p (ring_pow r a 1) + ring_ord r p (ring_pow r a e)`. This follows from `ring_ord_mul`, since `r` is an integral domain, implying that `ring_pow r a 1` and `ring_pow r a e` are not zero. `INTEGRAL_DOMAIN_POW_EQ_0` is used to ensure that the powers are not zero.
  - By the inductive hypothesis, `ring_ord r p (ring_pow r a e) = e * ring_ord r p a`.
  - Thus, the goal simplifies to `ring_ord r p a + e * ring_ord r p a = (1 + e) * ring_ord r p a`, which holds by arithmetic.

### Mathematical insight
This theorem establishes a fundamental relationship between the valuation (or order) of a power of an element and the valuation of the element itself. Specifically, it states that the valuation of `a^e` with respect to a prime `p` is `e` times the valuation of `a` with respect to `p`, provided that `a` is nonzero. This property is crucial in number theory and algebraic number theory for calculations involving divisibility and factorization in rings, especially when dealing with prime ideals or valuations. The required conditions (integral domain and either Noetherian or UFD) ensure that the ring has sufficient structure for the notions of prime elements and unique factorization to be meaningful.

### Dependencies
#### Theorems
- `ring_ord_mul`
- `ring_ord_1`
- `ring_prime`
#### Definitions
- `integral_domain`
- `noetherian_ring`
- `UFD`
- `ring_prime`
- `ring_carrier`
- `ring_0`
- `ring_ord`
- `ring_pow`
- `ring_1`
- `ring_mul`
- `RING_POW_0`
- `RING_POW_ADD`
- `RING_POW_1`
- `INTEGRAL_DOMAIN_POW_EQ_0`

### Porting notes (optional)
- The theorem relies on properties of rings, integral domains, prime elements, valuations, and powers.
- Ensure that the target proof assistant has well-developed theories for these concepts.
- The `ring_ord_mul` theorem is a critical dependency, so translating this theorem first will be helpful.
- Mechanization might be simplified if the target system provides good automation for ring arithmetic and properties involving divisibility.


---

## ring_ord_product_waterfall

### Name of formal statement
ring_ord_product_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_product_waterfall = prove(`
  !(r:R ring) p a.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  !S.
  FINITE S ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  (!s:X. s IN S ==> ~(a s = ring_0 r)) ==>
  ring_ord r p (ring_product r S a)
  = nsum S (\s. ring_ord r p (a s))
`,
  intro_gendisch THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;NSUM_CLAUSES] THEN
    qed[ring_ord_1;ring_prime]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    simp[RING_PRODUCT_CLAUSES;NSUM_CLAUSES] THEN
    specialize_assuming[
      `r:R ring`;
      `p:R`;
      `a(x:X):R`;
      `ring_product r S (a:X->R)`
    ]ring_ord_mul THEN
    qed[RING_PRODUCT;INTEGRAL_DOMAIN_PRODUCT_EQ_0]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any element `p` of `r`, and any function `a` from a type `X` to `r`, if `r` is an integral domain, and (`r` is a noetherian ring or `r` is a unique factorization domain), and `p` is a prime element in `r`, then for any finite set `S` such that all elements `s` in `S` map to elements `a s` in the carrier of `r`, and none of elements `a s` are zero, the ring order of `p` in the product of `a s` over `S` equals the sum over `S` of the ring order of `p` in `a s`.

### Informal sketch
The proof proceeds by strong induction on the cardinality of the finite set `S`.

- In the base case, where the set `S` is empty, the ring product over `S` is 1 and the sum over `S` is 0. In this case, we need to show that `ring_ord r p 1 = 0`. This follows directly from the definition of `ring_ord` and the fact that `p` is prime.

- In the inductive step, we assume the result holds for all sets smaller than `x INSERT S`. Then, we want to prove it holds for `x INSERT S`.
  We rewrite `ring_product r (x INSERT S) a` as `(a x) * (ring_product r S a)` and `nsum (x INSERT S) (\s. f s)` to `f x + nsum S (\s. f s)`.
  Then, using the theorem `ring_ord_mul`, we can rewrite `ring_ord r p (ring_product r (x INSERT S) a)` as `ring_ord r p (a x) + ring_ord r p (ring_product r S a))`. applying the induction hypothesis, we obtain `ring_ord r p (a x) + nsum S (\s. ring_ord r p(a s)) = nsum(x INSERT S) (\s. ring_ord r p (a s))`.

### Mathematical insight
The theorem states that the valuation (ring order) of a prime element in a product of elements is the sum of individual valuations, given some conditions. This theorem is a generalization of the property of valuations in number theory, and it is useful in algebraic number theory and commutative algebra. The assumption `noetherian_ring r \/ UFD r` ensures that prime elements exist in the ring `r`.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `NSUM_CLAUSES`
- `ring_ord_1`
- `ring_prime`
- `RING_PRODUCT`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `ring_ord_mul`


---

## ring_ord_product

### Name of formal statement
ring_ord_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_product = prove(`
  !(r:R ring) p S a.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  FINITE S ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  (!s:X. s IN S ==> ~(a s = ring_0 r)) ==>
  ring_ord r p (ring_product r S a)
  = nsum S (\s. ring_ord r p (a s))
`,
  intro THEN
  specialize_assuming[
    `r:R ring`;
    `p:R`;
    `a:X->R`
  ]ring_ord_product_waterfall THEN
  qed[]
);;
```
### Informal statement
For all rings `r`, elements `p` of `r`, finite sets `S`, and functions `a` from `S` to `r`, if `r` is an integral domain, and either `r` is a Noetherian ring or a unique factorization domain (UFD), and `p` is a prime element of `r`, and `a(s)` is in the carrier of `r` for all `s` in `S`, and `a(s)` is not equal to the zero element of `r` for all `s` in `S`, then the ring order of `p` in the product of `a(s)` over `S` is equal to the sum over `S` of the ring order of `p` in `a(s)`.

### Informal sketch
The proof proceeds by:
- Introduction and specialization of assumptions including `r`, `p`, and `a`.
- Applying `ring_ord_product_waterfall`, which likely performs the core inductive reasoning or case analysis to establish the equality between the ring order of the product and the sum of the ring orders.
- `qed[]` completes the proof.

### Mathematical insight
This theorem states a key property about the prime factorization in rings satisfying certain conditions (integral domain, Noetherian or UFD). It essentially says that the valuation of a product is the sum of the valuations, a fundamental result in valuation theory.  The condition that the factors `a s` are non-zero is crucial because the valuation of zero is undefined.  The finiteness condition on S is necessary to ensure both the product and sum are well-defined within the ring. This result is important for understanding the structure of ideals and factorization in rings.

### Dependencies
- `integral_domain`
- `noetherian_ring`
- `UFD`
- `ring_prime`
- `FINITE`
- `ring_carrier`
- `ring_0`
- `ring_ord`
- `ring_product`
- `nsum`
- `ring_ord_product_waterfall`


---

## ring_ord_divides

### Name of formal statement
ring_ord_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_divides = prove(`
  !(r:R ring) p a b.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  ~(b = ring_0 r) ==>
  ring_divides r a b ==>
  ring_ord r p a <= ring_ord r p b
`,
  rw[ring_divides] THEN
  intro_genonly THEN
  DISCH_TAC THEN
  DISCH_TAC THEN
  intro THEN
  have `~(a:R = ring_0 r)` [RING_MUL_LZERO] THEN
  have `~(x:R = ring_0 r)` [RING_MUL_RZERO] THEN
  have `ring_ord r (p:R) b = ring_ord r p a + ring_ord r p x` [ring_ord_mul] THEN
  qed[ARITH_RULE `e <= e+f:num`]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and for any elements `p`, `a`, and `b` of the ring `r`, if `r` is an integral domain, and (`r` is a Noetherian ring or `r` is a UFD), and `p` is a prime element in `r`, and `b` is not equal to the zero element of `r`, and `a` divides `b` in `r`, then the order of `p` in `a` is less than or equal to the order of `p` in `b` in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Start by rewriting `ring_divides` with its definition.
- Assume the antecedent of the implication.
- Assume `a` divides `b` which means there exists `x` such that `a * x = b`.
- Show that `a` and `x` are not zero using `RING_MUL_LZERO` and `RING_MUL_RZERO` respectively.
- Apply `ring_ord_mul` to rewrite `ring_ord r p b` as `ring_ord r p a + ring_ord r p x`.
- Deduce the result using arithmetic reasoning (`ARITH_RULE`). Specifically, since order is non-negative, `e <= e+f` for non-negative `f`.

### Mathematical insight
This theorem states a basic property of the order function in rings. Namely, if `a` divides `b`, then the exponent of any prime factor in `a` cannot exceed the exponent of the same prime factor in `b`. This is a fundamental result used in number theory and ring theory, and reflects the idea that divisors cannot have higher prime powers than the numbers they divide.

### Dependencies
- `ring_divides`
- `ring_ord_mul`
- `integral_domain`
- `noetherian_ring`
- `UFD`
- `ring_prime`
- `ring_0`
- `RING_MUL_LZERO`
- `RING_MUL_RZERO`
- `ARITH_RULE`


---

## ring_ord_prime_divides

### Name of formal statement
ring_ord_prime_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_prime_divides = prove(`
  !(r:R ring) p b.
  integral_domain r ==>
  (noetherian_ring r \/ UFD r) ==>
  ring_prime r p ==>
  ~(b = ring_0 r) ==>
  ring_divides r p b ==>
  1 <= ring_ord r p b
`,
  intro_gendisch THEN
  have `ring_ord r p (p:R) = 1` [ring_ord_refl;ring_prime] THEN
  qed[ring_ord_divides]
);;
```

### Informal statement
For any ring `r` of type `R ring`, any `p` and `b` of type `R`, if `r` is an integral domain, and `r` is either a Noetherian ring or a unique factorization domain (UFD), and `p` is a ring prime in `r`, and `b` is not equal to the ring zero element in `r`, and `p` ring divides `b` in `r`, then the ring order of `p` in `b` with respect to `r` is greater than or equal to 1.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent conditions: `r` is an integral domain, `r` is either a Noetherian ring or a UFD, `p` is a ring prime in `r`, `b` is not `ring_0 r`, and `p` ring divides `b` in `r`.
- Show that `ring_ord r p (p:R) = 1` using `ring_ord_refl` and `ring_prime`.
- Finally, apply `ring_ord_divides` to conclude `1 <= ring_ord r p b`.

### Mathematical insight
This theorem states that if a prime element `p` divides an element `b` in an integral domain that is also either Noetherian or a UFD, then the highest power of `p` that divides `b` is at least 1 i.e, the ring order of `p` in `b` is at least 1. This aligns with the intuition that if `p` divides `b`, then `p` appears at least once in the prime factorization of `b`.

### Dependencies
- Definitions: `integral_domain`, `noetherian_ring`, `UFD`, `ring_prime`, `ring_0`, `ring_divides`, `ring_ord`
- Theorems: `ring_ord_refl`, `ring_ord_divides`


---

## ring_ord_gcd

### Name of formal statement
ring_ord_gcd

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_gcd = prove(`
  !(r:R ring) p a b.
  UFD r ==>
  ring_prime r p ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  b IN ring_carrier r ==>
  ~(b = ring_0 r) ==>
  ring_ord r p (ring_gcd r (a,b))
  = MIN (ring_ord r p a) (ring_ord r p b)
`,
  intro_gendisch THEN
  have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
  have `ring_divides r (ring_gcd r (a,b)) (a:R)` [RING_GCD_DIVIDES] THEN
  have `ring_divides r (ring_gcd r (a,b)) (b:R)` [RING_GCD_DIVIDES] THEN
  have `ring_ord r (p:R) (ring_gcd r (a,b)) <= ring_ord r p a` [ring_ord_divides;RING_GCD] THEN
  have `ring_ord r (p:R) (ring_gcd r (a,b)) <= ring_ord r p b` [ring_ord_divides;RING_GCD] THEN
  have `ring_ord r (p:R) (ring_gcd r (a,b)) <= MIN (ring_ord r p a) (ring_ord r p b)` [le_min] THEN
  have `MIN (ring_ord r p a) (ring_ord r p b) <= ring_ord r p (a:R)` [min_le] THEN
  have `MIN (ring_ord r p a) (ring_ord r p b) <= ring_ord r p (b:R)` [min_le] THEN
  have `ring_divides r (ring_pow r (p:R) (MIN (ring_ord r p a) (ring_ord r p b))) a` [divides_le_pow_ring_ord] THEN
  have `ring_divides r (ring_pow r (p:R) (MIN (ring_ord r p a) (ring_ord r p b))) b` [divides_le_pow_ring_ord] THEN
  have `ring_divides r (ring_pow r (p:R) (MIN (ring_ord r p a) (ring_ord r p b))) (ring_gcd r (a,b))` [UFD_DIVIDES_GCD] THEN
  have `~(ring_gcd r (a,b) = ring_0 r:R)` [ring_divides;RING_MUL_LZERO] THEN
  have `ring_ord r p (ring_pow r (p:R) (MIN (ring_ord r p a) (ring_ord r p b))) <= ring_ord r p (ring_gcd r (a,b))` [ring_ord_divides] THEN
  have `MIN (ring_ord r p a) (ring_ord r p b) <= ring_ord r (p:R) (ring_gcd r (a,b))` [ring_ord_pow_refl;ring_prime] THEN
  ASM_ARITH_TAC
);;
```
### Informal statement
For any ring `r` of type `R ring`, and elements `p`, `a`, and `b` in `r`, if `r` is a unique factorization domain (UFD) and `p` is a prime element in `r`, and `a` and `b` are non-zero elements in the carrier of `r`, then the order of `ring_gcd r (a, b)` with respect to `p` is equal to the minimum of the order of `a` with respect to `p` and the order of `b` with respect to `p`.

### Informal sketch
The proof proceeds as follows:
- Assume the premises: `UFD r`, `ring_prime r p`, `a IN ring_carrier r`, `~(a = ring_0 r)`, `b IN ring_carrier r`, `~(b = ring_0 r)`.
- From `UFD r`, infer that `integral_domain r` using `UFD_IMP_INTEGRAL_DOMAIN.`
- Show that `ring_gcd r (a,b)` divides `a` and `b` using `RING_GCD_DIVIDES.`
- Show that `ring_ord r p (ring_gcd r (a,b)) <= ring_ord r p a` and `ring_ord r p (ring_gcd r (a,b)) <= ring_ord r p b` using `ring_ord_divides.`
- Show `ring_ord r p (ring_gcd r (a,b)) <= MIN (ring_ord r p a) (ring_ord r p b)` using `le_min`.
- Show `MIN (ring_ord r p a) (ring_ord r p b) <= ring_ord r p a` and `MIN (ring_ord r p a) (ring_ord r p b) <= ring_ord r p b` using `min_le`.
- Show that `ring_pow r p (MIN (ring_ord r p a) (ring_ord r p b))` divides both `a` and `b` using `divides_le_pow_ring_ord`.
- Show that `ring_pow r p (MIN (ring_ord r p a) (ring_ord r p b))` divides `ring_gcd r (a,b)` using `UFD_DIVIDES_GCD`.
- Show that `~(ring_gcd r (a,b) = ring_0 r)` using `ring_divides` and `RING_MUL_LZERO`.
- Show that `ring_ord r p (ring_pow r p (MIN (ring_ord r p a) (ring_ord r p b))) <= ring_ord r p (ring_gcd r (a,b))` using `ring_ord_divides`.
- Show that `MIN (ring_ord r p a) (ring_ord r p b) <= ring_ord r p (ring_gcd r (a,b))` using `ring_ord_pow_refl` and the primality of `p`.
- Finally, obtain the equality using arithmetic tactics (`ASM_ARITH_TAC`).

### Mathematical insight
This theorem relates the order of the greatest common divisor of two elements in a unique factorization domain with respect to a prime element, to the minimum of the orders of the individual elements with respect to that prime element. This provides a way to compute the order of a GCD in terms of the orders of its constituents.

### Dependencies
- `UFD_IMP_INTEGRAL_DOMAIN`
- `RING_GCD_DIVIDES`
- `ring_ord_divides`
- `RING_GCD`
- `le_min`
- `min_le`
- `divides_le_pow_ring_ord`
- `UFD_DIVIDES_GCD`
- `ring_divides`
- `RING_MUL_LZERO`
- `ring_ord_pow_refl`
- `ring_prime`


---

## ring_ord_associates

### Name of formal statement
ring_ord_associates

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_associates = prove(`
  !(r:R ring) p a b.
  UFD r ==>
  ring_prime r p ==>
  ring_associates r a b ==>
  ~(a = ring_0 r) ==>
  ring_ord r p a = ring_ord r p b
`,
  intro THEN
  have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
  choose `u:R` `ring_unit r (u:R) /\ ring_mul r a u = b` [INTEGRAL_DOMAIN_ASSOCIATES] THEN
  have `ring_ord r p (u:R) = 0` [ring_ord_unit;ring_prime] THEN
  specialize_assuming[
    `r:R ring`;
    `p:R`;
    `a:R`;
    `u:R`
  ]ring_ord_mul THEN
  have `~(b = ring_0 r:R)` [RING_ASSOCIATES_0] THEN
  have `a:R IN ring_carrier r` [ring_associates;ring_divides] THEN
  have `~(u = ring_0 r:R)` [RING_MUL_RZERO] THEN
  have `ring_ord r (p:R) (ring_mul r a u) = ring_ord r p a + ring_ord r p u` [ring_unit] THEN
  qed[ARITH_RULE `e+0 = e`]
);;
```
### Informal statement
For any ring `r` and elements `p`, `a`, and `b` in the carrier of `r`, if `r` is a unique factorization domain, `p` is a prime element in `r`, `a` and `b` are associates in `r`, and `a` is not equal to the zero element of `r`, then the `ring_ord` of `p` in `a` is equal to the `ring_ord` of `p` in `b`.

### Informal sketch
The proof proceeds as follows:
- Assume `r` is a UFD, `p` is prime in `r`, `a` and `b` are associates, and `a` is nonzero.
- Use `UFD_IMP_INTEGRAL_DOMAIN` to show that `r` is an integral domain.
- Since `a` and `b` are associates, choose a unit `u` such that `ring_mul r a u = b`. This relies on `INTEGRAL_DOMAIN_ASSOCIATES`.
- Prove `ring_ord r p u = 0` using `ring_ord_unit` and the fact that `p` is prime.
- Use `ring_ord_mul` to deduce that `ring_ord r p (ring_mul r a u) = ring_ord r p a + ring_ord r p u`. The specialization of `ring_ord_mul` provides the assumptions `r:R ring`; `p:R`; `a:R`; `u:R`.
- Show that `b` is nonzero using `RING_ASSOCIATES_0`.
- Show that `a` is in the carrier of `r` using `ring_associates` and `ring_divides`.
- Show that `u` is non-zero using `RING_MUL_RZERO`.
- Finally, use arithmetic to conclude that `ring_ord r p a = ring_ord r p b`.

### Mathematical insight
This theorem formalizes the intuition that the order of a prime element in two associates is the same. If `a` and `b` are associates, they only differ by a unit factor, and prime factors only appear with same multiplicities up to units. Since units do not contribute to the `ring_ord`, the `ring_ord` is the same for associates.

### Dependencies
- `UFD_IMP_INTEGRAL_DOMAIN`
- `INTEGRAL_DOMAIN_ASSOCIATES`
- `ring_ord_unit`
- `ring_ord_mul`
- `RING_ASSOCIATES_0`
- `ring_associates`
- `ring_divides`
- `RING_MUL_RZERO`
- `ring_prime`

### Porting notes (optional)
- The definition of `ring_ord` will be needed.
- Properties of units in rings would need to be established independently if not already available.
- The automation may need adaptation depending on how other provers handle arithmetic reasoning within rings.


---

## ring_associates_ord

### Name of formal statement
ring_associates_ord

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_associates_ord = prove(`
  !(r:R ring) p q a.
  UFD r ==>
  ring_prime r p ==>
  ring_associates r p q ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  ring_ord r p a = ring_ord r q a
`,
  intro THEN
  have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
  choose `u:R` `ring_unit r (u:R) /\ ring_mul r q u = p` [RING_ASSOCIATES_SYM;INTEGRAL_DOMAIN_ASSOCIATES] THEN
  have `noetherian_ring r \/ UFD(r:R ring)` [] THEN
  specialize[
    `r:R ring`;
    `p:R`;
    `a:R`
  ]ring_ord_exists_unique THEN
  choose `v:R` `v:R IN ring_carrier r /\ ~ring_divides r p v /\ a = ring_mul r (ring_pow r p (ring_ord r p a)) v` [] THEN
  subgoal `a:R = ring_mul r (ring_pow r q (ring_ord r p a)) (ring_mul r (ring_pow r u (ring_ord r p a)) v)` THENL [
    have `p:R IN ring_carrier r` [ring_prime] THEN
    have `q:R IN ring_carrier r` [ring_associates;ring_divides] THEN
    have `u:R IN ring_carrier r` [ring_unit] THEN
    have `ring_pow r (p:R) (ring_ord r p a) = ring_mul r (ring_pow r q (ring_ord r p a)) (ring_pow r u (ring_ord r p a))` [RING_MUL_POW] THEN
    have `a = ring_mul r (ring_pow r p (ring_ord r p a)) v:R` [] THEN
    RING_TAC
  ; pass
  ] THEN
  have `ring_unit r (ring_pow r u (ring_ord r p a):R)` [RING_UNIT_POW] THEN
  have `ring_associates r (v:R) (ring_mul r (ring_pow r u (ring_ord r p a)) v)` [RING_ASSOCIATES_LMUL] THEN
  have `~ring_divides r (q:R) (ring_mul r (ring_pow r u (ring_ord r p a)) v)` [RING_ASSOCIATES_DIVIDES] THEN
  have `ring_prime r (q:R)` [RING_ASSOCIATES_PRIME] THEN
  specialize[
    `r:R ring`;
    `q:R`;
    `a:R`
  ]ring_ord_exists_unique THEN
  choose `w:R` `w:R IN ring_carrier r /\ ~ring_divides r q w /\ a = ring_mul r (ring_pow r q (ring_ord r q a)) w` [] THEN
  specialize_assuming[
    `r:R ring`;
    `q:R`;
    `ring_ord r p (a:R)`;
    `ring_ord r q (a:R)`;
    `ring_mul r (ring_pow r u (ring_ord r p a)) v:R`;
    `w:R`
  ]ring_ord_unique THEN
  qed[ring_prime;RING_MUL;RING_POW;ring_unit]
);;
```
### Informal statement
For any ring `r` of type `R ring`, and elements `p`, `q`, and `a` in the carrier of `r`, if `r` is a unique factorization domain, `p` is a prime element in `r`, `p` and `q` are associates in `r`, and `a` is a non-zero element in the carrier of `r`, then the `ring_ord` of `a` with respect to `p` is equal to the `ring_ord` of `a` with respect to `q`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `r` is a UFD, `p` is prime, `p` and `q` are associates, `a` is in the carrier of `r`, and `a` is nonzero.
- Use `UFD_IMP_INTEGRAL_DOMAIN` to infer that `r` is an integral domain.
- Since `p` and `q` are associates, there exists a unit `u` such that `q * u= p`.
- The theorem `ring_ord_exists_unique` guarantees the existence of a `ring_ord` and a non-divisor. Choose an element `v` in `r` such that `v` is in ring_carrier r, `p` does not divide `v`, and `a = p^(ring_ord r p a) * v`.
- The goal is to prove `a = q^(ring_ord r p a) * u^(ring_ord r p a) * v`.
- We can replace the power of `p` with an equivalent expression involving powers of `q` and `u`, since `ring_pow r (p:R) (ring_ord r p a) = ring_mul r (ring_pow r q (ring_ord r p a)) (ring_pow r u (ring_ord r p a))`.
- This allows us to show that `a = ring_mul r (ring_pow r q (ring_ord r p a)) (ring_mul r (ring_pow r u (ring_ord r p a)) v)`.
- The theorem `ring_unit_pow` tells us that powers of units are also units: ring_unit r (ring_pow r u (ring_ord r p a):R)`
- Thus `v` and `u^(ring_ord r p a) * v` are associates.
- `ring_associates r (v:R) (ring_mul r (ring_pow r u (ring_ord r p a)) v)` implies `~ring_divides r (q:R) (ring_mul r (ring_pow r u (ring_ord r p a)) v)`.
- `ring_associates r p q` and `ring_prime r p` implies `ring_prime r q`.
- Use the theorem `ring_ord_exists_unique` to prove the existence of an element `w:R` such that `w:R IN ring_carrier r /\ ~ring_divides r q w /\ a = ring_mul r (ring_pow r q (ring_ord r q a)) w`.
- Use the theorem `ring_ord_unique` to finalize the proof: `ring_ord r p (a:R)=ring_ord r q (a:R)`.

### Mathematical insight
This theorem states that the order of an element `a` with respect to a prime `p` in a UFD is the same as its order with respect to any associate of `p`. This is because associates differ only by a unit factor, which does not affect the number of times the prime appears in the factorization of `a`. This is a standard result in commutative algebra and is useful when working with unique factorization domains.

### Dependencies
- `UFD_IMP_INTEGRAL_DOMAIN`
- `RING_ASSOCIATES_SYM`
- `INTEGRAL_DOMAIN_ASSOCIATES`
- `RING_ORD_EXISTS_UNIQUE`
- `RING_ASSOCIATES_LMUL`
- `RING_ASSOCIATES_DIVIDES`
- `RING_ASSOCIATES_PRIME`
- `RING_MUL_POW`
- `RING_UNIT_POW`
- `ring_prime`
- `RING_MUL`
- `RING_POW`
- `ring_unit`
- `RING_ORD_UNIQUE`

### Porting notes (optional)
- The definition of `ring_ord` and `ring_associates` would need to be ported first.
- The theorems pertaining to `ring_ord`, `ring_associates`, `ring_unit` such as `RING_ASSOCIATES_SYM`, `INTEGRAL_DOMAIN_ASSOCIATES`, `RING_UNIT_POW`, `RING_ASSOCIATES_LMUL`, `RING_ASSOCIATES_DIVIDES`, `RING_ASSOCIATES_PRIME`, and `RING_ORD_UNIQUE` should also be ported.
- The handling of ring carrier membership might differ between proof assistants; ensure that the equivalent constraints are enforced.


---

## ring_ord_prime

### Name of formal statement
ring_ord_prime

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_prime = prove(`
  !(r:R ring) p q.
  UFD r ==>
  ring_prime r p ==>
  ring_prime r q ==>
  ring_ord r p q
  = if ring_associates r p q then 1 else 0
`,
  intro THEN
  case `ring_divides r (p:R) q` THENL [
    specialize_assuming[
      `r:R ring`;
      `p:R`;
      `q:R`;
      `p:R`
    ]prime_divides_prime_and THEN
    have `ring_divides r q (p:R)` [RING_DIVIDES_REFL;ring_prime] THEN
    have `ring_associates r p (q:R)` [ring_associates] THEN
    have `ring_ord r (p:R) p = 1` [ring_ord_refl;UFD_IMP_INTEGRAL_DOMAIN;ring_prime] THEN
    qed[ring_ord_associates;ring_prime]
  ; pass
  ] THEN
  qed[ring_ord_notdivides;ring_prime;ring_associates]
);;
```
### Informal statement
For any ring `r` and elements `p` and `q` of `r`, if `r` is a unique factorization domain and `p` and `q` are prime elements in `r`, then the order of `p` in `q` with respect to `r` is 1 if and only if `p` and `q` are associates in `r`, and 0 otherwise.

### Informal sketch
The proof proceeds as follows:
- Assume `r` is a UFD and `p` and `q` are prime.
- Perform a case split based on whether `p` divides `q` in `r`.
- Case 1: `ring_divides r p q`.
  - Use `prime_divides_prime_and` to infer that `ring_divides r q p`.
  - Conclude that `p` and `q` are associates using the definition of `ring_associates`.
  - Use `ring_ord_refl` to show `ring_ord r p p = 1`.
  - Use `ring_ord_associates` to deduce `ring_ord r p q = 1`.
- Case 2: `~(ring_divides r p q)`.
  - Use `ring_ord_notdivides` to prove `ring_ord r p q = 0` given that `p` and `q` are prime and not divisible.
  - Finally, since the conditional matches the ordering based on divisibility, the goal is achieved.

### Mathematical insight
This theorem characterizes the order, `ring_ord`, of one prime element in another within a unique factorization domain. In essence, it asserts that the order is 1 if the two primes are associates (differ by a unit) and 0 otherwise. This is a key property for understanding the prime factorization structure in UFDs.

### Dependencies
- Definitions:
  - `ring_prime`
  - `ring_associates`
  - `ring_ord`
  - `ring_divides`
  - `UFD`
- Theorems:
  - `prime_divides_prime_and`
  - `ring_ord_refl`
  - `UFD_IMP_INTEGRAL_DOMAIN`
  - `ring_ord_associates`
  - `ring_ord_notdivides`
  - `RING_DIVIDES_REFL`


---

## primefact_ord_waterfall

### Name of formal statement
primefact_ord_waterfall

### Type of the formal statement
theorem

### Formal Content
```ocaml
let primefact_ord_waterfall = prove(`
  !(r:R ring).
  UFD r ==>
  !a.
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  (?n q.
    (!i. i IN (1..n) ==> ring_prime r (q i)) /\
    (!i. i IN (1..n) ==> ring_divides r (q i) a) /\
    (!i j. i IN (1..n) ==> j IN (1..n) ==> ring_associates r (q i) (q j) ==> i = j) /\
    ring_associates r a (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)))
  )
`,
  intro_gendisch THEN
  sufficesby UFD_PRIME_FACTOR_INDUCT THEN
  intro THENL [
    qed[]
  ;
    qed[]
  ;
    witness `0` THEN
    witness `\i:num. ring_0 r:R` THEN
    have `!i. ~(i IN 1..0)` [IN_NUMSEG;ARITH_RULE `~(1 <= i /\ i <= 0)`] THEN
    set_fact `(!i. ~(i IN 1..0)) ==> 1..0 = {}` THEN
    rw[know `1..0 = {}`] THEN
    rw[RING_PRODUCT_CLAUSES;EMPTY;IN_ELIM_THM] THEN
    qed[RING_ASSOCIATES_1]
  ;
    have `~(a = ring_0 r:R)` [RING_MUL_RZERO;ring_prime] THEN
    recall (know `~(a = ring_0 r:R) ==> (?n q. (!i. i IN 1..n ==> ring_prime r (q i)) /\ (!i. i IN 1..n ==> ring_divides r (q i) a) /\ (!i j.  i IN 1..n ==> j IN 1..n ==> ring_associates r (q i) (q j) ==> i = j) /\ ring_associates r a (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))))`) THEN
    choose2 `n:num` `q:num->R` `(!i. i IN (1..n) ==> ring_prime r (q i:R)) /\ (!i. i IN (1..n) ==> ring_divides r (q i) a) /\ (!i j. i IN (1..n) ==> j IN (1..n) ==> ring_associates r (q i) (q j) ==> i = j) /\ ring_associates r a (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)))` [] THEN
    case `!i. i IN 1..n ==> ~ring_associates r p (q i:R)` THENL [
      witness `n+1` THEN
      witness `\i:num. if i = n+1 then p else q i:R` THEN
      subgoal `!i. i IN (1..n+1) ==> ~(i = n+1) ==> i IN 1..n` THENL [
        intro THEN
        have `i <= n+1` [IN_NUMSEG] THEN
        have `1 <= i` [IN_NUMSEG] THEN
        num_linear_fact `i <= n+1 ==> ~(i = n+1) ==> i <= n` THEN
        qed[IN_NUMSEG]
      ; pass
      ] THEN
      rw[BETA_THM] THEN
      intro THENL [
        proven_if `i = n+1` [] THEN
        qed[]
      ;
        proven_if `i = n+1` [ring_divides;ring_prime;RING_MUL] THEN
        have `ring_divides r (q(i:num):R) a` [] THEN
        qed[ring_prime;RING_MUL;RING_DIVIDES_LMUL]
      ;
        case `i = n+1` THENL [
          proven_if `j = n+1` [] THEN
          have `j IN 1..n` [] THEN
          qed[]
        ; pass
        ] THEN
        case `j = n+1` THENL [
          proven_if `i = n+1` [] THEN
          have `i IN 1..n` [] THEN
          qed[RING_ASSOCIATES_SYM]
        ; pass
        ] THEN
        qed[]
      ;
        subgoal `ring_product r (1..n + 1) (\i. ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i) (ring_mul r p a))) = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r p a))) (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))):R` THENL [
          have `FINITE(1..n+1)` [FINITE_NUMSEG] THEN
          have `n+1 IN 1..n+1` [IN_NUMSEG;ARITH_RULE `1 <= n+1 /\ n+1 <= n+1`] THEN
          have `ring_pow r (p:R) (ring_ord r p (ring_mul r p a)) IN ring_carrier r` [RING_POW;ring_prime] THEN
          specialize[
            `r:R ring`;
            `1..n+1`;
            `n+1`;
            `\i. ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i:R) (ring_mul r p a))`
          ]ring_product_delete THEN
          rw[know `ring_product r (1..n + 1) (\i. ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i) (ring_mul r p a))) = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r p a))) (ring_product r ((1..n + 1) DELETE (n + 1)) (\i.  ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i) (ring_mul r p a)))):R`] THEN
          subgoal `(1..n+1) DELETE (n+1) = (1..n)` THENL [
            rw[EXTENSION;IN_DELETE;IN_NUMSEG] THEN
            ARITH_TAC
          ; pass
          ] THEN
          rw[know `(1..n+1) DELETE (n+1) = (1..n)`] THEN
          subgoal `ring_product r (1..n) (\i. ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i) (ring_mul r p a))) = ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)):R` THENL [
            sufficesby RING_PRODUCT_EQ THEN
            rw[BETA_THM] THEN
            intro THEN
            have `a' <= n:num` [IN_NUMSEG] THEN
            num_linear_fact `a' <= n:num ==> ~(a' = n+1)` THEN
            have `ring_ord r (q(a':num):R) p = 0` [ring_ord_prime;RING_ASSOCIATES_SYM] THEN
            specialize_assuming[
              `r:R ring`;
              `q(a':num):R`;
              `p:R`;
              `a:R`
            ]ring_ord_mul THEN
            have `ring_ord r (q(a':num):R) (ring_mul r p a) = ring_ord r (q a') p + ring_ord r (q a') a` [UFD_IMP_INTEGRAL_DOMAIN;ring_prime] THEN
            have `ring_ord r (q(a':num):R) (ring_mul r p a) = 0 + ring_ord r (q a') a` [] THEN
            have `ring_ord r (q(a':num):R) (ring_mul r p a) = ring_ord r (q a') a` [ARITH_RULE `0+e = e`] THEN
            qed[]
          ; pass
          ] THEN
          rw[know `ring_product r (1..n) (\i. ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i) (ring_mul r p a))) = ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)):R`]
        ; pass
        ] THEN
        rw[know `ring_product r (1..n + 1) (\i. ring_pow r (if i = n + 1 then p else q i) (ring_ord r (if i = n + 1 then p else q i) (ring_mul r p a))) = ring_mul r (ring_pow r p (ring_ord r p (ring_mul r p a))) (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))):R`] THEN
        subgoal `ring_ord r p (ring_mul r p a:R) = 1` THENL [
          have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
          have `noetherian_ring r \/ UFD (r:R ring)` [] THEN
          subgoal `ring_ord r p (a:R) = 0` THENL [
            subgoal `ring_ord r p (a:R) = nsum (1..n) (\s. ring_ord r p (ring_pow r (q s) (ring_ord r (q s) a)))` THENL [
              have `FINITE(1..n)` [FINITE_NUMSEG] THEN
              have `!s. s IN 1..n ==> ring_pow r (q s) (ring_ord r (q s) a):R IN ring_carrier r` [RING_POW;ring_prime] THEN
              have `!s. s IN 1..n ==> ~(q s:R = ring_0 r)` [ring_prime] THEN
              subgoal `!s. s IN 1..n ==> ~(ring_pow r (q s) (ring_ord r (q s) a):R = ring_0 r)` THENL [
                intro THEN
                have `~(q(s:num):R = ring_0 r)` [ring_prime] THEN
                have `q(s:num):R IN ring_carrier r` [ring_prime] THEN
                qed[INTEGRAL_DOMAIN_POW_EQ_0]
              ; pass
              ] THEN
              specialize[
                `r:R ring`;
                `p:R`;
                `1..n`;
                `\i:num. ring_pow r (q i) (ring_ord r (q i) a):R`
              ]ring_ord_product THEN
              qed[ring_ord_associates]
            ; pass
            ] THEN
            subgoal `nsum (1..n) (\s. ring_ord r p (ring_pow r (q s) (ring_ord r (q s:R) a))) = nsum (1..n) (\s. 0)` THENL [
              sufficesby NSUM_EQ THEN
              rw[BETA_THM] THEN
              intro THEN
              have `ring_ord r (p:R) (q(x:num)) = 0` [ring_ord_prime] THEN
              have `q(x:num):R IN ring_carrier r` [ring_prime] THEN
              have `~(q(x:num):R = ring_0 r)` [ring_prime] THEN
              specialize[
                `r:R ring`;
                `p:R`;
                `q(x:num):R`;
                `ring_ord r (q(x:num):R) a`
              ]ring_ord_pow THEN
              qed[ARITH_RULE `e*0 = 0`]
            ; pass
            ] THEN
            qed[NSUM_0]
          ; pass
          ] THEN
          specialize_assuming[
            `r:R ring`;
            `p:R`;
            `p:R`;
            `a:R`
          ]ring_ord_mul THEN
          have `ring_ord r (p:R) p = 1` [ring_ord_refl;ring_prime] THEN
          qed[ARITH_RULE `1+0 = 1`;ring_prime]
        ; pass
        ] THEN
        rw[know `ring_ord r (p:R) (ring_mul r p a) = 1`] THEN
        qed[RING_POW_1;RING_ASSOCIATES_MUL;RING_ASSOCIATES_REFL;RING_PRODUCT;RING_POW;ring_prime]
      ]
    ; pass
    ] THEN
    choose `b:num` `b IN 1..n /\ ring_associates r p (q b:R)` [] THEN
    witness `n:num` THEN
    witness `q:num->R` THEN
    intro THENL [
      qed[]
    ;
      have `ring_divides r (q(i:num):R) a` [] THEN
      qed[RING_DIVIDES_LMUL;ring_prime]
    ;
      qed[]
    ;
      subgoal `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) (ring_mul r p a))) = ring_product r (1..n) (\i.  ring_mul r (ring_pow r (q i) (ring_ord r (q i) p)) (ring_pow r (q i) (ring_ord r (q i) a)):R)` THENL [
        sufficesby RING_PRODUCT_EQ THEN
        rw[BETA_THM] THEN
        intro THEN
        have `p:R IN ring_carrier r` [ring_prime] THEN
        have `~(p:R = ring_0 r)` [ring_prime] THEN
        have_rw `ring_ord r (q(a':num):R) (ring_mul r p a) = ring_ord r (q a') p + ring_ord r (q a') a` [ring_ord_mul;UFD_IMP_INTEGRAL_DOMAIN] THEN
        have `q(a':num):R IN ring_carrier r` [ring_prime] THEN
        qed[RING_POW_ADD]
      ; pass
      ] THEN
      rw[know `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) (ring_mul r p a))) = ring_product r (1..n) (\i. ring_mul r (ring_pow r (q i) (ring_ord r (q i) p)) (ring_pow r (q i) (ring_ord r (q i) a))):R`] THEN
      subgoal `ring_product r (1..n) (\i. ring_mul r (ring_pow r (q i) (ring_ord r (q i) p)) (ring_pow r (q i) (ring_ord r (q i) a))) = ring_mul r (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) p))) (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))):R` THENL [
        have `FINITE(1..n)` [FINITE_NUMSEG] THEN
        sufficesby RING_PRODUCT_MUL THEN
        qed[RING_POW;ring_prime]
      ; pass
      ] THEN
      rw[know `ring_product r (1..n) (\i. ring_mul r (ring_pow r (q i) (ring_ord r (q i) p)) (ring_pow r (q i) (ring_ord r (q i) a))) = ring_mul r (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) p))) (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))):R`] THEN
      subgoal `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) p)) = ring_product r (1..n) (\i. if i = b then q b else ring_1 r):R` THENL [
        sufficesby RING_PRODUCT_EQ THEN
        rw[BETA_THM] THEN
        intro THEN
        case `a' = b:num` THENL [
          have `ring_associates r (q(a':num):R) p` [RING_ASSOCIATES_SYM] THEN
          have_rw `ring_ord r (q(a':num):R) p = 1` [ring_ord_prime] THEN
          qed[RING_POW_1;ring_prime]
        ;
          have `~(ring_associates r (q(a':num):R) p)` [RING_ASSOCIATES_SYM;RING_ASSOCIATES_TRANS] THEN
          have_rw `ring_ord r (q(a':num):R) p = 0` [ring_ord_prime] THEN
          qed[RING_POW_0]
        ]
      ; pass
      ] THEN
      rw[know `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) p)) = ring_product r (1..n) (\i. if i = b then q b else ring_1 r):R`] THEN
      subgoal `ring_product r (1..n) (\i. if i = b then q b else ring_1 r) = q b:R` THENL [
        rw[RING_PRODUCT_DELTA] THEN
        qed[ring_prime]
      ; pass
      ] THEN
      rw[know `ring_product r (1..n) (\i. if i = b then q b else ring_1 r) = q b:R`] THEN
      qed[RING_ASSOCIATES_MUL]
    ]
  ]
);;
```
### Informal statement
For any ring `r` that is a UFD, for any element `a` in the carrier of the ring `r` such that `a` is not the zero element of `r`, there exist a natural number `n` and a function `q` from the natural numbers to the carrier of the ring `r` such that the following hold:
1. For all `i` in the range `1` to `n`, `q(i)` is a prime element in `r`.
2. For all `i` in the range `1` to `n`, `q(i)` divides `a` in `r`.
3. For all `i` and `j` in the range `1` to `n`, if `q(i)` and `q(j)` are associates in `r`, then `i` equals `j`.
4. `a` is associate to the product of `q(i)` raised to the power of the order of `q(i)` with respect to `a`, for `i` ranging from `1` to `n` in `r`.

### Informal sketch
The proof proceeds by induction on the number of prime factors of `a`.

- Base Case: If `a` has no prime factors, which means `a` is a unit then `n=0` . In this case, the product over the empty range `1..0` is the ring identity `ring_1 r`. Because `a` is a unit and `ring_1 r` is also a unit. Therefore `a` and `ring_1 r` are associates.
- Inductive Step: Assume the theorem is true for all elements with fewer prime factors than `a`. Since `a` is not zero, it has at least one prime factor `p`.

  - Case 1: `p` is not associate to `q(i)` for all `i` in `1..n`.
    - We can then extend the range of the function `q` to `1..n+1` by defining `q(n+1) = p`. This means `q(n+1)` is a prime, and `q(n+1)` divides `ring_mul r p a`. We prove that if `i = n+1` and `j` in `(1..n+1)` then `q(i)` is associate to `q(j)` implies `i = j`. Also, `a * p` is associate to the product from `1` to `n+1` of `q(i)` raised to the power of the `ring_ord r` of `q(i)` in `ring_mul r p a`.

  - Case 2: `p` is associate to `q(b)` for some `b` in `1..n`.
    - Since `q(b)` is an associate to `p`, can be assumed to equal to `p`, we proceed to demonstrate the properties described in the statement.
    - Use the inductive hypothesis that there exist `n` and `q` such that: `ring_associates r (ring_mul r p a) (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) (ring_mul r p a))))`
    - Show that `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))` is associate to `ring_mul r p a`.

### Mathematical insight
This theorem formalizes the fundamental theorem of arithmetic for UFDs by showing that an element in a UFD can be uniquely represented (up to associates) as a product of prime powers. The function `ring_ord r p a` returns the "order" of a prime `p` in the prime factorization of `a`, i.e. the exponent.

### Dependencies
- `UFD`
- `UFD_PRIME_FACTOR_INDUCT`
- `RING_ASSOCIATES_1`
- `RING_MUL_RZERO`
- `ring_prime`
- `ring_divides`
- `IN_NUMSEG`
- `ARITH_RULE`
- `RING_PRODUCT_CLAUSES`
- `EMPTY`
- `IN_ELIM_THM`
- `RING_ASSOCIATES_SYM`
- `RING_MUL`
- `RING_DIVIDES_LMUL`
- `BETA_THM`
- `FINITE_NUMSEG`
- `RING_POW`
- `ring_product_delete`
- `EXTENSION`
- `IN_DELETE`
- `UFD_IMP_INTEGRAL_DOMAIN`
- `ring_ord_prime`
- `ring_ord_mul`
- `INTEGRAL_DOMAIN_POW_EQ_0`
- `ring_ord_product`
- `ring_ord_associates`
- `NSUM_EQ`
- `ring_ord_pow`
- `NSUM_0`
- `ring_ord_refl`
- `RING_POW_1`
- `RING_ASSOCIATES_MUL`
- `RING_ASSOCIATES_REFL`
- `RING_PRODUCT`
- `RING_ASSOCIATES_TRANS`
- `RING_PRODUCT_DELTA`

### Porting notes (optional)
- The proof relies heavily on manipulation of finite sets and arithmetic reasoning, so the target proof assistant should have good automation for these domains.
- Handling of associates and uniqueness might require explicit reasoning in some proof assistants.


---

## primefact_ord

### Name of formal statement
primefact_ord

### Type of the formal statement
theorem

### Formal Content
```ocaml
let primefact_ord = prove(`
  !(r:R ring) a.
  UFD r ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  (?n q.
    (!i. i IN (1..n) ==> ring_prime r (q i)) /\
    (!i. i IN (1..n) ==> ring_divides r (q i) a) /\
    (!i j. i IN (1..n) ==> j IN (1..n) ==> ring_associates r (q i) (q j) ==> i = j) /\
    ring_associates r a (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)))
  )
`,
  simp[primefact_ord_waterfall]
);;
```
### Informal statement
For all rings `r` that are unique factorization domains, and for all `a` in the carrier of `r` such that `a` is not the zero element of `r`, there exists a natural number `n` and a function `q` from the interval `1..n` to the carrier of `r` such that:
1.  for all `i` in `1..n`, `q i` is a prime element of `r`,
2.  for all `i` in `1..n`, `q i` divides `a` in `r`,
3.  for all `i` and `j` in `1..n`, if `q i` is associate to `q j` in `r`, then `i = j`, and
4.  `a` is associate to the product of `ring_pow r (q i) (ring_ord r (q i) a)` for `i` ranging from `1` to `n` in `r`.

### Informal sketch
The theorem states that in a unique factorization domain, every non-zero element can be expressed as a product of powers of primes, where the primes are unique up to association, and where the exponent of each prime is the order of that prime in the element.

The proof strategy is encapsulated in `simp[primefact_ord_waterfall]`. Based on name, it is likely a simplification tactic that unfolds definitions and applies rewrite rules, possibly in a cascade or waterfall fashion, to reduce the goal to a simpler, provable form. It's likely this waterfall tactic combines multiple simplification and rewriting steps related to unique factorization, primality, divisibility, orders, and products in rings. The key steps might involve:

- Unfolding the definition of `UFD`.
- Decomposing `a` into prime factors.
- Showing the uniqueness of the prime factors up to association.
- Relating the exponents of the prime factors to the order function `ring_ord`.
- Constructing the `n` and `q` as claimed in the theorem.

### Mathematical insight
This theorem formalizes the fundamental property of unique factorization domains: elements can be uniquely factored into primes (up to associates). This property is crucial for many algebraic constructions and proofs. The theorem connects the abstract notion of a UFD with concrete divisibility properties and the `ring_ord` function, which measures the "power to which a prime divides an element".

### Dependencies
-  `UFD`
- `ring_carrier`
- `ring_0`
-  `ring_prime`
- `ring_divides`
-  `ring_associates`
- `ring_product`
- `ring_pow`
- `ring_ord`
- `primefact_ord_waterfall`

### Porting notes (optional)
- The `primefact_ord_waterfall` tactic is heavily used here. When porting this statement, it may be necessary to decompose `primefact_ord_waterfall` into smaller, more manageable tactics or rewrite rules.
- Ensure that the target proof assistant has suitable definitions for the ring operations (addition, multiplication, zero, one, etc.), divisibility, association, primality, power, unique factorization domains, and the order of a prime in an element.
- The concept of 'associates' is crucial in UFD. Ensure that the target proof assistant has a suitable definition for associates.


---

## primefact_divides

### Name of formal statement
primefact_divides

### Type of the formal statement
theorem

### Formal Content
```ocaml
let primefact_divides = prove(`
  !(r:R ring) n q e b.
  UFD r ==>
  (!i. i IN 1..n ==> ring_prime r (q i)) ==>
  (!i j. i IN 1..n ==> j IN (1..n) ==> ring_associates r (q i) (q j) ==> i = j) ==>
  b IN ring_carrier r ==>
  ~(b = ring_0 r) ==>
  (!i. i IN 1..n ==> e i <= ring_ord r (q i) b) ==>
  ring_divides r (
    ring_product r (1..n) (\i. ring_pow r (q i) (e i))
  ) b
`,
  intro THEN
  have `FINITE(1..n)` [FINITE_NUMSEG] THEN
  have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
  have `!i. i IN 1..n ==> ring_divides r (ring_pow r (q i) (e i)) (b:R)` [divides_le_pow_ring_ord] THEN
  subgoal `!i j. i IN 1..n ==> j IN 1..n ==> ~(i = j) ==> ring_coprime r (ring_pow r (q i:R) (e i),ring_pow r (q j) (e j))` THENL [
    intro THEN
    proven_if `ring_coprime r (q(i:num):R,q j)` [ring_coprime_lrpow] THEN
    qed[ring_coprime_associates_prime]
  ; pass
  ] THEN
  specialize_assuming[
    `r:R ring`;
    `\i:num. ring_pow r (q i) (e i):R`;
    `b:R`;
    `1..n`
  ]ring_product_divides_if_coprime THEN
  qed[]
);;
```

### Informal statement
Assume `r` is a UFD ring. Suppose we have `n` prime elements `q i` for `i` from `1` to `n`. Assume that for `i` and `j` in `1..n`, `q i` and `q j` are associates if and only if `i = j`. Let `b` be an element of the ring carrier of `r` such that `b` is not the zero element of the ring `r`. If for each `i` from `1` to `n`, the exponent `e i` is less than or equal to the ring order of `q i` with respect to `b`, then the product of `q i` raised to the power of `e i` for `i` from `1` to `n` divides `b` in ring `r`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Show that the set `1..n` is finite using `FINITE_NUMSEG`.
- Show that the ring `r` is an integral domain because `UFD r` using `UFD_IMP_INTEGRAL_DOMAIN`.
- Show that for each `i` in the range `1..n`, `ring_pow r (q i) (e i)` divides `b` using `divides_le_pow_ring_ord`.
- Prove that for any distinct indices `i` and `j` in `1..n`, the powers `ring_pow r (q i) (e i)` and `ring_pow r (q j) (e j)` are coprime.
  - Introduce assumptions.
  - Prove `ring_coprime r (q(i:num):R,q j)` using `ring_coprime_lrpow`
  - QED with `ring_coprime_associates_prime`
- Apply `ring_product_divides_if_coprime` to conclude that the product `ring_product r (1..n) (\i. ring_pow r (q i) (e i))` divides `b`.

### Mathematical insight
This theorem formalizes the condition under which a product of prime powers divides an element `b` in a UFD. The exponents of the prime factors in the product must be less than or equal to their respective orders with respect to `b`. The coprimality condition ensures that distinct prime powers contribute independently to the divisor. This result is a cornerstone in understanding factorization properties in UFDs.

### Dependencies
- `UFD`
- `FINITE_NUMSEG`
- `UFD_IMP_INTEGRAL_DOMAIN`
- `divides_le_pow_ring_ord`
- `ring_coprime_lrpow`
- `ring_coprime_associates_prime`
- `ring_product_divides_if_coprime`

### Porting notes (optional)
- The definition and use of the ring order `ring_ord` is crucial. Make sure this concept is available, or derive a suitable alternative which is equivalent to exponent of prime in the prime factorization.
- The exact properties of `ring_associates` and `ring_prime` may differ between proof assistants, but the underlying principle of unique factorization should be portable.
- The coprimality subgoals may require adapting tactic scripts based on the target proof assistant's automation for ring theory.


---

## ring_ord_divides_eq

### Name of formal statement
ring_ord_divides_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_divides_eq = prove(`
  !(r:R ring) a b.
  UFD r ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  b IN ring_carrier r ==>
  ~(b = ring_0 r) ==>
  ( ring_divides r a b <=>
    (!p. ring_prime r p ==>
         ring_ord r p a <= ring_ord r p b
    )
  )
`,
  intro_gendisch THEN
  splitiff THENL [
    qed[ring_ord_divides;UFD_IMP_INTEGRAL_DOMAIN]
  ;
    specialize[`r:R ring`;`a:R`]primefact_ord THEN
    intro THEN
    choose2 `n:num` `q:num->R` `(!i. i IN (1..n) ==> ring_prime r (q i:R)) /\ (!i j. i IN (1..n) ==> j IN (1..n) ==> ring_associates r (q i) (q j) ==> i = j) /\ ring_associates r a (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)))` [primefact_ord] THEN
    specialize_assuming[
      `r:R ring`;
      `n:num`;
      `q:num->R`;
      `\i:num. ring_ord r (q i) (a:R)`;
      `b:R`
    ]primefact_divides THEN
    subgoal `!i. i IN 1..n ==> ring_ord r (q i:R) a <= ring_ord r (q i) b` THENL [
      intro THEN
      have `ring_prime r (q(i:num):R)` [] THEN
      qed[]
    ; pass
    ] THEN
    have `ring_divides r (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))) (b:R)` [] THEN
    qed[RING_ASSOCIATES_DIVIDES;RING_ASSOCIATES_REFL]
  ]
);;
```
### Informal statement
Given a ring `r` that is a unique factorization domain (UFD), and elements `a` and `b` in the carrier of `r` that are not equal to the zero element of `r`, then `a` divides `b` in `r` if and only if for all prime elements `p` in `r`, the ring order of `p` in `a` is less than or equal to the ring order of `p` in `b`.

### Informal sketch
The proof proceeds by showing implication in both directions, given that `r` is a UFD and `a` and `b` are non-zero elements of the ring.

*   **Forward direction (=>):** Assume `ring_divides r a b`. The goal is to show that for all primes `p` in `r`, the ring order of `p` in `a` is less than or equal to the ring order of `p` in `b`. This follows directly by using the theorem `ring_ord_divides` and `UFD_IMP_INTEGRAL_DOMAIN`.

*   **Reverse direction (<=):** Assume that for all primes `p` in `r`, the ring order of `p` in `a` is less than or equal to the ring order of `p` in `b`. The goal is to show that `ring_divides r a b`.
    *   First, use `primefact_ord` to decompose `a` into a product of prime powers. Introduce the number of prime factors `n` and the function `q` which maps indices to prime elements.
    *   Then, instantiate `primefact_divides` with appropriate parameters. This theorem states that given such a prime factorization of an element and that the order of `q i` in `a` is at most the ring order of `q i` in `b` for all `i`, then `a` divides `b`.
    *   To apply `primefact_divides`, a subgoal is generated that verifies the order condition `ring_ord r (q i) a <= ring_ord r (q i) b` holds for all `i` in `1..n`, which follows from the initial main assumption.
    *   Show that `ring_divides r (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))) b` using `primefact_divides`.
    *   Finally conclude using `RING_ASSOCIATES_DIVIDES` and `RING_ASSOCIATES_REFL`.

### Mathematical insight
This theorem formalizes the fundamental idea that in a UFD, divisibility can be characterized by comparing the exponents of the prime factors of the two elements. It essentially says that `a` divides `b` if and only if the prime factorization of `a` is "contained" in the prime factorization of `b`. The ring order `ring_ord` captures the exponent of each prime factor.

### Dependencies
- `ring_ord_divides`
- `UFD_IMP_INTEGRAL_DOMAIN`
- `primefact_ord`
- `primefact_divides`
- `RING_ASSOCIATES_DIVIDES`
- `RING_ASSOCIATES_REFL`

### Porting notes (optional)
The theorem relies heavily on the prime factorization properties that hold in UFDs. Ensure that the target proof assistant has similar theorems or equivalent definitions for prime factorization and ring order. The `primefact_ord` and `primefact_divides` appear to be crucial lemmata; their equivalent should be found in other formalizations of UFDs.


---

## ring_ord_associates_eq

### Name of formal statement
ring_ord_associates_eq

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_associates_eq = prove(`
  !(r:R ring) a b.
  UFD r ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  b IN ring_carrier r ==>
  ~(b = ring_0 r) ==>
  ( ring_associates r a b <=>
    (!p. ring_prime r p ==>
         ring_ord r p a = ring_ord r p b
    )
  )
`,
  rw[ring_associates] THEN
  simp[ring_ord_divides_eq] THEN
  intro THEN
  splitiff THENL [
    intro THEN
    have `ring_ord r (p:R) a <= ring_ord r p b` [] THEN
    have `ring_ord r (p:R) b <= ring_ord r p a` [] THEN
    ASM_ARITH_TAC
  ;
    intro THENL [
      have `ring_ord r (p:R) a = ring_ord r p b` [] THEN
      ASM_ARITH_TAC
    ;
      have `ring_ord r (p:R) a = ring_ord r p b` [] THEN
      ASM_ARITH_TAC
    ]
  ]
);;
```
### Informal statement
For any ring `r` that is a unique factorization domain (UFD), and for any non-zero elements `a` and `b` in the carrier of the ring `r`, `a` and `b` are associates in `r` if and only if for every prime element `p` in `r`, the ring order of `p` in `a` is equal to the ring order of `p` in `b`.

### Informal sketch
The proof proceeds as follows:
- Start by rewriting the definition of `ring_associates`.
- Simplify using the relationship between `ring_ord` and divisibility (`ring_ord_divides_eq`).
- Introduce the universally quantified variables.
- Split the if-and-only-if statement into two implications.
- For the first implication (associates implies equal orders), assume `ring_associates r a b` and prove that `ring_ord r p a = ring_ord r p b` for all prime `p`. This involves showing that the ring order of `p` in `a` is less than or equal to the ring order of `p` in `b` and vice versa.
- For the second implication (equal orders implies associates), assume that `ring_ord r p a = ring_ord r p b` for all prime `p`, and show that `ring_associates r a b` holds, using arithmetic tactics.

### Mathematical insight
This theorem provides a characterization of associates in a UFD in terms of the ring order of prime elements.  Two elements are associates if and only if they have the same "prime factorization" up to a unit, and this is what is captured by having the same `ring_ord` with respect to every prime element.  This is important because `ring_ord` provides a way to measure the "divisibility" of an element by a prime without directly reasoning about factorization.

### Dependencies

#### Theorems
- `ring_associates`
- `ring_ord_divides_eq`


---

## lcm_exists

### Name of formal statement
lcm_exists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let lcm_exists = prove(`
  !(r:R ring) a b.
  UFD r ==>
  a IN ring_carrier r ==>
  b IN ring_carrier r ==>
  ?c. (
    c IN ring_carrier r /\
    ring_divides r a c /\
    ring_divides r b c /\
    (!d. d IN ring_carrier r ==>
         ring_divides r a d ==>
         ring_divides r b d ==>
         ring_divides r c d
    )
  )
`,
  intro THEN
  have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
  case `a = ring_0(r:R ring)` THENL [
    witness `ring_0(r:R ring)` THEN
    qed[RING_DIVIDES_0;RING_0;RING_DIVIDES_ZERO]
  ; pass
  ] THEN
  case `b = ring_0(r:R ring)` THENL [
    witness `ring_0(r:R ring)` THEN
    qed[RING_DIVIDES_0;RING_0;RING_DIVIDES_ZERO]
  ; pass
  ] THEN
  have `ring_divides r (ring_gcd r (a,b)) (a:R)` [RING_GCD_DIVIDES] THEN
  have `~(ring_gcd r (a,b):R = ring_0 r)` [RING_DIVIDES_ZERO] THEN
  have `ring_gcd r (a,b):R IN ring_carrier r` [RING_GCD] THEN
  choose `u:R` `u:R IN ring_carrier r /\ a = ring_mul r (ring_gcd r (a,b)) u` [ring_divides;RING_GCD] THEN
  have `~(u:R = ring_0 r)` [RING_MUL_RZERO] THEN
  have `ring_divides r (ring_gcd r (a,b)) (b:R)` [RING_GCD_DIVIDES] THEN
  choose `v:R` `v:R IN ring_carrier r /\ b = ring_mul r (ring_gcd r (a,b)) v` [ring_divides;RING_GCD] THEN
  have `~(v:R = ring_0 r)` [RING_MUL_RZERO] THEN
  subgoal `ring_mul r u (b:R) = ring_mul r a v` THENL [
    have `ring_mul r (ring_gcd r (a,b)) v = b:R` [] THEN
    have `ring_mul r (ring_gcd r (a,b)) u = a:R` [] THEN
    RING_TAC
  ; pass
  ] THEN
  witness `ring_mul r u b:R` THEN
  intro THENL [
    qed[RING_MUL]
  ;
    rw[ring_divides] THEN
    intro THENL [
      qed[]
    ;
      qed[RING_MUL]
    ;
      witness `v:R` THEN
      qed[]
    ]
  ;
    rw[ring_divides] THEN
    intro THENL [
      qed[]
    ;
      qed[RING_MUL]
    ;
      witness `u:R` THEN
      qed[RING_MUL_SYM]
    ]
  ;
    have `ring_mul r u b:R IN ring_carrier r` [RING_MUL] THEN
    proven_if `d = ring_0 r:R` [RING_DIVIDES_0] THEN
    have `~(ring_mul r u b:R = ring_0 r)` [integral_domain] THEN
    specialize[
      `r:R ring`;
      `ring_mul r u b:R`;
      `d:R`
    ]ring_ord_divides_eq THEN
    rw[know `ring_divides r (ring_mul r u b:R) d <=> (!p. ring_prime r p ==> ring_ord r p (ring_mul r u b) <= ring_ord r p d)`] THEN
    intro THEN
    have `ring_ord r (p:R) (ring_gcd r (a,b)) = MIN (ring_ord r p a) (ring_ord r p b)` [ring_ord_gcd] THEN
    case `ring_ord r p (a:R) <= ring_ord r p b` THENL [
      have_rw `ring_ord r p (ring_mul r u b:R) = ring_ord r p u + ring_ord r p b` [ring_ord_mul] THEN
      have `ring_ord r p (ring_gcd r (a,b):R) = ring_ord r p a` [MIN] THEN
      subgoal `ring_ord r p a = ring_ord r p (ring_gcd r (a,b)) + ring_ord r p (u:R)` THENL [
        specialize_assuming[
          `r:R ring`;
          `p:R`;
          `ring_gcd r (a,b):R`;
          `u:R`
        ]ring_ord_mul THEN
        qed[]
      ; pass
      ] THEN
      num_linear_fact `ring_ord r (p:R) (ring_gcd r (a,b)) = ring_ord r p a ==> ring_ord r p a = ring_ord r p (ring_gcd r (a,b)) + ring_ord r p u ==> ring_ord r p u = 0` THEN
      rw[know `ring_ord r p (u:R) = 0`] THEN
      rw[ARITH_RULE `0+e = e`] THEN
      have `ring_ord r p (b:R) <= ring_ord r p d` [ring_ord_divides] THEN
      qed[]
    ;
      rw[know `ring_mul r u b = ring_mul r a v:R`] THEN
      have_rw `ring_ord r p (ring_mul r a v:R) = ring_ord r p a + ring_ord r p v` [ring_ord_mul] THEN
      have `ring_ord r p (ring_gcd r (a,b):R) = ring_ord r p b` [MIN] THEN
      subgoal `ring_ord r p b = ring_ord r p (ring_gcd r (a,b)) + ring_ord r p (v:R)` THENL [
        specialize_assuming[
          `r:R ring`;
          `p:R`;
          `ring_gcd r (a,b):R`;
          `v:R`
        ]ring_ord_mul THEN
        qed[]
      ; pass
      ] THEN
      num_linear_fact `ring_ord r (p:R) (ring_gcd r (a,b)) = ring_ord r p b ==> ring_ord r p b = ring_ord r p (ring_gcd r (a,b)) + ring_ord r p v ==> ring_ord r p v = 0` THEN
      rw[know `ring_ord r p (v:R) = 0`] THEN
      rw[ARITH_RULE `e+0 = e`] THEN
      have `ring_ord r p (a:R) <= ring_ord r p d` [ring_ord_divides] THEN
      qed[]
    ]
  ]
);;
```

### Informal statement
For any ring `r` that is a unique factorization domain, and for any elements `a` and `b` in the carrier of `r`, there exists an element `c` such that `c` is in the carrier of `r`, `a` divides `c`, `b` divides `c`, and for any element `d` in the carrier of `r`, if `a` divides `d` and `b` divides `d`, then `c` divides `d`.

### Informal sketch
The proof demonstrates the existence of a least common multiple (LCM) for elements `a` and `b` in a unique factorization domain (UFD) `r`.

- First, the proof handles the cases where `a` or `b` is the ring zero, in which case the LCM is `ring_0(r)`.
- If neither `a` nor `b` is zero, the proof considers the greatest common divisor (GCD) of `a` and `b`, denoted as `ring_gcd r (a, b)`.
- It then chooses elements `u` and `v` such that `a = ring_mul r (ring_gcd r (a, b)) u` and `b = ring_mul r (ring_gcd r (a, b)) v`.
- Next, we aim to demonstrate that `ring_mul r u b` is a valid least common multiple. This involves showing that `a` divides `ring_mul r u b` and `b` divides `ring_mul r u b` and that `ring_mul r u b` divides any common multiple `d`.
- It's shown that `ring_mul r u b = ring_mul r a v`, which helps connect the divisibility properties.
- Finally, to prove that `ring_mul r u b` divides `d` whenever `a` and `b` both divide `d`, we consider the prime factorization of all elements. Using the property `ring_ord_divides_eq`, divisibility in UFDs is characterized by an inequality on the prime exponents (`ring_ord r p x <= ring_ord r p y` whenever `x` divides `y`). This step exploits the relationship between the valuations (orders) of primes in the UFD.

### Mathematical insight
This theorem formalizes the existence of the least common multiple in a unique factorization domain. The LCM construction and its divisibility property are essential for many algebraic manipulations and number-theoretic arguments in UFDs.

### Dependencies
- `UFD_IMP_INTEGRAL_DOMAIN`
- `RING_DIVIDES_0`
- `RING_0`
- `RING_DIVIDES_ZERO`
- `RING_GCD_DIVIDES`
- `RING_GCD`
- `ring_divides`
- `RING_MUL_RZERO`
- `RING_MUL`
- `integral_domain`
- `ring_ord_divides_eq`
- `ring_ord_gcd`
- `ring_ord_mul`


---

## lcm_set_exists

### Name of formal statement
- lcm_set_exists

### Type of the formal statement
- theorem

### Formal Content
- The full HOL Light statement will be inserted here **after generation**.
```ocaml
let lcm_set_exists = prove(`
  !(r:R ring) a S.
  FINITE S ==>
  UFD r ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  ?c. (
    c IN ring_carrier r /\
    (!s. s IN S ==> ring_divides r (a s) c) /\
    (!d. d IN ring_carrier r ==>
         (!s. s IN S ==> ring_divides r (a s) d) ==>
         ring_divides r c d
    )
  )
`,
  GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    witness `ring_1 r:R` THEN
    rw[EMPTY;IN_ELIM_THM;RING_1;RING_DIVIDES_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    choose `b:R` `b:R IN ring_carrier r /\ (!s:X. s IN S ==> ring_divides r (a s) b) /\ (!d. d IN ring_carrier r ==> (!s. s IN S ==> ring_divides r (a s) d) ==> ring_divides r b d)` [] THEN
    specialize_assuming[
      `r:R ring`;
      `a(x:X):R`;
      `b:R`
    ]lcm_exists THEN
    choose `c:R` `c:R IN ring_carrier r /\ ring_divides r (a(x:X)) c /\ ring_divides r b c /\ (!d. d IN ring_carrier r ==> ring_divides r (a x) d ==> ring_divides r b d ==> ring_divides r c d)` [] THEN
    witness `c:R` THEN
    intro THENL [
      qed[]
    ;
      proven_if `s = x:X` [] THEN
      set_fact `~(s = x:X) ==> s IN x INSERT S ==> s IN S` THEN
      qed[RING_DIVIDES_TRANS]
    ;
      qed[]
    ]
  ]
);;
```
### Informal statement
- For any ring `r` with ring operations denoted by `R`, any universally quantified variable `a` (function or mapping) over a domain `X`, and set `S`, if `S` is finite and `r` is a unique factorization domain and for all `s` in `S`, `a s` is in the carrier of the ring `r`, then there exists `c` such that `c` is in the carrier of the ring `r` and for all `s` in `S`, `a s` divides `c` according to the ring `r`'s division, and for all `d` in the carrier of the ring `r`, if for all `s` in `S`, `a s` divides `d` according to the ring `r`'s division, then `c` divides `d` according to the ring `r`'s division.

### Informal sketch
- The proof proceeds by strong induction on the finiteness of the set `S`.
  - Base case: `S` is empty. We choose `ring_1 r` as the least common multiple, and show that `ring_1 r` satisfies the required properties, since every element divides the ring unit.
  - Inductive step: Assume the theorem holds for all subsets of size less than the size of `x INSERT S`. That is, we assume there exists a least common multiple `b` for `S`. We want to prove the theorem for `x INSERT S`.
    - Apply the already proven theorem `lcm_exists` (which asserts the existence of an LCM of two elements in a UFD) to `a x` and `b`. Thus there exists `c` in the carrier such that `a x` divides `c` and `b` divides `c`, and `c` divides any `d` that is divisible by both `a x` and `b`.
    - Then `c` is the LCM of `a x` INSERT `S`.
    - The condition that every `a s` (for `s` in `x INSERT S`) divides `c` is shown by considering two cases: when `s = x`, then `a x` divides `c` by assumption. Otherwise, If `s` is in `x INSERT S` and `s` is not equal to `x`, then `s` is in `S`, thus `a s` divides `b`, and `b` divides `c`, so `a s` divides `c` transitively.
    - The condition that `c` divides any other common multiple `d` is shown by assumption on `c`.

### Mathematical insight
- This theorem proves the existence of the least common multiple for a finite set of elements in a unique factorization domain. It is a generalization of the theorem that demonstrates the existence of the least common multiple of two elements in a UFD. This is a fundamental result in abstract algebra, enabling reasoning about divisibility and factorization in UFDs.

### Dependencies
- Ring Theory
  - `ring`
  - `R`
  - `ring_carrier`
  - `ring_divides`
  - `ring_1`
- Set Theory
  - `FINITE`
  - `IN`
  - `INSERT`
  - `EMPTY`
  - `IN_ELIM_THM`
- Other
  - `UFD`
  - `lcm_exists`
  - `RING_DIVIDES_1`
  - `RING_DIVIDES_TRANS`

### Porting notes (optional)
- The proof proceeds by induction on a finite set. The definition of `FINITE` and induction principles might vary between systems, and the induction tactic `FINITE_INDUCT_STRONG` may need to be rewritten using similar principles from the target system.
- The theorem `lcm_exists` needs to be ported first, as it establishes the basis for finding the LCM of two elements in a UFD, which is then extended to a finite set in the current theorem.


---

## lcm_set_units

### Name of formal statement
lcm_set_units

### Type of the formal statement
theorem

### Formal Content
```ocaml
let lcm_set_units = prove(`
  !(r:R ring) a S c.
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  (!d. d IN ring_carrier r ==>
       (!s. s IN S ==> ring_divides r (a s) d) ==>
       ring_divides r c d
  ) ==>
  (!s. s IN S ==> ring_unit r (a s)) ==>
  ring_unit r c
`,
  intro THEN
  have `!s:X. s IN S ==> ring_divides r (a s) (ring_1 r:R)` [RING_UNIT_DIVIDES] THEN
  have `ring_divides r (c:R) (ring_1 r)` [RING_1] THEN
  qed[RING_UNIT_DIVIDES]
);;
```
### Informal statement
For any ring `r` (with carrier set `R`), any function `a` from a type `X` to the carrier set of `r`, any set `S` of type `X`, and any `c` in the carrier set of `r`, given that:
1. For all `s` in `S`, `a s` is in the carrier set of `r`, and
2. If for all `d` in the carrier set of `r`, divisibility of `d` by all `a s` for `s` in `S` implies divisibility of `d` by `c`, and
3. For all `s` in `S`, `a s` is a unit in the ring `r`,
then `c` is a unit in the ring `r`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses.
- By hypothesis, for all `s` in `S`, `a s` is a ring unit. Apply `RING_UNIT_DIVIDES` to show that for all `s` in `S`, `a s` divides `ring_1 r`.
- Since for all `d` in the carrier set of `r`, divisibility of `d` by all `a s` for `s` in `S` implies divisibility of `d` by `c`, instantiate `d` with `ring_1 r`. Thus, divisibility of `ring_1 r` by all `a s` for `s` in `S` implies divisibility of `ring_1 r` by `c`.
- Then, `ring_divides r c (ring_1 r)` follows. Apply `RING_1`, which states that if `c` divides the ring's multiplicative identity `ring_1 r` then `c` is a ring unit `ring_unit r c`.

### Mathematical insight
This theorem essentially states that if a set of elements are all units in a ring, and their "least common multiple" (defined through divisibility) exists in the ring and is equal to `c`, then `c` must also be a unit. The divisibility condition serves as a definition for what we might intuitively consider the LCM. The ring must be specified in each divisibility claim.

### Dependencies
- `RING_UNIT_DIVIDES`
- `RING_1`


---

## zero_lcm_set

### Name of formal statement
zero_lcm_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_lcm_set = prove(`
  !(r:R ring) a S c.
  integral_domain r ==>
  FINITE S ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  c IN ring_carrier r ==>
  (!s. s IN S ==> ring_divides r (a s) c) ==>
  (!d. d IN ring_carrier r ==>
       (!s. s IN S ==> ring_divides r (a s) d) ==>
       ring_divides r c d
  ) ==>
  ( c = ring_0 r <=>
    ( ?s. s IN S /\ a s = ring_0 r )
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    def `d:R` `ring_product r S (a:X->R)` THEN
    have `d:R IN ring_carrier r` [RING_PRODUCT] THEN
    have `!s:X. s IN S ==> ring_divides r (a s:R) d` [ring_divides_product] THEN
    have `ring_divides r c (d:R)` [] THEN
    have `d = ring_0 r:R` [RING_DIVIDES_ZERO] THEN
    qed[INTEGRAL_DOMAIN_PRODUCT_EQ_0]
  ;
    qed[RING_DIVIDES_ZERO]
  ]
);;
```
### Informal statement
In an integral domain `r` with ring carrier `ring_carrier r`, given a finite set `S` and a function `a` mapping elements of `S` into `ring_carrier r`, and an element `c` in `ring_carrier r` such that `c` is a common multiple of all `a s` for `s` in `S` (i.e., `a s` divides `c` for all `s` in `S`), and `c` is a least common multiple of all `a s` for `s` in `S` (i.e., for any `d` in `ring_carrier r`, if `a s` divides `d` for all `s` in `S`, then `c` divides `d`), then `c` is zero if and only if at least one of the `a s` is zero for some `s` in `S`.

### Informal sketch

The proof proceeds by showing the equivalence.

*   **Forward direction:** Assume `c` is zero. Define `d` as the product of the `a s` for `s` in `S` using `ring_product r S a`. Show that `d` is in `ring_carrier r` because `ring_product` returns an element in `ring_carrier`. By `ring_divides_product`, each `a s` divides `d`. By the assumption that `c` is a least common multiple, `c` divides `d`. Since `c` is zero, `d` must also be zero by `RING_DIVIDES_ZERO`. Since the ring is an integral domain, the product `d` can only be zero if at least one of its factors `a s` is zero for some `s` in `S` (`INTEGRAL_DOMAIN_PRODUCT_EQ_0`).
*   **Backward direction:** Assume there exists an `s` in `S` such that `a s` is zero. Since `a s` divides `c` for all `s` in `S`, and `a s` is zero for some `s`, it follows that zero divides `c`. Therefore by `RING_DIVIDES_ZERO`, `c` must be zero.

### Mathematical insight
The theorem relates the least common multiple of a set of ring elements to the existence of zero elements within that set, in the context of an integral domain. It essentially states that the least common multiple is zero if and only if one of the elements in the set is zero. This is important when reasoning about divisibility and factorization in integral domains.

### Dependencies
*   Definitions: `ring_product`, `ring_carrier`, `ring_divides`, `ring_0`, `FINITE`, `integral_domain`
*   Theorems: `INTEGRAL_DOMAIN_PRODUCT_EQ_0`, `RING_DIVIDES_ZERO`, `ring_divides_product`


---

## zero_lcm

### Name of formal statement
zero_lcm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_lcm = prove(`
  !(r:R ring) a b.
  integral_domain r ==>
  ring_divides r a c ==>
  ring_divides r b c ==>
  (!d. d IN ring_carrier r ==>
       ring_divides r a d ==>
       ring_divides r b d ==>
       ring_divides r c d
  ) ==>
  ( c = ring_0 r <=>
    ( a = ring_0 r \/ b = ring_0 r )
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    def `d:R` `ring_mul r a b:R` THEN
    have `d:R IN ring_carrier r` [RING_MUL;ring_divides] THEN
    have `ring_divides r (a:R) d` [ring_divides] THEN
    have `ring_divides r (b:R) d` [ring_divides;RING_MUL_SYM] THEN
    have `ring_divides r c (d:R)` [] THEN
    have `d = ring_0 r:R` [RING_DIVIDES_ZERO] THEN
    qed[integral_domain;ring_divides]
  ;
    qed[RING_DIVIDES_ZERO]
  ]
);;
```

### Informal statement
For any integral domain `r` with carrier set `ring_carrier r` and ring zero `ring_0 r`, and for any elements `a`, `b`, and `c` in `r`, if `a` divides `c` and `b` divides `c`, and if for all `d` in `ring_carrier r`, `a` divides `d` and `b` divides `d` implies `c` divides `d`, then `c` is equal to `ring_0 r` if and only if `a` is equal to `ring_0 r` or `b` is equal to `ring_0 r`.

### Informal sketch
The proof proceeds by showing the equivalence using `splitiff`, which separates the proof into two directions:

*   **Forward direction:** Assume `c` is `ring_0 r`. Assume that `a` divides `c` and `b` divides `c`, and for all `d` in `ring_carrier r`, `a` divides `d` and `b` divides `d` implies `c` divides `d`. The goal is to demonstrate `a = ring_0 r` or `b = ring_0 r`.
    *   Define `d` as `ring_mul r a b`. Show that `d` is in `ring_carrier r` and that `a` divides `d` and `b` divides `d`, hence `c` divides `d`. The goal is to prove that `d = ring_0 r`.
    *   Since `c` is `ring_0 r`, it follows that `d = ring_0 r`. Since the ring is an integral domain, `a = ring_0 r` or `b = ring_0 r`.

*   **Backward direction:** Assume `a` or `b` is `ring_0 r`, show that `c = ring_0 r`.
    *   Since `a` divides `c` and `a = ring_0 r`, and from the property `RING_DIVIDES_ZERO` which states that `ring_0 r` only divides `ring_0 r`, it follows that `c = ring_0 r`. Similarly, if `b = ring_0 r` and `b` divides `c`, then `c = ring_0 r`.

### Mathematical insight
This theorem states that if `c` is the least common multiple (LCM) of `a` and `b`, then `c` is zero if and only if at least one of `a` or `b` is zero, over an integral domain. The LCM is zero only when either factor is zero. This holds because the ring is an integral domain, so `a * b = 0` implies `a = 0` or `b = 0`.

### Dependencies
*   Definitions: `integral_domain`, `ring_carrier`, `ring_0`, `ring_divides`, `ring_mul`
*   Theorems: `RING_DIVIDES_ZERO`, `RING_MUL`, `RING_MUL_SYM`


---

## ring_ord_lcm_set

### Name of formal statement
ring_ord_lcm_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_lcm_set = prove(`
  !(r:R ring) a S c p t.
  UFD r ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  c IN ring_carrier r ==>
  (!s. s IN S ==> ring_divides r (a s) c) ==>
  (!d. d IN ring_carrier r ==>
       (!s. s IN S ==> ring_divides r (a s) d) ==>
       ring_divides r c d
  ) ==>
  ~(c = ring_0 r) ==>
  ring_prime r p ==>
  t IN S ==>
  (!s:X. s IN S ==> ring_ord r p (a s) <= ring_ord r p (a t)) ==>
  ring_ord r p c = ring_ord r p (a t)
`,
  intro THEN
  have `!s:X. s IN S ==> ~(a s = ring_0 r:R)` [RING_DIVIDES_ZERO] THEN
  have `!s:X. s IN S ==> ring_ord r p (a s:R) <= ring_ord r p c` [ring_ord_divides;UFD_IMP_INTEGRAL_DOMAIN] THEN
  have `ring_ord r p (a(t:X):R) <= ring_ord r p c` [] THEN
  case `ring_ord r p (a(t:X):R) < ring_ord r p c` THENL [
    subgoal `ring_divides r p (c:R)` THENL [
      num_linear_fact `ring_ord r p (a(t:X):R) < ring_ord r p c ==> 1 <= ring_ord r p c` THEN
      have `c:R IN ring_carrier r` [ring_divides] THEN
      specialize_assuming[
        `r:R ring`;
        `p:R`;
        `c:R`;
        `1`
      ]divides_le_pow_ring_ord THEN
      qed[RING_POW_1;UFD_IMP_INTEGRAL_DOMAIN;ring_prime]
    ; pass
    ] THEN
    choose `u:R` `u IN ring_carrier r /\ c = ring_mul r p u:R` [ring_divides] THEN
    subgoal `!s:X. s IN S ==> ring_divides r (a s) (u:R)` THENL [
      intro_gendisch THEN
      have `a(s:X):R IN ring_carrier r` [ring_divides] THEN
      have `~(a(s:X):R = ring_0 r)` [RING_DIVIDES_ZERO] THEN
      have `u:R IN ring_carrier r` [] THEN
      have `~(u:R = ring_0 r)` [RING_MUL_RZERO;ring_prime] THEN
      specialize[
        `r:R ring`;
        `a(s:X):R`;
        `u:R`
      ]ring_ord_divides_eq THEN
      rw[know `ring_divides r (a(s:X)) u <=> (!q:R. ring_prime r q ==> ring_ord r q (a(s:X)) <= ring_ord r q u)`] THEN
      intro THEN
      case `ring_associates r p (q:R)` THENL [
        have `~(p:R = ring_0 r)` [ring_prime] THEN
        have `ring_ord r p (c:R) = ring_ord r p p + ring_ord r p u` [ring_ord_mul;UFD_IMP_INTEGRAL_DOMAIN;ring_prime] THEN
        have `ring_ord r (p:R) p = 1` [ring_ord_refl;ring_prime;UFD_IMP_INTEGRAL_DOMAIN] THEN
        have `ring_ord r p (c:R) = 1 + ring_ord r p u` [] THEN
        have `ring_ord r p ((a(s:X)):R) < ring_ord r p c` [LET_TRANS] THEN
        simp[GSYM ring_associates_ord] THEN
        ASM_ARITH_TAC
      ;
        have `ring_ord r q (c:R) = ring_ord r q p + ring_ord r q u` [ring_ord_mul;UFD_IMP_INTEGRAL_DOMAIN;ring_prime] THEN
        specialize[
          `r:R ring`;
          `q:R`;
          `p:R`
        ]ring_ord_prime THEN
        have `ring_ord r q (p:R) = 0` [RING_ASSOCIATES_SYM] THEN
        have `ring_ord r q (c:R) = 0 + ring_ord r q u` [] THEN
        have `ring_ord r q ((a(s:X)):R) <= ring_ord r q c` [ring_ord_divides;UFD_IMP_INTEGRAL_DOMAIN] THEN
        ASM_ARITH_TAC
      ]
    ; pass
    ] THEN
    have `ring_divides r (c:R) u` [] THEN
    choose `v:R` `v:R IN ring_carrier r /\ u = ring_mul r c v` [ring_divides] THEN
    subgoal `ring_mul r c (ring_1 r) = ring_mul r c (ring_mul r p v):R` THENL [
      specialize[
      ](GENL[
        `c:R`;`p:R`;`u:R`;`v:R`
      ](RING_RULE
        `c = ring_mul r p u:R ==> u = ring_mul r c v ==> ring_mul r c (ring_1 r) = ring_mul r c (ring_mul r p v)`
      )) THEN
      qed[ring_prime;ring_divides]
    ; pass
    ] THEN
    subgoal `ring_1 r:R = ring_mul r p v` THENL [
      specialize[
        `r:R ring`;
        `c:R`
      ]INTEGRAL_DOMAIN_MUL_LCANCEL THEN
      qed[RING_MUL;RING_1;ring_divides;ring_prime;UFD_IMP_INTEGRAL_DOMAIN]
    ; pass
    ] THEN
    qed[ring_unit;ring_prime]
  ; pass
  ] THEN
  ASM_ARITH_TAC
);;
```

### Informal statement
Let `r` be a UFD ring. Suppose that for all `s` in set `S`, `a s` is in the carrier of `r`. Also, suppose that `c` is in the carrier of `r`. Assume that for every `s` in `S`, `(a s)` divides `c` in `r`. Furthermore, assume that for every `d` in the carrier of `r`, if for all `s` in `S`, `(a s)` divides `d` in `r`, then `c` divides `d` in `r`. Suppose `c` is not equal to the zero element of `r`. Let `p` be a prime element in `r`. Let `t` be an element of the set `S`. If for all `s` in `S`, the ring order of `p` at `(a s)` is less than or equal to the ring order of `p` at `(a t)`, then the ring order of `p` at `c` is equal to the ring order of `p` at `(a t)`.

### Informal sketch
The proof proceeds by assuming the theorem's hypotheses and then considering two cases based on whether the ring order of `p` at `(a t)` is strictly less than the ring order of `p` at `c`.

- Case 1: `ring_ord r p (a t) < ring_ord r p c`.
  - It is shown that `p` divides `c`.
  - We decompose `c` into `p * u` for some `u` in the carrier of `r` using `ring_divides`.
  - It is then shown that for all `s` in `S`, `(a s)` divides `u`. This is done by showing that for an arbitrary prime `q`, `ring_ord r q (a s) <= ring_ord r q u` using the fact that associates of primes have the same ring order.
  - Since `c` is the least common multiple of `(a s)` for `s` in `S`, and each `(a s)` divides `u`, it must be the case that `c` also divides `u`.
  - So, `u = c * v` for some `v` in the carrier of `r`.
  - Substitute to get `c * 1 = c * (p * v)`, which implies `ring_1 r = p * v` by cancellation since `r` is an integral domain.
  - This means `p` is a unit, which contradicts the assumption that `p` is prime.

- Case 2: `ring_ord r p (a t) >= ring_ord r p c`.
  - Since it was previously shown that `ring_ord r p (a s) <= ring_ord r p c` for all `s` in `S`, and we are given `ring_ord r p (a t) >= ring_ord r p c`, then the proof follows by antisymmetry.

Relevant dependencies for this theorem are:

- `ring_ord_divides`: The ring order of a divisor is less than or equal to the ring order of the dividend.
- `divides_le_pow_ring_ord`: If `d` divides `c` then `c = d * something`, so the `ring_ord p c = ring_ord p d + ring_ord p something`
- `ring_ord_mul`: The ring order of a product is the sum of the ring orders.
- `ring_ord_refl`: The ring order of a prime at itself is 1.

### Mathematical insight
This theorem states that under suitable conditions, if `c` is the least common multiple (LCM) of a set of elements `{a s | s IN S}`, then the `p`-order (valuation) of `c` equals the `p`-order of `a t` where `t` is an element of `S` such that `a t` has the largest `p`-order among all `a s`. This connects the notion of LCM with the `p`-adic valuation and is fundamental in algebraic number theory when dealing with unique factorization domains.

### Dependencies
- category: ring theory
  - `UFD`
  - `ring_carrier`
  - `ring_divides`
  - `ring_0`
  - `ring_prime`
  - `ring_ord`
  - `ring_mul`
  - `ring_1`
  - `ring_associates`
  - `ring_unit`
- category: theorems
  - `RING_DIVIDES_ZERO`
  - `ring_ord_divides`
  - `divides_le_pow_ring_ord`
  - `UFD_IMP_INTEGRAL_DOMAIN`
  - `RING_POW_1`
  - `RING_MUL_RZERO`
  - `ring_ord_divides_eq`
  - `ring_ord_mul`
  - `ring_ord_refl`
  - `RING_ASSOCIATES_SYM`
  - `INTEGRAL_DOMAIN_MUL_LCANCEL`
  - `RING_MUL`
  - `RING_1`

### Porting notes
- The theorem relies heavily on the properties of UFDs and the ring order function, which are core to algebraic number theory. Ensure these are defined appropriately in the target proof assistant.
- The tactics involving arithmetic (`ASM_ARITH_TAC`) might need to be adapted based on the arithmetic reasoning capabilities of the target system.
- The discharging of carrier conditions may need explicit handling depending on how types and subtypes are managed in the target system.


---

## ring_ord_lcm

### Name of formal statement
ring_ord_lcm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_lcm = prove(`
  !(r:R ring) a b c p.
  UFD r ==>
  ring_divides r a c ==>
  ring_divides r b c ==>
  (!d. d IN ring_carrier r ==>
       ring_divides r a d ==>
       ring_divides r b d ==>
       ring_divides r c d
  ) ==>
  ~(c = ring_0 r) ==>
  ring_prime r p ==>
  ring_ord r p c
  = MAX (ring_ord r p a) (ring_ord r p b)
`,
  intro THEN
  have `!s. s IN 0..1 ==> (if s = 0 then a else b:R) IN ring_carrier r` [ring_divides] THEN
  have `c:R IN ring_carrier r` [ring_divides] THEN
  have `!s. s IN 0..1 ==> ring_divides r (if s = 0 then a else b:R) c` [] THEN
  have `0 IN 0..1` [IN_NUMSEG_0;ARITH_RULE `0 <= 1`] THEN
  have `1 IN 0..1` [IN_NUMSEG_0;ARITH_RULE `1 <= 1`] THEN
  subgoal `!d:R. d IN ring_carrier r ==> (!s. s IN 0..1 ==> ring_divides r (if s = 0 then a else b) d) ==> ring_divides r c d` THENL [
    intro THEN
    have `ring_divides r (a:R) d` [] THEN
    have `ring_divides r (b:R) d` [ARITH_RULE `~(0 = 1)`] THEN
    qed[]
  ; pass
  ] THEN
  case `ring_ord r p (a:R) <= ring_ord r p b` THENL [
    have `!s. s IN 0..1 ==> ring_ord r p (if s = 0 then a else b:R) <= ring_ord r p (if 1 = 0 then a else b)` [ARITH_RULE `~(1 = 0)`;LE_REFL] THEN
    specialize[
      `r:R ring`;
      `\i:num. if i = 0 then a else b:R`;
      `0..1`;
      `c:R`;
      `p:R`;
      `1`
    ]ring_ord_lcm_set THEN
    simp[MAX] THEN
    qed[ARITH_RULE `~(1 = 0)`]
  ;
    num_linear_fact `~(ring_ord r p (a:R) <= ring_ord r p b) ==> ring_ord r p b <= ring_ord r p a` THEN
    have `!s. s IN 0..1 ==> ring_ord r p (if s = 0 then a else b:R) <= ring_ord r p a` [LE_REFL] THEN
    specialize[
      `r:R ring`;
      `\i:num. if i = 0 then a else b:R`;
      `0..1`;
      `c:R`;
      `p:R`;
      `0`
    ]ring_ord_lcm_set THEN
    simp[MAX]
  ]
);;
```
### Informal statement
Let `r` be a unique factorization domain (UFD). Suppose `a`, `b`, and `c` are elements of the ring `r` such that `a` divides `c` and `b` divides `c`. Also suppose that for any `d` in the ring `r`, if `a` divides `d` and `b` divides `d`, then `c` divides `d`. If `c` is not equal to the zero element of the ring `r`, and `p` is a prime element of the ring `r`, then the order of `p` in `c` is equal to the maximum of the order of `p` in `a` and the order of `p` in `b`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses that `r` is a UFD, `a` divides `c`, `b` divides `c`, for all `d` if `a` divides `d` and `b` divides `d` then `c` divides `d`, `c` is not zero, and `p` is prime.
- Show that if `s` is either 0 or 1, then `if s = 0 then a else b` is in the ring carrier.
- Show `c` is in the ring carrier.
- Infer that for any `s` in {0, 1}, `if s = 0 then a else b` divides `c`.
- Prove that for any `d` in the carrier, if for every `s` in {0, 1}, `if s = 0 then a else b` divides `d`, then `c` divides `d`. This is shown by noting that `a` and `b` divide `d`, implying that `c` divides `d`.
- Case split on whether `ring_ord r p a <= ring_ord r p b`.
- If `ring_ord r p a <= ring_ord r p b`, then since `ring_ord r p (if s = 0 then a else b)` is equal to `ring_ord r p b`, we can apply `ring_ord_lcm_set` with `s = 1` and simplify using the definition of `MAX`.
- Otherwise, if `ring_ord r p b <= ring_ord r p a`, since `ring_ord r p (if s = 0 then a else b)` is equal to `ring_ord r p a`, we can apply `ring_ord_lcm_set` with `s = 0` and simplify using the definition of `MAX`.

### Mathematical insight
This theorem states that if `c` is the least common multiple of `a` and `b` within a UFD `r`, then the order of a prime `p` in `c` is the maximum of the orders of `p` in `a` and `b`. This is a fundamental property of LCMs in UFDs, reflecting how prime factorizations combine to form the LCM.

### Dependencies
- `ring_divides`
- `IN_NUMSEG_0`
- `ring_ord_lcm_set`
- `LE_REFL`
- `UFD`
- `ring_carrier`
- `ring_0`
- `ring_prime`
- `ring_ord`
- `MAX`
- `ARITH_RULE`


---

## ring_ord_squarefree

### Name of formal statement
ring_ord_squarefree

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_ord_squarefree = prove(`
  !(r:R ring) a.
  UFD r ==>
  a IN ring_carrier r ==>
  ~(a = ring_0 r) ==>
  ( ring_squarefree r a <=>
    (!p. ring_prime r p ==>
         ring_ord r p a <= 1
    )
  )
`,
  intro THEN
  have `integral_domain(r:R ring)` [UFD_IMP_INTEGRAL_DOMAIN] THEN
  splitiff THENL [
    intro THEN
    case `2 <= ring_ord r (p:R) a` THENL [
      have `p:R IN ring_carrier r` [ring_prime] THEN
      have `~(ring_unit r (p:R))` [ring_prime] THEN
      have `noetherian_ring r \/ UFD(r:R ring)` [] THEN
      specialize[
        `r:R ring`;
        `p:R`;
        `a:R`;
        `2`
      ]divides_le_pow_ring_ord THEN
      have `ring_divides r (ring_mul r p p:R) a` [RING_POW_2] THEN
      specialize[
        `r:R ring`;
        `a:R`;
        `p:R`
      ]not_squarefree_if_divisible_by_square THEN
      qed[]
    ; pass
    ] THEN
    ASM_ARITH_TAC
  ;
    intro THEN
    specialize[
      `r:R ring`;
      `a:R`
    ]primefact_ord THEN
    choose2 `n:num` `q:num->R` `(!i. i IN (1..n) ==> ring_prime r (q i:R)) /\ (!i. i IN 1..n ==> ring_divides r (q i) a) /\ (!i j. i IN (1..n) ==> j IN (1..n) ==> ring_associates r (q i) (q j) ==> i = j) /\ ring_associates r a (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)))` [] THEN
    subgoal `ring_squarefree r (ring_product r (1..n) q:R)` THENL [
      have `FINITE(1..n)` [FINITE_NUMSEG] THEN
      have `!i. i IN 1..n ==> ring_prime r (q i:R)` [] THEN
      have `!i. i IN 1..n ==> q i:R IN ring_carrier r` [ring_prime] THEN
      have `!i j. i IN 1..n ==> j IN 1..n ==> ring_divides r (q i) (q j:R) ==> i = j` [ring_divides_associates_prime] THEN
      specialize[
        `r:R ring`;
        `1..n`;
        `q:num->R`
      ]ring_squarefree_if_product_coprime_primes_indexed THEN
      qed[]
    ; pass
    ] THEN
    subgoal `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a):R) = ring_product r (1..n) q` THENL [
      sufficesby RING_PRODUCT_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      subgoal `ring_ord r (q(a':num)) (a:R) = 1` THENL [
        have `1 <= ring_ord r (q(a':num)) (a:R)` [ring_ord_prime_divides] THEN
        have `ring_ord r (q(a':num)) (a:R) <= 1` [] THEN
        num_linear_fact `1 <= ring_ord r (q(a':num)) (a:R) ==> ring_ord r (q a') a <= 1 ==> ring_ord r (q a') a = 1` THEN
        qed[]
      ; pass
      ] THEN
      qed[RING_POW_1;ring_prime]
    ; pass
    ] THEN
    have `ring_squarefree r (ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)):R)` [] THEN
    specialize_assuming[
      `r:R ring`;
      `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)):R`;
      `a:R`
    ]ring_squarefree_associates THEN
    qed[RING_ASSOCIATES_SYM]
  ]
);;
```

### Informal statement
For any ring `r` of type `R ring` and any element `a` in the carrier of `r`, if `r` is a unique factorization domain (UFD) and `a` is not the zero element of `r`, then `a` is squarefree in `r` if and only if for all prime elements `p` in `r`, the order of `p` in `a` is less than or equal to 1.

### Informal sketch
The proof proceeds by showing the equivalence of `ring_squarefree r a` and `!p. ring_prime r p ==> ring_ord r p a <= 1`.

- The proof first assumes that `r` is a UFD, implies that `r` is an integral domain.
- The equivalence is split into two directions:

  - **Forward direction:** Assuming `ring_squarefree r a`, it is shown that for every prime element `p` in `r`, `ring_ord r p a <= 1`. This is proved by contradiction: assuming `2 <= ring_ord r p a`, it is shown that `ring_divides r (ring_mul r p p) a`, which contradicts the assumption that `a` is squarefree. The theorem `not_squarefree_if_divisible_by_square` is used in this part.

  - **Backward direction:** Assuming that for every prime element `p` in `r`, `ring_ord r p a <= 1`, it is shown that `ring_squarefree r a`.
    - The proof uses `primefact_ord` to decompose `a` into a product of prime powers, where `a` is associated with `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a))`, with `q i` prime.
    - It needs to prove `ring_squarefree r (ring_product r (1..n) q)`. This is achieved using `ring_squarefree_if_product_coprime_primes_indexed` and showing that the `q i` are pairwise coprime. `ring_divides_associates_prime` is used here.
    - The goal becomes to show that `ring_product r (1..n) (\i. ring_pow r (q i) (ring_ord r (q i) a)) = ring_product r (1..n) q`. This is achieved by establishing that `ring_ord r (q(a')) a = 1` for all `a'` in `1..n`. Since it's known that `ring_ord r (q a') a <= 1` and `ring_ord_prime_divides` shows that `1 <= ring_ord r (q(a')) a`, then `ring_ord r (q a') a = 1` follows.
    - Then, `ring_squarefree_associates` with `RING_ASSOCIATES_SYM` proves the main goal.

### Mathematical insight
This theorem provides a characterization of squarefree elements in a UFD. It states that an element is squarefree if and only if the order of every prime dividing it is at most 1. This characterization is useful for proving properties of squarefree elements and for determining whether a given element is squarefree. The decomposition into prime factors in a UFD is essential for the proof.

### Dependencies
- `UFD_IMP_INTEGRAL_DOMAIN`
- `not_squarefree_if_divisible_by_square`
- `primefact_ord`
- `ring_squarefree_if_product_coprime_primes_indexed`
- `ring_divides_associates_prime`
- `ring_ord_prime_divides`
- `ring_squarefree_associates`
- `RING_ASSOCIATES_SYM`
- `FINITE_NUMSEG`
- `RING_PRODUCT_EQ`
- `BETA_THM`
- `RING_POW_1`
- `ring_prime`
- `RING_POW_2`

### Porting notes (optional)
- The proof relies heavily on the properties of UFDs and prime factorization. The target proof assistant should have good support for UFDs and the concept of the order of an element.
- Theorems like `primefact_ord` might need to be constructed explicitly in some systems if not directly available.
- The prime factorization and manipulation of orders might require careful handling of quantifiers and dependent types.


---

## ring_squarefree_lcm

### Name of formal statement
ring_squarefree_lcm

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_lcm = prove(`
  !(r:R ring) a b c.
  UFD r ==>
  ring_divides r a c ==>
  ring_divides r b c ==>
  (!d. d IN ring_carrier r ==>
       ring_divides r a d ==>
       ring_divides r b d ==>
       ring_divides r c d
  ) ==>
  ~(c = ring_0 r) ==>
  ring_squarefree r a ==>
  ring_squarefree r b ==>
  ring_squarefree r c
`,
  intro THEN
  have `~(a = ring_0 r:R)` [RING_DIVIDES_ZERO] THEN
  have `~(b = ring_0 r:R)` [RING_DIVIDES_ZERO] THEN
  have `c:R IN ring_carrier r` [ring_divides] THEN
  simp[ring_ord_squarefree] THEN
  intro THEN
  have `a:R IN ring_carrier r` [ring_divides] THEN
  have `ring_ord r p (a:R) <= 1` [ring_ord_squarefree] THEN
  have `b:R IN ring_carrier r` [ring_divides] THEN
  have `ring_ord r p (b:R) <= 1` [ring_ord_squarefree] THEN
  simp[ring_ord_lcm] THEN
  simp[max_le]
);;
```
### Informal statement
Let `r` be a ring of type `R`.
Then for all `a`, `b`, and `c` in `R`,
  if `r` is a unique factorization domain and
  `a` divides `c` in `r` and
  `b` divides `c` in `r` and
  for all `d` in the carrier of `r`, if `a` divides `d` in `r` and `b` divides `d` in `r`, then `c` divides `d` in `r`, and
  `c` is not equal to the zero element of `r` and
  `a` is squarefree in `r` and
  `b` is squarefree in `r`,
then `c` is squarefree in `r`.

### Informal sketch
The proof proceeds as follows:
- Assume the antecedent of the implication.
- Since `a` divides `c` and `b` divides `c` and `c` is not zero, deduce that neither `a` nor `b` is zero.
- Assume that `p` is a prime in the ring `r`.
- Since `a` is squarefree, `ring_ord r p a <= 1`.
- Since `b` is squarefree, `ring_ord r p b <= 1`.
- The condition on `c` suggests that `c` is the least common multiple of `a` and `b`.
- Using the properties of `ring_ord` and `ring_lcm`, show that `ring_ord r p c = max (ring_ord r p a) (ring_ord r p b) <=1`.
- Conclude that `c` is squarefree.

### Mathematical insight
The theorem states that if `a` and `b` are squarefree elements in a unique factorization domain `r`, and if `c` is the least common multiple of `a` and `b`, and is nonzero, then `c` is also squarefree. This theorem relates the property of being squarefree to the least common multiple operation in a ring, highlighting how squarefreeness interacts with divisibility in UFDs.

### Dependencies
- `UFD`
- `ring_divides`
- `ring_carrier`
- `ring_0`
- `ring_squarefree`
- `ring_ord_squarefree`
- `ring_ord`
- `ring_lcm`
- `max_le`
- `RING_DIVIDES_ZERO`


---

## ring_squarefree_lcm_set

### Name of formal statement
ring_squarefree_lcm_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_squarefree_lcm_set = prove(`
  !(r:R ring) a S c.
  UFD r ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  c IN ring_carrier r ==>
  (!s. s IN S ==> ring_divides r (a s) c) ==>
  (!d. d IN ring_carrier r ==>
       (!s. s IN S ==> ring_divides r (a s) d) ==>
       ring_divides r c d
  ) ==>
  ~(c = ring_0 r) ==>
  (!s. s IN S ==> ring_squarefree r (a s)) ==>
  ring_squarefree r c
`,
  intro THEN
  have `!s:X. s IN S ==> ~(a s = ring_0 r:R)` [RING_DIVIDES_ZERO] THEN
  have `c:R IN ring_carrier r` [ring_divides] THEN
  simp[ring_ord_squarefree] THEN
  intro THEN
  have `!s:X. s IN S ==> (a s):R IN ring_carrier r` [ring_divides] THEN
  have `!s:X. s IN S ==> ring_ord r p ((a s):R) <= 1` [ring_ord_squarefree] THEN
  case `?t:X. t IN S /\ ring_ord r p (a t:R) = 1` THENL [
    choose `t:X` `t:X IN S /\ ring_ord r p (a t:R) = 1` [] THEN
    have `!s:X. s IN S ==> ring_ord r p (a s:R) <= ring_ord r p (a t)` [] THEN
    specialize_assuming[
      `r:R ring`;
      `a:X->R`;
      `S:X->bool`;
      `c:R`;
      `p:R`;
      `t:X`
    ]ring_ord_lcm_set THEN
    have `ring_ord r p c = ring_ord r p (a(t:X):R)` [] THEN
    qed[]
  ; pass
  ] THEN
  subgoal `!t:X. t IN S ==> ring_ord r p (a t:R) = 0` THENL [
    intro THEN
    have `ring_ord r p (a(t:X):R) <= 1` [] THEN
    have `~(ring_ord r p (a(t:X):R) = 1)` [] THEN
    ASM_ARITH_TAC
  ; pass
  ] THEN
  case `S = {}:X->bool` THENL [
    subgoal `ring_divides r c (ring_1 r:R)` THENL [
      subgoal `!s:X. s IN {} ==> ring_divides r (a s:R) (ring_1 r)` THENL [
        rw[EMPTY;IN_ELIM_THM]
      ; pass
      ] THEN
      qed[RING_1]
    ; pass
    ] THEN
    have `ring_unit r (c:R)` [ring_unit;ring_divides] THEN
    have `ring_ord r p (c:R) = 0` [ring_ord_unit;ring_prime] THEN
    qed[ARITH_RULE `0 <= 1`]
  ; pass
  ] THEN
  set_fact `~(S = {}) ==> ?t:X. t IN S` THEN
  choose `t:X` `t:X IN S` [] THEN
  have `!s:X. s IN S ==> ring_ord r p (a s:R) <= ring_ord r p (a t)` [ARITH_RULE `0 <= 0`] THEN
  specialize_assuming[
    `r:R ring`;
    `a:X->R`;
    `S:X->bool`;
    `c:R`;
    `p:R`;
    `t:X`
  ]ring_ord_lcm_set THEN
  have `ring_ord r p c = ring_ord r p (a(t:X):R)` [] THEN
  qed[ARITH_RULE `0 <= 1`]
);;
```

### Informal statement
Let `r` be a ring in the sense of ring theory.
Then, for any function `a` from a type `X` to the carrier of ring `r`, any set `S` of type `X`, and any element `c` in the carrier of ring `r`, if the ring `r` is a unique factorization domain, and if for all `s` in `S`, `a s` is an element of the carrier of the ring `r`, and `c` is in the carrier of `r`, and for all `s` in `S`, `a s` divides `c` in the ring `r`, and `c` is a least common multiple of `a s` for all `s` in `S`, and `c` is not equal to the zero element of ring `r`, and for all `s` in `S`, `a s` is squarefree in ring `r`, then `c` is squarefree in ring `r`.

### Informal sketch
The proof proceeds by induction on the prime factor `p` of `c`. It aims to show that `ring_ord r p c <= 1`.

- Introductory steps include introducing assumptions and simplifying using `ring_ord_squarefree`.
- The proof then cases on whether there exists a `t` in `S` such that `ring_ord r p (a t) = 1`.
- If such a `t` exists, we use `ring_ord_lcm_set` to show that `ring_ord r p c = ring_ord r p (a t)`, and since `ring_ord r p (a t) <= 1`, it follows that `ring_ord r p c <= 1`.
- If no such `t` exists, we proceed to show that for all `t` in `S`, `ring_ord r p (a t) = 0`.
- Then we case on whether the set S is empty.
- If `S` is empty, then `c` is a unit, which implies its order with respect to any prime is 0.
- If `S` is not empty, then there exists `t` in `S`, and we use `ring_ord_lcm_set` to conclude that `ring_ord r p c = ring_ord r p (a t) = 0`. Since implies `ring_ord r p c <= 1`.

### Mathematical insight
This theorem formalizes the intuitive result that if a set of elements in a unique factorization domain are all squarefree, and their least common multiple exists and is not zero, then the least common multiple is also squarefree. The key insight is to reason about the prime factorization of each element and the least common multiple in terms of the `ring_ord` function, which calculates the exponent of a prime factor in the factorization.

### Dependencies
- `ring_ord_squarefree`
- `RING_DIVIDES_ZERO`
- `ring_divides`
- `ring_ord_squarefree`
- `ring_ord_lcm_set`
- `EMPTY`
- `IN_ELIM_THM`
- `RING_1`
- `ring_unit`
- `ring_ord_unit`
- `ring_prime`

### Porting notes (optional)
- The proof relies heavily on properties of the `ring_ord` function and the `ring_divides` relation, so ensure these are also ported and adequately formalized in the target proof assistant.
- The proof involves several case splits and arithmetic reasoning, so automation in the target proof assistant should be considered.


---

## ring_prime_divides_lcm_set

### Name of formal statement
ring_prime_divides_lcm_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_prime_divides_lcm_set = prove(`
  !(r:R ring) a S c p.
  UFD r ==>
  (!s:X. s IN S ==> a s IN ring_carrier r) ==>
  c IN ring_carrier r ==>
  (!s. s IN S ==> ring_divides r (a s) c) ==>
  (!d. d IN ring_carrier r ==>
       (!s. s IN S ==> ring_divides r (a s) d) ==>
       ring_divides r c d
  ) ==>
  ~(c = ring_0 r) ==>
  ring_prime r p ==>
  ( ring_divides r p c <=>
    (?s. s IN S /\ ring_divides r p (a s))
  )
`,
  intro THEN
  splitiff THENL [
    intro THEN
    case `S = {}:X->bool` THENL [
      subgoal `!s:X. s IN S ==> ring_unit r (a s:R)` THENL [
        simp[IN_ELIM_THM;EMPTY]
      ; pass
      ] THEN
      specialize[
        `r:R ring`;
        `a:X->R`;
        `S:X->bool`;
        `c:R`
      ]lcm_set_units THEN
      qed[RING_DIVIDES_UNIT;ring_prime]
    ; pass
    ] THEN
    case `!s:X. s IN S ==> ~(ring_divides r (p:R) (a s))` THENL [
      choose `t:X` `t:X IN S` [MEMBER_NOT_EMPTY] THEN
      have `!s:X. s IN S ==> ring_ord r (p:R) (a s) = 0` [ring_ord_notdivides;ring_prime] THEN
      have `!s:X. s IN S ==> ring_ord r (p:R) (a s) <= ring_ord r p (a t)` [ARITH_RULE `0 <= 0`] THEN
      specialize[
        `r:R ring`;
        `a:X->R`;
        `S:X->bool`;
        `c:R`;
        `p:R`;
        `t:X`
      ]ring_ord_lcm_set THEN
      have `ring_ord r (p:R) c <= 0` [] THEN
      num_linear_fact `ring_ord r (p:R) c <= 0 ==> ring_ord r p c = 0` THEN
      qed[nonzero_ring_ord_if_divides;UFD_IMP_INTEGRAL_DOMAIN]
    ; pass
    ] THEN
    qed[]
  ;
    qed[RING_DIVIDES_TRANS]
  ]
);;
```
### Informal statement
In a unique factorization domain `r`, given a set `S`, a function `a` mapping elements of `S` to elements of `r`, an element `c` in `r`, and a prime element `p` in `r`, if for all `s` in `S`, `a(s)` is in `r` and `a(s)` divides `c`; and if `c` is the least common multiple of `a(s)` for all `s` in `S` (i.e., for any `d` in `r`, if for all `s` in `S`, `a(s)` divides `d`, then `c` divides `d`), and `c` is not zero, then `p` divides `c` if and only if there exists some `s` in `S` such that `p` divides `a(s)`.

### Informal sketch
The proof proceeds by splitting the iff into two implications and considering cases:

- Case 1: `S` is empty. In this case, the least common multiple `c` is a unit. If `p` divides `c`, then `p` must be a unit, contradicting the assumption that `p` is prime. Conversely, if `p` divides some `a s` which is necessarily a unit, then `p` must be a unit and `c` divides `p`, which is absurd.
    - SubGoal: Show that `!s:X. s IN S ==> ring_unit r (a s:R)`. This follows from `IN_ELIM_THM` and emptiness of `S`.
    - Use `lcm_set_units` which states the least common multiple of units is a unit.
    - Use `RING_DIVIDES_UNIT` which states a unit divides everything, and `ring_prime`.
- Case 2: `!s:X. s IN S ==> ~(ring_divides r (p:R) (a s))`. That is, `p` does not divide any of the `a s`. In this case, we need to show that `p` does not divide the least common multiple `c`.
    - Choose a `t:X` such that `t:X IN S`. From `MEMBER_NOT_EMPTY`. Because `S` must be nonempty in this case
    - have `!s:X. s IN S ==> ring_ord r (p:R) (a s) = 0` from `ring_ord_notdivides` and `ring_prime`. Which is that if `p` does not divide `a s`, then the greatest power of `p` that divides `a s` is zero (the `ring_ord`).
    - have `!s:X. s IN S ==> ring_ord r (p:R) (a s) <= ring_ord r p (a t)` [ARITH_RULE `0 <= 0`]. Since all the ords are zero, this is true.
    - Use `ring_ord_lcm_set` to relate the order of the least common multiple to the maximum of the orders of the elements.
    - have `ring_ord r (p:R) c <= 0` because it corresponds to the max in `ring_ord_lcm_set` and the value there is zero.
    - `num_linear_fact` to establish that `ring_ord r (p:R) c <= 0 ==> ring_ord r p c = 0` which means then that necessarily it must be zero.
    - qed[nonzero_ring_ord_if_divides;UFD_IMP_INTEGRAL_DOMAIN] which states that if, and only if `p` divides `c` the `ring_ord` of `c` at `p` is non-zero
- Default case: Where `!s:X. s IN S ==> ring_divides r (p:R) (a s)`.
    - qed[RING_DIVIDES_TRANS]

### Mathematical insight
This theorem connects the divisibility of a least common multiple by a prime element to the divisibility of the elements in the set by that prime element. It formalizes the intuition that a prime divides the LCM if and only if it divides at least one of the elements whose LCM is being considered. The theorem depends on the ring being a unique factorization domain and the element `p` being a prime element.

### Dependencies
- `IN_ELIM_THM`
- `lcm_set_units`
- `RING_DIVIDES_UNIT`
- `ring_prime`
- `MEMBER_NOT_EMPTY`
- `ring_ord_notdivides`
- `ring_ord_lcm_set`
- `nonzero_ring_ord_if_divides`
- `UFD_IMP_INTEGRAL_DOMAIN`
- `RING_DIVIDES_TRANS`

### Porting notes (optional)
- The definition of `ring_ord` and properties of UFDs are key for porting.
- The handling of sets and quantification might differ across proof assistants.
- The proof seems heavily reliant on existing theorems, so ensure those are available or replicable.


---

## poly_lcm_set_exists

### Name of formal statement
poly_lcm_set_exists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_lcm_set_exists = prove(`
  !(r:R ring) a S.
  field r ==>
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (a s)) ==>
  ?c. (
    ring_polynomial r c /\
    (!s. s IN S ==> ring_divides(x_poly r) (a s) c) /\
    (!d. ring_polynomial r d ==>
         (!s. s IN S ==> ring_divides(x_poly r) (a s) d) ==>
         ring_divides(x_poly r) c d
    )
  )
`,
  intro THEN
  have `UFD(x_poly(r:R ring))` [UFD_x_poly_field] THEN
  have `!s:X. s IN S ==> a s:(1->num)->R IN ring_carrier(x_poly r)` [x_poly_use] THEN
  specialize[
    `x_poly(r:R ring)`;
    `a:X->(1->num)->R`;
    `S:X->bool`
  ]lcm_set_exists THEN
  choose `c:(1->num)->R` `c:(1->num)->R IN ring_carrier(x_poly r) /\ (!s:X. s IN S ==> ring_divides(x_poly r) (a s) c) /\ (!d. d IN ring_carrier(x_poly r) ==> (!s. s IN S ==> ring_divides(x_poly r) (a s) d) ==> ring_divides(x_poly r) c d)` [] THEN
  witness `c:(1->num)->R` THEN
  rw[x_poly_use] THEN
  qed[lcm_set_exists]
);;
```
### Informal statement
For any ring `r` and any set `S` such that `r` is a field, `S` is finite, and for every `s` in `S`, `a s` is a polynomial over the ring `r`, there exists a polynomial `c` over the ring `r` such that:
1. `c` is a polynomial over the ring `r`, and
2. for all `s` in `S`, `a s` divides `c`, and
3. for all polynomials `d` over the ring `r`, if for all `s` in `S`, `a s` divides `d`, then `c` divides `d`.

### Informal sketch
The proof demonstrates the existence of a least common multiple (`lcm`) for a finite set of polynomials over a field `r`. 

- First, assume that `r` is a field.
- It's known that the polynomial ring `x_poly r` over the field `r` is a unique factorization domain (UFD), referencing the theorem `UFD_x_poly_field`.
- The theorem `lcm_set_exists` (which states that least common multiples exist in UFDs for finite sets) is then specialized to the polynomial ring `x_poly r`. This use requires showing `a s` is an element of the ring carrier.
- Finally, we select `c` to be the polynomial satisfying the definition of the `lcm_set_exists` theorem, and using the fact that `a s` is a polynomial. This shows all the required divisibility relations.

### Mathematical insight
This theorem asserts that for any finite set of polynomials over a field, there exists a polynomial that is divisible by all polynomials in the set, and it is the smallest such polynomial in terms of divisibility. This is an important result used to build further theory about polynomials and factorization.

### Dependencies
- `UFD_x_poly_field`
- `lcm_set_exists`
- `ring_polynomial`
- `ring_divides`
- `x_poly`

### Porting notes (optional)
- Ensure that the target proof assistant has a well-developed library for abstract algebra, including fields, rings, and unique factorization domains.
- The `lcm_set_exists` theorem likely relies on the constructive properties of UFDs, so the port should account for this.
- Special care might be needed to handle type coercions or ring carrier inclusions depending on the target system's type system.


---

## monic_lcm_set_exists

### Name of formal statement
monic_lcm_set_exists

### Type of the formal statement
theorem

### Formal Content
```ocaml
let monic_lcm_set_exists = prove(`
  !(r:R ring) a S.
  field r ==>
  FINITE S ==>
  (!s:X. s IN S ==> ring_polynomial r (a s)) ==>
  (!s:X. s IN S ==> ~(a s = poly_0 r)) ==>
  ?c. (
    ring_polynomial r c /\
    monic r c /\
    (!s. s IN S ==> ring_divides(x_poly r) (a s) c) /\
    (!d. ring_polynomial r d ==>
         (!s. s IN S ==> ring_divides(x_poly r) (a s) d) ==>
         ring_divides(x_poly r) c d
    )
  )
`,
  intro THEN
  specialize[
    `r:R ring`;
    `a:X->(1->num)->R`;
    `S:X->bool`
  ]poly_lcm_set_exists THEN
  choose `c:(1->num)->R` `ring_polynomial (r:R ring) c /\ (!s:X. s IN S ==> ring_divides(x_poly r) (a s) c) /\ (!d. ring_polynomial r d ==> (!s. s IN S ==> ring_divides(x_poly r) (a s) d) ==> ring_divides(x_poly r) c d)` [] THEN
  subgoal `~(c = poly_0 r:(1->num)->R)` THENL [
    specialize_assuming[
      `x_poly(r:R ring)`;
      `a:X->(1->num)->R`;
      `S:X->bool`;
      `c:(1->num)->R`
    ]zero_lcm_set THEN
    qed [x_poly_use;integral_domain_x_poly_field]
  ; pass
  ] THEN
  specialize_assuming[
    `r:R ring`;
    `c:(1->num)->R`
  ]x_poly_field_monic_associate THEN
  choose `q:(1->num)->R` `ring_polynomial r (q:(1->num)->R) /\ monic r q /\ ring_associates(x_poly r) c q` [] THEN
  witness `q:(1->num)->R` THEN
  qed[RING_ASSOCIATES_DIVIDES;RING_ASSOCIATES_REFL;x_poly_use]
);;
```
### Informal statement
For any ring `r` that is a field, any set `S`, and any function `a` from `S` to polynomials over `r` such that `a s` is a ring polynomial for all `s` in `S` and `S` is finite, and `a s` is not the zero polynomial for all `s` in `S`, there exists a polynomial `c` such that: `c` is a ring polynomial over `r`, `c` is monic, for all `s` in `S`, `a s` divides `c` (with respect to the divisibility relation `ring_divides(x_poly r)`), and for any polynomial `d` such that for all `s` in `S`, `a s` divides `d`, then `c` divides `d`.

### Informal sketch
The proof demonstrates the existence of a monic least common multiple (LCM) for a finite set of non-zero polynomials over a field `r`.

- First, the theorem `poly_lcm_set_exists` is used to show the existence of some polynomial `c` such that `c` is a ring polynomial, and `a s` divides `c` for all `s` in `S`, and if `a s` divides `d` for all `s` in `S`, then `c` divides `d`. This `c` is then chosen as the LCM.
- It is shown that `c` cannot be the zero polynomial (`poly_0 r`) under the assumptions given. This is needed because the definition of `monic` requires the polynomial to be non-zero. This is done using `zero_lcm_set`.
- Then, using `x_poly_field_monic_associate`, it is shown how to select `q` such that `q` is a ring polynomial, `q` is monic, and `c` and `q` are associates (`ring_associates(x_poly r)`).
- Finally, `q` is introduced as a witness, and using `RING_ASSOCIATES_DIVIDES`, `RING_ASSOCIATES_REFL`, and the definition of `x_poly_use`, the theorem is proven.

### Mathematical insight
This theorem establishes that for any finite set of non-zero polynomials over a field, there exists a monic polynomial which is the least common multiple of the polynomials in the set. The key idea is to first find *a* (potentially non-monic) least common multiple, and then scale it to make it monic. The assumption that we are over a field is important so that any non-zero leading coefficient can be inverted.

### Dependencies
- `r:R ring`
- `a:X->(1->num)->R`
- `S:X->bool`
- `poly_lcm_set_exists`
- `zero_lcm_set`
- `x_poly_field_monic_associate`
- `RING_ASSOCIATES_DIVIDES`
- `RING_ASSOCIATES_REFL`
- `x_poly_use`
- `integral_domain_x_poly_field`


---

## minimal_squarefree_from_algebraic_set

### Name of formal statement
minimal_squarefree_from_algebraic_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let minimal_squarefree_from_algebraic_set = prove(`
  !S.
  FINITE S ==>
  S SUBSET algebraic_number ==>
  (?p.
    ring_polynomial QinC_ring p /\
    ring_squarefree(x_poly QinC_ring) p /\
    monic QinC_ring p /\
    S SUBSET complex_root p /\
    (!z. complex_root p z ==> (?s. s IN S /\ minimal_polynomial s = minimal_polynomial z))
  )
`,
  intro THEN
  recall field_QinC THEN
  have `!z:complex. z IN S ==> ring_polynomial QinC_ring (minimal_polynomial z)` [SUBSET;IN;algebraic_has_minimal_polynomial] THEN
  have `!z:complex. z IN S ==> ~(minimal_polynomial z = poly_0 QinC_ring)` [SUBSET;IN;algebraic_has_minimal_polynomial] THEN
  specialize[
    `QinC_ring`;
    `minimal_polynomial`;
    `S:complex->bool`
  ]monic_lcm_set_exists THEN
  choose `p:(1->num)->complex` `ring_polynomial QinC_ring p /\ monic QinC_ring p /\ (!s:complex. s IN S ==> ring_divides(x_poly QinC_ring) (minimal_polynomial s) p) /\ (!d. ring_polynomial QinC_ring d ==> (!s. s IN S ==> ring_divides(x_poly QinC_ring) (minimal_polynomial s) d) ==> ring_divides(x_poly QinC_ring) p d)` [] THEN
  witness `p:(1->num)->complex` THEN
  intro THENL [
    qed[]
  ;
    recall UFD_x_poly_QinC THEN
    have `!z:complex. z IN S ==> minimal_polynomial z IN ring_carrier(x_poly QinC_ring)` [x_poly_use] THEN
    have `p IN ring_carrier(x_poly QinC_ring)` [x_poly_use] THEN
    have `!z:complex. z IN S ==> ring_divides(x_poly QinC_ring) (minimal_polynomial z) p` [] THEN
    have `~(p = ring_0(x_poly QinC_ring))` [x_poly_use;monic_poly_0;ring_1_0_QinC;in_complex_ring] THEN
    subgoal `!z:complex. z IN S ==> ring_squarefree(x_poly QinC_ring) (minimal_polynomial z)` THENL [
      intro THEN
      have `algebraic_number z` [SUBSET;IN] THEN
      have `ring_irreducible(x_poly QinC_ring) (minimal_polynomial z)` [SUBSET;IN;algebraic_has_minimal_polynomial] THEN
      qed[squarefree_if_irreducible_over_field]
    ; pass
    ] THEN
    have `!z:complex. z IN S ==> ring_divides(x_poly QinC_ring) (minimal_polynomial z) p` [] THEN
    have `!d. d IN ring_carrier (x_poly QinC_ring) ==> (!s:complex. s IN S ==> ring_divides (x_poly QinC_ring) (minimal_polynomial s) d) ==> ring_divides (x_poly QinC_ring) p d` [x_poly_use] THEN
    specialize[
      `x_poly QinC_ring`;
      `minimal_polynomial`;
      `S:complex->bool`;
      `p:(1->num)->complex`
    ]ring_squarefree_lcm_set THEN
    qed[]
  ;
    qed[]
  ;
    rw[SUBSET] THEN
    intro THEN
    rw[IN] THEN
    have `algebraic_number x` [SUBSET;IN] THEN
    have `poly_eval complex_ring (minimal_polynomial x) x = Cx(&0)` [algebraic_has_minimal_polynomial] THEN
    have `ring_divides(x_poly QinC_ring) (minimal_polynomial x) p` [] THEN
    choose `u:(1->num)->complex` `u IN ring_carrier(x_poly QinC_ring) /\ p = ring_mul(x_poly QinC_ring) (minimal_polynomial x) u` [ring_divides] THEN
    subgoal `p = poly_mul complex_ring (minimal_polynomial x) u:(1->num)->complex` THENL [
      recall subring_complex_QinC THEN
      have `ring_powerseries QinC_ring (minimal_polynomial x:(1->num)->complex)` [ring_polynomial] THEN
      have `ring_powerseries QinC_ring (u:(1->num)->complex)` [ring_polynomial;x_poly_use] THEN
      specialize_assuming[
        `complex_ring`;
        `QinC`;
        `minimal_polynomial x`;
        `u:(1->num)->complex`
      ]poly_mul_subring THEN
      qed[x_poly_use]
    ; pass
    ] THEN
    subgoal `poly_eval complex_ring (poly_mul complex_ring (minimal_polynomial x) u) x = (poly_eval complex_ring (minimal_polynomial x) x) * (poly_eval complex_ring u x)` THENL [
      rw[GSYM complex_ring_clauses] THEN
      specialize_assuming[
        `complex_ring`;
        `minimal_polynomial x`;
        `u:(1->num)->complex`;
        `x:complex`
      ]POLY_EVAL_MUL THEN
      qed[poly_complex_if_poly_QinC;x_poly_use;in_complex_ring]
    ; pass
    ] THEN
    have `poly_eval complex_ring (poly_mul complex_ring (minimal_polynomial x) u) x = Cx(&0) * (poly_eval complex_ring u x)` [] THEN
    complex_field_fact `Cx(&0) * (poly_eval complex_ring u x) = Cx(&0)` THEN
    have `poly_eval complex_ring (poly_mul complex_ring (minimal_polynomial x) u) x = Cx(&0)` [] THEN
    have `poly_eval complex_ring p x = Cx(&0)` [] THEN
    qed[complex_root]
  ;
    intro THEN
    recall UFD_x_poly_QinC THEN
    have `!s. s IN S ==> minimal_polynomial s IN ring_carrier (x_poly QinC_ring)` [x_poly_use] THEN
    have `p IN ring_carrier (x_poly QinC_ring)` [x_poly_use] THEN
    have `!s. s IN S ==> ring_divides (x_poly QinC_ring) (minimal_polynomial s) p` [] THEN
    subgoal `!d. d IN ring_carrier (x_poly QinC_ring) ==> (!s. s IN S ==> ring_divides (x_poly QinC_ring) (minimal_polynomial s) d) ==> ring_divides (x_poly QinC_ring) p d` THENL [
      rw[GSYM x_poly_use] THEN
      qed[]
    ; pass
    ] THEN
    have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;ring_1_0_QinC] THEN
    subgoal `~(p = ring_0 (x_poly QinC_ring))` THENL [
      rw[GSYM x_poly_use] THEN
      qed[]
    ; pass
    ] THEN
    have `algebraic_number z` [algebraic_number_root_QinC_poly;complex_root] THEN
    have `ring_irreducible (x_poly QinC_ring) (minimal_polynomial z)` [algebraic_has_minimal_polynomial] THEN
    have `ring_prime (x_poly QinC_ring) (minimal_polynomial z)` [prime_iff_irreducible_over_field;field_QinC] THEN
    specialize[
      `x_poly QinC_ring`;
      `minimal_polynomial`;
      `S:complex->bool`;
      `p:(1->num)->complex`;
      `minimal_polynomial z`
    ]ring_prime_divides_lcm_set THEN
    have `ring_divides(x_poly QinC_ring) (minimal_polynomial z) p` [minimal_polynomial_divides] THEN
    choose `s:complex` `s IN S /\ ring_divides (x_poly QinC_ring) (minimal_polynomial z) (minimal_polynomial s)` [] THEN
    witness `s:complex` THEN
    have `algebraic_number s` [SUBSET;IN] THEN
    have `ring_irreducible (x_poly QinC_ring) (minimal_polynomial s)` [algebraic_has_minimal_polynomial] THEN
    have `ring_prime (x_poly QinC_ring) (minimal_polynomial s)` [prime_iff_irreducible_over_field;field_QinC] THEN
    have `ring_associates (x_poly QinC_ring) (minimal_polynomial z) (minimal_polynomial s)` [ring_divides_associates_prime;integral_domain_x_poly_QinC] THEN
    have `monic QinC_ring (minimal_polynomial s)` [algebraic_has_minimal_polynomial] THEN
    have `monic QinC_ring (minimal_polynomial z)` [algebraic_has_minimal_polynomial] THEN
    recall field_QinC THEN
    specialize[
      `QinC_ring`;
      `minimal_polynomial z`;
      `minimal_polynomial s`
    ]monic_associates THEN
    qed[]
  ]
);;
```
### Informal statement
For all sets S, if S is finite and S is a subset of the set of algebraic numbers, then there exists a polynomial `p` such that: `p` is a polynomial over the ring `QinC_ring`; `p` is squarefree over the ring `x_poly QinC_ring`; `p` is monic over the ring `QinC_ring`; S is a subset of the set of complex roots of `p`; and for all complex numbers `z`, if `z` is a complex root of `p`, then there exists an `s` in S such that the minimal polynomial of `s` is equal to the minimal polynomial of `z`.

### Informal sketch
The proof demonstrates the existence of a monic, squarefree polynomial `p` with coefficients in `QinC_ring` that vanishes on a finite set `S` of algebraic numbers, and whose roots have the same minimal polynomials as the elements of `S`.

- Introduce the assumptions that `S` is finite and a subset of algebraic numbers.
- Apply `monic_lcm_set_exists` to obtain a polynomial `p` that is monic, has coefficients in `QinC_ring`, is divisible by the minimal polynomial of each element in `S`, and divides any polynomial with coefficients in `QinC_ring` that is divisible by the minimal polynomial of each element in `S`.
- Show that `p` is squarefree. This involves demonstrating that each minimal polynomial of elements in `S` is irreducible based on `squarefree_if_irreducible_over_field` and ring-squarefree based on `ring_squarefree_lcm_set`
- Show that the polynomial `p` vanishes on the elements of `S`. This is done by exploiting the fact that the minimal polynomial of an algebraic number vanishes on that number and divides `p`, and then using `POLY_EVAL_MUL`.
- Show that every root of `p` has the same minimal polynomial as some element in `S`. Use `ring_prime_divides_lcm_set` and `monic_associates` to prove that their minimal polynomials associate, so since they are monic they are equal.

### Mathematical insight
This theorem ensures that for any finite set of algebraic numbers, a polynomial exists that captures all and only the minimal polynomial information of the set. This is a crucial step in many algebraic arguments, as it allows one to work with a single polynomial instead of a set of algebraic numbers or their minimal polynomials. The result guarantees that constructing such a polynomial is always possible.

### Dependencies
- `algebraic_has_minimal_polynomial`
- `squarefree_if_irreducible_over_field`
- `monic_lcm_set_exists`
- `POLY_EVAL_MUL`
- `x_poly_use`
- `monic_poly_0`
- `ring_1_0_QinC`
- `in_complex_ring`
- `uFD_x_poly_QinC`
- `subring_complex_QinC`
- `poly_complex_if_poly_QinC`
- `complex_root`
- `ring_squarefree_lcm_set`
- `prime_iff_irreducible_over_field`
- `field_QinC`
- `algebraic_number_root_QinC_poly`
- `ring_prime_divides_lcm_set`
- `ring_divides_associates_prime`
- `integral_domain_x_poly_QinC`
- `monic_associates`


---

## squarefree_from_algebraic_set

### Name of formal statement
squarefree_from_algebraic_set

### Type of the formal statement
theorem

### Formal Content
```ocaml
let squarefree_from_algebraic_set = prove(`
  !S.
  FINITE S ==>
  S SUBSET algebraic_number ==>
  (?p.
    ring_polynomial QinC_ring p /\
    ring_squarefree(x_poly QinC_ring) p /\
    monic QinC_ring p /\
    S SUBSET complex_root p
  )
`,
  qed[minimal_squarefree_from_algebraic_set]
);;
```
### Informal statement
For all sets `S`, if `S` is finite and `S` is a subset of the algebraic numbers, then there exists a polynomial `p` with coefficients in the QinC_ring such that `p` is a ring polynomial, `p` is ring squarefree with respect to `x_poly QinC_ring`, `p` is monic with respect to QinC_ring, and `S` is a subset of the complex roots of `p`.

### Informal sketch
The proof proceeds by showing the existence of a polynomial with the desired properties given a finite set of algebraic numbers `S`.

- Given the finite set `S` of algebraic numbers, construct a minimal polynomial for each element `a` in `S`. This is done using `minimal_squarefree_from_algebraic_set`.
- Take the product of all these minimal polynomials to obtain a single polynomial `p`.
- This polynomial `p` will have the property that all elements of `S` are roots of `p`.
- Verify that the constructed polynomial `p` satisfies the required conditions: it's a `ring_polynomial`, `ring_squarefree`, and `monic`.

### Mathematical insight
This theorem establishes that given any finite set of algebraic numbers, there exists a squarefree monic polynomial with coefficients in the considered ring that has each of the given algebraic numbers as a root. This is a fundamental result in algebraic number theory, ensuring that we can always find a polynomial representation for any finite collection of algebraic numbers.

### Dependencies
- Theorem: `minimal_squarefree_from_algebraic_set`


---

## squarefree_from_algebraic_set_avoiding_0

### Name of formal statement
squarefree_from_algebraic_set_avoiding_0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let squarefree_from_algebraic_set_avoiding_0 = prove(`
  !S.
  FINITE S ==>
  S SUBSET algebraic_number ==>
  ~(Cx(&0) IN S) ==>
  (?p.
    ring_polynomial QinC_ring p /\
    ring_squarefree(x_poly QinC_ring) p /\
    monic QinC_ring p /\
    S SUBSET complex_root p /\
    ~(complex_root p (Cx(&0)))
  )
`,
  intro THEN
  specialize[`S:complex->bool`]minimal_squarefree_from_algebraic_set THEN
  choose `p:(1->num)->complex` `ring_polynomial QinC_ring p /\ ring_squarefree (x_poly QinC_ring) p /\ monic QinC_ring p /\ S SUBSET complex_root p /\ (!z. complex_root p z ==> (?s. s IN S /\ minimal_polynomial s = minimal_polynomial z))` [] THEN
  witness `p:(1->num)->complex` THEN
  simp[] THEN
  case `complex_root p (Cx(&0))` THENL [
    choose `s:complex` `s IN S /\ minimal_polynomial s = minimal_polynomial(Cx(&0))` [] THEN
    have `minimal_polynomial s = x_minus_const QinC_ring (Cx(&0))` [minimal_polynomial_QinC;QinC_0] THEN
    have `minimal_polynomial s = x_minus_const complex_ring (Cx(&0))` [x_minus_const_QinC_eq_x_minus_const_complex] THEN
    have `poly_eval complex_ring (x_minus_const complex_ring (Cx(&0))) s = Cx(&0)` [maybe_algebraic_minimal_polynomial] THEN
    have `poly_eval complex_ring (x_minus_const complex_ring (Cx(&0))) s = ring_sub complex_ring s (Cx(&0))` [eval_x_minus_const;in_complex_ring] THEN
    have `ring_sub complex_ring s (Cx(&0)) = Cx(&0)` [] THEN
    have `s - (Cx(&0)) = Cx(&0)` [ring_sub_complex] THEN
    complex_field_fact `s - (Cx(&0)) = Cx(&0) ==> s = Cx(&0)` THEN
    qed[]
  ; pass
  ] THEN
  qed[]
);;
```

### Informal statement
For any finite set `S` of algebraic numbers such that `0` is not in `S`, there exists a polynomial `p` with coefficients in the quotient field of integers inside the complex numbers (`QinC_ring`) that is squarefree (when viewed as a polynomial over the quotient field of integers in the complex numbers), monic (with respect to `QinC_ring`), all elements of `S` are roots of `p`, and `0` is not a root of `p`.

### Informal sketch
The proof proceeds as follows:
- Start with the assumption that `S` is a finite set of algebraic numbers that does not contain 0.
- Apply `minimal_squarefree_from_algebraic_set` (which states that for any finite subset S of algebraic numbers, there is a squarefree polynomial p with coefficients in the quotient field of integers inside the complex numbers (`QinC_ring`) that is monic whose roots include all elements of S).
- Choose such a polynomial `p`, and show that every root of `p` has the same minimal polynomial as some `s` in `S`.
- Perform a case split based on whether `Cx(&0)` (the complex number 0) is a root of `p`.
  - If `Cx(&0)` is a root of `p`, then there exists some `s` in `S` such that `minimal_polynomial s = minimal_polynomial (Cx(&0))`.
  - Show that `minimal_polynomial (Cx(&0)) = x_minus_const QinC_ring (Cx(&0))` and `minimal_polynomial s = x_minus_const QinC_ring (Cx(&0))`.
  - Show that `poly_eval complex_ring (x_minus_const complex_ring (Cx(&0))) s = Cx(&0)`.
  - Simplify the expression and show that `s = Cx(&0)`.
  - This contradicts the assumption that `Cx(&0)` is not in `S`. This completes the proof for the case where `Cx(&0)` is a root of `p`.
  - If `Cx(&0)` is not a root of `p`, then the goal is achieved, using the polynomial from `minimal_squarefree_from_algebraic_set`.
- Therefore, such a polynomial `p` exists such that all elements of `S` are roots of `p` and `0` is not a root of `p`.

### Mathematical insight
The theorem combines the result of constructing a squarefree polynomial for a finite set of algebraic numbers with the additional constraint that the constructed polynomial does not have 0 as a root given that 0 is not in the initial set. The core idea is that if 0 were to be a root, one could derive a contradiction because 0 would have to share the same minimal polynomial as some element of the original set, implying 0 is in the set, which is a contradiction.

### Dependencies
- `FINITE`
- `SUBSET`
- `algebraic_number`
- `Cx`
- `ring_polynomial`
- `QinC_ring`
- `ring_squarefree`
- `x_poly`
- `monic`
- `complex_root`
- `minimal_squarefree_from_algebraic_set`
- `minimal_polynomial`
- `QinC_0`
- `x_minus_const_QinC_eq_x_minus_const_complex`
- `maybe_algebraic_minimal_polynomial`
- `eval_x_minus_const`
- `in_complex_ring`
- `ring_sub_complex`
- `complex_field_fact`
- `minimal_polynomial_QinC`
- `x_minus_const`
- `poly_eval`
- `complex_ring`
- `ring_sub`

### Porting notes (optional)
- The theorem relies on the definition of algebraic numbers and their minimal polynomials. Ensure that these concepts are defined appropriately in the target proof assistant.
- The handling of quotient rings (`QinC_ring`) may require special attention depending on the target system.
- Be mindful of the differences in automation regarding algebraic manipulations and field facts.


---

## poly_vars_sum_poly_subset

### Name of formal statement
poly_vars_sum_poly_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) p:X->(V->num)->R U S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  (!s. s IN S ==> poly_vars r (p s) SUBSET U) ==>
  poly_vars r (ring_sum(poly_ring r (:V)) S p) SUBSET U
```

### Informal statement
For any ring `r`, set `S`, function `p` from `X` to polynomials in `V` over `r`, and set `U`, if `S` is finite, and for every `s` in `S`, `p s` is a polynomial over `r` and the variables of `p s` are a subset of `U`, then the variables of the ring sum of `p s` over `S` are a subset of `U`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: If `S` is empty, then the ring sum over `S` is zero. The variables of zero are empty, and the empty set is a subset of any set `U`. This uses `RING_SUM_CLAUSES`, `POLY_RING`, `POLY_VARS_0`, and `EMPTY_SUBSET`.

- Inductive step: Assuming the result holds for all subsets of `S` with size less than the size of `x INSERT S`, we want to show that the result holds for `x INSERT S`. The ring sum over `x INSERT S` is `p x + ring_sum S p`. If `p x` is a polynomial with variables a subset of `U` and `ring_sum S p` is a polynomial with variables a subset of `U`, then their sum is also polynomial with variables a subset of `U`. This uses `RING_SUM_CLAUSES`, `POLY_RING`, `POLY_VARS_ADD` and the assumption that `p x` and `ring_sum S p` are polynomials.

### Mathematical insight
This theorem states that if we sum a finite number of polynomials whose variables are all contained in a set `U`, then the variables of the resulting polynomial are also contained in `U`. It’s a basic closure result for polynomial variables under finite summation.

### Dependencies
- `FINITE_INDUCT_STRONG`
- `RING_SUM_CLAUSES`
- `POLY_RING`
- `POLY_VARS_0`
- `EMPTY_SUBSET`
- `POLY_VARS_ADD`
- `RING_SUM`
- `ring_polynomial`
- `ring_carrier`


---

## poly_vars_product_poly_subset

### Name of formal statement
poly_vars_product_poly_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_vars_product_poly_subset = prove(`
  !(r:R ring) p:X->(V->num)->R U S.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  (!s. s IN S ==> poly_vars r (p s) SUBSET U) ==>
  poly_vars r (ring_product(poly_ring r (:V)) S p) SUBSET U
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;POLY_RING;POLY_VARS_1;EMPTY_SUBSET]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    have `p(x:X):(V->num)->R IN ring_carrier(poly_ring r (:V))` [poly_in_full_ring] THEN
    simp[RING_PRODUCT_CLAUSES] THEN
    have `ring_powerseries r (p(x:X):(V->num)->R)` [ring_polynomial] THEN
    have `ring_powerseries r (ring_product(poly_ring r (:V)) S (p:X->(V->num)->R))` [RING_PRODUCT;ring_polynomial;poly_in_full_ring] THEN
    rw[POLY_RING] THEN
    specialize[
      `r:R ring`;
      `p(x:X):(V->num)->R`;
      `ring_product(poly_ring r (:V)) S (p:X->(V->num)->R)`
    ]POLY_VARS_MUL THEN
    ASM SET_TAC[]
  ]
);;
```
### Informal statement
For any ring `r` of type `R ring`, any function `p` from type `X` to functions from `V` to natural numbers to `R`, and any sets `U` and `S`, if `S` is finite, and for all `s` in `S`, `p s` is a ring polynomial with coefficients in `r`, and for all `s` in `S`, the variables appearing in `p s` are a subset of `U`, then the variables appearing in the product of the polynomials `p s` for `s` in `S` (with respect to the polynomial ring over `r` with variables `V`) are a subset of `U`.

### Informal sketch
The proof proceeds by strong induction on the finiteness of `S`.

- Base case: If `S` is empty, then the product is the ring identity `ring_one`. The variables of `ring_one` are empty, which is a subset of any set `U`.
- Inductive step: Assume the conclusion holds for all subsets of cardinality less than the cardinality of `x INSERT S`. We are given that `p(x:X)` is a ring polynomial. We must show that the variables of the product of polynomials indexed by `x INSERT S` are a subset of `U`. This product can be written as `ring_mul (p x)` with `ring_product S p`. Each of the polynomials `p x` and `ring_product S p` (by the inductive hypothesis) have the property that its variables are a subset of `U`. We use the lemma `POLY_VARS_MUL` that states that the variables of a product of two polynomials are a subset of the union of the variables of each polynomial. We complete the proof by noting that the union of subsets of `U` is contained in `U`.

### Mathematical insight
This theorem states that if you take the product of polynomials whose variables are restricted to a set `U`, then the variables of the resulting product will also be restricted to `U`. This is key to showing closure properties about polynomials with constrained variables.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POLY_RING`
- `POLY_VARS_1`
- `EMPTY_SUBSET`
- `POLY_VARS_MUL`
- `RING_PRODUCT`
- `ring_polynomial`

### Porting notes (optional)
- Ensure that the target system has a notion of polynomial rings and polynomial variables
- Ensure finiteness is expressed; in HOL Light, it is via a predicate `FINITE`. Other systems may use an explicit cardinal.


---

## poly_vars_pow

### Name of formal statement
poly_vars_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_vars_pow = prove(`
  !(r:R ring) p:(V->num)->R n.
  ring_powerseries r p ==>
  poly_vars r (poly_pow r p n)
  SUBSET poly_vars r p
`,
  GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0;POLY_VARS_1;EMPTY_SUBSET]
  ;
    intro THEN
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    simp[poly_pow_add;poly_pow_1] THEN
    have `ring_powerseries r (poly_pow r p n:(V->num)->R)` [poly_pow_series] THEN
    specialize[
      `r:R ring`;
      `p:(V->num)->R`;
      `poly_pow r p n:(V->num)->R`
    ]POLY_VARS_MUL THEN
    ASM SET_TAC[]
  ]
);;
```

### Informal statement
For any ring `r` over a type `R`, any function `p` from variables of type `V` to `num` to `R` which is a ring powerseries, and any natural number `n`, the set of variables `poly_vars` of the polynomial power `poly_pow r p n` is a subset of the set of variables `poly_vars` of `p`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`.  Show that `poly_pow r p 0` is the constant polynomial 1, hence `poly_vars r (poly_pow r p 0)` which is `POLY_VARS_1` and then show that `EMPTY_SUBSET` holds.
- Inductive step: Assume the result holds for `n`.  Show it also holds for `SUC n = 1 + n`.  Rewrite `poly_pow r p (1+n)` as `poly_pow r p 1 * poly_pow r p n = p * poly_pow r p n` using `poly_pow_add` and `poly_pow_1`. Using the assumption that `ring_powerseries r (poly_pow r p n)` along with `POLY_VARS_MUL` which states that `poly_vars r (p * q)` is a subset of `poly_vars r p UNION poly_vars r q`. By the inductive hypothesis, `poly_vars r (poly_pow r p n)` is a subset of `poly_vars r p`, hence `poly_vars r p UNION poly_vars r (poly_pow r p n)` is equal to `poly_vars r p`, and thus `poly_vars r (poly_pow r p (SUC n))` is a subset of `poly_vars r p`.

### Mathematical insight
This theorem states that raising a polynomial to the power `n` does not introduce any new variables, i.e., the variables of `p^n` must be a subset of the variables in `p`.

### Dependencies
- `ring_powerseries`
- `poly_pow_0`
- `POLY_VARS_1`
- `EMPTY_SUBSET`
- `poly_pow_add`
- `poly_pow_1`
- `POLY_VARS_MUL`


---

## poly_vars_pow_subset

### Name of formal statement
poly_vars_pow_subset

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_vars_pow_subset = prove(`
  !(r:R ring) p:(V->num)->R n U.
  ring_powerseries r p ==>
  poly_vars r p SUBSET U ==>
  poly_vars r (poly_pow r p n) SUBSET U
`,
  qed[poly_vars_pow;SUBSET_TRANS]
);;
```
### Informal statement
For all rings `r` with carrier type `R`, all power series `p` from variables of type `V` to `num`, all natural numbers `n`, and all sets `U` of variables of type `V`, if `p` is a ring powerseries and the variables of `p` are a subset of `U`, then the variables of `p` raised to the power of `n` are a subset of `U`.

### Informal sketch
The proof proceeds as follows:
- Assume `p` is a ring powerseries and `poly_vars r p` is a subset of `U`.
- Apply `poly_vars_pow` to show that `poly_vars r (poly_pow r p n)` is a subset of `poly_vars r p`.
- Apply `SUBSET_TRANS` to show that `poly_vars r (poly_pow r p n)` is a subset of `U`.

### Mathematical insight
This theorem states that raising a power series to a power does not introduce new variables if it's already a restricted power series. It is important for reasoning about power series with a finite number of variables.

### Dependencies

Theorems:
- `poly_vars_pow`
- `SUBSET_TRANS`


---

## poly_evaluate_pow

### Name of formal statement
poly_evaluate_pow

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_evaluate_pow = prove(`
  !(r:R ring) p:(V->num)->R q:V->R n.
  ring_polynomial r p ==>
  (!i. i IN poly_vars r p ==> q i IN ring_carrier r) ==>
  poly_evaluate r (poly_pow r p n) q
  = ring_pow r (poly_evaluate r p q) n
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  INDUCT_TAC THENL [
    rw[poly_pow_0;ring_pow;POLY_RING_CLAUSES;POLY_EVALUATE_1]
  ;
    rw[ring_pow] THEN
    rw[ARITH_RULE `SUC n = 1+n`] THEN
    intro THEN
    have `ring_powerseries r (p:(V->num)->R)` [ring_polynomial] THEN
    simp[poly_pow_add;poly_pow_1] THEN
    have `ring_polynomial r (poly_pow r p n:(V->num)->R)` [poly_pow_poly] THEN
    subgoal `!i. i IN poly_vars r p UNION poly_vars r (poly_pow r p n:(V->num)->R) ==> q i IN ring_carrier r` THENL [
      rw[IN_UNION] THEN
      qed[poly_vars_pow;SUBSET]
    ; pass
    ] THEN
    specialize[
      `r:R ring`;
      `p:(V->num)->R`;
      `poly_pow r p n:(V->num)->R`;
      `q:V->R`
    ]POLY_EVALUATE_MUL THEN
    qed[]
  ]
);;
```
### Informal statement
For any ring `r` with carrier `R`, any polynomial `p` over `r` with variables of type `V`, any function `q` from `V` to `R`, and any natural number `n`, if `p` is a ring polynomial over `r`, and for all `i` in the polynomial variables of `p`, `q i` is in the ring carrier of `r`, then evaluating the `n`-th power of `p` at `q` is equal to taking the `n`-th power of the evaluation of `p` at `q`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. The statement reduces to showing that evaluating the `0`-th power of p, which is `1`, at `q` gives `1`, which is then equal to the `0`-th power of evaluating `p` at `q` which is again `1`.
- Inductive step: Assume the theorem holds for `n`. We need to prove it for `SUC n = 1+n`.
    - Expand `ring_pow (poly_evaluate r p q) (SUC n)` to `ring_mul r (poly_evaluate r p q) (ring_pow r (poly_evaluate r p q) n)`.
    - We specialize `POLY_EVALUATE_MUL` given that `ring_polynomial r (poly_pow r p n)` is true by `poly_pow_poly`, and using the hypothesis that `q i` are in the carrier of r for any `i` in the support of `p` and `poly_pow r p n`, which are `poly_vars r p` and `poly_vars r (poly_pow r p n)` respectively. The inclusion holds since `poly_vars r (poly_pow r p n)` is a subset of `poly_vars r p`.

### Mathematical insight
The theorem states that evaluating a polynomial power `p^n` is the same as taking the `n`-th power of the evaluation of the polynomial `p`, assuming certain well-formedness conditions like the ring properties and that the substitution `q` is valid. This is a fundamental property used when dealing with polynomial evaluations. The well-formedness conditions ensure that all the operations (powers, evaluation at q) are permissible in the ring where the polynomial is defined.

### Dependencies
- `poly_pow_0`
- `ring_pow`
- `POLY_RING_CLAUSES`
- `POLY_EVALUATE_1`
- `ARITH_RULE`
- `poly_pow_add`
- `poly_pow_1`
- `poly_pow_poly`
- `IN_UNION`
- `poly_vars_pow`
- `SUBSET`
- `POLY_EVALUATE_MUL`

### Porting notes (optional)
- The main challenge in porting lies in correctly representing the ring and polynomial structures, along with the evaluation function. The conditions on `q` may need careful attention depending on how dependent types are handled in the target proof assistant.
- The automation relies heavily on rewriting and simplification; a similar level of automation may be necessary in other provers.


---

## poly_evaluate_sum

### Name of formal statement
poly_evaluate_sum

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_evaluate_sum = prove(`
  !(r:R ring) p:X->(V->num)->R q:V->R S:X->bool.
  FINITE S ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  poly_evaluate r (ring_sum(poly_ring r (:V)) S p) q
  = ring_sum r S (\s. poly_evaluate r (p s) q)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_SUM_CLAUSES;POLY_RING_CLAUSES;POLY_EVALUATE_0]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    subgoal `p(x:X):(V->num)->R IN ring_carrier(poly_ring r (:V))` THENL [
      rw[POLY_RING_CLAUSES;IN_ELIM_THM;SUBSET_UNIV] THEN
      qed[]
    ; pass
    ] THEN
    simp[RING_SUM_CLAUSES;POLY_EVALUATE] THEN
    rw[POLY_RING_CLAUSES] THEN
    qed[poly_in_full_ring;RING_SUM;POLY_EVALUATE_ADD]
  ]
);;
```
### Informal statement
For any ring `r` (with carrier denoted by `R`), any function `p` from a type `X` to functions from `V` to numbers to `R`, any function `q` from `V` to `R`, and any predicate `S` on `X`, if `S` is finite and for all `s` in `S`, `p(s)` is a ring polynomial over `r`, then the evaluation of the ring sum (over elements of `S` with summand `p`) at `q` equals the ring sum (over elements of `S` with summand equal to evaluating each `p(s)` at `q`).

### Informal sketch
The proof proceeds by strong induction on the finiteness of the set `S`.
- Base case: `S` is empty. We use rewrite rules for `RING_SUM_CLAUSES`, `POLY_RING_CLAUSES` and `POLY_EVALUATE_0` to simplify both sides to zero.
- Inductive step: Assuming the theorem holds for all subsets of size less than `SIZE(x INSERT S)`, we show it holds for `x INSERT S`.
  - We establish that `x` is in `x INSERT S`.
  - We establish that if `s` is in `S`, then `s` is in `x INSERT S`.
  - We show that `p(x)` inhabits the carrier of the ring `poly_ring r (:V)`. This is handled by rewriting with `POLY_RING_CLAUSES` and using `IN_ELIM_THM` and `SUBSET_UNIV`.
  - We simplify using `RING_SUM_CLAUSES` and `POLY_EVALUATE`.
  - We rewrite using `POLY_RING_CLAUSES`.
  - Finally, we apply `poly_in_full_ring`, `RING_SUM` and `POLY_EVALUATE_ADD` to complete the proof.

### Mathematical insight
This theorem states that evaluating a sum of polynomials is the same as summing the evaluations of each polynomial at a given point. This is a standard property of polynomials and ring homomorphisms. The theorem is important because it allows to interchange the operations of summation and evaluation, which is useful in many algebraic manipulations.

### Dependencies
- `RING_SUM_CLAUSES`
- `POLY_RING_CLAUSES`
- `POLY_EVALUATE_0`
- `IN_ELIM_THM`
- `SUBSET_UNIV`
- `RING_SUM_CLAUSES`
- `POLY_EVALUATE`
- `POLY_RING_CLAUSES`
- `poly_in_full_ring`
- `RING_SUM`
- `POLY_EVALUATE_ADD`
- `FINITE_INDUCT_STRONG`


---

## poly_evaluate_product

### Name of formal statement
poly_evaluate_product

### Type of the formal statement
theorem

### Formal Content
```ocaml
let poly_evaluate_product = prove(`
  !(r:R ring) p:X->(V->num)->R q:V->R S:X->bool.
  FINITE S ==>
  (!v. q v IN ring_carrier r) ==>
  (!s. s IN S ==> ring_polynomial r (p s)) ==>
  poly_evaluate r (ring_product(poly_ring r (:V)) S p) q
  = ring_product r S (\s. poly_evaluate r (p s) q)
`,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  sufficesby FINITE_INDUCT_STRONG THEN
  intro THENL [
    rw[RING_PRODUCT_CLAUSES;POLY_RING_CLAUSES;POLY_EVALUATE_1]
  ;
    set_fact `(x:X) IN x INSERT S` THEN
    set_fact `!s:X. s IN S ==> s IN x INSERT S` THEN
    subgoal `p(x:X):(V->num)->R IN ring_carrier(poly_ring r (:V))` THENL [
      rw[POLY_RING_CLAUSES;IN_ELIM_THM;SUBSET_UNIV] THEN
      qed[]
    ; pass
    ] THEN
    simp[RING_PRODUCT_CLAUSES;POLY_EVALUATE] THEN
    rw[POLY_RING_CLAUSES] THEN
    qed[poly_in_full_ring;RING_PRODUCT;POLY_EVALUATE_MUL]
  ]
);;
```

### Informal statement
For any ring `r` (with type `R ring`), any functions `p` from `X` to `(V -> num) -> R`, any function `q` from `V` to `R`, and any set `S` of type `X`, if `S` is finite, and for all `v`, `q v` is in the carrier of the ring `r`, and for all `s` in `S`, `p s` is a polynomial with coefficients in the ring `r`, then evaluating the polynomial `ring_product(poly_ring r (:V)) S p` at `q` is equal to the ring product in `r` over `S` of the evaluations of `p s` at `q`.

### Informal sketch
The theorem states that the evaluation of a product of polynomials is the product of the evaluations. The proof proceeds by strong induction on the finiteness of the set `S`.

- Base case: When `S` is empty. The theorem holds because the `ring_product` (of polynomials) over an empty set is the ring unit, and `poly_evaluate` of the ring unit returns the ring unit.
- Inductive step: Assume the theorem holds for all sets `S'` such that `FINITE S'` and `S'` has fewer elements than `S`. Let `S` be `x INSERT S'`, where `x` is an element. By assumption, `S` is finite. The goal is to show that the theorem holds for `S`.
  - Use `RING_PRODUCT_CLAUSES` and `POLY_RING_CLAUSES` and `POLY_EVALUATE_1` to simplify the left hand side.
  - The tactic `set_fact` introduces facts about the membership of the element `x` in `x INSERT S` and the membership of an element `s` in `x INSERT S` from the membership of `s` in `S`. We then show that `p x` is a polynomial over the subring `poly_ring r (:V)`.
  - Simplify using `RING_PRODUCT_CLAUSES` and `POLY_EVALUATE`.
  - Apply the induction hypothesis and use `poly_in_full_ring`, `RING_PRODUCT`, and `POLY_EVALUATE_MUL` to complete the proof.

### Mathematical insight
This theorem is important because it connects the algebraic operation of polynomial multiplication with evaluation. It shows that evaluating a product of polynomials at a point is the same as taking the product of the evaluations of the individual polynomials at that point. This is a fundamental property used in many areas of mathematics, especially algebra and algebraic geometry.

### Dependencies
- `RING_PRODUCT_CLAUSES`
- `POLY_RING_CLAUSES`
- `POLY_EVALUATE_1`
- `IN_ELIM_THM`
- `SUBSET_UNIV`
- `POLY_EVALUATE`
- `poly_in_full_ring`
- `RING_PRODUCT`
- `POLY_EVALUATE_MUL`

### Porting notes (optional)
When porting to other proof assistants, pay close attention to the definitions of rings, polynomials, and evaluation functions. The handling of finiteness conditions on sets may vary between systems, so ensure that the inductive step is correctly translated to respect these differences.


---

## vandermonde_indep_range

### Name of formal statement
vandermonde_indep_range

### Type of the formal statement
theorem

### Formal Content
```ocaml
!(r:R ring) n c v.
  integral_domain r ==>
  (!i. i < n ==> c i IN ring_carrier r) ==>
  (!i. i < n ==> v i IN ring_carrier r) ==>
  (!i j. i < n ==> j < n ==> v i = v j ==> i = j) ==>
  (!e. e < n ==> ring_sum r (range n) (\i. ring_mul r (c i) (ring_pow r (v i) e)) = ring_0 r) ==>
  (!i. i < n ==> c i = ring_0 r)
```
### Informal statement
For any ring `r` that is an integral domain, and for any natural number `n`, if `c` and `v` are functions from natural numbers to the carrier set of `r` such that the values `v i` are distinct for `i < n`, and if the weighted sum of powers of `v i`, `ring_sum r (range n) (\i. ring_mul r (c i) (ring_pow r (v i) e))`, equals the zero element of `r` for all `e < n`, then all the coefficients `c i` must be the zero element of `r` for `i < n`.

### Informal sketch
The proof proceeds by induction on `n`.

- Base case: `n = 0`. The statement is trivially true since the condition `i < 0` is always false.
- Inductive step: Assume the statement holds for `n`. We want to prove it for `n+1`.
    - Assume that `r` is an integral domain, `c i` and `v i` are in the carrier set of `r` for `i < n+1`, `v i` are distinct for `i < n+1`, and `ring_sum r (range (n+1)) (\i. ring_mul r (c i) (ring_pow r (v i) e))` equals `ring_0 r` for `e < n+1`.
    - Define a new function `d i = ring_mul r (c i) (ring_sub r (v i) (v n))` for `i` a natural number.
    - Show that `d i` is in the carrier set of `r` for `i < n`.
    - Show that `ring_sum r (range (n+1)) (\i. ring_mul r (d i) (ring_pow r (v i) e))` equals `ring_0 r` for all `e < n`. This involves expanding the sum, using the inductive hypothesis, and simplifying.
    - Apply the inductive hypothesis to `d` to conclude that `d i = ring_0 r` for all `i < n`.
    - Show that `c i = ring_0 r` for all `i < n`. This uses the fact that `r` is an integral domain and that `v i` are distinct.
    - Finally, show that `c n = ring_0 r`. This uses the assumption that  `ring_sum r (range (n+1)) (\i. ring_mul r (c i) (ring_pow r (v i) 0))` equals `ring_0 r`. Rewriting `ring_pow r (v i) 0` to `1` and using `ring_sum_range_add_1` extracts `c n` out of the `ring_sum`.

### Mathematical insight
This theorem states that if a linear combination of powers of distinct elements in a ring vanishes for a sufficient number of powers, then all the coefficients must be zero. This is a form of linear independence for powers of distinct elements and relates to the properties of Vandermonde matrices and determinants. The requirement that the ring `r` is an integral domain is crucial to guarantee that if a product is zero, at least one of the factors must be zero.

### Dependencies
- `integral_domain`
- `ring_carrier`
- `ring_sum`
- `range`
- `ring_mul`
- `ring_pow`
- `ring_0`
- `ring_sub`
- `RING_SUM_EQ`
- `RING_SUM_LMUL`
- `RING_MUL_RZERO`
- `RING_SUB_RZERO`
- `RING_0`
- `RING_SUB_REFL`
- `RING_MUL_LZERO`
- `RING_POW_0`
- `RING_MUL_RID`
-`ring_sum_range_add_1`
-`RING_SUB`
-`RING_MUL`

### Porting notes (optional)
- Ensure that the target proof assistant has a well-developed theory of rings and integral domains.
- The inductive proof strategy is standard, but the manipulation of `ring_sum` terms might require careful attention to indices and carrier sets.
- The HOL Light proof relies heavily on rewriting rules proved using `RING_TAC`. You'll need to find or create similar tactics or lemmas in other systems.


---

## vandermonde_indep

### Name of formal statement
vandermonde_indep

### Type of the formal statement
theorem

### Formal Content
```ocaml
let vandermonde_indep = prove(`
  !(r:R ring) S c v.
  integral_domain r ==>
  FINITE S ==>
  (!s:X. s IN S ==> c s IN ring_carrier r) ==>
  (!s. s IN S ==> v s IN ring_carrier r) ==>
  (!s t. s IN S ==> t IN S ==> v s = v t ==> s = t) ==>
  (!e. e < CARD S ==> ring_sum r S (\s. ring_mul r (c s) (ring_pow r (v s) e)) = ring_0 r) ==>
  (!s. s IN S ==> c s = ring_0 r)
`,
  intro THEN
  choose `f:num->X` `IMAGE f (range(CARD S)) = S:X->bool` [finite_ordering] THEN
  subgoal `!i. i < CARD(S:X->bool) ==> (c:X->R o f) i = ring_0 r` THENL [
    subgoal `!i. i < CARD(S:X->bool) ==> f i:X IN S` THENL [
      intro THEN
      have `i IN range(CARD(S:X->bool))` [range_lt] THEN
      once_rw[GSYM(know `IMAGE f (range(CARD S)) = S:X->bool`)] THEN
      rw[IN_IMAGE] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `!i. i < CARD(S:X->bool) ==> (c:X->R o f) i:R IN ring_carrier r` THENL [
      rw[o_THM] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `!i. i < CARD(S:X->bool) ==> (v:X->R o f) i:R IN ring_carrier r` THENL [
      rw[o_THM] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `!i j. i < CARD(S:X->bool) ==> j < CARD S ==> (v:X->R o f) i = (v o f) j ==> i = j` THENL [
      rw[o_THM] THEN
      intro THEN
      have `f(i:num):X = f j` [] THEN
      qed[injective_finite_ordering]
    ; pass
    ] THEN
    subgoal `!e. e < CARD(S:X->bool) ==> ring_sum r (range (CARD S)) (\i. ring_mul r ((c:X->R o f) i) (ring_pow r ((v o f) i) e)) = ring_0 r:R` THENL [
      rw[o_THM] THEN
      intro THEN
      have `!x y. x IN range (CARD(S:X->bool)) ==> y IN range (CARD S) ==> f x = f y:X ==> x = y` [injective_finite_ordering;range_lt] THEN
      specialize[
        `r:R ring`;
        `f:num->X`;
        `\s:X. ring_mul r (c s) (ring_pow r (v s) e):R`;
        `range(CARD(S:X->bool))`
      ]RING_SUM_IMAGE THEN
      have `ring_sum r S (\s:X. ring_mul r (c s) (ring_pow r (v s) e)) = ring_0 r:R` [] THEN
      have `ring_sum r (IMAGE f (range (CARD(S:X->bool)))) (\s:X. ring_mul r (c s) (ring_pow r (v s) e)) = ring_0 r:R` [] THEN
      have `ring_sum r (range (CARD(S:X->bool))) ((\s:X. ring_mul r (c s) (ring_pow r (v s) e)) o f) = ring_0 r:R` [] THEN
      subgoal `ring_sum r (range (CARD S)) (\i. ring_mul r (c (f i)) (ring_pow r (v (f i)) e)) = ring_sum r (range (CARD(S:X->bool))) ((\s:X. ring_mul r (c s) (ring_pow r (v s) e)) o f):R` THENL [
        rw[o_DEF]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `r:R ring`;
      `CARD(S:X->bool)`;
      `c:X->R o f:num->X`;
      `v:X->R o f:num->X`
    ]vandermonde_indep_range THEN
    qed[]
  ; pass
  ] THEN
  choose `i:num` `i IN range(CARD(S:X->bool)) /\ s:X = f i` [IN_IMAGE] THEN
  have `i < CARD(S:X->bool)` [range_lt] THEN
  have `c(f(i:num):X):R = ring_0 r` [o_THM] THEN
  qed[injective_finite_ordering]
);;
```
### Informal statement
For any ring `r` (with carrier set `ring_carrier r`, zero `ring_0 r`, addition `ring_add r`, multiplication `ring_mul r`, and power `ring_pow r`), any set `S`, any functions `c` and `v` from `X` to the carrier of `r`, if:
1. `r` is an integral domain,
2. `S` is finite,
3. for all `s` in `S`, `c s` is in the carrier of `r`,
4. for all `s` in `S`, `v s` is in the carrier of `r`,
5. for all `s` and `t` in `S`, if `v s = v t`, then `s = t` (i.e., `v` is injective on `S`),
6. for all `e` less than the cardinality of `S`, the ring sum of `c s * v s ^ e` over all `s` in `S` is equal to the zero of `r`,

then for all `s` in `S`, `c s` is equal to the zero of `r`.

### Informal sketch
The proof demonstrates that if a linear combination of powers of distinct elements `v s` in a ring `r` (where the coefficients are `c s`) sums to zero for all powers less than the cardinality of the set `S`, then all coefficients `c s` must be zero. This leverages the properties of integral domains and finite sets:

- Assume the hypotheses and aim to show `!s. s IN S ==> c s = ring_0 r`.
- Choose an arbitrary element `s` in `S`.
- Since `S` is finite, choose a bijection `f` from `range (CARD S)` to `S`.
- It suffices to show that `c (f i) = ring_0 r` for all `i < CARD S`.
- Show that `f i IN S` for `i < CARD S`.
- Show that `c (f i) IN ring_carrier r` for `i < CARD S`.
- Show that `v (f i) IN ring_carrier r` for `i < CARD S`.
- Show injectivity: `v (f i) = v (f j)` implies `i = j` for `i, j < CARD S`.
- Show that `ring_sum r (range (CARD S)) (\i. ring_mul r (c (f i)) (ring_pow r (v (f i)) e)) = ring_0 r` for all `e < CARD S`.
 - Apply `RING_SUM_IMAGE` to rewrite the sum over `S` to a sum over `range (CARD S)`.
- Use `vandermonde_indep_range`, which is presumably a separate lemma establishing the result for sums over ranges.
- Then, choose `i:num` such that `i IN range(CARD(S:X->bool)) /\ s:X = f i` and show that that `c(f i) = ring_0 r`, which completes the proof.

### Mathematical insight
The theorem formalizes a version of Vandermonde's independence. It states that given a set of distinct elements, a specific condition involving sums of powers implies that some coefficients must be zero. The injectivity condition on `v` ensures that the elements whose powers are being considered are distinct, which is crucial for the Vandermonde matrix to be non-singular, and hence for the linear independence argument to work. The condition that `r` is an integral domain is necessary to ensure that polynomial rings over `r` have the right properties, in particular that if `p(x) = 0` for infinitely many values of `x` then `p` is the zero polynomial.

### Dependencies
- `integral_domain`
- `FINITE`
- `ring_carrier`
- `ring_sum`
- `ring_mul`
- `ring_pow`
- `ring_0`
- `injective_finite_ordering`
- `range_lt`
- `o_THM`
- `IN_IMAGE`
- `GSYM`
- `IMAGE`
- `vandermonde_indep_range`
- `IN_IMAGE`


---

## expformal_linearly_independent

### Name of formal statement
expformal_linearly_independent

### Type of the formal statement
theorem

### Formal Content
```ocaml
let expformal_linearly_independent = prove(`
  !S:complex->bool B:complex->complex.
  FINITE S ==>
  poly_sum complex_ring S (
    \z. poly_mul complex_ring (
      poly_const complex_ring (B z)
    ) (
      expformal z
    )
  ) = poly_0 complex_ring ==>
  (!z. z IN S ==> B z = Cx(&0))
`,
  intro THEN
  subgoal `!d. ring_sum complex_ring S (\z:complex. B z * z pow d) = Cx(&0)` THENL [
    intro THEN
    have `coeff d (poly_0 complex_ring) = Cx(&0)` [coeff_poly_0;complex_ring_clauses] THEN
    subgoal `coeff d (poly_sum complex_ring S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z))) = ring_sum complex_ring S (\z. coeff d (poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z)))` THENL [
      specialize[
        `complex_ring`;
        `\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z)`
      ]coeff_poly_sum THEN
      qed[series_complex]
    ; pass
    ] THEN
    subgoal `ring_sum complex_ring S (\z. coeff d (poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z))) = ring_sum complex_ring S (\z. (B z * z pow d) / Cx(&(FACT d)))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      simp[coeff_poly_const_times;series_complex;in_complex_ring] THEN
      rw[expformal;coeff_series_from_coeffs;complex_ring_clauses] THEN
      CONV_TAC COMPLEX_FIELD
    ; pass
    ] THEN
    subgoal `ring_sum complex_ring S (\z. (B z * z pow d) / Cx(&(FACT d))) = ring_sum complex_ring S (\z. B z * z pow d) / Cx(&(FACT d))` THENL [
      simp[GSYM vsum_ring_sum_complex] THEN
      rw[complex_div] THEN
      specialize[
        `inv(Cx(&(FACT d)))`;
        `\z:complex. B z * z pow d`;
        `S:complex->bool`
      ]VSUM_COMPLEX_RMUL THEN
      qed[]
    ; pass
    ] THEN
    have `ring_sum complex_ring S (\z. B z * z pow d) / Cx(&(FACT d)) = Cx (&0)` [] THEN
    have `~(FACT d = 0)` [FACT_NZ] THEN
    have `~(&(FACT d) = &0:real)` [REAL_OF_NUM_EQ] THEN
    have `~(Cx(&(FACT d)) = Cx(&0))` [CX_INJ] THEN
    complex_field_fact `~(Cx (&(FACT d)) = Cx (&0)) ==> ring_sum complex_ring S (\z. B z * z pow d) / Cx (&(FACT d)) = Cx (&0) ==> ring_sum complex_ring S (\z. B z * z pow d) = Cx (&0)` THEN
    qed[]
  ; pass
  ] THEN
  recall integral_domain_complex THEN
  have `!s:complex. s IN S ==> B s IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `!s:complex. s IN S ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `!s t:complex. s IN S ==> t IN S ==> I s = I t ==> s = t` [I_THM] THEN
  subgoal `!e. e < CARD S ==> ring_sum complex_ring S (\s. ring_mul complex_ring (B s) (ring_pow complex_ring (I s) e)) = ring_0 complex_ring` THENL [
    rw[I_THM;ring_pow_complex;complex_ring_clauses] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `complex_ring`;
    `S:complex->bool`;
    `B:complex->complex`;
    `I:complex->complex`
  ]vandermonde_indep THEN
  qed[complex_ring_clauses]
);;
```

### Informal statement
For all sets `S` of complex numbers and all functions `B` from complex numbers to complex numbers, if `S` is finite and if the sum, over all `z` in `S`, of `B(z)` times `expformal(z)` is the zero polynomial, then `B(z)` is zero for all `z` in `S`.

### Informal sketch
The proof demonstrates that if a finite linear combination of `expformal` functions (parameterized by elements of `S`) equals the zero polynomial, then all coefficients `B(z)` must be zero.

- The proof begins by assuming the hypothesis: `FINITE S` and that the ring sum of `B z * expformal z` over `S` is the zero polynomial (using `poly_sum`, `poly_mul`, `poly_const`, `poly_0`, and `complex_ring`).

- The goal is to show that `B z = Cx(&0)` for all `z` in `S`.

- A subgoal is introduced to show that `ring_sum complex_ring S (\z:complex. B z * z pow d) = Cx(&0)` holds for any `d`.
  - It's shown that coefficient `d` of `poly_0 complex_ring` is `Cx(&0)` using `coeff_poly_0` and `complex_ring_clauses`.
  - The proof proceeds by showing that the d-th coefficient of `poly_sum complex_ring S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z))` is equal to `ring_sum complex_ring S (\z. coeff d (poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z)))`, which uses `coeff_poly_sum` and `series_complex`.
  - The subsequent step equates `ring_sum complex_ring S (\z. coeff d (poly_mul complex_ring (poly_const complex_ring (B z)) (expformal z)))` with `ring_sum complex_ring S (\z. (B z * z pow d) / Cx(&(FACT d)))`.
    This is done using `coeff_poly_const_times`, `series_complex`, `expformal`, `coeff_series_from_coeffs` and `complex_ring_clauses`. Some field arithmetic simplifications are done with `CONV_TAC COMPLEX_FIELD`.
  - Next, `ring_sum complex_ring S (\z. (B z * z pow d) / Cx(&(FACT d)))` is equated with `ring_sum complex_ring S (\z. B z * z pow d) / Cx(&(FACT d))` by using `GSYM vsum_ring_sum_complex` and `VSUM_COMPLEX_RMUL`
  - From `ring_sum complex_ring S (\z. B z * z pow d) / Cx(&(FACT d)) = Cx (&0)`, and using the fact that `Cx(&(FACT d))` is not zero, it's inferred that `ring_sum complex_ring S (\z. B z * z pow d) = Cx (&0)` by field arithmetic.
  - These steps reduce the problem to showing the vanishing of a Vandermonde-like matrix.

- The proof uses `I_THM` to show that for all `s` and `t` in `S`, if `I s = I t`, then `s = t`

- Given this equality, the proof applies the `vandermonde_indep` theorem to conclude that `B z = Cx(&0)` for all `z` in S.

### Mathematical insight
The theorem states that the `expformal` functions parameterized by distinct elements of a finite set are linearly independent. This is a crucial property for many applications. The proof reduces the linear independence argument to a Vandermonde matrix structure.

### Dependencies
- `FINITE`
- `poly_sum`
- `complex_ring`
- `poly_mul`
- `poly_const`
- `expformal`
- `poly_0`
- `Cx`
- `coeff_poly_0`
- `coeff_poly_sum`
- `series_complex`
- `coeff_poly_const_times`
- `coeff_series_from_coeffs`
-`complex_ring_clauses`
- `vsum_ring_sum_complex`
- `VSUM_COMPLEX_RMUL`
- `FACT_NZ`
- `REAL_OF_NUM_EQ`
- `CX_INJ`
- `integral_domain_complex`
- `in_complex_ring`
- `I_THM`
- `ring_pow_complex`
-`vandermonde_indep`
### Porting notes (optional)
The theorem relies on the representation of polynomials and complex numbers. The `expformal` series representation is crucial and must be handled carefully during porting. The `vandermonde_indep` theorem needs to be ported or proven within the target system. The notion of `ring_sum` and `ring_mul` of `complex_ring` should be carefully considered during translation into other systems.


---

## expformal_perm_linearly_independent

### Name of formal statement
expformal_perm_linearly_independent

### Type of the formal statement
theorem

### Formal Content
```ocaml
let expformal_perm_linearly_independent = prove(`
  !S:complex->bool B:complex->complex i:complex->complex.
  FINITE S ==>
  i permutes S ==>
  poly_sum complex_ring S (
    \z. poly_mul complex_ring (
      poly_const complex_ring (B z)
    ) (
      expformal (i z)
    )
  ) = poly_0 complex_ring ==>
  (!z. z IN S ==> B z = Cx(&0))
`,
  intro THEN
  subgoal `poly_sum complex_ring S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z))) = poly_sum complex_ring S (\z. poly_mul complex_ring ( poly_const complex_ring (B(inverse i z))) (expformal z))` THENL [
    rw[poly_sum] THEN
    have `!x y:complex. x IN S ==> y IN S ==> i x = i y:complex ==> x = y` [PERMUTES_INJECTIVE] THEN
    specialize[
      `x_series complex_ring`;
      `i:complex->complex`;
      `\z. poly_mul complex_ring (poly_const complex_ring (B (inverse i z:complex))) (expformal z)`;
      `S:complex->bool`
    ]RING_SUM_IMAGE THEN
    have `IMAGE (i:complex->complex) S = S` [PERMUTES_IMAGE] THEN
    have_rw` ring_sum (x_series complex_ring) S (\z. poly_mul complex_ring (poly_const complex_ring (B(inverse i z))) (expformal z)) = ring_sum (x_series complex_ring) S ((\z. poly_mul complex_ring (poly_const complex_ring (B (inverse i z))) (expformal z)) o i)` [] THEN
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;o_THM] THEN
    qed[PERMUTES_INVERSES]
  ; pass
  ] THEN
  have `!z:complex. z IN S ==> B(inverse i z:complex) = Cx(&0)` [expformal_linearly_independent] THEN
  intro THEN
  have `z = (inverse i) (i z:complex):complex` [PERMUTES_INVERSES] THEN
  have `i(z:complex):complex IN S` [PERMUTES_IN_IMAGE] THEN
  qed[]
);;
```
### Informal statement
For any set `S` of complex numbers, any functions `B` and `i` mapping complex numbers to complex numbers, if `S` is finite and `i` permutes `S` and the sum over all `z` in `S` of `B(z) * expformal(i(z))` is the zero polynomial, then for all `z` in `S`, `B(z)` is the complex number 0.

### Informal sketch
The proof proceeds as follows:
- Assume `S` is a finite set of complex numbers, `i` permutes `S`, and the sum over `z` in `S` of `B(z) * expformal(i(z))` is equal to the zero polynomial.

- The first subgoal is to show that `poly_sum complex_ring S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z))) = poly_sum complex_ring S (\z. poly_mul complex_ring ( poly_const complex_ring (B(inverse i z))) (expformal z))`. This involves rewriting the sum over `S` and using the properties of permutations (`PERMUTES_INJECTIVE`, `PERMUTES_IMAGE`, `PERMUTES_INVERSES`). The tactic `RING_SUM_IMAGE` specializes a theorem about sums of images under a ring.

- Then, we pass to the main stage, referencing the theorem `expformal_linearly_independent` given that the sum over all `z` in `S` of `B(inverse i z) * expformal(z)` is the zero polynomial, it follows that `B(inverse i z)` is zero for all `z` in `S`.
- Finally, using that `i` permutes `S` again, the fact that `inverse i (i z) = z` and `i(z)` is an element of S, the result `B(z) = 0` is proven for all `z` in `S`.

### Mathematical insight
This theorem states that if a finite set of exponential formal power series, with the exponents being permutations of the given set, sum to zero, then the coefficients must all be zero. This shows that the exponentials of permuted sets remain linearly independent. This is a stronger result compared to the standard linear independence as it incorporates the more specific condition that exponents are permutations.

### Dependencies
- `PERMUTES_INJECTIVE`
- `RING_SUM_IMAGE`
- `PERMUTES_IMAGE`
- `PERMUTES_INVERSES`
- `expformal_linearly_independent`
- `BETA_THM`
- `o_THM`


---

## ring_product_perm_sum_mul_exp_expand

### Name of formal statement
ring_product_perm_sum_mul_exp_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_perm_sum_mul_exp_expand = prove(`
  !(a:A ring) (b:B ring) E:A->B c:A->B S:A->bool.
  (!x:A. x IN ring_carrier a ==>
         E x IN ring_carrier b) ==>
  E(ring_0 a) = ring_1 b ==>
  (!x y:A. E(ring_add a x y)
           = ring_mul b (E x) (E y)) ==>
  FINITE S ==>
  S SUBSET ring_carrier a ==>
  (!s:A. s IN S ==> c s IN ring_carrier b) ==>
  ring_product b (perm S) (
    \i. ring_sum b S (
      \z. ring_mul b (c z) (E(i z))
    )
  )
  =
  ring_sum b (
    IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)
  ) (
    \e.
      ring_mul b (
        ring_product b {y | ~(e y = 0)} (
          \y. ring_pow b (c y) (e y)
        )
      ) (
        ring_sum b {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} (
          E o (\f. ring_sum a (perm S) (\i. i (f i)))
        )
      )
  )
`,
  intro THEN
  rw[o_DEF] THEN
  have `FINITE(perm(S:A->bool))` [finite_perm] THEN
  have `FINITE(functions (perm S) (S:A->bool))` [finite_functions] THEN
  subgoal `!p q. p IN perm S ==> q:A IN S ==> p q IN S` THENL [
    intro THEN
    have `p:A->A permutes S` [perm;IN] THEN
    qed[PERMUTES_IN_IMAGE]
  ; pass
  ] THEN
  have `!f p. f IN functions (perm S) S ==> p IN perm S ==> f p:A IN S` [image_functions_subset;SUBSET;IN_IMAGE] THEN
  have `!q:A. q IN S ==> q IN ring_carrier a` [SUBSET] THEN
  have `!p q. p IN perm S ==> q:A IN S ==> ring_mul b (c q) (E(p q)):B IN ring_carrier b` [RING_MUL] THEN
  specialize[
    `b:B ring`;
    `\i:A->A z:A. ring_mul b (c z) (E(i z)):B`;
    `S:A->bool`;
    `perm(S:A->bool)`
  ]ring_product_sum_expand THEN
  simp[] THEN
  subgoal `ring_sum b (functions (perm S) S) (\f. ring_product b (perm S) (\i:A->A. ring_mul b (c (f i)) (E (i (f i))))) = ring_sum b (functions (perm S) S) (\f. ring_mul b (ring_product b (perm S) (c o f)) (E(ring_sum a (perm S) (\i. i(f i))))):B` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;o_DEF] THEN
    intro THEN
    have `!i:A->A. i IN perm S ==> c(a' i:A):B IN ring_carrier b /\ E(i(a' i)) IN ring_carrier b` [] THEN
    specialize[
      `b:B ring`;
      `\i. c ((a':(A->A)->A) i):B`;
      `\i. E(i((a':(A->A)->A) i)):B`;
      `perm(S:A->bool)`
    ]RING_PRODUCT_MUL THEN
    simp[] THEN
    subgoal `E (ring_sum a (perm S) (\i:A->A. i (a' i))) = ring_product b (perm S) (E o (\i. i (a' i))):B` THENL [
      sufficesby ring_exp_sum THEN
      qed[]
    ; pass
    ] THEN
    simp[o_DEF]
  ; pass
  ] THEN
  simp[] THEN
  subgoal `ring_sum b (functions (perm S) S) (\f. ring_mul b (ring_product b (perm S) (c o f)) (E(ring_sum a (perm S) (\i. i(f i))))) = ring_sum b (functions (perm S) S) (\f. ring_mul b (ring_product b {y | ~(numpreimages f (perm S) y = 0)} (\y. ring_pow b (c y) (numpreimages f (perm S) y))) (E(ring_sum a (perm S) (\i:A->A. i(f i)))):B)` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM] THEN
    intro THEN
    subgoal `!y:A. y IN IMAGE a' (perm(S:A->bool)) ==> c y:B IN ring_carrier b` THENL [
      rw[IN_IMAGE] THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `b:B ring`;
      `perm(S:A->bool)`;
      `a':(A->A)->A`;
      `c:A->B`
    ]ring_product_o_v2 THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  specialize[
    `b:B ring`;
    `\f:(A->A)->A. numpreimages f (perm S)`;
    `\f:(A->A)->A. ring_mul b (ring_product b {y | ~(numpreimages f (perm S) y = 0)} (\y. ring_pow b (c y) (numpreimages f (perm S) y))) (E (ring_sum a (perm S) (\i. i (f i)))):B`;
    `functions (perm S) (S:A->bool)`
  ]RING_SUM_IMAGE_GEN THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM;IN_IMAGE] THEN
  intro THEN
  specialize[
    `functions (perm S) (S:A->bool)`;
    `\f:(A->A)->A. numpreimages f (perm S) = a'`
  ]FINITE_RESTRICT THEN
  subgoal `ring_sum b {x:(A->A)->A | x IN functions (perm S) S /\ numpreimages x (perm S) = a'} (\g. ring_mul b (ring_product b {y | ~(numpreimages g (perm S) y = 0)} (\y. ring_pow b (c y) (numpreimages g (perm S) y))) (E (ring_sum a (perm S) (\i. i (g i)))):B) = ring_sum b {x | x IN functions (perm S) S /\ numpreimages x (perm S) = a'} (\g. ring_mul b (ring_product b {y | ~(a' y = 0)} (\y. ring_pow b (c y) (a' y))) (E (ring_sum a (perm S) (\i. i (g i)))))` THENL [
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;IN_ELIM_THM] THEN
    simp[]
  ; pass
  ] THEN
  simp[] THEN
  specialize_assuming[
    `b:B ring`;
    `\f:(A->A)->A. E (ring_sum a (perm S) (\i. i (f i))):B`;
    `ring_product b {y | ~(numpreimages x (perm(S:A->bool)) y = 0)} (\a:A. ring_pow b (c a) (numpreimages x (perm S) a)):B`;
    `{f:(A->A)->A | f IN functions (perm S) S /\ numpreimages f (perm S) = numpreimages x (perm S)}`
  ]RING_SUM_LMUL THEN
  qed[RING_PRODUCT;RING_SUM]
);;
```

### Informal statement
Let `a` and `b` be rings of type `A ring` and `B ring` respectively. Let `E` be a function from `A` to `B`, `c` be a function from `A` to `B`, and `S` be a predicate on `A` (i.e., `S` is a function from `A` to `bool`).
Suppose that for all `x` in the carrier of ring `a`, `E(x)` is in the carrier of ring `b`. Suppose also that `E(ring_0 a) = ring_1 b`, and for all `x` and `y` in `A`, `E(ring_add a x y) = ring_mul b (E x) (E y)`.
If `S` is finite and a subset of the carrier of ring `a`, and for all `s` in `S`, `c s` is in the carrier of ring `b`, then the following equality holds:

```
ring_product b (perm S) (λi. ring_sum b S (λz. ring_mul b (c z) (E(i z))))
=
ring_sum b (IMAGE (λf. numpreimages f (perm S)) (functions (perm S) S)) 
(λe. ring_mul b (ring_product b {y | ¬(e y = 0)} (λy. ring_pow b (c y) (e y))) 
(ring_sum b {f | f ∈ functions (perm S) S ∧ numpreimages f (perm S) = e} (E o (λf. ring_sum a (perm S) (λi. i(f i))))))
```

Here, `perm S` denotes the permutations of `S`, `functions (perm S) S` represents all functions from `perm S` to `S`, `numpreimages f (perm S)` is the function that maps each element `y` of `A` to the number of elements in `perm S` that `f` maps to `y`, and `IMAGE f S` is the image of the set `S` under the function `f`.

### Informal sketch
The theorem states an expansion of a product of sums in rings, where the product is indexed by permutations of some set `S`. The main steps of the proof are as follows:

- The proof starts by introducing all the assumptions using `intro`.
- It then proves that `perm S` is finite and `functions (perm S) S` is finite using `finite_perm` and `finite_functions`.
- Show that domain and range conditions regarding permutations `perm S` and functions from `perm S` to `S` are met.
- Apply `ring_product_sum_expand`: This expands the product of sums into sum of products indexed by functions from `perm S` to `S`.
- Rewrite a subterm using `ring_exp_sum`.
- A key step involves using `ring_product_o_v2`, and simplifying using `o_DEF`.
- Apply `RING_SUM_IMAGE_GEN` to go from summing over functions to summing over the number of preimages to arrive at the final expression.
- In the end several rewrites using `BETA_THM`, `IN_ELIM_THM` and `RING_SUM_LMUL` allow the final proof.

### Mathematical insight
This theorem provides a complex algebraic identity that expands a product of sums in a non-commutative ring. The left-hand side involves a product over all permutations of a set S, while the right-hand side involves a sum over the number of preimages related to functions from the set of permutations of S to S, including the sum of evaluation of ring exponentials. The usefulness is limited due to the number of predicates; it is likely that such a theorem is required as part of a larger piece of theory.

### Dependencies
- `o_DEF`
- `PERMUTES_IN_IMAGE`
- `image_functions_subset`
- `SUBSET`
- `IN_IMAGE`
- `RING_MUL`
- `RING_PRODUCT_SUM_EXPAND`
- `BETA_THM`
- `RING_SUM_EQ`
- `RING_PRODUCT_MUL`
- `ring_exp_sum`
- `ring_product_o_v2`
- `RING_SUM_IMAGE_GEN`
- `IN_IMAGE`
- `FINITE_RESTRICT`
- `IN_ELIM_THM`
- `RING_SUM_LMUL`
- `RING_PRODUCT`
- `RING_SUM`

### Porting notes (optional)
This theorem involves significant manipulation of sums and products within a ring structure. Porting it to another proof assistant might require careful attention to proper handling of ring axioms and the finiteness conditions.
The use of `perm` and `functions` datatypes would need equivalent constructions in the target proof assistant, along with the `numpreimages` counting function.
Automation might be difficult. Consider replaying the proof step by step.


---

## product_perm_sum_mul_cexp_expand

### Name of formal statement
product_perm_sum_mul_cexp_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_perm_sum_mul_cexp_expand = prove(`
  !c:complex->complex S:complex->bool.
  FINITE S ==>
  ring_product complex_ring (perm S) (
    \i. ring_sum complex_ring S (
      \z. ring_mul complex_ring (c z) (cexp(i z))
    )
  )
  =
  ring_sum complex_ring (
    IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)
  ) (
    \e.
      ring_product complex_ring {y | ~(e y = 0)} (
        \y. (c y) pow (e y)
      )
      *
      ring_sum complex_ring {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} (
        cexp o (\f. ring_sum complex_ring (perm S) (\i. i (f i)))
      )
  )
`,
  intro THEN
  rw[GSYM ring_pow_complex] THEN
  rw[GSYM complex_ring_clauses] THEN
  specialize_assuming[
    `complex_ring`;
    `complex_ring`;
    `cexp`;
    `c:complex->complex`;
    `S:complex->bool`
  ]ring_product_perm_sum_mul_exp_expand THEN
  qed[in_complex_ring;CEXP_0;CEXP_ADD;SUBSET;complex_ring_clauses]
);;
```
### Informal statement
For any function `c` from complex numbers to complex numbers, and any predicate `S` on complex numbers such that the set `{x | S x}` is finite, the product, indexed by elements `i` in the permutations of `S`, of the sum, indexed by elements `z` satisfying `S`, of `c z` multiplied by `cexp(i z)`, is equal to the sum, indexed by the image under `numpreimages` of functions from the permutations of `S` to `S`, of the product, indexed by `y` such that `e y` is not zero, of `c y` raised to the power of `e y`, multiplied by the sum, indexed by `f` in the functions from the permutations of `S` to `S` having the property that the number of preimages under `f` in the permutations of `S` is equal to `e`, of `cexp` composed with the sum, indexed by `i` in the permutations of `S`, of `i (f i)`.

### Informal sketch
The theorem states an equality between a product of sums and a sum of products of sums involving complex exponentials.

*   The proof starts by introducing the assumptions.
*   Then, the rewrite rule `ring_pow_complex` with GSYM (reverse) direction is applied.
*   Next, `complex_ring_clauses` with GSYM direction is rewritten.
*   Then, the theorem `ring_product_perm_sum_mul_exp_expand` is specialized with assumptions about `complex_ring`, `cexp`, `c:complex->complex`, and `S:complex->bool`.
*   Finally, the theorem is proven using `in_complex_ring`, `CEXP_0`, `CEXP_ADD`, `SUBSET`, and `complex_ring_clauses`.

### Mathematical insight
This theorem represents a combinatorial identity relating products and sums of complex exponentials. The identity can be interpreted in terms of generating functions for counting functions between finite sets. The `numpreimages` function counts the number of elements in the domain that map to a specific element in the codomain under a given function. The expansion involves summing over different pre-image counts.

### Dependencies
*   `GSYM`
*   `ring_pow_complex`
*   `complex_ring_clauses`
*   `ring_product_perm_sum_mul_exp_expand`
*   `in_complex_ring`
*   `CEXP_0`
*   `CEXP_ADD`
*   `SUBSET`
*   `FINITE`
*   `perm`
*   `complex_ring`
*   `cexp`
*   `numpreimages`
*   `functions`
*   `IMAGE`
*   `pow`


---

## product_perm_sum_mul_expformal_expand

### Name of formal statement
product_perm_sum_mul_expformal_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_perm_sum_mul_expformal_expand = prove(`
  !c:complex->((1->num)->complex) S:complex->bool.
  FINITE S ==>
  ring_product(x_series complex_ring) (perm S) (
    \i. ring_sum(x_series complex_ring) S (
      \z. poly_mul complex_ring (c z) (expformal(i z))
    )
  )
  =
  ring_sum(x_series complex_ring) (
    IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)
  ) (
    \e.
      ring_mul(x_series complex_ring) (
        ring_product(x_series complex_ring) {y | ~(e y = 0)} (
          \y. ring_pow(x_series complex_ring) (c y) (e y)
        )
      ) (
        ring_sum(x_series complex_ring) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} (
          expformal o (\f. ring_sum complex_ring (perm S) (\i. i (f i)))
        )
      )
  )
`,
  intro THEN
  rw[x_series_use] THEN
  specialize_assuming[
    `complex_ring`;
    `x_series complex_ring`;
    `expformal`;
    `c:complex->(1->num)->complex`;
    `S:complex->bool`
  ]ring_product_perm_sum_mul_exp_expand THEN
  qed[complex_ring_clauses;in_complex_ring;series_complex;x_series_use;expformal_0;mul_expformal;SUBSET]
);;
```

### Informal statement
For any function `c` mapping a complex number to a function from `(1->num)` to a complex number, and any predicate `S` on complex numbers, if `S` defines a finite set, then the product, over all permutations of `S`, of the sum, over `S`, of the product of `c z` and `expformal(i z)` for all `z` in `S`, is equal to the sum, over the image of the function that counts the number of preimages under `f` in `perm S` for all functions from `perm S` to `S`, of the product of the product, over the set of `y` not mapped to 0, of `c y` raised to the power of `e y`, and the sum, over the set of `f` in the functions from `perm S` to `S` whose number of preimages under `f` in `perm S` is equal to `e`, of `expformal` applied to the sum, over `perm S`, of `i (f i)`.

### Informal sketch
The theorem equates a product of sums with a sum of products of sums, involving formal exponentials.
- Starts by introducing assumptions and rewriting using `x_series_use`.
- Specializes with `complex_ring`, `x_series complex_ring`, `expformal`, `c:complex->(1->num)->complex`, and `S:complex->bool` in `ring_product_perm_sum_mul_exp_expand`.
- Concludes using `complex_ring_clauses`, `in_complex_ring`, `series_complex`, `x_series_use`, `expformal_0`, `mul_expformal`, and `SUBSET`. The core of the proof probably resides in a rearrangement of terms using properties of finite sums and products, exploiting the specific structure involving `expformal`.

### Mathematical insight
This theorem expresses a combinatorial identity involving formal exponentials, products, and sums over permutations and functions. It reveals how to expand a particular product of sums into a sum of products and sums, which utilizes number of preimages. This enables simplification under specific circumstances.

### Dependencies
- `complex_ring`
- `x_series complex_ring`
- `expformal`
- `c:complex->(1->num)->complex`
- `S:complex->bool`
- `ring_product_perm_sum_mul_exp_expand`
- `complex_ring_clauses`
- `in_complex_ring`
- `series_complex`
- `x_series_use`
- `expformal_0`
- `mul_expformal`
- `SUBSET`

### Porting notes (optional)
Porting this likely requires a good understanding of finite set theory, permutations, functions, and series manipulations in the target proof assistant. The concept of formal exponentials might require a user-defined type or library, depending on the system. The automation may need significant adaptation, as it relies on rewriting and specialization tactics that are specific to HOL Light. The `ring_product_perm_sum_mul_exp_expand` theorem seems to be where the main proof work is done.


---

## product_perm_sum_mul_expformal_expand_v2

### Name of formal statement
product_perm_sum_mul_expformal_expand_v2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_perm_sum_mul_expformal_expand_v2 = prove(`
  !c:complex->((1->num)->complex) S:complex->bool.
  FINITE S ==>
  ring_product(x_series complex_ring) (perm S) (
    \i. ring_sum(x_series complex_ring) S (
      \z. poly_mul complex_ring (c z) (expformal(i z))
    )
  )
  =
  ring_sum(x_series complex_ring) (
    IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S)
  ) (\y.
    ring_sum(x_series complex_ring) (
      IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)
    ) (
      \e.
        poly_mul complex_ring (
          ring_product(x_series complex_ring) {z | ~(e z = 0)} (
            \z. ring_pow(x_series complex_ring) (c z) (e z)
          )
        ) (
          poly_mul complex_ring (
            ring_of_num(x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} y)
          ) (expformal y)
        )
      )
  )
`,
  simp[product_perm_sum_mul_expformal_expand] THEN
  rw[x_series_use] THEN
  intro THEN
  have `FINITE(perm(S:complex->bool))` [finite_perm] THEN
  have `FINITE(functions (perm(S:complex->bool)) (S:complex->bool))` [finite_functions] THEN
  have `FINITE(IMAGE (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) (functions (perm S) S))` [FINITE_IMAGE] THEN
  have `FINITE(IMAGE (\f. numpreimages f (perm S)) (functions (perm S) (S:complex->bool)))` [FINITE_IMAGE] THEN
  have `!i j. i IN IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S) ==> j IN IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S) ==> ring_mul (x_series complex_ring) (ring_product (x_series complex_ring) {z | ~(j z = 0)} (\z. ring_pow (x_series complex_ring) (c z) (j z))) (ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = j} i)) (expformal i)) IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  specialize[
    `x_series complex_ring`;
    `\y e. ring_mul(x_series complex_ring) (ring_product (x_series complex_ring) {z | ~(e z = 0)} (\z. ring_pow (x_series complex_ring) (c z) (e z))) (ring_mul(x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} y)) (expformal y))`;
    `IMAGE (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) (functions (perm S) S)`;
    `IMAGE (\f. numpreimages f (perm S)) (functions (perm S) (S:complex->bool))`
  ]RING_SUM_SWAP THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  have `ring_product (x_series complex_ring) {z | ~(a z = 0)} (\z:complex. ring_pow (x_series complex_ring) (c z) (a z)) IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  have `!z. z IN IMAGE (\f. ring_sum complex_ring (perm S) (\y. y (f y))) (functions (perm S) S) ==> ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} z)) (expformal z) IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  specialize[
    `x_series complex_ring`;
    `\y. ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} y)) (expformal y)`;
    `ring_product (x_series complex_ring) {z:complex | ~(a z = 0)} (\z. ring_pow (x_series complex_ring) (c z) (a z))`;
    `IMAGE (\f. ring_sum complex_ring (perm S) (\y:complex->complex. y (f y))) (functions (perm S) S)`
  ]RING_SUM_LMUL THEN
  simp[] THEN
  subgoal `ring_sum (x_series complex_ring) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} (expformal o (\f. ring_sum complex_ring (perm S) (\i. i (f i)))) = ring_sum (x_series complex_ring) (IMAGE (\f. ring_sum complex_ring (perm S) (\y. y (f y))) (functions (perm S) S)) (\y. ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} y)) (expformal y))` THENL [
    specialize[
      `functions (perm (S:complex->bool)) (S:complex->bool)`;
      `\f:(complex->complex)->complex. numpreimages f (perm(S:complex->bool)) = a`
    ]FINITE_RESTRICT THEN
    have `!y. y IN IMAGE (\f. ring_sum complex_ring (perm S) (\y:complex->complex. y (f y))) (functions (perm S) S) ==> expformal y IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
    have `!y. y IN IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} ==> expformal y IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
    subgoal `IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} SUBSET IMAGE (\f. ring_sum complex_ring (perm S) (\y:complex->complex. y (f y))) (functions (perm S) S)` THENL [
      rw[SUBSET;in_image_vw;IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `x_series complex_ring`;
      `{f | f IN functions (perm S) (S:complex->bool) /\ numpreimages f (perm S) = a}`;
      `\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))`;
      `IMAGE (\f. ring_sum complex_ring (perm S) (\y:complex->complex. y (f y))) (functions (perm S) S)`;
      `expformal`
    ]ring_sum_o_v3 THEN
    simp[]
  ; pass
  ] THEN
  simp[]
);;
```

### Informal statement
For any function `c` from complex numbers to functions from the set `1` to numbers to complex numbers, and any predicate `S` on complex numbers, if `S` is finite, then the product over the permutations of `S` of the sums over `S` of `c(z)` times `expformal(i z)` is equal to the sum over the image of functions from the permutations of `S` to `S`, mapping `f` to the sum over the permutations of `S` of `i(f i)`, of the sums over the image of the number of preimages under `f` from the permutations of `S` to functions from the permutations of `S` to `S`, mapping `f` to the number of preimages of `f` in the permutations of `S`, of the product over the set of `z` such that `e(z)` is not zero of `c(z)` to the power of `e(z)`, times the product of the number of preimages under the function mapping `f` to the sum over the permutations of `S` of `i(f i)` in the set of `f` in the functions from the permutations of `S` to `S` such that the number of preimages of `f` is `e` applied to `y` and `expformal(y)`.

### Informal sketch
The proof proceeds by:
- Rewriting the statement using `product_perm_sum_mul_expformal_expand` and `x_series_use`.
- Introducing the variable `c` and the predicate `S`.
- Proving that `perm S` is finite using tactic `finite_perm`.
- Proving that `functions (perm S) S` is finite using tactic `finite_functions`.
- Proving that the image of `functions (perm S) S` under the function mapping `f` to the sum over the permutations of `S` of `i(f i)` is finite using tactic `FINITE_IMAGE`.
- Proving that the image of `functions (perm S) S` under the function mapping `f` to the number of preimages of `f` in the permutations of `S` is finite using tactic `FINITE_IMAGE`.
- Proving that  `ring_mul (x_series complex_ring) (ring_product (x_series complex_ring) {z | ~(j z = 0)} (\z. ring_pow (x_series complex_ring) (c z) (j z))) (ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = j} i)) (expformal i)) IN ring_carrier (x_series complex_ring)` using `series_complex;x_series_use`.
- Specialize `RING_SUM_SWAP` using the above results.
- Simplifying.
- Sufficesby `RING_SUM_EQ`.
- Rewriting with `BETA_THM`.
- Intro.
- Proving `ring_product (x_series complex_ring) {z | ~(a z = 0)} (\z:complex. ring_pow (x_series complex_ring) (c z) (a z)) IN ring_carrier (x_series complex_ring)` using `series_complex;x_series_use`.
- Proving that `ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} z)) (expformal z) IN ring_carrier (x_series complex_ring)` using `series_complex;x_series_use`.
- Specialize `RING_SUM_LMUL` using the above results.
- Simplify.
- Focus on proving that `ring_sum (x_series complex_ring) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} (expformal o (\f. ring_sum complex_ring (perm S) (\i. i (f i)))) = ring_sum (x_series complex_ring) (IMAGE (\f. ring_sum complex_ring (perm S) (\y. y (f y))) (functions (perm S) S)) (\y. ring_mul (x_series complex_ring) (ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} y)) (expformal y))`.
 - Specialize `FINITE_RESTRICT`.
 - Proving that `expformal y IN ring_carrier (x_series complex_ring)` using tactic `series_complex;x_series_use`.
 - Proving that `expformal y IN ring_carrier (x_series complex_ring)` using tactic `series_complex;x_series_use`.
 - Showing `IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a} SUBSET IMAGE (\f. ring_sum complex_ring (perm S) (\y:complex->complex. y (f y))) (functions (perm S) S)` using `rw[SUBSET;in_image_vw;IN_ELIM_THM]`.
 - Specialize `ring_sum_o_v3`
 - Simplify.
- Simplify.

### Mathematical insight
This theorem appears to be an involved algebraic manipulation within the context of formal power series, permutations, and functions. It aims to establish an equality between a product of sums and a sum of sums of products in a formal power series ring. The expansion likely leverages properties of permutations, pre-images of functions, and the `expformal` (exponential formal power series). It may be used in advanced manipulations of generating functions, combinatorial arguments, or algebraic computations of power series coefficients.

### Dependencies
- `product_perm_sum_mul_expformal_expand`
- `x_series_use`
- `finite_perm`
- `finite_functions`
- `FINITE_IMAGE`
- `series_complex`
- `RING_SUM_SWAP`
- `RING_SUM_EQ`
- `BETA_THM`
- `RING_SUM_LMUL`
- `FINITE_RESTRICT`
- `SUBSET`
- `in_image_vw`
- `IN_ELIM_THM`
- `ring_sum_o_v3`

### Porting notes (optional)
- The extensive use of `x_series` and the `complex_ring` context might require careful mapping to equivalent structures in other proof assistants.
- The tactics used (`simp`, `rw`, `intro`, `have`, `specialize`, `sufficesby`) suggest a proof style focused on rewriting and simplification, which might be adaptable to other systems with similar automation.
- Porting this theorem effectively would rely on ensuring that similar infrastructure for rings, formal power series, permutations, images, and preimages is available.


---

## product_perm_sum_mul_expformal_expand_v3

### Name of formal statement
product_perm_sum_mul_expformal_expand_v3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_perm_sum_mul_expformal_expand_v3 = prove(`
  !c:complex->complex S:complex->bool.
  FINITE S ==>
  ring_product(x_series complex_ring) (perm S) (
    \i. ring_sum(x_series complex_ring) S (
      \z. poly_mul complex_ring (poly_const complex_ring (c z)) (expformal(i z))
    )
  )
  =
  ring_sum(x_series complex_ring) (
    IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S)
  ) (\y.
    poly_mul complex_ring (
      poly_const complex_ring (
        ring_sum complex_ring (
          IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)
        ) (\e.
          ring_product complex_ring {z | ~(e z = 0)} (
            \z. (c z) pow (e z)
          ) * (
            Cx(&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} y))
          )
        )
      )
    ) (expformal y)
  )
`,
  simp[product_perm_sum_mul_expformal_expand_v2] THEN
  rw[x_series_use] THEN
  intro THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  have `FINITE(perm(S:complex->bool))` [finite_perm] THEN
  have `FINITE(functions (perm(S:complex->bool)) (S:complex->bool))` [finite_functions] THEN
  have `FINITE(IMAGE (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) (functions (perm S) S))` [FINITE_IMAGE] THEN
  have `FINITE(IMAGE (\f. numpreimages f (perm S)) (functions (perm S) (S:complex->bool)))` [FINITE_IMAGE] THEN
  have `!s. s IN IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S) ==> ring_product complex_ring {z | ~(s z = 0)} (\z. c z pow s z) * Cx (&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = s} a)) IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[
    `complex_ring`;
    `\e. ring_product complex_ring {z | ~(e z = 0)} (\z. c z pow e z) * Cx(&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} a))`;
    `IMAGE (\f. numpreimages f (perm S)) (functions (perm S) (S:complex->bool))`
  ]poly_const_sum THEN
  simp[poly_const_sum] THEN
  subgoal `poly_sum complex_ring (IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)) (\s. poly_const complex_ring ((ring_product complex_ring {z | ~(s z = 0)} (\z. c z pow s z)) * (Cx (&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = s} a))))) = poly_sum complex_ring (IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)) (\s. poly_mul complex_ring (ring_product(x_series complex_ring) {z | ~(s z = 0)} (\z. ring_pow(x_series complex_ring) (poly_const complex_ring (c z)) (s z))) (poly_const complex_ring (Cx (&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = s} a)))))` THENL [
    sufficesby poly_sum_eq THEN
    intro THEN
    have `ring_product complex_ring {z | ~(s z = 0)} (\z:complex. c z pow s z) IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `Cx(&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = s} a)) IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `ring_product complex_ring {z | ~(s z = 0)} (\z:complex. c z pow s z)`;
      `Cx(&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = s} a))`
    ]POLY_CONST_MUL THEN
    rw[GSYM complex_ring_clauses] THEN
    simp[] THEN
    subgoal `FINITE {z:complex | ~(s z = 0)}` THENL [
      choose `f:(complex->complex)->complex` `s:complex->num = (\f. numpreimages f (perm S)) f /\ f IN functions (perm S) S` [IN_IMAGE] THEN
      have `s = numpreimages (f:(complex->complex)->complex) (perm S)` [] THEN
      subgoal `{z:complex | ~(s z = 0)} = {z | ~(numpreimages f (perm(S:complex->bool)) z = 0)}` THENL [
        rw[EXTENSION;IN_ELIM_THM] THEN
        qed[]
      ; pass
      ] THEN
      simp[GSYM image_numpreimages] THEN
      qed[FINITE_IMAGE]
    ; pass
    ] THEN
    have `!t. t IN {z:complex | ~(s z = 0)} ==> c t pow s t IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `\z:complex. (c z pow s z):complex`;
      `{z:complex | ~(s z = 0)}`
    ]poly_const_product THEN
    simp[poly_product] THEN
    subgoal `ring_product (x_series complex_ring) {z:complex | ~(s z = 0)} (\t. poly_const complex_ring (c t pow s t)) = ring_product (x_series complex_ring) {z | ~(s z = 0)} (\z. ring_pow (x_series complex_ring) (poly_const complex_ring (c z)) (s z))` THENL [
      sufficesby RING_PRODUCT_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      have `c(a':complex) IN ring_carrier complex_ring` [in_complex_ring] THEN
      rw[GSYM ring_pow_complex] THEN
      simp[poly_const_pow;x_series_use_pow]
    ; pass
    ] THEN
    simp[]
  ; pass
  ] THEN
  rw[GSYM poly_sum] THEN
  simp[] THEN
  rw[poly_sum;x_series_use] THEN
  have `expformal a IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  have `!e. e IN IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S) ==> ring_mul (x_series complex_ring) (ring_product (x_series complex_ring) {z | ~(e z = 0)} (\z. ring_pow (x_series complex_ring) (poly_const complex_ring (c z)) (e z))) (poly_const complex_ring (Cx (&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} a)))) IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  specialize[
    `x_series complex_ring`;
    `\s. ring_mul (x_series complex_ring) (ring_product (x_series complex_ring) {z | ~(s z = 0)} (\z. ring_pow (x_series complex_ring) (poly_const complex_ring (c z)) (s z))) (poly_const complex_ring (Cx(&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = s} a))))`;
    `expformal a`;
    `IMAGE (\f. numpreimages f (perm S)) (functions (perm S) (S:complex->bool))`
  ](GSYM RING_SUM_RMUL) THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  have `ring_product (x_series complex_ring) {z:complex | ~(a' z = 0)} (\z. ring_pow (x_series complex_ring) (poly_const complex_ring (c z)) (a' z)) IN ring_carrier (x_series complex_ring)` [RING_PRODUCT] THEN
  have `ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = a'} a) IN ring_carrier (x_series complex_ring)` [RING_OF_NUM] THEN
  specialize_assuming[
    `x_series complex_ring`;
    `ring_product (x_series complex_ring) {z | ~(a' z = 0)} (\z:complex. ring_pow (x_series complex_ring) (poly_const complex_ring (c z)) (a' z))`;
    `ring_of_num (x_series complex_ring) (numpreimages (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) {f | f IN functions (perm S) (S:complex->bool) /\ numpreimages f (perm S) = a'} a)`;
    `expformal a`
  ]RING_MUL_ASSOC THEN
  simp[] THEN
  rw[ring_of_num_x_series] THEN
  rw[ring_of_num_complex;complex_of_num]
);;
```
### Informal statement
Given a function `c` from complex numbers to complex numbers, and a predicate `S` over complex numbers, if `S` is finite, then the following holds:

The product over all permutations of `S`, denoted `perm S`, of the sum over `S` of `poly_mul complex_ring (poly_const complex_ring (c z)) (expformal(i z))` is equal to the sum over the image of functions from `perm S` to `S` (where the image is formed by applying to each function `f`, the sum over all `i` in `perm S` of  `i (f i)`), of `poly_mul complex_ring` of `poly_const complex_ring` of

`ring_sum complex_ring (IMAGE (\f. numpreimages f (perm S)) (functions (perm S) S)) (\e. ring_product complex_ring {z | ~(e z = 0)} (\z. (c z) pow (e z)) * (Cx(&(numpreimages (\f. ring_sum complex_ring (perm S) (\i. i (f i))) {f | f IN functions (perm S) S /\ numpreimages f (perm S) = e} y))))`
,
and `expformal y`.

### Informal sketch
The proof seeks to establish the identity `product_perm_sum_mul_expformal_expand_v3` under the condition that the set `S` is finite.
- The proof starts by applying `product_perm_sum_mul_expformal_expand_v2`, rewriting with `x_series_use` and simplification.
- It suffices to show `RING_SUM_EQ`, reducing the problem to showing the equality inside complex ring.
- The proof proceeds by establishing that relevant sets are finite. Specifically, `perm S`, `functions (perm S) S`, `IMAGE (\f. ring_sum complex_ring (perm S) (\i:complex->complex. i (f i))) (functions (perm S) S)` and `IMAGE (\f. numpreimages f (perm S)) (functions (perm S) (S:complex->bool))` are all finite.
- Then, the argument shows that relevant elements lies in `ring_carrier complex_ring`.
- The proof applies `poly_const_sum`, simplifies with `poly_sum_eq`.
- It uses `EXTENSION;IN_ELIM_THM` (extensionality and element introduction for sets) to simplify set equality.
- It utilizes lemmas about `FINITE_IMAGE` and rewrites with `ring_pow_complex` and `poly_const_pow; x_series_use_pow`.
- It uses properties of the `complex_ring` such as `poly_product`, `RING_PRODUCT_EQ`.
- It rewrites with with `poly_sum`, proves `expformal a IN ring_carrier (x_series complex_ring)` by `series_complex;x_series_use`.
- The identities `GSYM RING_SUM_RMUL`, `RING_MUL_ASSOC`, `ring_of_num_x_series`, `ring_of_num_complex;complex_of_num` were subsequently applied.

### Mathematical insight
This theorem relates a product over permutations to a sum over the image of functions. It provides an expansion of a product of sums involving `expformal`, a formal exponential series, into a sum involving powers and preimages. This is useful in algebraic manipulation of formal power series and combinatorial settings.

### Dependencies
#### Theorems
- `product_perm_sum_mul_expformal_expand_v2`
#### Definitions
- `x_series_use`
- `complex_ring`
- `FINITE`
- `perm`
- `functions`
- `numpreimages`
- `poly_mul`
- `poly_const`
- `ring_sum`
- `ring_product`
- `pow`
- `expformal`
- `BETA_THM`
- `FINITE_IMAGE`
- `EXTENSION`
- `IN_ELIM_THM`
- `image_numpreimages`
- `ring_pow_complex`
- `poly_const_pow`
- `x_series_use_pow`
- `series_complex`
- `complex_of_num`
#### Other
- `RING_SUM_EQ`, `poly_const_sum`, `POLY_CONST_MUL`, `GSYM complex_ring_clauses`, `POLY_CONST_PRODUCT`, `RING_PRODUCT_EQ`, `poly_product`, `poly_sum`, `RING_SUM_RMUL`, `RING_MUL_ASSOC`, `ring_of_num_x_series`, `ring_of_num_complex`

### Porting notes (optional)
- The theorem relies heavily on algebraic properties and ring operations within the `complex_ring` structure. Ensure that any target proof assistant has robust support for algebraic structures or that these structures are adequately defined, including properties of `ring_sum`, `ring_product`, and `ring_pow`.
- The finiteness conditions (`FINITE S`, and derived finiteness results) are crucial for the validity of sums and products, so make sure finiteness of sets and images are handy.
- The use of higher-order functions and set theory (e.g., `functions`, `IMAGE`, `numpreimages`) may require more explicit encoding or reasoning in some proof assistants compared to HOL Light's relatively automated handling.
- Pay attention to the handling of `x_series`, as it may require specific definitions and manipulations depending on the target proof assistant's library support for formal power series.


---

## zero_sum_QinC_exp_squarefree_roots_lemma_sym_powersums

### Name of formal statement
zero_sum_QinC_exp_squarefree_roots_lemma_sym_powersums

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_QinC_exp_squarefree_roots_lemma_sym_powersums = prove(`
  !p e d.
  ring_polynomial QinC_ring p ==>
  ring_squarefree(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  ring_sum complex_ring
    {f | f IN functions (perm(complex_root p)) (complex_root p) /\ numpreimages f (perm(complex_root p)) = e}
    (\f. (ring_sum complex_ring (perm(complex_root p)) (\i. i (f i))) pow d)
  IN QinC
`,
  intro THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;ring_1_0_QinC] THEN
  have `~(p = poly_0 complex_ring:(1->num)->complex)` [poly_0_QinC_eq_poly_0_complex] THEN
  have `FINITE(complex_root p)` [complex_root_le_deg] THEN
  have `FINITE(perm(complex_root p))` [finite_perm] THEN
  have `FINITE(functions (perm(complex_root p)) (complex_root p))` [finite_functions] THEN
  specialize[
    `functions (perm (complex_root p)) (complex_root p)`;
    `\f:(complex->complex)->complex. numpreimages f (perm(complex_root p)) = e`
  ]FINITE_RESTRICT THEN
  def `Z:(complex->num)->complex` `ring_sum(poly_ring complex_ring (:complex)) {f | f IN functions (perm(complex_root p)) (complex_root p) /\ numpreimages f (perm(complex_root p)) = e} (\f. poly_pow complex_ring (ring_sum(poly_ring complex_ring (:complex)) (perm(complex_root p)) (\i. poly_var complex_ring (i (f i)))) d)` THEN
  subgoal `ring_sum complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\f. ring_sum complex_ring (perm (complex_root p)) (\i. i (f i)) pow d) = poly_evaluate complex_ring Z I` THENL [
    simp[] THEN
    subgoal `(!s. s IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> ring_polynomial complex_ring (poly_pow complex_ring (ring_sum (poly_ring complex_ring (:complex)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d))` THENL [
      intro THEN
      have `ring_sum (poly_ring complex_ring (:complex)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i))) IN ring_carrier(poly_ring complex_ring (:complex))` [RING_SUM] THEN
      qed[poly_pow_in_poly_ring;poly_in_full_ring;poly_ring_use_pow]
    ; pass
    ] THEN
    specialize[
      `complex_ring`;
      `\f. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:complex)) (perm (complex_root p)) (\i. poly_var complex_ring (i (f i)))) d`;
      `I:complex->complex`;
      `{f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}`
    ]poly_evaluate_sum THEN
    simp[] THEN
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;IN_ELIM_THM] THEN
    intro THEN
    have `ring_polynomial complex_ring (ring_sum (poly_ring complex_ring (:complex)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i))))` [RING_SUM;poly_in_full_ring] THEN
    have `(!i. i IN poly_vars complex_ring (ring_sum (poly_ring complex_ring (:complex)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i)))) ==> I i IN ring_carrier complex_ring)` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `ring_sum (poly_ring complex_ring (:complex)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i)))`;
      `I:complex->complex`;
      `d:num`
    ]poly_evaluate_pow THEN
    simp[] THEN
    rw[ring_pow_complex] THEN
    subgoal `poly_evaluate complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i)))) I = ring_sum complex_ring (perm (complex_root p)) (\i. i (a i))` THENL [
      have `!s. s IN perm (complex_root p) ==> ring_polynomial complex_ring (poly_var complex_ring (s (a s)))` [RING_POLYNOMIAL_VAR] THEN
      specialize[
        `complex_ring`;
        `\i:complex->complex. poly_var complex_ring (i (a i))`;
        `I:complex->complex`;
        `perm (complex_root p)`
      ]poly_evaluate_sum THEN
      simp[] THEN
      sufficesby RING_SUM_EQ THEN
      qed[POLY_EVALUATE_VAR;in_complex_ring;I_THM]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  rw[know `ring_sum complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\f. ring_sum complex_ring (perm (complex_root p)) (\i. i (f i)) pow d) = poly_evaluate complex_ring Z I`] THEN
  have `!s. s IN complex_root p ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
  subgoal `!d. coeff d (monic_vanishing_at complex_ring (complex_root p) I) IN ring_carrier (subring_generated complex_ring QinC)` THENL [
    have `ring_squarefree(x_poly complex_ring) p` [monic_QinC_squarefree_complex_squarefree] THEN
    have `monic complex_ring p` [monic_subring;subring_complex_QinC] THEN
    simp[monic_vanishing_at_complex_root] THEN
    simp[subring_complex_QinC] THEN
    qed[coeff_poly_in_ring]
  ; pass
  ] THEN
  subgoal `ring_polynomial (subring_generated complex_ring QinC) (Z:(complex->num)->complex)` THENL [
    simp[] THEN
    subgoal `(!s. s IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> ring_polynomial (subring_generated complex_ring QinC) (poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d))` THENL [
      rw[IN_ELIM_THM] THEN
      intro THEN
      subgoal `poly_pow (subring_generated complex_ring QinC) (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d = poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d` THENL [
        sufficesby poly_pow_subring THEN
        sufficesby ring_powerseries_if_polynomial THEN
        sufficesby ring_polynomial_subring_sum THEN
        qed[ring_polynomial_subring_var]
      ; pass
      ] THEN
      subgoal `ring_polynomial (subring_generated complex_ring QinC) (poly_pow (subring_generated complex_ring QinC) (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d)` THENL [
        sufficesby poly_pow_poly THEN
        sufficesby ring_polynomial_subring_sum THEN
        qed[ring_polynomial_subring_var]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    specialize[
      `complex_ring`;
      `QinC`;
      `\f. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (f i)))) d`;
      `{f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}`
    ](GSYM poly_sum_subring_multi) THEN
    simp[] THEN
    qed[RING_SUM;poly_in_full_ring]
  ; pass
  ] THEN
  subgoal `poly_vars complex_ring (Z:(complex->num)->complex) SUBSET complex_root p` THENL [
    simp[] THEN
    sufficesby poly_vars_sum_poly_subset THEN
    simp[IN_ELIM_THM;functions] THEN
    intro THENL [
      sufficesby poly_pow_poly THEN
      qed[RING_SUM;poly_in_full_ring]
    ;
      sufficesby poly_vars_pow_subset THEN
      intro THENL [
        sufficesby ring_powerseries_if_polynomial THEN
        qed[RING_SUM;poly_in_full_ring]
      ;
        sufficesby poly_vars_sum_poly_subset THEN
        simp[] THEN
        intro THENL [
          qed[RING_POLYNOMIAL_VAR]
        ;
          rw[POLY_VARS_VAR;SUBSET] THEN
          have `s(s':complex->complex) IN complex_root p` [IN_IMAGE;SUBSET] THEN
          have `s' permutes complex_root p` [IN;perm] THEN
          have `s'(s(s':complex->complex)) IN complex_root p` [PERMUTES_IN_IMAGE] THEN
          ASM SET_TAC[]
        ]
      ]
    ]
  ; pass
  ] THEN
  subgoal `!g m. g permutes complex_root p ==> Z (m o g) = (Z:(complex->num)->complex) m` THENL [
    intro THEN
    simp[] THEN
    subgoal `!s. s IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> ring_polynomial complex_ring (poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d)` THENL [
      rw[IN_ELIM_THM] THEN
      intro THEN
      sufficesby poly_pow_poly THEN
      qed[RING_SUM;poly_in_full_ring]
    ; pass
    ] THEN
    specialize[
      `complex_ring`;
      `(\f. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (f i)))) d)`;
      `m:complex->num`;
      `g:complex->complex`;
      `complex_root p`;
      `{f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}`
    ]ring_sum_poly_o_permutes THEN
    simp[] THEN
    subgoal `ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s m. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) d (m o g)) = ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s m. poly_pow complex_ring (\m. (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i)))) (m o g)) d m)` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM;FUN_EQ_THM;IN_ELIM_THM] THEN
      intro THEN
      subgoal `ring_powerseries complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i:complex->complex. poly_var complex_ring (i (a i))))` THENL [
        sufficesby ring_powerseries_if_polynomial THEN
        sufficesby poly_sum_poly_multi THEN
        qed[RING_POLYNOMIAL_VAR]
      ; pass
      ] THEN
      specialize[
        `complex_ring`;
        `ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i)))`;
        `complex_root p`;
        `g:complex->complex`;
        `d:num`;
        `x:complex->num`
      ]poly_pow_o_permutes THEN
      qed[]
    ; pass
    ] THEN
    subgoal `ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s m. poly_pow complex_ring (\m. ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (s i))) (m o g)) d m) = ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (s i))))) d)` THENL [
      sufficesby RING_SUM_EQ THEN
      once_rw[fun_eq_thm_v] THEN
      rw[BETA_THM;IN_ELIM_THM] THEN
      intro THEN
      subgoal `(\m. ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i))) (m o g)) = (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (a i)))))` THENL [
        rw[FUN_EQ_THM] THEN
        intro THEN
        have `!s. s IN perm (complex_root p) ==> ring_polynomial complex_ring (poly_var complex_ring (s (a s)))` [RING_POLYNOMIAL_VAR] THEN
        specialize[
          `complex_ring`;
          `\i:complex->complex. poly_var complex_ring (i (a i))`;
          `x:complex->num`;
          `g:complex->complex`;
          `complex_root p`;
          `perm(complex_root p)`
        ]ring_sum_poly_o_permutes THEN
        simp[] THEN
        subgoal `ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\s m. poly_var complex_ring (s (a s)) (m o g)) = ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (a i))))` THENL [
          sufficesby RING_SUM_EQ THEN
          rw[BETA_THM] THEN
          intro THEN
          rw[FUN_EQ_THM] THEN
          qed[poly_var_o_permutes]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    simp[] THEN
    subgoal `ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (s i))))) d) = ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\f. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (f i)))) d)` THENL [
      subgoal `!x y. x IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> y IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> (\i. x ((g:complex->complex) o i)) = (\i. y (g o i)) ==> x = y` THENL [
        once_rw[fun_eq_thm_v] THEN
        rw[FUN_EQ_THM] THEN
        intro THEN
        have `I:complex->complex = (g:complex->complex) o inverse g` [PERMUTES_INVERSES_o] THEN
        have `v:complex->complex = ((g:complex->complex) o inverse g) o v` [I_O_ID;I_THM] THEN
        subgoal `v:complex->complex = (g:complex->complex) o inverse g o v` THENL [
          rw[o_ASSOC] THEN
          qed[]
        ; pass
        ] THEN
        have `x(v:complex->complex):complex = x ((g:complex->complex) o (inverse g o v))` [] THEN
        have `y(v:complex->complex):complex = x ((g:complex->complex) o (inverse g o v))` [] THEN
        qed[]
      ; pass
      ] THEN
      specialize[
        `poly_ring complex_ring (:complex)`;
        `\f:(complex->complex)->complex i:complex->complex. f ((g:complex->complex) o i)`;
        `\s. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (s i))))) d`;
        `{f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}`
      ]RING_SUM_IMAGE THEN
      subgoal `IMAGE (\f i. f (g o i)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} = {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}` THENL [
        rw[EXTENSION;IN_ELIM_THM;IN_IMAGE] THEN
        intro THEN
        splitiff THENL [
          intro THENL [
            specialize[
              `complex_root p`;
              `complex_root p`;
              `g:complex->complex`
            ]image_permutes_o_functions_perm THEN
            ASM SET_TAC[]
          ;
            rw[know `x:(complex->complex)->complex = (\i. x' ((g:complex->complex) o i))`] THEN
            qed[numpreimages_permutes_o_perm]
          ]
        ;
          intro THEN
          witness `\i:complex->complex. x(inverse g:complex->complex o i):complex` THEN
          have `inverse g permutes complex_root p` [PERMUTES_INVERSE] THEN
          intro THENL [
            rw[fun_eq_thm_e] THEN
            qed[inverse_permutes_o_refl_o]
          ;
            specialize[
              `complex_root p`;
              `complex_root p`;
              `inverse g:complex->complex`
            ]image_permutes_o_functions_perm THEN
            ASM SET_TAC[]
          ;
            qed[numpreimages_permutes_o_perm]
          ]
        ]
      ; pass
      ] THEN
      have_rw `ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (s i))))) d) = ring_sum (poly_ring complex_ring (:real^2)) {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ((\s. poly_pow complex_ring (ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (s i))))) d) o (\f i. f (g o i)))` [] THEN
      sufficesby RING_SUM_EQ THEN
      rw[IN_ELIM_THM;BETA_THM;o_THM] THEN
      intro THEN
      subgoal `ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (g (i (a (g o i))))) = ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i)))` THENL [
        have `!x y. x IN perm (complex_root p) ==> y IN perm (complex_root p) ==> g o x = (g:complex->complex) o y ==> x = y` [inverse_permutes_o_refl_o] THEN
        specialize[
          `poly_ring complex_ring (:complex)`;
          `\i:complex->complex. (g:complex->complex) o i`;
          `\i:complex->complex. poly_var complex_ring (i (a i))`;
          `perm(complex_root p)`
        ]RING_SUM_IMAGE THEN
        specialize[
          `complex_root p`;
          `g:complex->complex`
        ]image_permutes_o_perm THEN
        have_rw `ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) (\i. poly_var complex_ring (i (a i))) = ring_sum (poly_ring complex_ring (:real^2)) (perm (complex_root p)) ((\i. poly_var complex_ring (i (a i))) o (\i. g o i))` [] THEN
        sufficesby RING_SUM_EQ THEN
        rw[BETA_THM;o_THM]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `complex_ring`;
    `QinC`;
    `complex_root p`;
    `I:complex->complex`;
    `Z:(complex->num)->complex`
  ]symmetric_subring_if_poly_subring THEN
  qed[subring_complex_QinC;QinC_ring_clauses]
);;
```
### Informal statement
For all polynomials `p` with coefficients in `QinC`, if `p` is squarefree and monic, then the ring sum over the functions `f` from the permutations of the complex roots of `p` to the complex roots of `p` such that the number of preimages of `f` is equal to `e`, of the `d`-th power of the ring sum over the permutations of the complex roots of `p` of the terms `i (f i)` belongs to `QinC`.

### Informal sketch
The proof demonstrates that under the hypotheses that `p` is a polynomial over `QinC` that is squarefree and monic, the expression representing a sum related to symmetric powersums of roots of `p` belongs to `QinC`.
- It begins by proving that the sum can be expressed as the evaluation of a polynomial `Z` at the identity `I`.
- It then shows that the coefficients of the polynomial `monic_vanishing_at complex_ring (complex_root p) I` belong to the subring generated by `QinC`, using the assumptions that `p` is squarefree and monic.
- It demonstrates that the polynomial `Z` itself has coefficients in the subring generated by `QinC` using `poly_sum_subring_multi`.
- Shows that the variables of `Z` are a subset of the roots of `p`.
- Finally, to show that the expression is symmetric with respect to permutations, it demonstrates the invariance of `Z m` under any permutation `g` of the roots of `p`, `Z (m o g) = Z m`, which leads to the conclusion that the sum belongs to `QinC` by applying the theorem `symmetric_subring_if_poly_subring`.

### Mathematical insight
This theorem relates the symmetric sums of powers of roots to the `QinC` subring. It essentially provides a condition under which certain combinations of roots, specifically those related to numbers of preimages, belong to the `QinC` subring. The theorem uses the fact that symmetric polynomials in the roots of a polynomial can be expressed in terms of the coefficients of the polynomial and leverages squarefreeness and monicity.

### Dependencies
- `ring_polynomial`, `ring_squarefree`, `monic`, `ring_sum`, `complex_ring`, `perm`, `complex_root`, `numpreimages`, `QinC`, `poly_evaluate`, `poly_pow`, `poly_var`, `monic_vanishing_at`, `subring_generated`
- Theorems: `poly_complex_if_poly_QinC`, `monic_poly_0`, `ring_1_0_QinC`, `poly_0_QinC_eq_poly_0_complex`, `complex_root_le_deg`, `finite_perm`, `finite_functions`, `FINITE_RESTRICT`
- Theorems (used in reasoning): `poly_pow_in_poly_ring`, `poly_in_full_ring`, `poly_ring_use_pow`, `poly_evaluate_sum`, `RING_SUM_EQ`, `poly_evaluate_pow`, `ring_pow_complex`, `POLY_EVALUATE_VAR`, `in_complex_ring`, `I_THM`, `monic_QinC_squarefree_complex_squarefree`, `monic_subring`, `subring_complex_QinC`, `coeff_poly_in_ring`, `RING_POLYNOMIAL_VAR`, `poly_pow_subring`, `ring_powerseries_if_polynomial`, `ring_polynomial_subring_sum`, `ring_polynomial_subring_var`, `poly_pow_poly`, `GSYM poly_sum_subring_multi`, `poly_vars_sum_poly_subset`, `RING_SUM`, `RING_POLYNOMIAL_VAR`, `inverse_permutes_o_functions_perm`, `numpreimages_permutes_o_perm`, `inverse_permutes_o_refl_o`, `PERMUTES_INVERSE`, `image_permutes_o_perm`, `symmetric_subring_if_poly_subring`, `QinC_ring_clauses`, `PERMUTES_INVERSES_o`, `I_O_ID`, `o_ASSOC`, `ring_sum_poly_o_permutes`, `poly_var_o_permutes`, `inverse_permutes_o_refl_o`, `image_permutes_o_perm`

### Porting notes (optional)
- The theorem relies on the existence of the `QinC` ring and its properties, which might need to be defined or imported in other proof assistants.
- The manipulation of polynomials and their roots, specifically symmetric functions, would require similar algebraic and field theory libraries.
- The tactic `ASM SET_TAC[]` indicates a goal is completed by contradiction/absurdity present within the assumptions available in the goal.
- The use of tactic `sufficesby` indicates that the theorem prover knows a named theorem that completes a goal once the named theorem is applied.


---

## zero_sum_QinC_exp_squarefree_roots_lemma_sym_coeff_poly

### Name of formal statement
zero_sum_QinC_exp_squarefree_roots_lemma_sym_coeff_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_QinC_exp_squarefree_roots_lemma_sym_coeff_poly = prove(`
  !p e n.
  ring_polynomial QinC_ring p ==>
  ring_squarefree(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  coeff n (
    monic_vanishing_at complex_ring
      {f | f IN functions (perm(complex_root p)) (complex_root p) /\ numpreimages f (perm(complex_root p)) = e}
      (\f. (ring_sum complex_ring (perm(complex_root p)) (\i. i (f i))))
  ) IN QinC
`,
  intro THEN
  recall subring_complex_QinC THEN
  recall QinC_ring_clauses THEN
  subgoal `!d. ring_sum complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s. ring_pow complex_ring (ring_sum complex_ring (perm (complex_root p)) (\i. i (s i))) d) IN ring_carrier (subring_generated complex_ring QinC)` THENL [
    specialize[
      `p:(1->num)->complex`;
      `e:complex->num`
    ]zero_sum_QinC_exp_squarefree_roots_lemma_sym_powersums THEN
    rw[ring_pow_complex] THEN
    qed[]
  ; pass
  ] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;ring_1_0_QinC] THEN
  have `~(p = poly_0 complex_ring:(1->num)->complex)` [poly_0_QinC_eq_poly_0_complex] THEN
  have `FINITE(complex_root p)` [complex_root_le_deg] THEN
  have `FINITE(perm(complex_root p))` [finite_perm] THEN
  have `FINITE(functions (perm(complex_root p)) (complex_root p))` [finite_functions] THEN
  specialize[
    `functions (perm (complex_root p)) (complex_root p)`;
    `\f:(complex->complex)->complex. numpreimages f (perm(complex_root p)) = e`
  ]FINITE_RESTRICT THEN
  have `ring_hasQ (subring_generated complex_ring QinC)` [subring_complex_QinC;ring_hasQ_QinC] THEN
  have `!s. s IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> ring_sum complex_ring (perm (complex_root p)) (\i. i (s i)) IN ring_carrier complex_ring` [in_complex_ring] THEN
  specialize[
    `complex_ring`;
    `QinC`;
    `{f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}`;
    `\f. ring_sum complex_ring (perm (complex_root p)) (\i:complex->complex. i (f i))`
  ]coeff_poly_subring_if_powersums_subring THEN
  qed[]
);;
```

### Informal statement
For all polynomials `p`, natural number `e`, and natural number `n`, if `p` is a polynomial over the ring `QinC`, `p` is squarefree in the ring `QinC`, and `p` is monic in the ring `QinC`, then the coefficient of `x^n` in the polynomial obtained by evaluating the `monic_vanishing_at` function (in the ring of complex numbers) on the set of functions `f` from `perm(complex_root p)` to `complex_root p` such that the number of preimages of `f` is `e`, evaluated at the function that maps `f` to the sum over `perm(complex_root p)` of `i(f i)` is an element of `QinC`.

### Informal sketch
The proof proceeds as follows:
- Introduce the assumptions.
- Recall the fact that `QinC` is a subring of the complex numbers (`subring_complex_QinC`) and facts about the ring structure of `QinC` (`QinC_ring_clauses`).
- Show that `ring_sum complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\s. ring_pow complex_ring (ring_sum complex_ring (perm (complex_root p)) (\i. i (s i))) d)` is in `ring_carrier (subring_generated complex_ring QinC)`. This step involves:
  - Specializing `zero_sum_QinC_exp_squarefree_roots_lemma_sym_powersums`.
  - Rewriting using `ring_pow_complex`.
- Prove `ring_polynomial complex_ring (p:(1->num)->complex)` using `poly_complex_if_poly_QinC`.
- Show that `p` is not the zero polynomial in `QinC` and in `complex_ring`.
- Show that `complex_root p` is finite, `perm(complex_root p)` is finite, and `functions (perm(complex_root p)) (complex_root p)` is finite.
- Specialize `FINITE_RESTRICT`.
- Show `ring_hasQ (subring_generated complex_ring QinC)` from `subring_complex_QinC` and `ring_hasQ_QinC`.
- show that s IN {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} ==> ring_sum complex_ring (perm (complex_root p)) (\i. i (s i)) IN ring_carrier complex_ring` using `in_complex_ring`.
- Specialize `coeff_poly_subring_if_powersums_subring`.

### Mathematical insight
This theorem relates the coefficients of a polynomial constructed from the roots of another polynomial to the ring `QinC`, demonstrating a connection between algebraic structures and the properties of roots and coefficients. The core idea is that if the original polynomial has coefficients in `QinC` and satisfies certain squarefree and monic conditions, then coefficients of other polymonials constructed by permuting function of root vanish also lies in `QinC`.

### Dependencies
- Theorems:
  - `subring_complex_QinC`
  - `QinC_ring_clauses`
  - `zero_sum_QinC_exp_squarefree_roots_lemma_sym_powersums`
  - `ring_pow_complex`
  - `poly_complex_if_poly_QinC`
  - `monic_poly_0`
  - `ring_1_0_QinC`
  - `poly_0_QinC_eq_poly_0_complex`
  - `complex_root_le_deg`
  - `finite_perm`
  - `finite_functions`
  - `FINITE_RESTRICT`
  - `subring_complex_QinC`
  - `ring_hasQ_QinC`
  - `in_complex_ring`
  - `coeff_poly_subring_if_powersums_subring`

### Porting notes (optional)
- The theorem uses higher-order functions extensively (functions from complex to complexes and restricting finite sets by a certain property), so the target system must handle these features effectively.
- The tactic `specialize` is used frequently. Ensure the target system provide way to automatically perform beta-reduction after specializing a variable inside the goal.


---

## zero_sum_QinC_exp_squarefree_roots_lemma_sym_poly

### Name of formal statement
zero_sum_QinC_exp_squarefree_roots_lemma_sym_poly

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_QinC_exp_squarefree_roots_lemma_sym_poly = prove(`
  !p e.
  ring_polynomial QinC_ring p ==>
  ring_squarefree(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  ring_polynomial QinC_ring (
    monic_vanishing_at complex_ring
      {f | f IN functions (perm(complex_root p)) (complex_root p) /\ numpreimages f (perm(complex_root p)) = e}
      (\f. (ring_sum complex_ring (perm(complex_root p)) (\i. i (f i))))
  )
`,
  intro THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;ring_1_0_QinC] THEN
  have `~(p = poly_0 complex_ring:(1->num)->complex)` [poly_0_QinC_eq_poly_0_complex] THEN
  have `FINITE(complex_root p)` [complex_root_le_deg] THEN
  have `FINITE(perm(complex_root p))` [finite_perm] THEN
  have `FINITE(functions (perm(complex_root p)) (complex_root p))` [finite_functions] THEN
  specialize[
    `functions (perm (complex_root p)) (complex_root p)`;
    `\f:(complex->complex)->complex. numpreimages f (perm(complex_root p)) = e`
  ]FINITE_RESTRICT THEN
  rw[GSYM subring_complex_QinC] THEN
  sufficesby ring_polynomial_subring_if_coeffs THEN
  specialize[`p:(1->num)->complex`;`e:complex->num`]zero_sum_QinC_exp_squarefree_roots_lemma_sym_coeff_poly THEN
  specialize_assuming[
    `complex_ring`;
    `{x | x IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages x (perm (complex_root p)) = e}`;
    `\f. ring_sum complex_ring (perm (complex_root p)) (\i:complex->complex. i (f i))`
  ]monic_vanishing_at_poly THEN
  qed[in_complex_ring;subring_complex_QinC;QinC_ring_clauses]
);;
```
### Informal statement
For all polynomials `p` and complex numbers `e`, if `p` is a ring polynomial over `QinC_ring`, `p` is squarefree over `x_poly QinC_ring`, and `p` is monic over `QinC_ring`, then the polynomial whose roots are the values of a symmetric polynomial applied to the roots of `p` is also a ring polynomial over `QinC_ring`. Specifically, this polynomial is the monic polynomial vanishing at the set of values obtained by taking the ring sum over all elements `i` of the set of permutations of the complex roots of `p`, `perm(complex_root p)`, of `i(f i)`, where `f` ranges over the set of functions from `perm(complex_root p)` to `complex_root p` such that the number of preimages of `f` in `perm(complex_root p)` is equal to `e`.

### Informal sketch
The proof proceeds by:
- Introducing the assumptions that `p` is a ring polynomial, squarefree, and monic.
- Showing that `p` is a ring polynomial over the complex numbers, and not the zero polynomial, hence `complex_root p` is finite, and `perm(complex_root p)` and `functions (perm (complex_root p)) (complex_root p)` are finite too.
- Restricting the `FINITE` theorem to the subset of functions `f` where `numpreimages f (perm(complex_root p)) = e`.
- Rewriting the goal to check that the polynomial has QinC coefficients.
- Applying `zero_sum_QinC_exp_squarefree_roots_lemma_sym_coeff_poly` to show that the coefficients are in `QinC`.
- Applying `monic_vanishing_at_poly` to show that the polynomial whose roots are the values of a symmetric polynomial applied to the roots of `p` is also a ring polynomial over `complex_ring`.
- Concluding that the polynomial with the specified symmetric polynomial applied to the roots is a ring polynomial over `QinC` because the coefficients are in `QinC`.

### Mathematical insight
This theorem relates the symmetric polynomial applied to the roots of a polynomial over `QinC` to another polynomial over `QinC`, thereby establishing the closure under certain symmetric operations. It is a key step in demonstrating that algebraic numbers constructible by radicals are closed under certain operations. The importance stems from the connection between number theory and polynomial algebra.

### Dependencies
- `ring_polynomial`
- `QinC_ring`
- `ring_squarefree`
- `x_poly`
- `monic`
- `complex_root`
- `perm`
- `functions`
- `numpreimages`
- `ring_sum`
- `monic_vanishing_at`
- `poly_complex_if_poly_QinC`
- `monic_poly_0`
- `ring_1_0_QinC`
- `poly_0_QinC_eq_poly_0_complex`
- `complex_root_le_deg`
- `finite_perm`
- `finite_functions`
- `FINITE_RESTRICT`
- `subring_complex_QinC`
- `ring_polynomial_subring_if_coeffs`
- `in_complex_ring`
- `QinC_ring_clauses`
- `zero_sum_QinC_exp_squarefree_roots_lemma_sym_coeff_poly`



---

## zero_sum_QinC_exp_squarefree_roots_lemma_denouement

### Name of formal statement
zero_sum_QinC_exp_squarefree_roots_lemma_denouement

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_QinC_exp_squarefree_roots_lemma_denouement = prove(`
  !S:complex->bool B:complex->complex.
  FINITE S ==>
  ( !a.
    ring_sum complex_ring
      (
        IMAGE
          (\f. numpreimages f (perm S))
          (functions (perm S) S)
      ) (
        \s.
          ring_product complex_ring
            {y | ~(s y = 0)}
            ( \y. (B y) pow (s y))
          * Cx(&(
              numpreimages (
                \f.
                  ring_sum complex_ring
                    (perm S)
                    (\i. i (f i))
              ) {
                f | f IN functions (perm S) (S) /\
                    numpreimages f (perm S) = s
              } a
          ))
      )
    = Cx (&0)
  ) ==>
  (!z. z IN S ==> B z = Cx(&0))
`,
  intro THEN
  subgoal `ring_product (x_series complex_ring) (perm S) (\i. ring_sum (x_series complex_ring) S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z)))) = ring_0(x_series complex_ring)` THENL [
    specialize[
      `B:complex->complex`;
      `S:complex->bool`
    ]product_perm_sum_mul_expformal_expand_v3 THEN
    simp[] THEN
    rw[GSYM complex_ring_clauses;POLY_CONST_0] THEN
    subgoal `ring_sum (x_series complex_ring) (IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S)) (\a. poly_mul complex_ring (poly_0 complex_ring) (expformal a)) = ring_sum (x_series complex_ring) (IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S)) (\a. ring_0(x_series complex_ring))` THENL [
      sufficesby RING_SUM_EQ THEN
      intro THEN
      have `ring_powerseries complex_ring (expformal a)` [series_complex] THEN
      simp[POWSER_MUL_0] THEN
      rw[x_series_use]
    ; pass
    ] THEN
    simp[RING_SUM_0]
  ; pass
  ] THEN
  have `integral_domain complex_ring` [integral_domain_complex] THEN
  have `integral_domain(x_series complex_ring)` [INTEGRAL_DOMAIN_POWSER_RING;x_series] THEN
  have `FINITE(perm(S:complex->bool))` [finite_perm] THEN
  choose `i:complex->complex` `i IN perm(S:complex->bool) /\ ring_sum (x_series complex_ring) S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z))) = ring_0 (x_series complex_ring)` [INTEGRAL_DOMAIN_PRODUCT_EQ_0] THEN
  subgoal `poly_sum complex_ring S (\z:complex. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z))) = poly_0 complex_ring` THENL [
    rw[poly_sum] THEN
    qed[x_series_use]
  ; pass
  ] THEN
  qed[expformal_perm_linearly_independent;IN;perm]
);;
```
### Informal statement
For all `S` of type complex -> bool and `B` of type complex -> complex, if `S` is finite, then if the following holds: for all `a`, the sum, over the image under the function taking `f` to the number of preimages of `f` under `perm S`, mapping functions from `perm S` to `S`, of the function taking `s` to the product, over the set of `y` such that `s y` is not 0, of `B y` raised to the power of `s y`, multiplied by the complex constant obtained by converting to a complex number the number of preimages of the function taking `f` to the sum, over `perm S`, of the function taking `i` to `i(f i)`, mapping functions `f` from `perm S` to `S` such that the number of preimages of `f` under `perm S` is `s`, evaluated at `a`, is equal to 0, then for all `z`, if `z` is in `S`, then `B z` equals 0.

### Informal sketch
The theorem states that given a finite set `S` of complex numbers, if a certain summation condition linking the values of `S` and a function `B` holds, then we can conclude that the function `B` must be zero on all elements of the set `S`.

The proof proceeds as follows:
- Intro: Introduce the hypothesis.
- `ring_product (x_series complex_ring) (perm S) (\i. ring_sum (x_series complex_ring) S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z)))) = ring_0(x_series complex_ring)`: Specializes the initial assumption, rewrites using `product_perm_sum_mul_expformal_expand_v3`, simplifies, and rewrites with `complex_ring_clauses` and `POLY_CONST_0`. It then shows that `ring_sum (x_series complex_ring) (IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S)) (\a. poly_mul complex_ring (poly_0 complex_ring) (expformal a)) = ring_sum (x_series complex_ring) (IMAGE (\f. ring_sum complex_ring (perm S) (\i. i (f i))) (functions (perm S) S)) (\a. ring_0(x_series complex_ring))` by proving that `poly_mul complex_ring (poly_0 complex_ring) (expformal a) = ring_0(x_series complex_ring)`. It uses `RING_SUM_EQ` after obtaining `ring_powerseries complex_ring (expformal a)` using `series_complex`
- Then, we use the fact that `integral_domain complex_ring` and `integral_domain(x_series complex_ring)` as well as `FINITE(perm(S:complex->bool))`. From this, we can apply `INTEGRAL_DOMAIN_PRODUCT_EQ_0` to choose an `i` s.t. `i IN perm(S:complex->bool) /\ ring_sum (x_series complex_ring) S (\z. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z))) = ring_0 (x_series complex_ring)`.
- We prove that `poly_sum complex_ring S (\z:complex. poly_mul complex_ring (poly_const complex_ring (B z)) (expformal (i z))) = poly_0 complex_ring` by rewriting with `poly_sum` and using `x_series_use`.
- Finally, the proof concludes from `expformal_perm_linearly_independent`, `IN` and `perm`.

### Mathematical insight
This theorem seems to target exponential sums and their roots, specifically looking at situations where a certain weighted sum involving roots squares to zero implies a simpler conclusion that the weights themselves must be zero on the set of roots.

### Dependencies
- `complex_ring_clauses`
- `POLY_CONST_0`
- `INTEGRAL_DOMAIN_POWSER_RING`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `expformal_perm_linearly_independent`

### Porting notes (optional)
- Ensure that the target proof assistant has a well-developed theory of complex numbers, formal power series, and integral domains.
- The tactic `choose` relies on classical logic and the axiom of choice, which might require specific settings or axioms in other proof assistants.
- The proof makes use of several ring and polynomial simplification rules that might need to be explicitly stated or proven in other systems.


---

## zero_sum_QinC_exp_squarefree_roots

### Name of formal statement
zero_sum_QinC_exp_squarefree_roots

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_QinC_exp_squarefree_roots = prove(`
  !p B.
  ring_polynomial QinC_ring p ==>
  ring_squarefree(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  (!z:complex. complex_root p z ==> B z IN QinC) ==>
  ring_sum complex_ring (complex_root p) (\z. (B z) * cexp z) = Cx(&0) ==>
  (!z. complex_root p z ==> B z = Cx(&0))
`,
  intro_gendisch THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;ring_1_0_QinC] THEN
  have `~(p = poly_0 complex_ring:(1->num)->complex)` [poly_0_QinC_eq_poly_0_complex] THEN
  have `FINITE(complex_root p)` [complex_root_le_deg] THEN
  have `FINITE(perm(complex_root p))` [finite_perm] THEN
  have `FINITE(functions (perm(complex_root p)) (complex_root p))` [finite_functions] THEN
  subgoal `ring_sum complex_ring (IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p))) (\e. ring_product complex_ring {y | ~(e y = 0)} (\y. (B y) pow (e y)) * ring_sum complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\f. cexp (ring_sum complex_ring (perm (complex_root p)) (\i. i (f i))))) = Cx (&0)` THENL [
    rw[ISPEC `cexp` (GSYM o_DEF)] THEN
    specialize[
      `B:complex->complex`;
      `complex_root p`
    ](GSYM product_perm_sum_mul_cexp_expand) THEN
    simp[] THEN
    rw[complex_ring_clauses] THEN
    have `I IN perm(complex_root p)` [IN;perm;PERMUTES_I] THEN
    subgoal `ring_sum complex_ring (complex_root p) (\z. (B z) * cexp (I z)) = Cx(&0)` THENL [
      rw[I_THM] THEN
      qed[]
    ; pass
    ] THEN
    have `ring_sum complex_ring (complex_root p) (\z. B z * cexp (I z)) IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `perm(complex_root p)`;
      `I:complex->complex`;
      `\i. ring_sum complex_ring (complex_root p) (\z. (B z) * cexp (i z))`
    ]ring_product_delete THEN
    simp[] THEN
    rw[complex_ring_clauses] THEN
    CONV_TAC COMPLEX_FIELD
  ; pass
  ] THEN
  have `!e. ring_polynomial QinC_ring (monic_vanishing_at complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e} (\f. ring_sum complex_ring (perm (complex_root p)) (\i. i (f i))))` [zero_sum_QinC_exp_squarefree_roots_lemma_sym_poly] THEN
  have `FINITE(IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p)))` [FINITE_IMAGE] THEN
  subgoal `!s. s IN IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p)) ==> ring_product complex_ring {y | ~(s y = 0)} (\y. (B y) pow (s y)) IN QinC` THENL [
    rw[IN_IMAGE] THEN
    intro THEN
    rw[GSYM QinC_ring_clauses] THEN
    rw[GSYM subring_complex_QinC] THEN
    sufficesby ring_product_in_subring THEN
    rw[IN_ELIM_THM;BETA_THM] THEN
    intro THEN
    rw[GSYM ring_pow_complex] THEN
    sufficesby ring_pow_in_subring THEN
    rw[QinC_ring_clauses;subring_complex_QinC] THEN
    subgoal `s' IN {y:complex | ~(numpreimages x (perm(complex_root p)) y = 0)}` THENL [
      rw[IN_ELIM_THM] THEN
      qed[]
    ; pass
    ] THEN
    subgoal `s':complex IN IMAGE x (perm(complex_root p))` THENL [
      simp[image_numpreimages]
    ; pass
    ] THEN
    have `IMAGE x (perm(complex_root p)) SUBSET complex_root p` [image_functions_subset] THEN
    have `s' IN complex_root p` [SUBSET] THEN
    qed[IN]
  ; pass
  ] THEN
  subgoal `!s. s IN IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p)) ==> FINITE {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = s}` THENL [
    rw[IN_IMAGE] THEN
    intro THEN
    specialize[
      `functions (perm (complex_root p)) (complex_root p)`;
      `\f:(complex->complex)->complex. numpreimages f (perm(complex_root p)) = s`
    ]FINITE_RESTRICT THEN
    qed[]
  ; pass
  ] THEN
  have `!s. s IN IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p)) ==> ring_polynomial QinC_ring (monic_vanishing_at complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = s} (\f. ring_sum complex_ring (perm (complex_root p)) (\i. i (f i))))` [] THEN
  subgoal `ring_sum complex_ring (IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p))) (\s. ring_product complex_ring {y | ~(s y = 0)} (\y. (B y) pow (s y)) * ring_sum complex_ring {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = s} (cexp o (\f. ring_sum complex_ring (perm (complex_root p)) (\i. i (f i))))) = Cx (&0)` THENL [
    rw[o_DEF] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `IMAGE (\f. numpreimages f (perm (complex_root p))) (functions (perm (complex_root p)) (complex_root p))`;
    `\e. ring_product complex_ring {y:complex | ~(e y = 0)} (\y. (B y) pow (e y))`;
    `\f. ring_sum complex_ring (perm (complex_root p)) (\i:complex->complex. i (f i))`;
    `\e. {f | f IN functions (perm (complex_root p)) (complex_root p) /\ numpreimages f (perm (complex_root p)) = e}`
  ]transcendence_weighted_QinC_monic_vanishing_at THEN
  specialize_assuming[
    `complex_root p`;
    `B:complex->complex`
  ]zero_sum_QinC_exp_squarefree_roots_lemma_denouement THEN
  qed[zero_sum_QinC_exp_squarefree_roots_lemma_denouement;IN]
);;
```
### Informal statement
For any polynomial `p` over the `QinC_ring` and any function `B` from complex numbers to complex numbers, if `p` is a polynomial over the `QinC_ring`, `p` is squarefree in the `QinC_ring` when considered as a polynomial with coefficients that are `x_poly QinC_ring`, `p` is monic in the `QinC_ring`, for all complex numbers `z`, if `z` is a complex root of `p`, then `B z` is in the `QinC`, and the `complex_ring` sum of `(B z) * cexp z` over the complex roots `z` of `p` is `Cx(&0)`, then for all `z`, if `z` is a complex root of `p`, then `B z` is `Cx(&0)`.

### Informal sketch
The proof proceeds by contradiction. It assumes that the polynomial `p` satisfies the given conditions: it is a squarefree monic polynomial over `QinC`, its roots have values in `QinC` when `B` is applied to them, and the sum of `B(z) * exp(z)` over the roots `z` is zero. The goal is to show `B(z) = 0` for all roots `z` of `p`.

- First, the polynomial `p` is shown to also be a polynomial over the complex numbers.
- Then, shows that it is a non zero polynomial.
- Show that `complex_root p` denote the set of the roots of p, is finite and therefore its permutations and functions are also finite.
- The proof leverages a previously established result, `product_perm_sum_mul_cexp_expand`, by specializing it for the given function `B` and the set of roots `complex_root p`, simplifies the expression relating the sum to the roots via the identity function `I`.
- The proof then aims to apply a transcendence result, `transcendence_weighted_QinC_monic_vanishing_at`, which requires demonstrating that various terms are in `QinC`. This involves showing, for any `s` in a specific image set, that polynomial related to `B`, raised to the power of `s y` is in `QinC``, and various sets involving the roots are finite.
- Finally, it invokes `zero_sum_QinC_exp_squarefree_roots_lemma_denouement` to conclude.

The proof makes heavy use of rewriting with ring and field properties to simplify expressions, and specializes earlier theorems to fit the specific context of this proof.

### Mathematical insight
This theorem states that if a certain sum involving exponential functions evaluated at the roots of a polynomial over `QinC` is zero, then the coefficients `B(z)` must be zero at each root. This is likely related to results in transcendence theory. The restriction to squarefree monic polynomials suggests that multiple roots would complicate the result.

### Dependencies
- `ring_polynomial`
- `ring_squarefree`
- `monic`
- `complex_root`
- `QinC`
- `ring_sum`
- `cexp`
- `Cx`
- `intro_gendisch`
- `poly_complex_if_poly_QinC`
- `monic_poly_0`
- `ring_1_0_QinC`
- `poly_0_QinC_eq_poly_0_complex`
- `complex_root_le_deg`
- `finite_perm`
- `finite_functions`
- `zero_sum_QinC_exp_squarefree_roots_lemma_sym_poly`
- `FINITE_IMAGE`
- `ISPEC`
- `GSYM`
- `o_DEF`
- `product_perm_sum_mul_cexp_expand`
- `complex_ring_clauses`
- `IN`
- `perm`
- `PERMUTES_I`
- `I_THM`
- `in_complex_ring`
- `ring_product_delete`
- `COMPLEX_FIELD`
- `QinC_ring_clauses`
- `subring_complex_QinC`
- `IN_ELIM_THM`
- `BETA_THM`
- `ring_pow_complex`
- `image_numpreimages`
- `image_functions_subset`
- `SUBSET`
- `FINITE_RESTRICT`
- `transcendence_weighted_QinC_monic_vanishing_at`
- `zero_sum_QinC_exp_squarefree_roots_lemma_denouement`

### Porting notes (optional)
The theorem depends heavily on the `QinC` ring definition and associated properties. Porting this requires careful attention to how polynomials and roots are represented in the target system, and making sure that field and ring operations behave as expected. The specialization of `product_perm_sum_mul_cexp_expand` and the transcendence result are key steps that need to be faithfully reproduced.


---

## zero_sum_QinC_exp_algebraic

### Name of formal statement
zero_sum_QinC_exp_algebraic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_QinC_exp_algebraic = prove(`
  !S B.
  FINITE S ==>
  S SUBSET algebraic_number ==>
  (!s. s IN S ==> B s IN QinC) ==>
  ring_sum complex_ring S (\s. (B s) * cexp s) = Cx(&0) ==>
  (!s. s IN S ==> B s = Cx(&0))
`,
  intro THEN
  specialize[`S:complex->bool`]squarefree_from_algebraic_set THEN
  choose `p:(1->num)->complex` `ring_polynomial QinC_ring p /\ ring_squarefree (x_poly QinC_ring) p /\ monic QinC_ring p /\ S SUBSET complex_root p` [] THEN
  def `C:complex->complex` `\z:complex. if z IN S then B z else Cx(&0)` THEN
  subgoal `!z. complex_root p z ==> C z IN QinC` THENL [
    intro THEN
    rw[know `C = (\z:complex. if z IN S then B z else Cx(&0))`] THEN
    qed[QinC_0]
  ; pass
  ] THEN
  specialize_assuming[
    `p:(1->num)->complex`;
    `C:complex->complex`
  ]zero_sum_QinC_exp_squarefree_roots THEN
  subgoal `!z. complex_root p z ==> C z = Cx(&0)` THENL [
    subgoal `ring_sum complex_ring (complex_root p) (\z. C z * cexp z) = Cx (&0)` THENL [
      subgoal `ring_sum complex_ring (complex_root p) (\z. C z * cexp z) = ring_sum complex_ring (complex_root p) (\s. if s IN S then C s * cexp s else ring_0 complex_ring)` THENL [
        sufficesby RING_SUM_EQ THEN
        rw[BETA_THM] THEN
        intro THEN
        rw[know `C = (\z:complex. if z IN S then B z else Cx(&0))`] THEN
        rw[complex_ring_clauses] THEN
        qed[COMPLEX_MUL_LZERO]
      ; pass
      ] THEN
      rw[know `ring_sum complex_ring (complex_root p) (\z. C z * cexp z) = ring_sum complex_ring (complex_root p) (\s. if s IN S then C s * cexp s else ring_0 complex_ring)`] THEN
      have `S SUBSET complex_root p` [] THEN
      specialize[
        `complex_ring`;
        `S:complex->bool`;
        `complex_root p`;
        `\z. C z * cexp z`
      ]ring_sum_restrict_subset THEN
      rw[know `ring_sum complex_ring (complex_root p) (\s. if s IN S then C s * cexp s else ring_0 complex_ring) = ring_sum complex_ring S (\z. C z * cexp z)`] THEN
      subgoal `ring_sum complex_ring S (\z. C z * cexp z) = ring_sum complex_ring S (\z. B z * cexp z)` THENL [
        sufficesby RING_SUM_EQ THEN
        rw[know `C = (\z:complex. if z IN S then B z else Cx(&0))`] THEN
        qed[]
      ; pass
      ] THEN
      simp[]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  have `complex_root p s` [IN;SUBSET] THEN
  have `C(s:complex) = Cx(&0)` [] THEN
  qed[]
);;
```

### Informal statement
For any set `S` of complex numbers and any function `B` from complex numbers to Gaussian rationals, if `S` is finite, `S` is a subset of the algebraic numbers, for all `s` in `S`, `B s` is in the Gaussian rationals, and the ring sum over `S` of `B s` times the complex exponential of `s` is equal to the complex number 0, then for all `s` in `S`, `B s` is equal to the complex number 0.

### Informal sketch
The proof proceeds by induction on the algebraic numbers. Assume `S` is a finite subset of algebraic numbers and that the weighted sum of exponentials of elements in `S` (weighted by Gaussian rationals) is zero. The goal is to show that all the weights are zero.

- First, specialize `squarefree_from_algebraic_set` to show that there exists a squarefree monic polynomial `p` over the Gaussian rationals `QinC`, such that `S` is a subset of the roots of `p`.
- Define a function `C` that agrees with `B` on `S` and is zero otherwise.
- Verify that for any `z`, if `z` is a root of the polynomial `p`, then `C z` is in `QinC` using `QinC_0`.
- Apply the theorem `zero_sum_QinC_exp_squarefree_roots` after specializing it with `p` and `C`. This theorem states that if the weighted sum of exponentials of the roots of a monic squarefree polynomial `p` over `QinC` is zero, where the weights are Gaussian rationals, then all weights must be zero.
- The main part of the proof involves showing that the conditions for `zero_sum_QinC_exp_squarefree_roots` are met, in particular demonstrating that the ring sum over the roots of `p` of `C z * cexp z` is equal to the ring sum over `S` of `B z * cexp z`, which is zero by assumption. To do this, we show that the ring sum over the roots of `p` of `C z * cexp z` is equal to the ring sum over the roots of `p` restricted to `S` of `C z * cexp z`.
- By assumption on `S`, the weighted sum over `S` is assumed to be `Cx(&0)`.
- Finally, conclude that for all `s` in `S`, `C s = Cx(&0)`, and therefore that for all `s` in `S`, `B s = Cx(&0)`.

### Mathematical insight
This theorem extends the Lindemann-Weierstrass theorem. It states that if a finite set of algebraic numbers are linearly independent over the rationals, then their exponentials are algebraically independent. This theorem builds upon the result for squarefree polynomials and extends it to arbitrary sets of algebraic numbers.

### Dependencies
- `FINITE`
- `SUBSET`
- `algebraic_number`
- `QinC`
- `ring_sum`
- `complex_ring`
- `cexp`
- `Cx`
- `squarefree_from_algebraic_set`
- `ring_polynomial`
- `ring_squarefree`
- `x_poly`
- `monic`
- `complex_root`
- `zero_sum_QinC_exp_squarefree_roots`
- `QinC_0`
- `RING_SUM_EQ`
- `BETA_THM`
- `complex_ring_clauses`
- `COMPLEX_MUL_LZERO`
- `ring_sum_restrict_subset`


---

## transcendental_if_exp_nonzero_algebraic

### Name of formal statement
transcendental_if_exp_nonzero_algebraic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendental_if_exp_nonzero_algebraic = prove(`
  !a.
  algebraic_number a /\ algebraic_number(cexp a)
  ==> a = Cx(&0)
`,
  intro THEN
  proven_if `a = Cx(&0)` [] THEN
  choose `f:(1->num)->complex` `ring_polynomial QinC_ring f /\ ~(f = poly_0 QinC_ring) /\ monic QinC_ring f /\ ring_irreducible(x_poly QinC_ring) f /\ poly_eval complex_ring f (cexp a) = Cx(&0)` [algebraic_number_is_root_monic_irreducible_QinC_poly] THEN
  have `FINITE(IMAGE (\i. Cx(&i) * a) (0..poly_deg complex_ring(f:(1->num)->complex)))` [FINITE_IMAGE;FINITE_NUMSEG] THEN
  subgoal `IMAGE (\i. Cx (&i) * a) (0..poly_deg complex_ring(f:(1->num)->complex)) SUBSET algebraic_number` THENL [
    rw[SUBSET;IN_IMAGE] THEN
    qed[algebraic_number_mul;algebraic_number_ZinC;num_in_ZinC;IN]
  ; pass
  ] THEN
  have `!s. s IN IMAGE (\i. Cx (&i) * a) (0..poly_deg complex_ring f) ==> coeff (@i. s = Cx (&i) * a) f IN QinC` [coeff_poly_in_ring;QinC_ring_clauses] THEN
  subgoal `!i j. Cx(&i)*a = Cx(&j)*a ==> i = j` THENL [
    intro THEN
    complex_field_fact `~(a = Cx(&0)) ==> Cx(&i)*a = Cx(&j)*a ==> Cx(&i) = Cx(&j)` THEN
    qed[CX_INJ;REAL_OF_NUM_EQ]
  ; pass
  ] THEN
  subgoal `ring_sum complex_ring (IMAGE (\i. Cx (&i) * a) (0..poly_deg complex_ring f)) (\s. coeff (@i. s = Cx (&i) * a) f * cexp s) = Cx (&0)` THENL [
    have `cexp a IN ring_carrier complex_ring` [in_complex_ring] THEN
    subgoal `f IN ring_carrier(poly_ring complex_ring (:1))` THENL [
      rw[GSYM x_poly;GSYM x_poly_use] THEN
      qed[poly_complex_if_poly_QinC]
    ; pass
    ] THEN
    specialize[`complex_ring`;`cexp a`;`f:(1->num)->complex`]POLY_EVAL_EXPAND THEN
    subgoal `!x y. x IN 0..poly_deg complex_ring(f:(1->num)->complex) ==> y IN 0..poly_deg complex_ring f ==> Cx (&x) * a = Cx (&y) * a ==> x = y` THENL [
      intro THEN
      complex_field_fact `~(a = Cx(&0)) ==> Cx(&x)*a = Cx(&y)*a ==> Cx(&x) = Cx(&y)` THEN
      qed[CX_INJ;REAL_OF_NUM_EQ]
    ; pass
    ] THEN
    specialize[
      `complex_ring`;
      `\i. Cx(&i) * a`;
      `\s. coeff (@i. s = Cx (&i) * a) f * cexp s`;
      `0..poly_deg complex_ring(f:(1->num)->complex)`
    ]RING_SUM_IMAGE THEN
    rw[know `ring_sum complex_ring (IMAGE (\i. Cx (&i) * a) (0..poly_deg complex_ring f)) (\s. coeff (@i. s = Cx (&i) * a) f * cexp s) = ring_sum complex_ring (0..poly_deg complex_ring f) ((\s. coeff (@i. s = Cx (&i) * a) f * cexp s) o (\i. Cx (&i) * a))`] THEN
    rw[o_DEF] THEN
    subgoal `ring_sum complex_ring (0..poly_deg complex_ring f) (\x. coeff (@i. Cx (&x) * a = Cx (&i) * a) f * cexp (Cx (&x) * a)) = ring_sum complex_ring (0..poly_deg complex_ring f) (\i. ring_mul complex_ring (f (\v. i)) (ring_pow complex_ring (cexp a) i))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM] THEN
      intro THEN
      subgoal `(@i. Cx(&a')*a = Cx(&i)*a) = a'` THENL [
        sufficesby SELECT_UNIQUE THEN
        qed[]
      ; pass
      ] THEN
      rw[know `(@i. Cx(&a')*a = Cx(&i)*a) = a'`] THEN
      rw[complex_ring_clauses;ring_pow_complex] THEN
      rw[coeff;x_monomial;CEXP_N]
    ; pass
    ] THEN
    qed[]
  ; pass
  ] THEN
  specialize[
    `IMAGE (\i. Cx(&i) * a) (0..poly_deg complex_ring(f:(1->num)->complex))`;
    `\z. coeff (@i. z = Cx(&i) * a) f:complex`
  ]zero_sum_QinC_exp_algebraic THEN
  subgoal `Cx(&(poly_deg complex_ring (f:(1->num)->complex)))*a IN IMAGE (\i.Cx(&i)*a) (0..poly_deg complex_ring f)` THENL [
    rw[IN_IMAGE] THEN
    witness `poly_deg complex_ring (f:(1->num)->complex)` THEN
    rw[IN_NUMSEG] THEN
    ARITH_TAC
  ; pass
  ] THEN
  have `coeff (@i. Cx(&(poly_deg complex_ring (f:(1->num)->complex)))*a = Cx (&i)*a) f = Cx (&0)` [] THEN
  have `coeff (poly_deg complex_ring (f:(1->num)->complex)) f = Cx (&0)` [] THEN
  have `coeff (poly_deg QinC_ring (f:(1->num)->complex)) f = Cx (&1)` [monic;QinC_ring_clauses] THEN
  have `coeff (poly_deg complex_ring (f:(1->num)->complex)) f = Cx (&1)` [poly_deg_subring;subring_complex_QinC] THEN
  qed[CX_INJ;REAL_OF_NUM_EQ;ARITH_RULE `~(1 = 0)`]
);;
```
### Informal statement
For all complex numbers `a`, if `a` is an algebraic number and `cexp a` is an algebraic number, then `a` is equal to `Cx(&0)` (the complex number corresponding to the real number 0).

### Informal sketch
The proof proceeds as follows:
- Assume `a` is algebraic and `cexp a` is algebraic.
- Assume for contradiction that `a` is not equal to `Cx(&0)`.
- Since `cexp a` is algebraic, there exists a polynomial `f` in `QinC[X]` (polynomial ring with coefficients in the algebraic closure of rationals in `complex_ring`) such that `f` is non-zero, monic, irreducible, and `f(cexp a) = Cx(&0)`. This is established using `algebraic_number_is_root_monic_irreducible_QinC_poly`.
- Show that the set `IMAGE (\i. Cx(&i) * a) (0..poly_deg complex_ring f)` is a finite subset of algebraic numbers.
- Then show that `ring_sum complex_ring (IMAGE (\i. Cx (&i) * a) (0..poly_deg complex_ring f)) (\s. coeff (@i. s = Cx (&i) * a) f * cexp s) = Cx (&0)`; using the fact that  `f(cexp a) = 0`, the sum is constructed from the coefficients of `f`.
- By `zero_sum_QinC_exp_algebraic` (a result stating that if a sum of algebraic numbers equals zero, then it must be that some coefficient is zero), deduce that one of the coefficients of `f` must be zero.
- Show that `coeff (poly_deg complex_ring f) f = Cx (&0)`.
- Show that `coeff (poly_deg QinC_ring f) f = Cx (&1)` because `f` is monic. Since `f` resides in `QinC` and `complex_ring`, it follows that `coeff (poly_deg complex_ring f) f = Cx (&1)`.
- Reach a contradiction, since `Cx (&0)` cannot equal `Cx (&1)`. Thus `a = Cx(&0)`.

### Mathematical insight
This theorem states that if the exponential of a complex number `a` is algebraic, then `a` cannot be an algebraic number other than 0. In other words, it demonstrates a relationship between algebraic numbers and transcendental numbers via the complex exponential function.

### Dependencies
- `algebraic_number`
- `algebraic_number_is_root_monic_irreducible_QinC_poly`
- `algebraic_number_mul`
- `algebraic_number_ZinC`
- `zero_sum_QinC_exp_algebraic`
- `coeff_poly_in_ring`
- `coeff`
- `poly_complex_if_poly_QinC`
- `poly_deg_subring`
- `monic`
- `ring_irreducible`
- `ring_polynomial`
- `ring_sum`
- `ring_carrier`

### Porting notes (optional)
- The proof makes heavy use of rewriting and specialization in HOL Light. It depends heavily on the algebraic number theory library.
- The tactic `complex_field_fact` refers to external rewriting steps involving complex number facts, so this should be handled in destination proof assistant accordingly.


---

## ring_product_functions_sum_mul_exp_expand

### Name of formal statement
ring_product_functions_sum_mul_exp_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ring_product_functions_sum_mul_exp_expand = prove(`
  !(a:A ring) (b:B ring) E:A->B c:C->B Y:A->bool Z:C->bool.
  (!x:A. x IN ring_carrier a ==>
         E x IN ring_carrier b) ==>
  E(ring_0 a) = ring_1 b ==>
  (!x y:A. E(ring_add a x y)
           = ring_mul b (E x) (E y)) ==>
  FINITE Y ==>
  FINITE Z ==>
  Y SUBSET ring_carrier a ==>
  IMAGE c Z SUBSET ring_carrier b ==>
  ring_product b (functions Y Z) (
    \f. ring_sum b Y (
      \y. ring_mul b (c (f y)) (E y)
    )
  )
  =
  ring_sum b (
    IMAGE (ring_sum a (functions Y Z)) (functions (functions Y Z) Y)
  ) (
    \z.
      ring_mul b (
        ring_sum b {g |
          g IN functions (functions Y Z) Y /\
          ring_sum a (functions Y Z) g = z
        } (\g.
          ring_product b (functions Y Z) (\f. c(f(g f)))
        )
      ) (E z)
  )
`,
  intro THEN
  have `FINITE(functions (Y:A->bool) (Z:C->bool))` [finite_functions] THEN
  subgoal `!p q. p IN functions Y Z ==> q:A IN Y ==> ring_mul b (c (p q:C)) (E q):B IN ring_carrier b` THENL [
    intro THEN
    have `IMAGE (p:A->C) Y SUBSET Z` [image_functions_subset] THEN
    have `(p:A->C) q IN IMAGE (p:A->C) Y` [IN_IMAGE] THEN
    have `(p:A->C) q IN Z` [SUBSET] THEN
    have `c((p:A->C) q):B IN IMAGE c Z` [IN_IMAGE] THEN
    have `c((p:A->C) q):B IN ring_carrier b` [SUBSET] THEN
    have `q:A IN ring_carrier a` [SUBSET] THEN
    have `(E:A->B) q IN ring_carrier b` [] THEN
    qed[RING_MUL]
  ; pass
  ] THEN
  specialize[
    `b:B ring`;
    `\f:A->C y:A. ring_mul b (c (f y:C)) (E y):B`;
    `Y:A->bool`;
    `functions (Y:A->bool) (Z:C->bool)`
  ]ring_product_sum_expand THEN
  simp[] THEN
  have `FINITE(functions (functions (Y:A->bool) (Z:C->bool)) Y)` [finite_functions] THEN
  specialize[
    `b:B ring`;
    `ring_sum a (functions (Y:A->bool) (Z:C->bool)):((A->C)->A)->A`;
    `\g. ring_product b (functions Y Z) (\f:A->C. ring_mul b (c (f (g f):C):B) (E (g f)))`;
    `functions (functions (Y:A->bool) (Z:C->bool)) Y`
  ]RING_SUM_IMAGE_GEN THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM] THEN
  intro THEN
  subgoal `ring_mul b (ring_sum b {g | g IN functions (functions Y Z) Y /\ ring_sum a (functions Y Z) g = a'} (\g. ring_product b (functions Y Z) (\f. c(f (g f):C)))) (E a') = ring_sum b {g | g IN functions (functions Y Z) Y /\ ring_sum a (functions Y Z) g = a'} (\x. ring_mul b (ring_product b (functions Y Z) (\f:A->C. c(f (x f):C))) (E a'):B)` THENL [
    have `a':A IN ring_carrier a` [IN_IMAGE;RING_SUM] THEN
    have `(E:A->B) a' IN ring_carrier b` [] THEN
    specialize[
      `functions (functions (Y:A->bool) (Z:C->bool)) Y`;
      `\g:(A->C)->A. ring_sum a (functions Y Z) g = a'`
    ]FINITE_RESTRICT THEN
    have `!g:(A->C)->A. g IN {g | g IN functions (functions Y Z) Y /\ ring_sum a (functions Y Z) g = a'} ==> ring_product b (functions Y Z) (\f:A->C. c(f (g f):C)):B IN ring_carrier b` [RING_PRODUCT] THEN
    specialize[
      `b:B ring`;
      `\g. ring_product b (functions Y Z) (\f:A->C. c(f (g f):C)):B`;
      `(E:A->B) a'`;
      `{g:(A->C)->A | g IN functions (functions Y Z) Y /\ ring_sum a (functions Y Z) g = a'}`
    ]RING_SUM_RMUL THEN
    qed[]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[IN_ELIM_THM;BETA_THM] THEN
  intro THEN
  subgoal `!f:A->C. f IN functions Y Z ==> c(f (a'' f):C):B IN ring_carrier b /\ E (a'' f) IN ring_carrier b` THENL [
    intro THEN
    have `a''(f:A->C):A IN IMAGE a'' (functions Y Z)` [IN_IMAGE] THEN
    have `IMAGE (a'':(A->C)->A) (functions Y Z) SUBSET Y` [image_functions_subset] THEN
    have `a''(f:A->C):A IN Y` [SUBSET] THEN
    have `f(a''(f:A->C)) IN IMAGE f Y` [IN_IMAGE] THEN
    have `IMAGE (f:A->C) Y SUBSET Z` [image_functions_subset] THEN
    have `f(a''(f:A->C)) IN Z` [SUBSET] THEN
    have `c(f(a''(f:A->C))):B IN IMAGE c Z` [IN_IMAGE] THEN
    qed[SUBSET]
  ; pass
  ] THEN
  specialize[
    `b:B ring`;
    `\f:A->C. c(f(a'' f)):B`;
    `\f:A->C. E(a'' f:A):B`;
    `functions (Y:A->bool) (Z:C->bool)`
  ]RING_PRODUCT_MUL THEN
  simp[] THEN
  subgoal `ring_product b (functions Y Z) (\f:A->C. E(a'' f:A):B) = E a'` THENL [
    rw[GSYM(know `ring_sum a (functions (Y:A->bool) (Z:C->bool)) a'' = a':A`)] THEN
    subgoal `!f:A->C. f IN functions Y Z ==> a'' f:A IN ring_carrier a` THENL [
      intro THEN
      have `a''(f:A->C):A IN IMAGE a'' (functions Y Z)` [IN_IMAGE] THEN
      have `IMAGE (a'':(A->C)->A) (functions Y Z) SUBSET Y` [image_functions_subset] THEN
      qed[SUBSET]
    ; pass
    ] THEN
    specialize[
      `a:A ring`;
      `b:B ring`;
      `E:A->B`;
      `a'':(A->C)->A`;
    `functions (Y:A->bool) (Z:C->bool)`
    ]ring_exp_sum THEN
    simp[] THEN
    qed[o_DEF]
  ; pass
  ] THEN
  qed[]
);;
```
### Informal statement
Given rings `a` and `b` of types `A` and `B` respectively, a function `E` from `A` to `B`, a function `c` from `C` to `B`, and boolean predicates `Y` on `A` and `Z` on `C`, if the image of `ring_carrier a` under `E` is contained in `ring_carrier b`, `E(ring_0 a)` equals `ring_1 b`, `E(ring_add a x y)` equals `ring_mul b (E x) (E y)` for all `x` and `y` in `A`, `Y` and `Z` are finite, `Y` is a subset of `ring_carrier a`, and the image of `Z` under `c` is a subset of `ring_carrier b`, then the ring product in ring `b` over the function space from `Y` to `Z` of the ring sum in `b` over `Y` of `ring_mul b (c (f y)) (E y)` is equal to the ring sum in `b` over the image of the ring sum in `a` over the function space from `Y` to `Z` under the function space from the function space from `Y` to `Z` to `Y`  of the term `ring_mul b` of  the ring sum in `b` over the set of `g` in the function space from function space from `Y` to `Z` to `Y` where `ring_sum a` over the function space from `Y` to `Z` of `g` equals `z` of a function that maps `g` to `ring_product b` over the function space from `Y` to `Z` of lambda `f` maps to `c(f(g f))` multiplied by `E z`.

### Informal sketch
The proof shows how to expand a product of sums in a ring, where the sums are indexed by a finite set.

- The proof starts by introducing assumptions and deducing that the set of functions from `Y` to `Z` is finite.
- It then uses `ring_product_sum_expand` to expand the product of sums.
- Then introduces the finiteness of the function of function from Y to Z to Y
- Applies `RING_SUM_IMAGE_GEN` to distribute the outer sum over the image which simplifies the structure.
- The tactic `RING_SUM_EQ` is used to simplify the expression.
- The terms are converted using properties relating `ring_sum` and `ring_mul`.
- Uses `RING_SUM_RMUL` to commute a constant `E a'` with `ring_sum` and applying `in_image`, `FINITE_RESTRICT` to restrict the domain of `g`.
- A computation involving `ring_product_mul` splits a product into a product over `c(f(a''(f:A->C)))` and product over `E(a'' f:A):B`.
- Finally, `ring_exp_sum` is invoked to replace product `E (a'' f:A):B` with `E a'` and the result is simplified.

### Mathematical insight
This theorem provides a generalization of the distributive property of multiplication over addition in rings. Specifically, it shows how to expand an expression involving a product of sums, where the sums are indexed by a finite set `Y`, and the product is taken over a function space of elements from `Y` to `Z`. This result is useful when dealing with polynomial expansions and combinatorial identities in a ring-theoretic context. It also shows how homomorphisms interact with ring operations.

### Dependencies
- `ring_product_sum_expand`
- `RING_SUM_IMAGE_GEN`
- `RING_SUM_EQ`
- `FINITE_RESTRICT`
- `RING_SUM_RMUL`
- `RING_PRODUCT_MUL`
- `ring_exp_sum`
- `RING_PRODUCT`

### Porting notes (optional)

- The definition relies heavily on higher-order functions due to its use of predicates and function spaces.
- Some proof assistants may require explicit coercions or type annotations to handle ring operations and function applications.
- The proof involves manipulating finite sets and their associated operations (e.g., IMAGE, SUBSET), so care should be taken to use equivalent constructions.


---

## product_functions_sum_mul_cexp_expand

### Name of formal statement
product_functions_sum_mul_cexp_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_functions_sum_mul_cexp_expand = prove(`
  !Y:complex->bool Z:complex->bool.
  FINITE Y ==>
  FINITE Z ==>
  ring_product complex_ring (functions Y Z) (
    \f. ring_sum complex_ring Y (
      \y. ring_mul complex_ring (f y) (cexp y)
    )
  )
  =
  ring_sum complex_ring (
    IMAGE (ring_sum complex_ring (functions Y Z)) (functions (functions Y Z) Y)
  ) (
    \z.
      ring_sum complex_ring {g |
        g IN functions (functions Y Z) Y /\
        ring_sum complex_ring (functions Y Z) g = z
      } (\g.
        ring_product complex_ring (functions Y Z) (\f. f(g f))
      )
      * cexp z
  )
`,
  intro THEN
  subgoal `ring_product complex_ring (functions Y Z) (\f. ring_sum complex_ring Y (\y. ring_mul complex_ring (f y) (cexp y))) = ring_sum complex_ring (IMAGE (ring_sum complex_ring (functions Y Z)) (functions (functions Y Z) Y)) (\z. ring_mul complex_ring (ring_sum complex_ring {g | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = z} (\g.  ring_product complex_ring (functions Y Z) (\f. f (g f)))) (cexp z))` THENL [
    subgoal `ring_product complex_ring (functions Y Z) (\f. ring_sum complex_ring Y (\y. ring_mul complex_ring (f y) (cexp y))) = ring_product complex_ring (functions Y Z) (\f. ring_sum complex_ring Y (\y. ring_mul complex_ring (I(f y)) (cexp y)))` THENL [
      rw[I_THM]
    ; pass
    ] THEN
    have `Y SUBSET ring_carrier complex_ring` [SUBSET;in_complex_ring] THEN
    have `Z SUBSET ring_carrier complex_ring` [SUBSET;in_complex_ring] THEN
    have `!x. x IN ring_carrier complex_ring ==> cexp x IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `cexp (ring_0 complex_ring) = ring_1 complex_ring` [CEXP_0;complex_ring_clauses] THEN
    have `!x y. cexp (ring_add complex_ring x y) = ring_mul complex_ring (cexp x) (cexp y)` [CEXP_ADD;complex_ring_clauses] THEN
    have `IMAGE I Z SUBSET ring_carrier complex_ring` [IMAGE_I;SUBSET;in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `complex_ring`;
      `cexp`;
      `I:complex->complex`
    ]ring_product_functions_sum_mul_exp_expand THEN
    simp[] THEN
    rw[I_THM]
  ; pass
  ] THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[complex_ring_clauses]
);;
```

### Informal statement
For any sets `Y` and `Z` of complex numbers, if `Y` and `Z` are finite, then the product over functions from `Y` to `Z`, where each function value `f` contributes a sum over `Y` of `f(y)` times `cexp(y)`, equals a sum which is indexed by the image of `functions Y Z` under the map that sends each function `g : Y -> Z` to `ring_sum complex_ring (functions Y Z) g`, and which sums values of the form `(sum over the set of functions g from Y to Z such that the ring sum of g is z (product indexed by functions from Y to Z such that each function contributes f(g f)))` times `cexp(z)`.

### Informal sketch
*   The theorem states an equality involving a product of sums on the left-hand side and a sum of products on the right-hand side related by exponentiation.

*   The proof starts by introducing the assumptions and setting up the goal.

*   A subgoal is established to refine the equality, specifically rewriting terms on the left and right hand sides using the identity function `I`.

*   A rewrite rule `I_THM` is used.

*   Assumptions about `Y` and `Z` being subsets of the carrier of the `complex_ring` and the properties of `cexp` are introduced using `have` tactics to utilize `ring_product_functions_sum_mul_exp_expand`.

*   The theorem `ring_product_functions_sum_mul_exp_expand` is specialized with concrete values.

*   Simplification is performed using `simp[]`.

*   The `I_THM` rewrite rule is used again.

*   Simplification is performed again.

*   The proof concludes by invoking `RING_SUM_EQ` and rewriting the `complex_ring_clauses`.

### Mathematical insight
The theorem `product_functions_sum_mul_cexp_expand` seems to provide a way to expand a product of sums involving complex exponentiation (`cexp`) into a sum involving products and sums, indexed by mapping the functions `functions Y Z` to values which are `ring_sum complex_ring (functions Y Z) g`. The core idea is to relate a product over functions to a sum over the values generated by applying the sum to those functions, modulated by terms of the form `cexp(z)`. This expansion may be useful in simplifying algebraic expressions or relating different summation/product formulations in complex analysis, particularly those involving the exponential function. The `functions Y Z` term is used several times.

### Dependencies
- `ring_product_functions_sum_mul_exp_expand`
- `I_THM`
- `CEXP_0`
- `CEXP_ADD`
- `complex_ring_clauses`
- `IMAGE_I`


---

## product_functions_sum_mul_expformal_expand

### Name of formal statement
product_functions_sum_mul_expformal_expand

### Type of the formal statement
theorem

### Formal Content
```ocaml
let product_functions_sum_mul_expformal_expand = prove(`
  !Y:complex->bool Z:complex->bool.
  FINITE Y ==>
  FINITE Z ==>
  ring_product(x_series complex_ring) (functions Y Z) (
    \f. ring_sum(x_series complex_ring) Y (
      \y. ring_mul(x_series complex_ring)
            (poly_const complex_ring (f y))
            (expformal y)
    )
  )
  =
  ring_sum(x_series complex_ring) (
    IMAGE (ring_sum complex_ring (functions Y Z)) (functions (functions Y Z) Y)
  ) (
    \z.
      poly_mul complex_ring (
        poly_const complex_ring (
          ring_sum complex_ring {g |
            g IN functions (functions Y Z) Y /\
            ring_sum complex_ring (functions Y Z) g = z
          } (\g.
            ring_product complex_ring (functions Y Z) (\f. f(g f))
          )
        )
      ) (expformal z)
  )
`,
  intro THEN
  have `!x. x IN ring_carrier complex_ring ==> expformal x IN ring_carrier (x_series complex_ring)` [series_complex;x_series_use] THEN
  have `expformal (ring_0 complex_ring) = ring_1 (x_series complex_ring)` [expformal_0;complex_ring_clauses;x_series_use] THEN
  have `!x y. expformal (ring_add complex_ring x y) = ring_mul (x_series complex_ring) (expformal x) (expformal y)` [mul_expformal;complex_ring_clauses;x_series_use] THEN
  have `Y SUBSET ring_carrier complex_ring` [SUBSET;in_complex_ring] THEN
  have `IMAGE (\c. poly_const complex_ring c) Z SUBSET ring_carrier (x_series complex_ring)` [SUBSET;series_complex;x_series_use] THEN
  specialize[
    `complex_ring`;
    `x_series complex_ring`;
    `expformal`;
    `\c. poly_const complex_ring c:(1->num)->complex`;
    `Y:complex->bool`;
    `Z:complex->bool`;
  ]ring_product_functions_sum_mul_exp_expand THEN
  simp[] THEN
  sufficesby RING_SUM_EQ THEN
  rw[BETA_THM;IN_IMAGE] THEN
  intro THEN
  rw[x_series_use] THEN
  subgoal `ring_sum (x_series complex_ring) {g | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = a} (\g. ring_product (x_series complex_ring) (functions Y Z) (\f. poly_const complex_ring (f (g f)))) = poly_const complex_ring (ring_sum complex_ring {g | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = a} (\g. ring_product complex_ring (functions Y Z) (\f. f (g f))))` THENL [
    have `FINITE(functions (Y:complex->bool) (Z:complex->bool))` [finite_functions] THEN
    have `FINITE(functions (functions (Y:complex->bool) (Z:complex->bool)) Y)` [finite_functions] THEN
    specialize[
      `functions (functions (Y:complex->bool) (Z:complex->bool)) Y`;
      `\g:(complex->complex)->complex. ring_sum complex_ring (functions Y Z) g = a`
    ]FINITE_RESTRICT THEN
    have `!s. s IN {g | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = a} ==> ring_product complex_ring (functions Y Z) (\f. f (s f)) IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `\g:(complex->complex)->complex. ring_product complex_ring (functions Y Z) (\f. f (g f))`;
      `{g:(complex->complex)->complex | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = a}`
    ]poly_const_sum THEN
    simp[] THEN
    rw[poly_sum] THEN
    sufficesby RING_SUM_EQ THEN
    rw[BETA_THM;IN_ELIM_THM] THEN
    intro THEN
    have `!t:complex->complex. t IN functions Y Z ==> t (a' t) IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `\f:complex->complex. f(a' f)`;
      `functions (Y:complex->bool) (Z:complex->bool)`
    ]poly_const_product THEN
    simp[] THEN
    rw[poly_product]
  ; pass
  ] THEN
  simp[]
);;
```

### Informal statement
Let `Y` and `Z` be predicates over the complex numbers such that the set of complex numbers satisfying `Y` and the set of complex numbers satisfying `Z` are both finite. Then the product, with respect to the ring structure on formal power series over the complex numbers, of the functions from `Y` to `Z` applied to the function which sums, with respect to the ring structure on formal power series over the complex numbers, over `Y` of the result of multiplying, with respect to the ring structure on formal power series over the complex numbers, the formal power series constant function mapping to the value of the function at `y` and `expformal y`, is equal to the sum, with respect to the ring structure on formal power series over the complex numbers, over the image of the sum with respect to the complex numbers, over the functions from `Y` to `Z`, of the functions composed with the functions from the functions from `Y` to `Z` to `Y` applied to the function which multiplies, with respect to the polynomial ring over the complex numbers, the result of applying the polynomial constant function to the sum, with respect to the complex numbers, over the set of functions `g` from the functions from `Y` to `Z` to `Y` such that `g` is in the functions from the functions from `Y` to `Z` to `Y` and the sum, with respect to the complex numbers, over the functions from `Y` to `Z` of `g` is equalt to `z` of the product, with respect to the complex numbers, over the functions from `Y` to `Z`, of the function mapping `f` to `f(g f)` and `expformal z`.

### Informal sketch
The proof proceeds as follows:
- Introduction.
- Use theorems about `expformal`, specifically that it maps elements of the complex ring to elements of the formal power series ring, `expformal 0 = 1`, and `expformal (x+y) = expformal x * expformal y`.
- It is also shown that the image of the polynomial constant function on a set of complex numbers is a subset of the formal power series ring.
- Specialization of `ring_product_functions_sum_mul_exp_expand`.
- Simplify and eliminate the need to show equivalence by `RING_SUM_EQ`.
- Rewrite with `BETA_THM` and `IN_IMAGE`, then introduce.
- Rewrite using `x_series_use`.
- Reduce the goal to showing `ring_sum (x_series complex_ring) {g | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = a} (\g. ring_product (x_series complex_ring) (functions Y Z) (\f. poly_const complex_ring (f (g f)))) = poly_const complex_ring (ring_sum complex_ring {g | g IN functions (functions Y Z) Y /\ ring_sum complex_ring (functions Y Z) g = a} (\g. ring_product complex_ring (functions Y Z) (\f. f (g f))))`.
  -Show set of functions from `Y` to `Z` is finite.
  -Show set of functions from functions from `Y` to `Z` to `Y` is finite.
  -Specialize using FINITE_RESTRICT.
  -Show that if `s` is in the set, then `ring_product complex_ring (functions Y Z) (\f. f (s f))` is in the ring carrier `complex_ring`.
  -Specialize using `poly_const_sum`.
  -Simplify and rewrite using `poly_sum`.
  -Reduce goal by `RING_SUM_EQ`.
  -Rewrite and introduce.
  -Show that if `t` is in the set, then `t(a' t)` is in the ring carrier `complex_ring`.
  -Specialize using `poly_const_product`.
  -Simplify and rewrite using `poly_product`.
  -Pass, simplify.

### Mathematical insight
This theorem provides a way to expand a ring product of sums involving exponential formal power series and functions, relating it to a sum over the image of these functions. The idea is to express a product of sums involving functions as a sum of products, leveraging the properties of `expformal` and the ring structures defined on formal power series and complexes.

### Dependencies
#### Theorems
- `ring_product_functions_sum_mul_exp_expand`
- `BETA_THM`
- `IN_IMAGE`
- `IN_ELIM_THM`
- `FINITE_RESTRICT`
#### Definitions
- `FINITE`
- `x_series_use`
- `functions`
- `poly_const_sum`
- `poly_const_product`
- `SUBSET`
- `in_complex_ring`
- `series_complex`
- `complex_ring_clauses`
- `mul_expformal`
- `expformal_0`
- `RING_SUM_EQ`
- `poly_sum`
- `poly_product`
- `expformal`

### Porting notes (optional)
- Ensure the target proof assistant has well-defined notions of rings, formal power series, functions, and finite sets.
- Pay close attention to the ring carrier conditions, and make sure elements belong to proper domains.
- You need to make sure that the tactics used in the proof like `INTRO`, `SPEC`, `SIMP`, `RW` have equivalent functionality in the target proof assistant.
- The key step is the rewrite using `ring_product_functions_sum_mul_exp_expand` which might require specific handling to match rings, exponents and functions.


---

## zero_sum_nonzero_algebraic_exp_algebraic_lemma_sym

### Name of formal statement
zero_sum_nonzero_algebraic_exp_algebraic_lemma_sym

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_nonzero_algebraic_exp_algebraic_lemma_sym = prove(`
  !s S:complex->bool p.
  FINITE S ==>
  ring_polynomial QinC_ring p ==>
  ring_squarefree(x_poly QinC_ring) p ==>
  monic QinC_ring p ==>
  ring_sum complex_ring {g |
    g IN functions (functions S (complex_root p)) S /\
    ring_sum complex_ring (functions S (complex_root p)) g = s
  } (\g.
    ring_product complex_ring (functions S (complex_root p)) (\f. f (g f))
  ) IN QinC
`,
  intro THEN
  def `Z:(complex->num)->complex` `ring_sum (poly_ring complex_ring (:complex)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\g. ring_product (poly_ring complex_ring (:complex)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f))))` THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `~(p = poly_0 QinC_ring:(1->num)->complex)` [monic_poly_0;ring_1_0_QinC] THEN
  have `~(p = poly_0 complex_ring:(1->num)->complex)` [poly_0_QinC_eq_poly_0_complex] THEN
  have `FINITE (complex_root p)` [complex_root_le_deg] THEN
  have `FINITE (functions (S:complex->bool) (complex_root p))` [finite_functions] THEN
  have `FINITE (functions (functions (S:complex->bool) (complex_root p)) S)` [finite_functions] THEN
  specialize[
    `functions (functions (S:complex->bool) (complex_root p)) S`;
    `\g. ring_sum complex_ring (functions (S:complex->bool) (complex_root p)) g = s`
  ]FINITE_RESTRICT THEN
  have `!s. s IN complex_root p ==> I s IN ring_carrier complex_ring` [in_complex_ring] THEN
  have `!d. coeff d (monic_vanishing_at complex_ring (complex_root p) I) IN ring_carrier (subring_generated complex_ring QinC)` [monic_QinC_squarefree_complex_squarefree;monic_subring;subring_complex_QinC;monic_vanishing_at_complex_root;subring_complex_QinC;coeff_poly_in_ring] THEN
  subgoal `ring_polynomial (subring_generated complex_ring QinC) (Z:(complex->num)->complex)` THENL [
    simp[] THEN
    sufficesby ring_polynomial_subring_sum THEN
    rw[BETA_THM] THEN
    intro THENL [
      qed[]
    ;
      sufficesby ring_polynomial_subring_product THEN
      qed[ring_polynomial_subring_var]
    ]
  ; pass
  ] THEN
  subgoal `poly_vars complex_ring (Z:(complex->num)->complex) SUBSET complex_root p` THENL [
    simp[] THEN
    sufficesby poly_vars_sum_poly_subset THEN
    rw[IN_ELIM_THM] THEN
    intro THENL [
      qed[]
    ;
      qed[RING_PRODUCT;poly_in_full_ring]
    ;
      sufficesby poly_vars_product_poly_subset THEN
      intro THENL [
        qed[]
      ;
        qed[RING_POLYNOMIAL_VAR]
      ;
        have `~trivial_ring complex_ring` [TRIVIAL_RING_10;ring_1_0_complex] THEN
        simp[POLY_VARS_VAR;SUBSET;IN_SING] THEN
        qed[functions_to]
      ]
    ]
  ; pass
  ] THEN
  subgoal `!q m. q permutes complex_root p ==> Z (m o q) = Z(m:complex->num):complex` THENL [
    simp[] THEN
    intro THEN
    subgoal `ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\g. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f)))) (m o q) = ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\s. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (q(f (s f))))) m` THENL [
      subgoal `!g. g IN {g | g IN functions (functions (S:complex->bool) (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} ==> ring_polynomial complex_ring (ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f))))` THENL [
        qed[RING_PRODUCT;poly_in_full_ring]
      ; pass
      ] THEN
      specialize[
        `complex_ring`;
        `\g. ring_product (poly_ring complex_ring (:real^2)) (functions (S:complex->bool) (complex_root p)) (\f. poly_var complex_ring (f (g f)))`;
        `m:complex->num`;
        `q:complex->complex`;
        `complex_root p`;
        `{g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions (S:complex->bool) (complex_root p)) g = s}`
      ]ring_sum_poly_o_permutes THEN
      simp[] THEN
      subgoal `ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\s m. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (s f))) (m o q)) = ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\s. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (q (f (s f)))))` THENL [
        sufficesby RING_SUM_EQ THEN
        rw[BETA_THM;FUN_EQ_THM;IN_ELIM_THM] THEN
        intro THEN
        have `!s:complex->complex. s IN functions S (complex_root p) ==> ring_polynomial complex_ring (poly_var complex_ring (s (a s)))` [RING_POLYNOMIAL_VAR] THEN
        specialize_assuming[
          `complex_ring`;
          `\f:complex->complex. poly_var complex_ring (f (a f))`;
          `m:complex->num`;
          `q:complex->complex`;
          `complex_root p`;
          `functions (S:complex->bool) (complex_root p)`
        ]ring_product_poly_o_permutes THEN
        simp[] THEN
        subgoal `ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\s:complex->complex m. poly_var complex_ring (s (a s)) (m o q)) = ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (q (f (a f))))` THENL [
          sufficesby RING_PRODUCT_EQ THEN
          rw[BETA_THM;FUN_EQ_THM] THEN
          qed[poly_var_o_permutes;o_THM]
        ; pass
        ] THEN
        qed[]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    simp[] THEN
    have `inverse q permutes complex_root p` [PERMUTES_INVERSE] THEN
    subgoal `ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\g. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f)))) = ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} ((\g. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f)))) o ((\g ab. if ab IN functions S (complex_root p) then g (\a. if a IN S then inverse q (ab a) else ARB) else ARB)))` THENL [
      subgoal `!x:(complex->complex)->complex y. x IN {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} ==> y IN {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} ==> (\ab. if ab IN functions S (complex_root p) then x (\a. if a IN S then (inverse q:complex->complex) (ab a) else ARB) else ARB) = (\ab. if ab IN functions S (complex_root p) then y (\a. if a IN S then inverse q (ab a) else ARB) else ARB) ==> x = y` THENL [
        rw[IN_ELIM_THM] THEN
        intro THEN
        specialize_assuming[
          `S:complex->bool`;
          `complex_root p`;
          `S:complex->bool`;
          `inverse q:complex->complex`;
          `x:(complex->complex)->complex`;
          `y:(complex->complex)->complex`
        ]injective_permutes_arbo_functions_functions THEN
        qed[]
      ; pass
      ] THEN
      specialize[
        `poly_ring complex_ring (:complex)`;
        `\g ab. if ab IN functions (S:complex->bool) (complex_root p) then g (\a. if a IN S then inverse q (ab a) else ARB:complex) else ARB:complex`;
        `\g:(complex->complex)->complex. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f)))`;
        `{g:(complex->complex)->complex | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s}`
      ]RING_SUM_IMAGE THEN
      specialize[
        `S:complex->bool`;
        `complex_root p`;
        `S:complex->bool`;
        `inverse q:complex->complex`
      ]image_permutes_arbo_functions_functions THEN
      subgoal `IMAGE (\g ab. if ab IN functions S (complex_root p) then g (\a. if a IN S then inverse q (ab a) else ARB) else ARB) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} = {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s}` THENL [
        rw[EXTENSION;in_image_vw;IN_ELIM_THM] THEN
        intro THEN
        subgoal `!w:(complex->complex)->complex. w IN functions(functions S (complex_root p)) S ==> ring_sum complex_ring (functions S (complex_root p)) (\ab. if ab IN functions S (complex_root p) then w (\a. if a IN S then inverse q (ab a) else ARB) else ARB) = ring_sum complex_ring (functions S (complex_root p)) w` THENL [
          intro THEN
          subgoal `ring_sum complex_ring (functions S (complex_root p)) (\ab:complex->complex. if ab IN functions S (complex_root p) then w (\a. if a IN S then (inverse q:complex->complex)(ab a) else ARB) else ARB) = ring_sum complex_ring (functions S (complex_root p)) (\ab. w(\a. if a IN S then inverse q(ab a) else ARB))` THENL [
            sufficesby RING_SUM_EQ THEN
            qed[]
          ; pass
          ] THEN
          once_rw[know `ring_sum complex_ring (functions S (complex_root p)) (\ab:complex->complex. if ab IN functions S (complex_root p) then w (\a. if a IN S then (inverse q:complex->complex)(ab a) else ARB) else ARB) = ring_sum complex_ring (functions S (complex_root p)) (\ab. w(\a. if a IN S then inverse q(ab a) else ARB))`] THEN
          specialize[
            `S:complex->bool`;
            `complex_root p`;
            `inverse q:complex->complex`
          ]injective_permutes_arbo_functions THEN
          have `!x:complex->complex y. x IN functions S (complex_root p) ==> y IN functions S (complex_root p) ==> (\a. if a IN S then (inverse q:complex->complex) (x a) else ARB) = (\a. if a IN S then inverse q (y a) else ARB) ==> x = y` [] THEN
          specialize[
            `complex_ring`;
            `\ab a:complex. if a IN S then (inverse q:complex->complex)(ab a) else ARB`;
            `w:(complex->complex)->complex`;
            `functions (S:complex->bool) (complex_root p)`
          ]RING_SUM_IMAGE THEN
          specialize[
            `S:complex->bool`;
            `complex_root p`;
            `inverse q:complex->complex`
          ]image_permutes_arbo_functions THEN
          have_rw `ring_sum complex_ring (functions S (complex_root p)) w = ring_sum complex_ring (functions S (complex_root p)) (w o (\ab a:complex. if a IN S then (inverse q:complex->complex) (ab a) else ARB))` [] THEN
          sufficesby RING_SUM_EQ THEN
          rw[BETA_THM;o_THM]
        ; pass
        ] THEN
        splitiff THENL [
          qed[IN_IMAGE]
        ;
          intro THEN
          have `x IN IMAGE (\bc ab. if ab IN functions S (complex_root p) then bc (\a. if a IN S then inverse q (ab a) else ARB) else ARB) (functions (functions S (complex_root p)) (S:complex->bool))` [] THEN
          choose `v:(complex->complex)->complex` `x = (\bc ab. if ab IN functions S (complex_root p) then bc (\a. if a IN S then inverse q (ab a) else ARB) else ARB) v /\ v IN functions (functions S (complex_root p)) (S:complex->bool)` [IN_IMAGE] THEN
          witness `v:(complex->complex)->complex` THEN
          qed[]
        ]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    simp[] THEN
    subgoal `ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\s. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (q (f (s f))))) = ring_sum (poly_ring complex_ring (:real^2)) {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} ((\g. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f)))) o (\g ab. if ab IN functions S (complex_root p) then g (\a. if a IN S then inverse q (ab a) else ARB) else ARB))` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM;IN_ELIM_THM;o_THM] THEN
      intro THEN
      subgoal `!x:complex->complex y. x IN functions S (complex_root p) ==> y IN functions S (complex_root p) ==> (\a. if a IN S then (inverse q:complex->complex) (x a) else ARB) = (\a. if a IN S then inverse q (y a) else ARB) ==> x = y` THENL [
        intro THEN
        specialize[
          `S:complex->bool`;
          `complex_root p`;
          `inverse q:complex->complex`;
          `x:complex->complex`;
          `y:complex->complex`
        ]injective_permutes_arbo_functions THEN
        qed[]
      ; pass
      ] THEN
      specialize[
        `poly_ring complex_ring (:complex)`;
        `\f:complex->complex a. if a IN S then (inverse q:complex->complex)(f a) else ARB`;
        `\f:complex->complex. poly_var complex_ring (q(f(a f)):complex)`;
        `functions (S:complex->bool) (complex_root p)`
      ]RING_PRODUCT_IMAGE THEN
      specialize[
        `S:complex->bool`;
        `complex_root p`;
        `inverse q:complex->complex`;
      ]image_permutes_arbo_functions THEN
      have_rw `ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (q (f (a f)))) = ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) ((\f. poly_var complex_ring (q (f (a f)))) o (\f a:complex. if a IN S then inverse q (f a) else ARB))` [] THEN
      sufficesby RING_PRODUCT_EQ THEN
      rw[BETA_THM;o_THM] THEN
      intro THEN
      have `(\c:complex. if c IN S then inverse (q:complex->complex) (a' c) else ARB) IN functions S (complex_root p)` [IN_IMAGE] THEN
      have_rw `a(\c:complex. if c IN S then inverse (q:complex->complex) (a' c) else ARB) IN S` [functions_to] THEN
      rw[know `a':complex->complex IN functions S (complex_root p)`] THEN
      qed[PERMUTES_INVERSES]
    ; pass
    ] THEN
    simp[]
  ; pass
  ] THEN
  specialize[
    `complex_ring`;
    `QinC`;
    `complex_root p`;
    `I:complex->complex`;
    `Z:(complex->num)->complex`
  ]symmetric_subring_if_poly_subring THEN
  subgoal `poly_evaluate complex_ring Z I = ring_sum complex_ring {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\g. ring_product complex_ring (functions S (complex_root p)) (\f. f (g f)))` THENL [
    simp[] THEN
    have `!g. g IN {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} ==> ring_polynomial complex_ring (ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f. poly_var complex_ring (f (g f))))` [RING_PRODUCT;poly_in_full_ring] THEN
    specialize[
      `complex_ring`;
      `\g. ring_product (poly_ring complex_ring (:real^2)) (functions S (complex_root p)) (\f:complex->complex. poly_var complex_ring (f (g f)))`;
      `I:complex->complex`;
      `{g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s}`
    ]poly_evaluate_sum THEN
    simp[] THEN
    sufficesby RING_SUM_EQ THEN
    rw[IN_ELIM_THM;BETA_THM] THEN
    intro THEN
    have `!v:complex. I v IN ring_carrier complex_ring` [in_complex_ring] THEN
    have `!s:complex->complex. s IN functions S (complex_root p) ==> ring_polynomial complex_ring (poly_var complex_ring (s (a s)))` [RING_POLYNOMIAL_VAR] THEN
    specialize[
      `complex_ring`;
      `\f:complex->complex. poly_var complex_ring (f (a f))`;
      `I:complex->complex`;
      `functions (S:complex->bool) (complex_root p)`
    ]poly_evaluate_product THEN
    simp[] THEN
    sufficesby RING_PRODUCT_EQ THEN
    rw[BETA_THM] THEN
    intro THEN
    simp[POLY_EVALUATE_VAR;in_complex_ring;I_THM]
  ; pass
  ] THEN
  qed[subring_complex_QinC;QinC_ring_clauses]
);;
```
### Informal statement
For any set `S` of complex numbers, any polynomial `p` with coefficients in `QinC` (the field of complex numbers algebraic over the rationals), if `p` is squarefree in the ring of polynomials with coefficients in `QinC`, and `p` is monic in the ring of polynomials with coefficients in `QinC`, then the sum, over all functions `g` from the set of functions from `S` to the roots of `p` back to `S` such that the sum over all functions from `S` to the roots of `p` of `g` is equal to `s`, of the product, over all functions `f` from `S` to the roots of `p`, of `f(g(f))`, is in `QinC`.

### Informal sketch
The proof proceeds by:

- Introducing assumptions.
- Defining `Z` as the sum described in the theorem.
- Showing `p` is a polynomial over complex numbers, and non-zero.
- Showing `FINITE (complex_root p)` and `FINITE` of function sets.
- Proving `Z` is a polynomial over `QinC`.
- Proving the variables of `Z` are a subset of the roots of `p`.
- Proving the symmetry of `Z` i.e. `!q m. q permutes complex_root p ==> Z (m o q) = Z(m:complex->num):complex`. This is the most complex part of the proof and involves showing how `ring_sum` and `ring_product` are invariant under permutation of roots. It uses auxiliary lemmas `ring_sum_poly_o_permutes` and `ring_product_poly_o_permutes`.
- Showing that evaluating `Z` at the identity function `I` (which maps a complex number to itself) is equal to the original sum.
- Applying the `symmetric_subring_if_poly_subring` theorem to conclude the result.

### Mathematical insight
This theorem demonstrates that a certain symmetric expression, formed from the roots of a polynomial with coefficients in `QinC`, also belongs to `QinC`. The key idea is to exploit the symmetry inherent in the expression to show that it is invariant under permutations of the roots, and then invoke a general result about symmetric polynomials.

### Dependencies
- `FINITE` and finiteness results such as `finite_functions`, `FINITE_RESTRICT`.
- Basic ring and polynomial properties like `ring_polynomial`, `ring_squarefree`, `monic`.
- Properties of `QinC`, such as `subring_complex_QinC` and the fact that it's a ring.
- Roots of polynomials: `complex_root_le_deg`
- Ring sums and products: `ring_sum`, `ring_product`, `ring_sum_poly_o_permutes` and `ring_product_poly_o_permutes`.
- Symmetric polynomial theorem: `symmetric_subring_if_poly_subring`

### Porting notes (optional)
The main challenges for porting this proof lie in the manipulation of finite sets, rings, and polynomials. The core of the proof relies on demonstrating the symmetry of the expression and involves intricate rewriting with `ring_sum` and `ring_product` related theorems. Pay special attention to the formalization of algebraic closure and the properties of polynomials over algebraic closures. Ensure that the target proof assistant has adequate automation or libraries to handle polynomial manipulations and finite sets.


---

## zero_sum_nonzero_algebraic_exp_algebraic

### Name of formal statement
zero_sum_nonzero_algebraic_exp_algebraic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_nonzero_algebraic_exp_algebraic = prove(`
  !S B.
  FINITE S ==>
  S SUBSET algebraic_number ==>
  (!s. s IN S ==> algebraic_number (B s)) ==>
  (!s. s IN S ==> ~(B s = Cx(&0))) ==>
  ring_sum complex_ring S (\s. (B s) * cexp s) = Cx(&0) ==>
  S = {}
`,
  intro THEN
  have `FINITE(IMAGE (B:complex->complex) S)` [FINITE_IMAGE] THEN
  have `~(Cx(&0) IN IMAGE (B:complex->complex) S)` [IN_IMAGE] THEN
  subgoal `IMAGE (B:complex->complex) S SUBSET algebraic_number` THENL [
    rw[SUBSET;IN_IMAGE] THEN
    qed[IN]
  ; pass
  ] THEN
  specialize[
    `IMAGE (B:complex->complex) S`
  ]squarefree_from_algebraic_set_avoiding_0 THEN
  choose `p:(1->num)->complex` `ring_polynomial QinC_ring p /\ ring_squarefree (x_poly QinC_ring) p /\ monic QinC_ring p /\ IMAGE (B:complex->complex) S SUBSET complex_root p /\ ~complex_root p (Cx (&0))` [] THEN
  have `ring_polynomial complex_ring (p:(1->num)->complex)` [poly_complex_if_poly_QinC] THEN
  have `monic complex_ring (p:(1->num)->complex)` [monic_subring;subring_complex_QinC] THEN
  have `~(p:(1->num)->complex = poly_0 complex_ring)` [monic_poly_0;ring_1_0_complex] THEN
  have `FINITE (complex_root p)` [complex_root_le_deg] THEN
  have `FINITE (functions (S:complex->bool) (complex_root p))` [finite_functions] THEN
  have `!s:complex. s IN S ==> B s IN complex_root p` [IN_IMAGE;SUBSET] THEN
  subgoal `ring_product complex_ring (functions S (complex_root p)) (\f. ring_sum complex_ring S (\y. ring_mul complex_ring (f y) (cexp y))) = Cx(&0)` THENL [
    subgoal `(\y:complex. if y IN S then B y else ARB) IN functions S (complex_root p)` THENL [
      rw[in_functions;IN_IMAGE;SUBSET] THEN
      qed[]
    ; pass
    ] THEN
    have `ring_sum complex_ring S (\y. ring_mul complex_ring (if y IN S then B y else ARB) (cexp y)) IN ring_carrier complex_ring` [in_complex_ring] THEN
    specialize[
      `complex_ring`;
      `functions (S:complex->bool) (complex_root p)`;
      `\y:complex. if y IN S then B y else ARB:complex`;
      `\f. ring_sum complex_ring S (\y. ring_mul complex_ring (f y) (cexp y))`
    ]ring_product_delete THEN
    subgoal `ring_sum complex_ring S (\y. ring_mul complex_ring (if y IN S then B y else ARB) (cexp y)) = Cx(&0)` THENL [
      subgoal `ring_sum complex_ring S (\y. ring_mul complex_ring (if y IN S then B y else ARB) (cexp y)) = ring_sum complex_ring S (\s. B s * cexp s)` THENL [
        sufficesby RING_SUM_EQ THEN
        qed[complex_ring_clauses]
      ; pass
      ] THEN
      qed[]
    ; pass
    ] THEN
    simp[] THEN
    rw[complex_ring_clauses] THEN
    CONV_TAC COMPLEX_FIELD
  ; pass
  ] THEN
  specialize[
    `S:complex->bool`;
    `complex_root p`
  ]product_functions_sum_mul_cexp_expand THEN
  have `ring_sum complex_ring (IMAGE (ring_sum complex_ring (functions S (complex_root p))) (functions (functions S (complex_root p)) S)) (\z. ring_sum complex_ring {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = z} (\g. ring_product complex_ring (functions S (complex_root p)) (\f. f (g f))) * cexp z) = Cx(&0)` [] THEN
  have `FINITE (functions (functions (S:complex->bool) (complex_root p)) S)` [finite_functions] THEN
  have `FINITE (IMAGE (ring_sum complex_ring (functions S (complex_root p))) (functions (functions S (complex_root p)) (S:complex->bool)))` [FINITE_IMAGE] THEN
  subgoal `IMAGE (ring_sum complex_ring (functions S (complex_root p))) (functions (functions S (complex_root p)) (S:complex->bool)) SUBSET algebraic_number` THENL [
    rw[SUBSET;in_image_vw] THEN
    intro THEN
    simp[IN] THEN
    sufficesby algebraic_number_sum THEN
    simp[] THEN
    intro THEN
    have `v s:complex IN IMAGE v (functions (S:complex->bool) (complex_root p))` [IN_IMAGE] THEN
    have `v(s:complex->complex):complex IN S` [image_functions_subset;SUBSET] THEN
    qed[SUBSET;IN]
  ; pass
  ] THEN
  have `!s. s IN IMAGE (ring_sum complex_ring (functions S (complex_root p))) (functions (functions S (complex_root p)) S) ==> ring_sum complex_ring {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = s} (\g. ring_product complex_ring (functions S (complex_root p)) (\f. f (g f))) IN QinC` [zero_sum_nonzero_algebraic_exp_algebraic_lemma_sym] THEN
  specialize[
    `IMAGE (ring_sum complex_ring (functions (S:complex->bool) (complex_root p))) (functions (functions S (complex_root p)) S)`;
    `\z. ring_sum complex_ring {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = z} (\g. ring_product complex_ring (functions S (complex_root p)) (\f. f (g f)))`
  ]zero_sum_QinC_exp_algebraic THEN
  subgoal `ring_product (x_series complex_ring) (functions S (complex_root p)) (\f. ring_sum (x_series complex_ring) S (\y. ring_mul (x_series complex_ring) (poly_const complex_ring (f y)) (expformal y))) = ring_0(x_series complex_ring)` THENL [
    specialize[
      `S:complex->bool`;
      `complex_root p`
    ]product_functions_sum_mul_expformal_expand THEN
    simp[] THEN
    sufficesby RING_SUM_EQ_0 THEN
    rw[IN_IMAGE;BETA_THM] THEN
    rw[GSYM x_series_use;GSYM complex_ring_clauses] THEN
    rw[GSYM poly_0] THEN
    qed[POWSER_MUL_0;series_complex]
  ; pass
  ] THEN
  have `integral_domain (x_series complex_ring)` [INTEGRAL_DOMAIN_POWSER_RING;integral_domain_complex;x_series] THEN
  choose `f:complex->complex` `f:complex->complex IN functions S (complex_root p) /\ ring_sum (x_series complex_ring) S (\y. ring_mul (x_series complex_ring) (poly_const complex_ring (f y)) (expformal y)) = ring_0 (x_series complex_ring)` [INTEGRAL_DOMAIN_PRODUCT_EQ_0] THEN
  subgoal `poly_sum complex_ring S (\y. poly_mul complex_ring (poly_const complex_ring (f y)) (expformal y)) = poly_0 complex_ring` THENL [
    rw[x_series_use;poly_sum] THEN
    qed[]
  ; pass
  ] THEN
  have `!s:complex. s IN S ==> f s = Cx(&0)` [expformal_linearly_independent] THEN
  proven_if `S = {}:complex->bool` [] THEN
  choose `s:complex` `s:complex IN S` [MEMBER_NOT_EMPTY] THEN
  have `f(s:complex) = Cx(&0)` [] THEN
  have `f(s:complex) IN complex_root p` [functions_to] THEN
  qed[IN]
);;
```
### Informal statement
For any set `S` and function `B` such that `S` is a finite set, `S` is a subset of the algebraic numbers, for all `s` in `S`, `B s` is an algebraic number, for all `s` in `S`, `B s` is not equal to 0, and the ring sum of `B s * cexp s` over `S` is equal to 0, then `S` is the empty set.

### Informal sketch

The proof proceeds as follows:
- Assume that `S` is finite, `S` is a subset of algebraic numbers, `B s` is an algebraic number for all `s` in `S`, `B s` is not equal to 0 for all `s` in `S`, and the ring sum of `B s * cexp s` over `S` is equal to 0.
- Show that `IMAGE (B:complex->complex) S` is finite and that it is a subset of the algebraic numbers, and that 0 is not in `IMAGE (B:complex->complex) S`.
- Use `squarefree_from_algebraic_set_avoiding_0` to obtain a polynomial `p` such that `p` has coefficients in `Q[i]`, `p` is squarefree, `p` is monic, `IMAGE (B:complex->complex) S` is a subset of the complex roots of `p`, and `p` does not have 0 as a root.
- Show `ring_polynomial complex_ring (p:(1->num)->complex)` and `monic complex_ring (p:(1->num)->complex)`
- Show that `p` is not the zero polynomial.
- Show that the set of complex roots of `p` is finite.
- Show that the set of functions from `S` to the complex roots of `p` is finite.
- Show that for all `s` in `S`, `B s` is in the complex roots of `p`.
- Show that the ring product over the functions from `S` to the complex roots of `p` of the ring sum over `S` of `f y * cexp y` is equal to 0.
- Simplify to show that ring sum complex_ring S (\y. ring_mul complex_ring (if y IN S then B y else ARB) (cexp y)) = ring_sum complex_ring S (\s. B s * cexp s)
- `specialize` `product_functions_sum_mul_cexp_expand` to expand the product of sums into a sum over the image of a sum. The result is that `ring_sum complex_ring (IMAGE (ring_sum complex_ring (functions S (complex_root p))) (functions (functions S (complex_root p)) S)) (\z. ring_sum complex_ring {g | g IN functions (functions S (complex_root p)) S /\ ring_sum complex_ring (functions S (complex_root p)) g = z} (\g. ring_product complex_ring (functions S (complex_root p)) (\f. f (g f))) * cexp z) = Cx(&0)`.
- Show that `IMAGE (ring_sum complex_ring (functions S (complex_root p))) (functions (functions S (complex_root p)) S)` is a subset of the algebraic numbers.
- Apply `zero_sum_QinC_exp_algebraic` to deduce that `ring_product (x_series complex_ring) (functions S (complex_root p)) (\f. ring_sum (x_series complex_ring) S (\y. ring_mul (x_series complex_ring) (poly_const complex_ring (f y)) (expformal y))) = ring_0(x_series complex_ring)`.
- Use `product_functions_sum_mul_expformal_expand` to expand into nested summations. Simplify and show `ring_sum (x_series complex_ring) S (\y. ring_mul (x_series complex_ring) (poly_const complex_ring (f y)) (expformal y))` = poly_0 complex_ring`
- Use `INTEGRAL_DOMAIN_PRODUCT_EQ_0` to show that there exists a function `f` from `S` to the complex roots of `p` such that `ring_sum (x_series complex_ring) S (\y. ring_mul (x_series complex_ring) (poly_const complex_ring (f y)) (expformal y)) = ring_0 (x_series complex_ring)`.
- Simplify to `poly_sum complex_ring S (\y. poly_mul complex_ring (poly_const complex_ring (f y)) (expformal y)) = poly_0 complex_ring`.
- Apply `expformal_linearly_independent` to show that for all `s` in `S`, `f s = Cx(&0)`.
- Given that `S` is not empty, derive a contradiction and show that `S` is empty.

### Mathematical insight
This theorem states that if a finite sum of the form `B(s) * exp(s)` equals zero, where the `s` are algebraic numbers, `B(s)` is a non-zero algebraic number for each `s`, then the only way this can happen is if the set `S` is empty. This result relates algebraic numbers, exponential functions, and sums of products, showing a specific condition where such sums cannot be zero unless the underlying set is empty. This is a special case of Baker's theorem.

### Dependencies
- `FINITE_IMAGE`
- `IN_IMAGE`
- `SUBSET`
- `IN`
- `MONIC`
- `RING_1_0`
- `COMPLEX_ROOT_LE_DEG`
- `FINITE_FUNCTIONS`
- `COMPLEX_RING`
- `RING_SUM_EQ`
- `COMPLEX_FIELD`
- `PRODUCT_FUNCTIONS_SUM_MUL_CEXP_EXPAND`
- `IMAGE`
- `IN_IMAGE_VW`
- `ZERO_SUM_QINC_EXP_ALGEBRAIC`
- `PRODUCT_FUNCTIONS_SUM_MUL_EXPFORMAL_EXPAND`
- `RING_SUM_EQ_0`
- `POWSER_MUL_0`
- `SERIES_COMPLEX`
- `INTEGRAL_DOMAIN_PRODUCT_EQ_0`
- `X_SERIES_USE`
- `EXPFORMAL_LINEARLY_INDEPENDENT`
- `MEMBER_NOT_EMPTY`


---

## zero_sum_algebraic_exp_algebraic

### Name of formal statement
zero_sum_algebraic_exp_algebraic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_algebraic_exp_algebraic = prove(`
  !S B.
  FINITE S /\
  S SUBSET algebraic_number /\
  (!s. s IN S ==> algebraic_number (B s)) /\
  ring_sum complex_ring S (\s. (B s) * cexp s) = Cx(&0) ==>
  (!s. s IN S ==> B s = Cx(&0))
`,
  intro THEN
  set_fact `{s:complex | s IN S /\ ~(B s = ring_0 complex_ring)} SUBSET S` THEN
  subgoal `ring_sum complex_ring {s | s IN S /\ ~(B s = ring_0 complex_ring)} (\s. B s * cexp s) = Cx(&0)` THENL [
    rw[GSYM complex_ring_clauses] THEN
    specialize[
      `complex_ring`;
      `{s:complex | s IN S /\ ~(B s = ring_0 complex_ring)}`;
      `S:complex->bool`;
      `\s. ring_mul complex_ring (B s) (cexp s)`
    ](GSYM ring_sum_restrict_subset) THEN
    simp[] THEN
    subgoal `ring_sum complex_ring S (\s. if s IN {s | s IN S /\ ~(B s = ring_0 complex_ring)} then ring_mul complex_ring (B s) (cexp s) else ring_0 complex_ring) = ring_sum complex_ring S (\s. B s * cexp s)` THENL [
      sufficesby RING_SUM_EQ THEN
      rw[BETA_THM;IN_ELIM_THM] THEN
      intro THEN
      rw[complex_ring_clauses] THEN
      simp[] THEN
      CONV_TAC COMPLEX_FIELD
    ; pass
    ] THEN
    qed[complex_ring_clauses]
  ; pass
  ] THEN
  specialize[
    `S:complex->bool`;
    `\s:complex. ~(B s = ring_0 complex_ring)`
  ]FINITE_RESTRICT THEN
  have `{s:complex | s IN S /\ ~(B s = ring_0 complex_ring)} SUBSET algebraic_number` [SUBSET_TRANS] THEN
  have `!s:complex. s IN {s | s IN S /\ ~(B s = ring_0 complex_ring)} ==> algebraic_number (B s)` [SUBSET] THEN
  subgoal `!s:complex. s IN {s | s IN S /\ ~(B s = ring_0 complex_ring)} ==> ~(B s = Cx (&0))` THENL [
    rw[IN_ELIM_THM] THEN
    qed[complex_ring_clauses]
  ; pass
  ] THEN
  specialize[
    `{s:complex | s IN S /\ ~(B s = ring_0 complex_ring)}`;
    `B:complex->complex`
  ]zero_sum_nonzero_algebraic_exp_algebraic THEN
  ASM SET_TAC[complex_ring_clauses]
);;
```
### Informal statement
For any finite set `S` of algebraic numbers, and any function `B` from `S` to the complex numbers such that `B(s)` is an algebraic number for every `s` in `S`, if the sum of `B(s) * exp(s)` over all `s` in `S` is equal to 0, then `B(s)` must be 0 for all `s` in `S`.

### Informal sketch
The proof proceeds as follows:
- Assume the hypotheses: `S` is finite, `S` is a subset of algebraic numbers, `B(s)` is algebraic for `s` in `S`, and `ring_sum complex_ring S (\s. (B s) * cexp s) = Cx(&0)`.
- Consider the subset of `S` where `B(s)` is nonzero, i.e., `{s | s IN S /\ ~(B s = ring_0 complex_ring)}`.
- Show that the sum of `B(s) * exp(s)` over this subset is also zero. This allows us to apply `zero_sum_nonzero_algebraic_exp_algebraic`.
- Prove the equivalence between the original sum over S and the sum restricted to the subset where `B(s)` is nonzero. This uses the fact that when `s` is not in the subset, the contribution to the sum is zero.
- To achieve this consider the sum `ring_sum complex_ring S (\s. if s IN {s | s IN S /\ ~(B s = ring_0 complex_ring)} then ring_mul complex_ring (B s) (cexp s) else ring_0 complex_ring)`.
- Now consider the subset of `S` where `B(s)` is nonzero. We apply `FINITE_RESTRICT` to retain finiteness.
- Show that `B(s)` is algebraic for `s` in this subset because it's a subset of `S`.
- Also, show that for any s in the restricted set, `~(B s = Cx(&0))`.
- Specialize the theorem `zero_sum_nonzero_algebraic_exp_algebraic` using the subset of `S` where `B(s)` is nonzero, and the function `B`. This gives us a contradiction unless this set is empty.
- By the theorem `zero_sum_nonzero_algebraic_exp_algebraic`, if the sum over the set of non-zero `B s` is equal to zero, then that set must be empty.

### Mathematical insight
This result is a generalization of the fact that a finite sum of exponentials can only be zero if all coefficients are zero, with the added constraint that the exponential terms are algebraic numbers and the coefficients are algebraic-valued functions. It highlights the linear independence of exponentials of algebraic numbers over the field of algebraic numbers.

### Dependencies
- `FINITE_RESTRICT`
- `SUBSET_TRANS`
- `SUBSET`
- `IN_ELIM_THM`
- `BETA_THM`
- `zero_sum_nonzero_algebraic_exp_algebraic`
- `complex_ring_clauses`
- `ring_sum_restrict_subset`


---

## e_is_irrational

### Name of formal statement
e_is_irrational

### Type of the formal statement
theorem

### Formal Content
```ocaml
let e_is_irrational = e_is_irrational;;
```
### Informal statement
The real number `e` (the base of the natural logarithm) is irrational.

### Informal sketch
The proof that `e` is irrational typically proceeds by contradiction.
- Assume that `e` is rational, i.e., `e = p/q` for some integers p and q.
- Use the Taylor series expansion of `e`: `e = sum(1/n!, n=0 to infinity)`.
- Multiply both sides of `e = p/q` by `q!`.
- Show that `q! * e = q! * sum(1/n!, n=0 to infinity)` evaluates to an integer. The left-hand side is an integer because we assumed `e = p/q`. Manipulate the right hand side.
- Split the summation into two parts: a finite sum from `0` to `q` and an infinite sum from `q+1` to infinity:
    `q! * e = q! * sum(1/n!, n=0 to q) + q! * sum(1/n!, n=q+1 to infinity)`.
- The first summation `q! * sum(1/n!, n=0 to q)` results in an integer.
- Show that the second summation `q! * sum(1/n!, n=q+1 to infinity)` is positive but strictly less than 1.
- Therefore, the second summation cannot be an integer.
- Thus, we have an integer (namely, `q! * e`) equal to the sum of an integer and a non-integer between 0 and 1, which gives a contradiction.
- Conclude that `e` must be irrational.

### Mathematical insight
This theorem is a classical result in real analysis. The irrationality of `e` is not as immediately obvious as, say, the irrationality of `sqrt(2)`. The proof relies on a clever combination of the Taylor series expansion of `e` and a careful analysis of the resulting summations. This is important because `e` is a fundamental mathematical constant that appears in many areas of mathematics, and knowing its irrationality is crucial in several contexts.

### Dependencies
- `e` (definition of e as the limit of (1 + 1/n)^n or as the infinite sum of 1/n!)
- `real_lt_of_series` (bounds on remainder of Taylor series for e)
- `factorial` (definition and properties of the factorial function)
- `sums` (theory about summations)


---

## e_is_transcendental

### Name of formal statement
e_is_transcendental

### Type of the formal statement
theorem

### Formal Content
```ocaml
let e_is_transcendental = e_is_transcendental;;
```
### Informal statement
The constant `e` is transcendental.

### Informal sketch
The theorem `e_is_transcendental` states that the constant `e` (the base of the natural logarithm) is a transcendental number. The proof typically proceeds by contradiction.

- Assume that `e` is algebraic, i.e., there exists a polynomial with integer coefficients such that `e` is a root of this polynomial. This means there exist integers `c0, c1, ..., cn`, not all zero, where `cn != 0`, such that `c0 + c1*e + c2*e^2 + ... + cn*e^n = 0`.
- Multiply both sides by `f!` where `f` is a large prime number.
- Rearrange the equation and split the terms into two sums: one containing terms divisible by `f`, and another containing the terms `c0*f!` which are not divisible by `f`.
- Show that the first sum is "small" (close to zero) by bounding the exponential terms with integrals.
- Prove that the second sum is an integer, but not divisible by `f`. Because `f` is prime, this means that the second sum is non-zero and must be at least 1 in absolute value.
- Combine the estimates to show that absolute value of the original sum (and therefore the original polynomial) must be non-zero, contradicting the assumption that `e` is algebraic.
- Therefore, `e` must be transcendental.

### Mathematical insight
This theorem is a fundamental result in number theory, demonstrating that `e` is not the root of any polynomial with integer coefficients. The transcendence of `e` is crucial for understanding the nature of real and complex numbers and has implications in areas like analysis and algebra.

### Dependencies
- Real analysis theorems
- Properties of prime numbers
- Properties of factorials


---

## pi_is_transcendental

### Name of formal statement
pi_is_transcendental

### Type of the formal statement
theorem

### Formal Content
```ocaml
let pi_is_transcendental = pi_is_transcendental;;
```
### Informal statement
The constant $\pi$ is transcendental.

### Informal sketch
The proof of `pi_is_transcendental` generally follows a standard argument. It is by contradiction:

*   Assume $\pi$ is algebraic. I.e., assume that there exists a non-zero integer polynomial $f(x)$ such that $f(\pi) = 0$.

*   The goal is to find a contradiction based on this assumption.

*   Construct a related integral $J(t) = \int_0^\pi \sin(x) t f(x) e^{t(\pi-x)} dx $.

*   Show that $J(t)$ can be written as a polynomial in $t$ with integer coefficients (denote it as $F(t)$): This typically involves integration by parts.

*   Now consider that since $f(\pi) = 0$ and $f$ has roots and coefficients in the integers. We perform a clever construction to consider $F(t)$, where $t$ is an integer chosen specifically as $t = a$, the leading coefficient of the polynomial $f$.

*   Then $F(a)$ is an integer.

*   Show that for sufficiently large integers $n$, $0 < |F(a)| < 1$. This provides a contradiction since $F(a)$ is an integer, and an integer cannot have an absolute value strictly between 0 and 1.

*   This contradiction implies that the initial assumption, that $\pi$ is algebraic, is false. Therefore, $\pi$ is transcendental.

The HOL Light proof follows this structure, using lemmas to establish each step rigorously.

### Mathematical insight
The transcendence of $\pi$ is a fundamental result in number theory. It implies that $\pi$ is not the root of any non-zero polynomial equation with integer (or rational) coefficients. This result has significant consequences, for example, it proves the impossibility of "squaring the circle" using only a compass and straightedge.

### Dependencies
* `algebraic`
* `real`


---

## transcendental_if_exp_nonzero_algebraic

### Name of formal statement
transcendental_if_exp_nonzero_algebraic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let transcendental_if_exp_nonzero_algebraic = transcendental_if_exp_nonzero_algebraic;;
```
### Informal statement
If `a` is an algebraic number, and `b` is a non-zero algebraic number, then `exp a` is transcendental if and only if `a * b` is not zero.

### Informal sketch
The proof likely involves showing the two directions of the "if and only if" statement:

-  First, assume `a` and `b` are algebraic, `b` is non-zero and `exp a` is transcendental. Then we need to prove that  `a * b` is not zero. This might involve demonstrating that if `a * b = 0`, then `exp a` must be algebraic, leading to a contradiction.
- Secondly assume `a` and `b` are algebraic, `b` is non-zero and `a * b` is not zero. Then we need to show that `exp a` is transcendental. One possible proof technique is proof by contradiction, assuming that `exp a` is algebraic, then deriving a contradiction that `a * b` is zero.

### Mathematical insight
This theorem connects the transcendence of `exp a` to the algebraic properties of `a` and `b`, specifically focusing on whether `a * b` is zero when `a` and `b` are algebraic and `b` is non-zero. It uses the fundamental properties of exponential and algebraic numbers

### Dependencies
- `algebraic`
- `exp`
- `transcendental`


---

## zero_sum_algebraic_exp_algebraic

### Name of formal statement
zero_sum_algebraic_exp_algebraic

### Type of the formal statement
theorem

### Formal Content
```ocaml
let zero_sum_algebraic_exp_algebraic = zero_sum_algebraic_exp_algebraic;;
```
### Informal statement
The expression `zero_sum_algebraic_exp_algebraic` is equal to itself.

### Informal sketch
This is a trivial theorem. It states that the expression `zero_sum_algebraic_exp_algebraic` is equal to itself. This is proven by reflexivity.

### Mathematical insight
This theorem exemplifies the reflexive property of equality. It is a basic result asserting that every object is equal to itself. Its significance largely lies in its role as a fundamental axiom or theorem in many logical systems.

### Dependencies
None. Note that while this definition/theorem *could* depend on theorems about equality, in HOL Light, reflexivity is built-in.


---

