# e_is_transcendental.ml

## Overview

Number of statements: 24

The file `e_is_transcendental.ml` provides a formal proof in HOL Light that the mathematical constant *e* is transcendental, following an informal proof available at planetmath.org. It concatenates the original proof script, which was partitioned across multiple files, while maintaining the original module structure. The proof relies on theories from several imported files, including binomial coefficients, real analysis, transcendence, prime numbers, iteration, integers, floor function, and Liouville numbers.


## PROVE(t,tac)

### Name of formal statement
PROVE

### Type of the formal statement
Definition

### Formal Content
```ocaml
let PROVE(t,tac) =
  let th = TAC_PROOF(([],t),tac) in
  let t' = concl th in
  if t' = t then th else
  try EQ_MP (ALPHA t' t) th
  with Failure _ -> failwith "PROVE: justification generated wrong theorem";;
```

### Informal statement
Define a function `PROVE` that takes a term `t` and a tactic `tac` as input and attempts to prove `t` using `tac`. The function first applies the tactic `tac` to the goal `t` (with no assumptions), resulting in a theorem `th`. If the conclusion `t'` of the theorem `th` is identical to the original term `t`, the function returns the theorem `th`. Otherwise, it attempts to adjust the theorem `th` by using `EQ_MP` and `ALPHA` conversion to show that `t'` is alpha-equivalent to `t`, thus obtaining a theorem whose conclusion is exactly `t`. If this adjustment fails, the function raises an exception, indicating that the tactic `tac` failed to prove the given term `t` precisely.

### Informal sketch
The `PROVE` function is a core mechanism for conducting proofs in HOL Light. Here's a breakdown of its operation:

- The function begins by applying the provided tactic `tac` to the term `t` using `TAC_PROOF`. This generates a theorem `th`.
- The conclusion `t'` of the generated theorem `th` is extracted.
- A check is performed to determine if `t'` is exactly equal to the original term `t`. If they are equal, the theorem `th` is returned, signifying a successful proof.
- If `t'` is not exactly equal to `t`, an attempt is made to adjust the theorem. This involves using `ALPHA` to determine if `t'` and `t` are alpha-equivalent (i.e., differ only in the names of bound variables). If they are, the `EQ_MP` rule is applied along with the alpha-equivalence theorem to modify `th` such that its conclusion is exactly `t`.
- If the alpha-conversion and `EQ_MP` application fail at any point, the function raises a "justification generated wrong theorem" exception, indicating that the tactic `tac` did not correctly prove the original term `t`.

### Mathematical insight
The `PROVE` function encapsulates a standard proof pattern. It ensures that a given tactic not only proves *something*, but that it proves the *exact* desired goal. The inclusion of alpha-equivalence handling reflects the importance of considering terms equal up to renaming of bound variables, a common concern in formal logic. The failure case is important for maintaining soundness, as it prevents accepting proofs of subtly different statements than the intended theorem. The function provides increased robustness of proofs by explicitly checking their generated result.

### Dependencies
- `TAC_PROOF`
- `concl`
- `EQ_MP`
- `ALPHA`


---

## OLD_SUM

### Name of formal statement
OLD_SUM

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let OLD_SUM = sum;;
```

### Informal statement
The definition introduces `OLD_SUM` as an alias for the function `sum`.

### Informal sketch
The definition simply binds the identifier `OLD_SUM` to the current value of the identifier `sum`. This is a direct definitional assignment and requires no proof.

### Mathematical insight
The definition is introduced to preserve a previous sum function from HOL Light's core because loading the `Library/analysis.ml` file overwrites the core's definition of `sum`. It ensures subsequent code can still access the original `sum` by referring to it as `OLD_SUM`.

### Dependencies
None


---

## ADD_ASSUMS

### Name of formal statement
ADD_ASSUMS

### Type of the formal statement
Definition

### Formal Content
```ocaml
let ADD_ASSUMS lst thm =
    let f x y = ADD_ASSUM y x in
    List.fold_left f thm lst
;;
```

### Informal statement
Given a list of assumptions `lst` and a theorem `thm`, the function `ADD_ASSUMS` adds each element of the list `lst` as an assumption to the theorem `thm`. The assumptions are added sequentially from left to right.

### Informal sketch
The definition of `ADD_ASSUMS` takes a list of terms `lst` representing assumptions and a theorem `thm`.
- It defines a function `f` such that `f x y` adds the assumption `y` to the theorem `x`. This is equivalent to `ADD_ASSUM y x`.
- It folds the list of assumptions `lst` from left to right using the function `f` and the initial theorem `thm`. This means it iteratively adds each assumption in `lst` to `thm` using `ADD_ASSUM`.

### Mathematical insight
The function `ADD_ASSUMS` provides a convenient way to add multiple assumptions to a theorem at once. This is useful when one wants to state a theorem under multiple hypotheses, which is a common scenario in mathematical proofs.

### Dependencies
- `ADD_ASSUM`
- `List.fold_left`


---

## SPLIT_CONJOINED_ASSUMPT_TAC

### Name of formal statement
SPLIT_CONJOINED_ASSUMPT_TAC

### Type of the formal statement
Tactic

### Formal Content
```ocaml
let SPLIT_CONJOINED_ASSUMPT_TAC t =
    (UNDISCH_TAC t) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC)
;;
```

### Informal statement
The tactic `SPLIT_CONJOINED_ASSUMPT_TAC` transforms a goal `t` that contains an assumption of the form `A /\ B` into a goal that contains two separate assumptions, `A` and `B`.

### Informal sketch
The tactic `SPLIT_CONJOINED_ASSUMPT_TAC` operates as follows:
- First, the assumption `A /\ B` is moved into the hypothesis of the goal using `UNDISCH_TAC`.
- Second, the assumption `A /\ B ==> Z` is transformed to `A ==> Y ==> Z` by rewriting using the tautology `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`.
- Third, the implication `A ==> B ==> Z` is discharged twice using `DISCH_TAC` to obtain the new goal with assumptions `A` and `B`, and the original goal as the conclusion.

### Mathematical insight
This tactic facilitates reasoning by breaking down conjunctive assumptions into their constituent parts, which can simplify proofs and make it easier to apply other tactics or theorems. It leverages the equivalence between an implication with a conjunctive antecedent and a nested implication.

### Dependencies
*   Theorems: `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`
*   Tactics: `UNDISCH_TAC`, `ONCE_REWRITE_TAC`, `DISCH_TAC`, `TAUT`

### Porting notes (optional)
In other proof assistants, the `UNDISCH_TAC` functionality (moving an assumption to the hypothesis) might be achieved by applying similar discharge tactics. The tautology rewrite is a common operation that can usually be implemented using similar rewriting or simplification features. The double discharge implemented by `DISCH_TAC THEN DISCH_TAC `can be achieved by sequential application of discharge tactics in other proof assistants.


---

## ADD_ASSUM_DISCH

### Name of formal statement
ADD_ASSUM_DISCH

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let ADD_ASSUM_DISCH ass thm = DISCH ass (ADD_ASSUM ass thm);;
```

### Informal statement
For any assumption `ass` of type term and any theorem `thm`, the result of `ADD_ASSUM_DISCH ass thm` is the theorem obtained by adding the assumption `ass` to the assumptions of `thm` using `ADD_ASSUM ass thm`, and then discharging the assumption `ass` from the augmented theorem using `DISCH ass (ADD_ASSUM ass thm)`.

### Informal sketch
- The definition directly applies the functions `ADD_ASSUM` and `DISCH` in sequence.
- First, the assumption `ass` is added to the theorem `thm` using `ADD_ASSUM`. This typically involves adding `ass` to the antecedent of the theorem's conclusion if the theorem is an implication. If the theorem is of the form `|- t`, then `ADD_ASSUM ass thm` results in the theorem `ass |- t`.
- Second, the assumption `ass` is discharged from the resulting theorem. Specifically, `DISCH ass thm'` transforms the theorem `ass |- t` into `|- ass ==> t`.
- Therefore, the combined operation effectively transforms a theorem `|- t` into the theorem `|- ass ==> t`.

### Mathematical insight
This definition provides a convenient shorthand for adding and discharging an assumption in one step. It is a common pattern in theorem proving where one introduces an assumption to prove a statement and then immediately removes it by forming an implication using the assumption.

### Dependencies
- `ADD_ASSUM`
- `DISCH`


---

## BRW

### Name of formal statement
BRW

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let BRW t f = ONCE_REWRITE_RULE [TAUT t] f;;
```

### Informal statement
Define `BRW` as a function that takes a term `t` and a term `f` and applies a rewrite rule derived from the tautology of `t` to `f` using `ONCE_REWRITE_RULE`.

### Informal sketch
- The function `BRW` takes a term `t` and a term `f` as input.
- It creates a rewrite rule from the tautology of `t` using `TAUT t`.
- It applies this rewrite rule to `f` using `ONCE_REWRITE_RULE`. The `ONCE_REWRITE_RULE` ensures that the rewrite rule is applied only once.

### Mathematical insight
The `BRW` definition provides a convenient way to apply boolean rewriting based on the tautology of a given term. This is often useful for simplifying logical expressions within a formal proof.

### Dependencies
- Definition: `ONCE_REWRITE_RULE`
- Theorem: `TAUT`


---

## BRW0

### Name of formal statement
BRW0

### Type of the formal statement
theorem

### Formal Content
```ocaml
let BRW0 f = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` f;;
```

### Informal statement
For any function `f`, the boolean rewrite applies to the theorem stating that `(X implies (Y implies Z))` is equivalent to `((X and Y) implies Z)`.

### Informal sketch
- This is a boolean rewrite theorem `BRW`. It states that for any function `f`, the boolean rewrite applies to the equivalence between the curried implication `(X ==> Y ==> Z)` and the implication with conjunction `(X /\ Y ==> Z)`.
- The proof likely involves demonstrating the equivalence and then using a boolean rewriting tactic to apply it.

### Mathematical insight
This theorem expresses the logical equivalence between curried implications and implications with conjunction. It's a fundamental property in logic that simplifies reasoning about conditional statements. It allows replacing a nested implication with a single implication that has a conjunction in the premise. This is a commonly used simplification in propositional and predicate logic.

### Dependencies
- `BRW`
- Boolean logic connectives: `==>`, `/\`


---

## BRW1

### Name of formal statement
BRW1

### Type of the formal statement
Theorem

### Formal Content
```ocaml
let BRW1 f = BRW `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` f;;
```

### Informal statement
For any function `f`, the Boolean Rewriting `BRW` of the equivalence `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` using `f` holds.

### Informal sketch
The theorem states that a specific rewrite rule, which is the equivalence `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`, holds under Boolean Rewriting (`BRW`). The `BRW` function likely applies a set of rewrite rules defined by the function `f` to the given equivalence until no further changes occur. The task is to show the rewritten equivalence is valid, probably by applying the function f step by step until the equivalence is reached.

*   Show that `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` is a valid equivalence. This can be proven using standard propositional logic principles.
*   Verify that Boolean Rewriting preserves the validity.

### Mathematical insight
This theorem essentially asserts the validity of a specific equivalence under Boolean rewriting. This could be useful to reduce the number of propositional variables especially when `Z` is always `F` (false). The equivalence transforms a conjunction inside an implication into nested implications, which is a standard transformation in propositional logic. The theorem suggests that rewriting using this equivalence (and others encoded in `f`) is a sound process.

### Dependencies
- `BRW`


---

## rewrites0

### Name of formal statement
rewrites0

### Type of the formal statement
Definition

### Formal Content
```ocaml
let rewrites0 = map REAL_ARITH [`&0 + (y:real) = y`;`(x:real) * &0 = &0`;`(&1:real) + &0 = &1`;`(x:real) * &1 = x`];;
```

### Informal statement
The definition `rewrites0` is a list of theorems derived via `REAL_ARITH` applied to each of the following equations concerning real numbers:
- 0 + y = y
- x * 0 = 0
- 1 + 0 = 1
- x * 1 = x

### Informal sketch
The definition `rewrites0` is constructed by applying the tactic `REAL_ARITH` to each of the four listed equations. `REAL_ARITH` is a simplification tactic in HOL Light that uses real number arithmetic to prove the given equations. The result of each `REAL_ARITH` application is a theorem, and these theorems are collected into a list. No further proof is needed as the equations are proven directly by `REAL_ARITH`.

### Mathematical insight
The theorems in `rewrites0` are fundamental identities in real number arithmetic. They are useful for simplifying expressions and rewriting equations involving real numbers, particularly in automated proof procedures. These identities formalize the properties of 0 as the additive identity, 1 as the multiplicative identity, and 0 as the multiplicative annihilator.

### Dependencies
- Theories: `real arithmetic`
- Tactics: `REAL_ARITH`


---

## PDI_DEF

### Name of formal statement
PDI_DEF

### Type of the formal statement
new_recursive_definition

### Formal Content
```ocaml
let PDI_DEF = new_recursive_definition num_RECURSION
    `    (poly_diff_iter p 0 = p)
      /\ (poly_diff_iter p (SUC n) = poly_diff (poly_diff_iter p n))
    `
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [PDI_DEF])
)

let SODN = new_definition
    `SODN p n = iterate poly_add (0..n) (\i.poly_diff_iter p i)`
;;
```

### Informal statement
Define a function `poly_diff_iter` that takes a polynomial `p` and a natural number `n` as input.
- If `n` is 0, `poly_diff_iter p 0` is equal to `p`.
- If `n` is the successor of some natural number `m` (i.e., `n = m + 1`), then `poly_diff_iter p (SUC m)` is equal to the polynomial derivative of `poly_diff_iter p m`.

### Informal sketch
The definition of `poly_diff_iter` is given by primitive recursion on the natural number `n`. The base case is when `n` is zero, and the recursive step involves applying the `poly_diff` function to the result of `poly_diff_iter` applied to `n`.

### Mathematical insight
The function `poly_diff_iter p n` represents the `n`-th derivative of the polynomial `p`. It is defined recursively by repeatedly applying the polynomial differentiation operation (`poly_diff`) to the polynomial.

### Dependencies
- `num_RECURSION`

---
### Name of formal statement
PDI_POLY_DIFF_COMM

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PDI_DEF = new_recursive_definition num_RECURSION
    `    (poly_diff_iter p 0 = p)
      /\ (poly_diff_iter p (SUC n) = poly_diff (poly_diff_iter p n))
    `
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [PDI_DEF])
)

let SODN = new_definition
    `SODN p n = iterate poly_add (0..n) (\i.poly_diff_iter p i)`
;;
```

### Informal statement
For all polynomials `p` and natural numbers `n`, the `n`-th iteration of the polynomial derivative of `poly_diff p` is equal to the polynomial derivative of the `n`-th iteration of the polynomial derivative of `p`.  In other words, `poly_diff_iter (poly_diff p) n = poly_diff (poly_diff_iter p n)`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: When `n = 0`, both sides of the equation reduce to `poly_diff p`.
- Inductive step: Assume the equation holds for `n = k`. We must show it holds for `n = k + 1`. That is, we must show `poly_diff_iter (poly_diff p) (SUC k) = poly_diff (poly_diff_iter p (SUC k))`.
  - By the definition of `poly_diff_iter`, `poly_diff_iter (poly_diff p) (SUC k) = poly_diff (poly_diff_iter (poly_diff p) k)`.
  - By the induction hypothesis, since we assuming  `poly_diff_iter (poly_diff p) k) = poly_diff (poly_diff_iter p k)`, we can replace  `poly_diff_iter (poly_diff p) k)` with `poly_diff (poly_diff_iter p k)` to get `poly_diff (poly_diff_iter (poly_diff p) (SUC k)) = poly_diff (poly_diff (poly_diff_iter p k))`.
  - Again, using the definition of `poly_diff_iter`, `poly_diff (poly_diff_iter p (SUC k)) = poly_diff (poly_diff (poly_diff_iter p k))`. Thus concluding the inductive step to complete the result.

### Mathematical insight
This theorem states that taking the polynomial derivative and iterating the polynomial derivative operation commute. That is, differentiating a polynomial and then taking the n-th iterated derivative is the same as taking the n-th iterated derivative first and then differentiating. This is a key property in calculus and polynomial manipulation.

### Dependencies
- `PDI_DEF`

---
### Name of formal statement
SODN

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let PDI_DEF = new_recursive_definition num_RECURSION
    `    (poly_diff_iter p 0 = p)
      /\ (poly_diff_iter p (SUC n) = poly_diff (poly_diff_iter p n))
    `
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [PDI_DEF])
)

let SODN = new_definition
    `SODN p n = iterate poly_add (0..n) (\i.poly_diff_iter p i)`
;;
```

### Informal statement
Define `SODN p n` to be the sum, from `i=0` to `n`, of the `i`-th iterated derivative of the polynomial `p`. Formally, `SODN p n = iterate poly_add (0..n) (\i.poly_diff_iter p i)`.

### Informal sketch
The definition of `SODN p n` involves iterating the `poly_add` function (which presumably adds two polynomials) over the range of integers from 0 to `n`. In each iteration, the function `\i.poly_diff_iter p i` is applied, which computes the `i`-th iterated derivative of `p`.  The `iterate` operator effectively folds `poly_add` across this range of iterated derivatives, starting with an initial value of 0.

### Mathematical insight
`SODN p n` represents the sum of the polynomial `p` and its first `n` derivatives. This sum arises in contexts such as Taylor series approximations (without the scaling factor.)

### Dependencies
None


---

## SOD

### Name of formal statement
SOD

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let SOD = new_definition `!p. SOD p = SODN p (LENGTH p)`;;
```

### Informal statement
For any `p`, `SOD p` is defined to be `SODN p (LENGTH p)`.

### Informal sketch
The definition introduces `SOD` as a function that applies `SODN` to `p` and the length of `p`. No proof is involved, as this is definitional.

### Mathematical insight
This definition likely defines `SOD`, which likely stands for "Sum Of Digits," in terms of `SODN` and `LENGTH`. The function `SODN` probably computes the sum of the first `n` digits of a number, and `LENGTH` returns the number of digits. Thus, the sum of all digits in `p` is the sum of the first `LENGTH p` digits.

### Dependencies
- Definitions: `SODN`, `LENGTH`


---

## PHI

### Name of formal statement
PHI

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let PHI = new_definition `Phi f x = (exp (-- x)) * (poly (SOD f) x)`
```

### Informal statement
For any `f` and `x`, `Phi f x` is defined as `(exp (-- x)) * (poly (SOD f) x)`.

### Informal sketch
This is a definition, so there is nothing to prove.

### Mathematical insight
The definition introduces a function `Phi` which is defined in terms of exponentiation and the polynomial function applied to `SOD f`.

### Dependencies
- `exp`
- `--` (real negation)
- `poly`
- `SOD`

---
### Name of formal statement
PLANETMATH_EQN_1_1_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_1_1_1 = PROVE(
    `! x f.((Phi f) diffl ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x))) )(x)`,
    let lem1 = SPECL [`\x.exp (--x)`;
                      `\x.poly (SOD f) x`;
                      `--(exp (--x))`;
                      `poly (poly_diff (SOD f)) x`;
                      `x:real`]  DIFF_MUL in
    let EXP_NEG_X_DIFF = PROVE(
          `!x. ((\x.exp (--x)) diffl (-- (exp (--x))))(x)`,
          STRIP_TAC THEN DIFF_TAC THEN REAL_ARITH_TAC) in
    let lem2 = SPEC `x:real` EXP_NEG_X_DIFF in
    let lem3 = SPECL [`SOD f`;`x:real`] POLY_DIFF in
    let lem4 = CONJ lem2 lem3 in
    let lem5 = BETA_RULE (MP lem1 lem4) in
    let lem6 = REAL_ARITH `(a*(b - c)) = (-- a*c) + (b*a)` in
    let PHI_abs = PROVE(
          `Phi f  = \x.((exp (-- x)) * (poly (SOD f) x))`,
          (PURE_REWRITE_TAC [SYM (ABS `x:real` (SPEC_ALL PHI))])
          THEN (ACCEPT_TAC (SYM (ETA_CONV `\x.(Phi f x)`))))
    in
    (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC [PHI_abs]) THEN
    (REWRITE_TAC [lem6]) THEN
    (ACCEPT_TAC lem5)
)
```

### Informal statement
For all `x` and `f`, the derivative of `Phi f` at `x` is equal to `(exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x))`.

### Informal sketch
The proof proceeds as follows:
- First, apply the differentiation rule for a product of two functions.
- Then use the derivative of exp(--x) is --exp(--x)
- Use the derivative of `poly p x` is `poly (poly_diff p) x`.
- Combine the above two results.
- Apply beta reduction.
- Apply a rewrite rule `(a*(b - c)) = (-- a*c) + (b*a)`.
- A lemma `PHI_abs` uses the definition of `PHI` to rewrite `Phi f` to `\x.((exp (-- x)) * (poly (SOD f) x))`.
- The main proof consists of rewriting using the `PHI_abs` lemma, the rewrite rule, followed by the result from differentiating the product.

### Mathematical insight
This theorem gives a closed-form expression for the derivative of the function `Phi f x`.
It leverages the product rule for differentiation and the known derivatives of exponential and polynomial functions.

### Dependencies
- `Phi`
- `diffl`
- `exp`
- `--`
- `poly`
- `SOD`
- `poly_diff`
- `DIFF_MUL`
- `POLY_DIFF`

---
### Name of formal statement
POLY_SUB

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_SUB = PROVE(
        `!p1 p2 x. poly (p1 ++ (neg p2)) x = poly p1 x - poly p2 x`,
        (REWRITE_TAC [POLY_ADD;poly_neg;POLY_CMUL]) THEN REAL_ARITH_TAC
)
```

### Informal statement
For all polynomials `p1` and `p2`, and all `x`, the polynomial evaluated at `x` of the concatenation of `p1` with the negation of `p2` is equal to the polynomial evaluated at `x` of `p1` minus the polynomial evaluated at `x` of `p2`.

### Informal sketch
The proof expands the definition `poly (p1 ++ (neg p2)) x` using `POLY_ADD`, `poly_neg`, and `POLY_CMUL`, followed by simplification using real arithmetic.

### Mathematical insight
This theorem relates polynomial subtraction (via coefficient-wise negation and list concatenation) to the subtraction of the polynomial evaluation functions.

### Dependencies
- `poly`
- `++` (list concatenation)
- `neg`
- `POLY_ADD`
- `poly_neg`
- `POLY_CMUL`

---
### Name of formal statement
ZERO_INSERT_NUMSEG

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZERO_INSERT_NUMSEG = PROVE(
    `!n. (0..n) = (0 INSERT (1..n))`,
    let lem01 = SIMP_RULE [ARITH_RULE `0 <= n`] (SPECL [`0`;`n:num`] NUMSEG_LREC) in
    let lem02 = SIMP_RULE [ARITH_RULE `0 + 1 = 1`] lem01 in
    (ACCEPT_TAC (GEN_ALL (GSYM lem02)))
)
```

### Informal statement
For all natural numbers `n`, the set of natural numbers from 0 to `n` is equal to the set consisting of 0 inserted into the set of natural numbers from 1 to `n`.

### Informal sketch
The proof proceeds by:
- Rewriting the left-hand side using the recursive definition of `NUMSEG_LREC` given `0 <= n`.
- Simplifying the result using `0 + 1 = 1`.
- Generalizing the result.

### Mathematical insight
This theorem provides a way to decompose a number segment starting from 0 into a singleton set containing 0 and another number segment starting from 1.

### Dependencies
- `NUMSEG_LREC`
- `INSERT`

---
### Name of formal statement
PDI_POLYDIFF_SUC_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PDI_POLYDIFF_SUC_LEMMA = PROVE(
    `!f n .(poly_diff_iter (poly_diff f) n) = poly_diff_iter f (SUC n)`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [PDI_DEF]);
      (ONCE_REWRITE_TAC [PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [PDI_DEF]) THEN
      (SIMP_TAC [PDI_POLY_DIFF_COMM])
    ]
)
```

### Informal statement
For all `f` and `n`, the `n`-th iterate of `poly_diff` applied to `poly_diff f` is equal to the `(SUC n)`-th iterate of `poly_diff` applied to `f`.

### Informal sketch
The proof uses induction on `n`.
- Base case: using the definition of `PDI_DEF`.
- Inductive step: rewrite using the definition of `PDI_DEF` twice, then uses `PDI_POLY_DIFF_COMM` to commute the `poly_diff` operations.

### Mathematical insight
The lemma expresses that differentiating a polynomial `f` once and then iterating the differentiation `n` times is the same as differentiating `f` a total of `(n+1)` times.

### Dependencies
- `poly_diff_iter`
- `poly_diff`
- `PDI_DEF`
- `PDI_POLY_DIFF_COMM`
- `SUC`

---
### Name of formal statement
SOD_POLY_DIFF_ITERATE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SOD_POLY_DIFF_ITERATE = PROVE(
    `!f .(SOD (poly_diff f)) = iterate (++) (1..(LENGTH f)) (\i.poly_diff_iter f i)`,
    let lemA1 = SPECL [`1`;`0`] NUMSEG_EMPTY in
    let lemA2 = SIMP_RULE [ARITH_RULE `0 < 1`] lemA1 in
    let lem1 =  MATCH_MP ITERATE_IMAGE_NONZERO MONOIDAL_POLY_ADD in
    let lem2 = ISPECL [`poly_diff_iter f`;`SUC`;`0..(LENGTH (poly_diff f))`] lem1 in
    let lem3 = SIMP_RULE [FINITE_NUMSEG] lem2 in
    let lem4 = ONCE_REWRITE_RULE [ARITH_RULE `~(~(x=y) /\ (SUC x) = (SUC y))`] lem3 in
    let lem5 = SIMP_RULE [] lem4 in
    let lem6 = ISPECL [`0`;`n:num`;`1`] NUMSEG_OFFSET_IMAGE in
    let lem7 = SIMP_RULE [ARITH_RULE `!m.m+1 = SUC m`] lem6 in
    let lem8 = SIMP_RULE [ARITH_RULE `SUC 0 = 1`] lem7 in
    let lem9 = ONCE_REWRITE_RULE [ETA_CONV `(\i. SUC i)`] lem8 in
    let lem10 = ONCE_REWRITE_RULE [GSYM lem9] lem5 in
    let lem11 = ONCE_REWRITE_RULE [GSYM (ETA_CONV `(\i. poly_diff_iter f i)`)] lem10 in
    let lem12 = SIMP_RULE [o_DEF] lem11 in
    let lemma0 = PROVE(
        `! h t.SUC (LENGTH (poly_diff (CONS h t))) = LENGTH (CONS h t)`,
        (SIMP_TAC [LENGTH_POLY_DIFF;LENGTH;PRE])
    ) in
    (ONCE_REWRITE_TAC [SOD]) THEN (ONCE_REWRITE_TAC [SODN]) THEN
    (ONCE_REWRITE_TAC [PDI_POLYDIFF_SUC_LEMMA ]) THEN LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_diff;LENGTH]) THEN
      (SIMP_TAC [GSYM lemma0;lem12]) THEN
      (SIMP_TAC [NUMSEG_SING;MONOIDAL_POLY_ADD;ITERATE_SING]) THEN
      (SIMP_TAC [lemA2;MATCH_MP ITERATE_CLAUSES_GEN MONOIDAL_POLY_ADD]) THEN
      (ONCE_REWRITE_TAC [POLY_ADD_IDENT]) THEN
      (SIMP_TAC [PDI_DEF;POLY_DIFF_CLAUSES]);
      (SIMP_TAC [lem12;GSYM lemma0])
    ]
)
```

### Informal statement
For all `f`, `SOD (poly_diff f)` is equal to the iterate of `(++)` over the number segment from `1` to the length of `f`, applying `\i.poly_diff_iter f i` to each element `i`.

### Informal sketch
The proof proceeds by:
- Several lemmas prepare the grounds to rewrite the right handside of the equation.
- Induction on the list representing the polynomial `f`.
- The base case involves simplifying the expression when f is the empty list using `poly_diff`, `LENGTH`, `NUMSEG_SING`, `MONOIDAL_POLY_ADD`, `ITERATE_SING`, `POLY_ADD_IDENT`,`PDI_DEF;POLY_DIFF_CLAUSES`.
- The inductive step relies on `lemma0` to relate `SUC (LENGTH (poly_diff (CONS h t)))` to `LENGTH (CONS h t)`.

### Mathematical insight
This theorem expresses `SOD (poly_diff f)` in terms of iterating the list concatenation operation `(++)` on increasingly differentiated versions of `f`. The `iterate` captures the creation of the series of derivatives as captured by `SOD`.

### Dependencies
- `SOD`
- `poly_diff`
- `iterate`
- `(++)`
- `LENGTH`
- `poly_diff_iter`
- `NUMSEG_EMPTY`
- `ITERATE_IMAGE_NONZERO`
- `MONOIDAL_POLY_ADD`
- `FINITE_NUMSEG`
- `NUMSEG_OFFSET_IMAGE`
- `o_DEF`
- `LENGTH_POLY_DIFF`
- `PRE`
- `SODN`
- `PDI_POLYDIFF_SUC_LEMMA`
- `poly_diff`
- `NUMSEG_SING`
- `ITERATE_SING`
- `ITERATE_CLAUSES_GEN`
- `POLY_ADD_IDENT`
- `PDI_DEF`
- `POLY_DIFF_CLAUSES`
- `CONS`

---
### Name of formal statement
ZERO_ITERATE_POLYADD_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ZERO_ITERATE_POLYADD_LEMMA = PROVE(
    `!n f .iterate (++) (0 INSERT (1..n)) f
           = (f 0) ++ iterate (++) (1..n) f`,
    let lem0 = PROVE(`!n. ~(0 IN (1..n))`,
                      STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN
                      ARITH_TAC) in
    let lem1 = ISPEC `poly_add` ITERATE_CLAUSES_GEN in
    let lem2 = SIMP_RULE [MONOIDAL_POLY_ADD] lem1  in
    let lem3 = CONJUNCT2 lem2  in
    let lem4 = ISPECL [`f:(num -> (real)list)`;`0`;`1..n`] lem3  in
    let lem5 = ISPECL [`poly_add`;`f:(num -> (real)list)`;`1..n` ] FINITE_SUPPORT  in
    let lem6 = SIMP_RULE [FINITE_NUMSEG] lem5 in
    let lem7 = MP lem4 lem6  in
    let lem9 = SIMP_RULE [lem0] lem7  in
    (ACCEPT_TAC (GEN_ALL lem9))
)
```

### Informal statement
For all `n` and `f`, the iterate of `(++)` over `0 INSERT (1..n)` with the function `f` is equal to `(f 0) ++ iterate (++) (1..n) f`.

### Informal sketch
The proof proceeds as follows:
- Establish a lemma `lem0` stating `~(0 IN (1..n))`.
- Use `ITERATE_CLAUSES_GEN` and `MONOIDAL_POLY_ADD` to derive `lem3`.
- Instantiate `lem3` to get `lem4`.
- Prove `FINITE_SUPPORT` for `poly_add`.
- Use `lem0` to simplify the result.

### Mathematical insight
This lemma shows how to extract the first element (corresponding to index 0) from an iterated concatenation, separating the contribution of index 0 from the rest of the iteration.

### Dependencies
- `iterate`
- `(++)`
- `INSERT`
- `NUMSEG`
- `ITERATE_CLAUSES_GEN`
- `MONOIDAL_POLY_ADD`
- `FINITE_SUPPORT`
- `FINITE_NUMSEG`

---
### Name of formal statement
SOD_SOD_POLYDIFF

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SOD_SOD_POLYDIFF = PROVE(
    `!f .(SOD f) = f ++ (SOD (poly_diff f))`,
    (ONCE_REWRITE_TAC [SOD_POLY_DIFF_ITERATE]) THEN (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (ONCE_REWRITE_TAC [ZERO_INSERT_NUMSEG]) THEN
    (ONCE_REWRITE_TAC [ZERO_ITERATE_POLYADD_LEMMA]) THEN
    (BETA_TAC) THEN (SIMP_TAC [PDI_DEF])
)
```

### Informal statement
For all `f`, `SOD f` is equal to the concatenation of `f` with `SOD (poly_diff f)`.

### Informal sketch
The proof rewrites the statement by:
- Using `SOD_POLY_DIFF_ITERATE`.
- Using the definition of `SOD`.
- Using the definition of `SODN`.
- Using `ZERO_INSERT_NUMSEG`.
- Using `ZERO_ITERATE_POLYADD_LEMMA`.
- Beta reduction.
- Simplifying with `PDI_DEF`.

### Mathematical insight
This theorem expresses `SOD f` recursively in terms of `SOD (poly_diff f)`, showing how the series of derivatives are built.

### Dependencies
- `SOD`
- `++` (list concatenation)
- `poly_diff`
- `SOD_POLY_DIFF_ITERATE`
- `SODN`
- `ZERO_INSERT_NUMSEG`
- `ZERO_ITERATE_POLYADD_LEMMA`
- `PDI_DEF`

---
### Name of formal statement
SUC_INSERT_NUMSEG

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SUC_INSERT_NUMSEG = PROVE(
    `!n. (0..(SUC n)) = (SUC n) INSERT (0..n)`,
    let lem01 = SIMP_RULE [ARITH_RULE `0 <= SUC n`]
                          (SPECL [`0`;`n:num`] NUMSEG_REC) in
    ACCEPT_TAC (GEN_ALL lem01)
)
```

### Informal statement
For all natural numbers `n`, the set of natural numbers from 0 to `(SUC n)` is equal to the set consisting of `(SUC n)` inserted into the set of natural numbers from 0 to `n`.

### Informal sketch
The proof proceeds by:
- Rewriting the left-hand side using the recursive definition of `NUMSEG_REC` given `0 <= SUC n`.
- Generalizing the result.

### Mathematical insight
This theorem provides a way to decompose a number segment ending at SUC n into a singleton set containing SUC n and another number segment ending at n.

### Dependencies
- `NUMSEG_REC`
- `INSERT`
- `SUC`

---
### Name of formal statement
SUC_NOT_IN_NUMSEG

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SUC_NOT_IN_NUMSEG = PROVE(
    `!m n. ~((SUC n) IN (m..n))`,
    STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC
)
```

### Informal statement
For all `m` and `n`, it is not the case that `(SUC n)` is in the set of numbers from `m` to `n`.

### Informal sketch
The proof proceeds by:
- Rewriting the `IN` predicate using `IN_NUMSEG`.
- Using arithmetic reasoning.

### Mathematical insight
This theorem states that the successor of `n` cannot be in a numerical segment that ends at `n`. Because `SUC n` is strictly greater than `n`, it can never be a member of the segment `m..n`.

### Dependencies
- `SUC`
- `IN`
- `NUMSEG`
- `IN_NUMSEG`

---
### Name of formal statement
SUC_ITERATE_PDI_POLYDIFF_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SUC_ITERATE_PDI_POLYDIFF_LEMMA = PROVE(
    `iterate (++) ((SUC n) INSERT (0..n)) (\i.poly_diff_iter (poly_diff p) i) =
     (poly_diff_iter (poly_diff p) (SUC n)) ++
     iterate (++) (0..n) (\i.poly_diff_iter (poly_diff p) i)`,
    let lem1 = ISPEC `poly_add` ITERATE_CLAUSES_GEN in
    let lem2 = SIMP_RULE [MONOIDAL_POLY_ADD] lem1 in
    let lem3 = CONJUNCT2 lem2 in
    let lem4 = ISPECL [`(\i.poly_diff_iter (poly_diff p) i)`;`SUC n`;`0..n`] lem3 in
    let lem5 = ISPECL [`poly_add`;`\i.poly_diff_iter (poly_diff p) i`;`0..n` ] FINITE_SUPPORT in
    let lem6 = SIMP_RULE [FINITE_NUMSEG] lem5 in
    let lem7 = MP lem4 lem6 in
    let lem9 = SIMP_RULE [SPEC `0` SUC_NOT_IN_NUMSEG] lem7 in
    ACCEPT_TAC lem9
)
```

### Informal statement
For all `n` and `p`, the iterate of `(++)` over `(SUC n) INSERT (0..n)` with the function `\i.poly_diff_iter (poly_diff p) i` is equal to `(poly_diff_iter (poly_diff p) (SUC n)) ++ iterate (++) (0..n) (\i.poly_diff_iter (poly_diff p) i)`.

### Informal sketch
The proof proceeds as follows:
- Use `ITERATE_CLAUSES_GEN` and `MONOIDAL_POLY_ADD` to derive `lem3`.
- Instantiate `lem3` to get `lem4`.
- Use `FINITE_SUPPORT` and `FINITE_NUMSEG` to show the support is finite.
- Use `SUC_NOT_IN_NUMSEG` to show that the successor is not in the number segment.

### Mathematical insight
This lemma separates the contribution of the `(SUC n)`-th derivative from the remaining derivatives in the iterated concatenation.

### Dependencies
- `iterate`
- `(++)`
- `INSERT`
- `NUMSEG`
- `poly_diff_iter`
- `poly_diff`
- `SUC`
- `ITERATE_CLAUSES_GEN`
- `MONOIDAL_POLY_ADD`
- `FINITE_SUPPORT`
- `FINITE_NUMSEG`
- `SUC_NOT_IN_NUMSEG`

---
### Name of formal statement
SODN_POLY_DIFF_COMM

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SODN_POLY_DIFF_COMM = PROVE(
    `!n p.(SODN (poly_diff p) n) = poly_diff (SODN p n)`,
    let lem = MP (ISPEC `poly_add` ITERATE_SING) MONOIDAL_POLY_ADD in
    let lem1 = ISPEC `poly_add` ITERATE_CLAUSES_GEN in
    let lem2 = SIMP_RULE [MONOIDAL_POLY_ADD] lem1 in
    let lem3 = CONJUNCT2 lem2 in
    let lem10 = SIMP_RULE [GSYM SUC_INSERT_NUMSEG] SUC_ITERATE_PDI_POLYDIFF_LEMMA in
    let lema00 = ISPECL [`(\i.poly_diff_iter (p) i)`;`SUC n`;`0..n`] lem3 in
    let lema0 = SIMP_RULE [GSYM SUC_INSERT_NUMSEG] lema00 in
    let lem15 = ISPECL [`poly_add`;`\i.poly_diff_iter (p) i`;`0..n` ] FINITE_SUPPORT in
    let lem16 = SIMP_RULE [FINITE_NUMSEG] lem15 in
    let lema1 = MP lema0 lem16 in
    let lema2 = SIMP_RULE [SPEC `0` SUC_NOT_IN_NUMSEG] lema1 in
    let lema3 = ONCE_REWRITE_RULE [GSYM SODN] lema2 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [SODN]) THEN
      (SIMP_TAC [NUMSEG_SING;ITERATE_SING]) THEN
      (ONCE_REWRITE_TAC [lem]) THEN
      (BETA_TAC) THEN
      (SIMP_TAC [PDI_POLY_DIFF_COMM])
      ;
      (ONCE_REWRITE_TAC [SODN]) THEN (ONCE_REWRITE_TAC [lem10]) THEN
      (ONCE_REWRITE_TAC [GSYM SODN]) THEN (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [PDI_DEF ]) THEN
      (ONCE_REWRITE_TAC [PDI_POLY_DIFF_COMM]) THEN
      (ONCE_REWRITE_TAC [GSYM POLYDIFF_ADD]) THEN
      STRIP_TAC THEN AP_TERM_TAC THEN
      (ONCE_REWRITE_TAC [lema3]) THEN (SIMP_TAC [PDI_DEF])
    ]
)
```

### Informal statement
For all `n` and `p`, `SODN (poly_diff p) n` is equal to `poly_diff (SODN p n)`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: Rewrite `SODN`, simplify using `NUMSEG_SING;ITERATE_SING`, rewrite using `MONOIDAL_POLY_ADD` & `ITERATE_SING`, Beta reduce and simplify using `PDI_POLY_DIFF_COMM`
- Inductive step: Uses lemmas  `SUC_INSERT_NUMSEG`,`SUC_ITERATE_PDI_POLYDIFF_LEMMA`,`FINITE_NUMSEG`,`SUC_NOT_IN_NUMSEG`.

### Mathematical insight
This theorem states that the `n`-th coefficient list of the polynomial derivative is equal to the derivative of the `n`-th coefficient list of the polynomial.

### Dependencies
- `SODN`
- `poly_diff`
- `NUMSEG`
- `iterate`
- `poly_diff_iter`
- `PDI_POLY_DIFF_COMM`
- `ITERATE_SING`
- `MONOIDAL_POLY_ADD`
- `ITERATE_CLAUSES_GEN`
- `SUC_INSERT_NUMSEG`
- `SUC_ITERATE_PDI_POLYDIFF_LEMMA`
- `FINITE_SUPPORT`
- `FINITE_NUMSEG`
- `SUC_NOT_IN_NUMSEG`
- `PDI_DEF`
- `POLYDIFF_ADD`

---
### Name of formal statement
SUC_ITERATE_POLYADD_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let SUC_ITERATE_POLYADD_LEMMA = PROVE(
    `!n f .iterate (++) ((SUC n) INSERT (0..n)) f
           = (f (SUC n)) ++ iterate (++) (0..n) f`,
    let lem1 = ISPEC `poly_add` ITERATE_CLAUSES_GEN in
    let lem2 = SIMP_RULE [MONOIDAL_POLY_ADD] lem1  in
    let lem3 = CONJUNCT2 lem2  in
    let lem4 = ISPECL [`f:(num -> (real)list)`;`SUC n`;`0..n`] lem3  in
    let lem5 = ISPECL [`poly_add`;`f:(num -> (real)list)`;`0..n` ] FINITE_SUPPORT  in
    let lem6 = SIMP_RULE [FINITE_NUMSEG] lem5 in
    let lem7 = MP lem4 lem6  in
    let lem9 = SIMP_RULE [SPEC `0` SUC_NOT_IN_NUMSEG] lem7  in
    ACCEPT_TAC (GEN_ALL lem9)
)
```

### Informal statement
For all `n` and `f`, the iterate of `(++)` over `(SUC n) INSERT (0..n)` applied to `f` is equal to `(f (SUC n)) ++ iterate (++) (0..n) f`.

### Informal sketch
The proof proceeds as follows:
- Apply `ITERATE_CLAUSES_GEN` and simplify with `MONOIDAL_POLY_ADD` to obtain `lem3`.
- Instantiate `lem3` with appropriate parameters to obtain `lem4`.
- Show finite support using `FINITE_SUPPORT` and `FINITE_NUMSEG`.
- Use `SUC_NOT_IN_NUMSEG` to simplify.
- Generalize the result.

### Mathematical insight
This lemma separates the element corresponding to the successor of `n` from the rest of the iteration when iterating over a number segment up to the successor of `n`.

### Dependencies
- `iterate`
- `(++)`
- `INSERT`
- `SUC`
- `NUMSEG`
- `ITERATE_CLAUSES_GEN`
- `MONOIDAL_POLY_ADD`
- `FINITE_SUPPORT`
- `FINITE_NUMSEG`
- `SUC_NOT_IN_NUMSEG`

---
### Name of formal statement
NUMSEG_LENGTH_POLYDIFF_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let NUMSEG_LENGTH_POLYDIFF_LEMMA = PROVE(
    `!f. (0..(LENGTH f)) = ((LENGTH f) INSERT (0..(LENGTH (poly_diff f))))`,
    (SIMP_TAC [LENGTH_POLY_DIFF]) THEN (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [LENGTH;PRE]) THEN (SIMP_TAC [NUMSEG_CLAUSES]) THEN
      (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN]);
      (SIMP_TAC [LENGTH;PRE]) THEN
      (SIMP_TAC [ARITH_RULE `0 <= SUC n`;NUMSEG_REC])
    ]
)
```

### Informal statement
For all `f`, the number segment from `0` to `LENGTH f` is equal to `(LENGTH f) INSERT (0..(LENGTH (poly_diff f)))`.

### Informal sketch
The proof proceeds by:
- Simplifying with `LENGTH_POLY_DIFF`.
- Inducting on the list `f`.
- Base case: simplify `LENGTH`, `PRE`, `NUMSEG_CLAUSES`, `INSERT_DEF;NOT_IN_EMPTY;IN`.
- Inductive case: simplify `LENGTH`, `PRE`, and `NUMSEG_REC`.

### Mathematical insight
This lemma relates the number segment up to the length of a list `f` to the number segment up to the length of its derivative. The length of the original list is inserted into the segment of its deriviative.

### Dependencies
- `NUMSEG`
- `LENGTH`
- `INSERT`
- `poly_diff`
- `LENGTH_POLY_DIFF`
- `PRE`
- `NUMSEG_CLAUSES`
- `INSERT_DEF`
- `NOT_IN_EMPTY`
- `IN`
- `NUMSEG_REC`

---
### Name of formal statement
POLY_DIFF_LENGTH_LT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LT = PROVE(
    `!p. (~(p=[])) ==> (LENGTH (poly_diff p)) < (LENGTH p)`,
    SIMP_TAC [LENGTH_POLY_DIFF;LENGTH_EQ_NIL;
               ARITH_RULE `!n.(~(n=0)) ==> (PRE n) < n`]
);;  
```

### Informal statement
For all `p`, if `p` is not the empty list, then the length of `poly_diff p` is less than the length of `p`.

### Informal sketch
The proof proceeds by:
- Rewriting using `LENGTH_POLY_DIFF` which states `LENGTH (poly_diff p) = PRE (LENGTH p)`.
- Rewriting using `LENGTH_EQ_NIL` which states `(LENGTH p = 0) = (p = [])`.
- Applying arithmetic reasoning `!n.(~(n=0)) ==> (PRE n) < n`.

### Mathematical insight
This theorem formalizes the mathematical fact that differentiating a polynomial (represented as a list of coefficients) reduces its degree, and therefore reduces the length of the list representation.

### Dependencies
- `poly_diff`
- `LENGTH`
- `LENGTH_POLY_DIFF`
- `LENGTH_EQ_NIL`
- `PRE`


---

## POLY_DIFF_LENGTH_LE_SUC

### Name of formal statement
POLY_DIFF_LENGTH_LE_SUC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all polynomials `p` (represented as a list of real coefficients) and natural numbers `n`, if the length of `p` is less than or equal to the successor of `n`, then the length of the derivative of `p` is less than or equal to `n`.

### Informal sketch
The proof proceeds by:
- Induction on whether the polynomial `p` (represented as a list) is the empty list `[]`.
- If `p` is `[]`, simplify using the definitions of `poly_diff` and `LENGTH` and use arithmetic reasoning.
- If `p` is not `[]`, use previously proved theorems `POLY_DIFF_LENGTH_LT`, `LT_SUC_LE` and `LTE_TRANS` (transitivity of less than or equal) using MESON.

### Mathematical insight
This theorem establishes a relationship between the length (number of coefficients) of a polynomial and the length of its derivative. Specifically, it shows that differentiation reduces the length of the polynomial by at least one.

### Dependencies
- Definitions: `poly_diff`, `LENGTH`
- Theorems: `POLY_DIFF_LENGTH_LT`, `LT_SUC_LE`, `LTE_TRANS`

---
### Name of formal statement
PDI_LENGTH_AUX

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all natural numbers `n` and polynomials `p`, if the length of `p` is less than or equal to `n`, then `poly_diff_iter p n` (the `n`-th iterated derivative of `p`) is equal to the empty list.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 0`. Use `PDI_DEF`, `LENGTH_EQ_NIL` which states `LENGTH l = 0 <=> l = []`, and the arithmetic rule `n <= 0 <=> n = 0` using MESON.
- Inductive step: Using `PDI_DEF`, `PDI_POLY_DIFF_COMM` (commutativity of `poly_diff_iter` and `poly_diff`), and `POLY_DIFF_LENGTH_LE_SUC`, use MESON.

### Mathematical insight
This theorem states that if we iterate the polynomial derivative enough times (specifically `n` times, where `n` is greater than or equal to the length of the polynomial), we will eventually obtain the zero polynomial, which is represented by the empty list.

### Dependencies
- Definitions: `PDI_DEF` (definition of `poly_diff_iter`)
- Theorems: `LENGTH_EQ_NIL`, `ARITH_RULE n <= 0 <=> n = 0`, `PDI_POLY_DIFF_COMM`, `POLY_DIFF_LENGTH_LE_SUC`

---
### Name of formal statement
PDI_LENGTH_NIL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all polynomials `p`, `poly_diff_iter p (LENGTH p)` (the `LENGTH p`-th iterated derivative of `p`) is the empty list (the zero polynomial).

### Informal sketch
The proof follows by simplifying with `PDI_LENGTH_AUX` and `LE_REFL` (reflexivity of less than or equal).

### Mathematical insight
This theorem is a direct consequence of `PDI_LENGTH_AUX`. It states that if we iterate polynomial differentiation a number of times equal to the length of the polynomial, we get the zero polynomial.

### Dependencies
- Theorems: `PDI_LENGTH_AUX`, `LE_REFL`

---
### Name of formal statement
SOD_POLYDIFF_THEOREM

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all `f`, the sum of derivatives of `f` (`SOD (poly_diff f)`) is equal to the derivative of the sum of derivatives of `f` (`poly_diff (SOD f)`).

### Informal sketch
The proof proceeds as follows:
- Rewrite using the definition of `SOD`.
- Rewrite using `SODN_POLY_DIFF_COMM`.
- Rewrite using `SODN`.
- Rewrite the right hand side using `NUMSEG_LENGTH_POLYDIFF_LEMMA`, instantiated with polynomial `f`. This lemma relates the numeric segment 0..LENGTH(poly_diff f) with 0..LENGTH f.
- Induction on the list `f`.
    - Base case: `f` is the empty list. Simplify using `poly_diff`, `LENGTH`, `SUM_SING_NUMSEG`, and `lemmmag` (`0 INSERT (0..0) = (0..0)`).
    - Inductive step: Simplify using `LENGTH_POLY_DIFF`, `LENGTH`, and `PRE`. Rewrite using `SUC_ITERATE_POLYADD_LEMMA`. Simplify using `LENGTH`, `PRE`, and the definition of `SODN`. Rewrite again using `SUC_LENGTH_CONS` (`SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`), `PDI_LENGTH_NIL`, and the clauses for `POLY_ADD`.

### Mathematical insight
This theorem provides a relationship between taking the derivative of a polynomial and summing the derivatives, establishing that these operations commute. `SOD f` represents sum of successive derivatives of `f`.

### Dependencies
- Definitions: `SOD`, `SODN`
- Theorems: `SODN_POLY_DIFF_COMM`, `NUMSEG_LENGTH_POLYDIFF_LEMMA`,`SUC_ITERATE_POLYADD_LEMMA`, `SUC_LENGTH_CONS`, `PDI_LENGTH_NIL`, `POLY_ADD_CLAUSES`, `LENGTH_POLY_DIFF`, `SUM_SING_NUMSEG `, `INSERT_DEF`, `NOT_IN_EMPTY`, `IN`

---
### Name of formal statement
SOD_SOD_DIFF_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all polynomials `f` and real numbers `x`, `(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`.
In words, evaluating the sum of derivatives of `f` at `x`, then subtracting the evaluation of the derivative of the sum of derivatives of `f` at `x`, results in the same value as evaluating `f` at `x`.

### Informal sketch
The proof uses `SOD_SOD_POLYDIFF`, `POLY_ADD`, `POLY_SUB`, `SOD_POLYDIFF_THEOREM` and the real arithmetic simplification rule `((x:real) + y) -y = x` using MESON.

### Mathematical insight
This lemma provides a fundamental relationship between a polynomial `f`, its sum of derivatives `SOD f`, and the derivative `poly_diff` of the sum of derivatives `SOD f`. It suggests how the original polynomial f can be retrieved by evaluating at `x` the difference `(poly (SOD f) x) - (poly (poly_diff (SOD f)) x)`.

### Dependencies
- Theorems: `SOD_SOD_POLYDIFF`, `POLY_ADD`, `POLY_SUB`, `SOD_POLYDIFF_THEOREM`, `REAL_ARITH ((x:real) + y) -y = x`

---
### Name of formal statement
PLANETMATH_EQN_1_1_2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all polynomials `f` and real numbers `x`,
`((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x))) = (-- (exp (--x))) * (poly f x)`.
In words, the exponential of negative x multiplied by the difference between the polynomial obtained by taking the derivative of sum of derivatives of `f` evaluated at `x`, and sum of derivatives of `f` evaluated at `x` equals to the negative of exponential of negative x multiplied by value of polynomial `f` evaluated at `x`.

### Informal sketch
The proof proceeds as follows:
- Rewrite with lemma lem17: `(x - y) = (-- (y - x))`.
- Rewrite with `SOD_SOD_DIFF_LEMMA`.
- Use real arithmetic simplification.

### Mathematical insight
This equation relates the polynomial `f` with its sum of derivatives. It builds up on `SOD_SOD_DIFF_LEMMA`

### Dependencies
- Theorems: `SOD_SOD_DIFF_LEMMA`

---
### Name of formal statement
PLANETMATH_EQN_1_1_3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all real numbers `x` and polynomials `f`, `((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)` holds. This means that the derivative of the function `Phi f` at `x` is equal to the value of `-- (exp (--x)) * (poly f x)` at `x`.

### Informal sketch
The proof rewrites with `PLANETMATH_EQN_1_1_2` and accepts the result with `PLANETMATH_EQN_1_1_1`. Note that `Phi` is defined in terms of derivative of `SOD` and `poly` and `exp`.

### Mathematical insight
This equation defines the derivative of `Phi f` at `x`

### Dependencies
- Theorems: `PLANETMATH_EQN_1_1_2`, `PLANETMATH_EQN_1_1_1`

---
### Name of formal statement
PHI_CONTL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all `f` and `x`, `Phi f` is continuous at `x`.

### Informal sketch
This theorem exploits the theorem `DIFF_CONT` and `PLANETMATH_EQN_1_1_3` which provide the condition `DIFF_CONT (Phi f) (-- (exp (--x)) * (poly f x)) x ==> (Phi f) continuous x`.

### Mathematical insight
This states that the function denoted by `Phi f` is continuous.

### Dependencies
- Theorems: `DIFF_CONT`, `PLANETMATH_EQN_1_1_3`

---
### Name of formal statement
PHI_DIFFERENTIABLE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all polynomials `f` and real numbers `x`, `(Phi f)` is differentiable at `x`.

### Informal sketch
The proof follows by substituting the derivative, using `PLANETMATH_EQN_1_1_1`, and using the definition of the `differentiable` predicate.

### Mathematical insight
This theorem establishes that the function `Phi f` is differentiable for any polynomial `f` and real number `x`.

### Dependencies
- Definitions: `differentiable`
- Theorems: `PLANETMATH_EQN_1_1_1`

---
### Name of formal statement
PLANETMATH_EQN_1_2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
This theorem is a step towards showing that there exists a `xi` such that a subsequent lemma holds. The precise meaning requires unfolding several definitions and intermediate lemmas. In words, this proof establishes intermediate conditions that are required to prove the main theorem.

### Informal sketch
The proof is involved and relies on several intermediate lemmas derived from theorems such as `MVT` (Mean Value Theorem), `DIFF_UNIQ`,`PHI_DIFFERENTIABLE`, and `PHI_CONTL`. It constructs an argument ultimately based on the Mean Value Theorem and uniqueness of derivatives to establish existence of a `xi`.

### Mathematical insight
This theorem is an intermediate step in proving a more significant result. It leverages the Mean Value Theorem and the properties of `Phi f` (differentiability and continuity) to set up the conditions required for the existence of a point `xi`.

### Dependencies
- Theorems: `MVT`, `DIFF_UNIQ`, `PHI_DIFFERENTIABLE`, `PHI_CONTL`

---
### Name of formal statement
xi_DEF

### Type of the formal statement
new specification

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
This specification introduces a new function `xi`, implicitly defined based on the theorem `PLANETMATH_EQN_1_2`.

### Informal sketch
The specification uses `PLANETMATH_EQN_1_2` to define the value of `xi x f` by Skolemization.

### Mathematical insight
This definition introduces the function `xi x f`, which represents a specific point guaranteed to exist based on the previous theorem `PLANETMATH_EQN_1_2`, by application of mean value theorem MVT to `Phi`.

### Dependencies
- Theorems: `PLANETMATH_EQN_1_2`

---
### Name of formal statement
PLANETMATH_LEMMA_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_DIFF_LENGTH_LE_SUC = PROVE(
    `! p n . (LENGTH p <= SUC n)  ==> (LENGTH (poly_diff p) <= n)`,
    (REPEAT STRIP_TAC) THEN (ASM_CASES_TAC `p:(real)list =[]`) THENL
    [ (ASM_SIMP_TAC [poly_diff;LENGTH]) THEN (ARITH_TAC);
      (ASM_MESON_TAC [POLY_DIFF_LENGTH_LT;LT_SUC_LE;LTE_TRANS])
    ]
)
let PDI_LENGTH_AUX = PROVE(
    `! n p. (LENGTH p <= n) ==> poly_diff_iter p n = []`,
    INDUCT_TAC THENL
    [ MESON_TAC [PDI_DEF;LENGTH_EQ_NIL;ARITH_RULE `n <= 0 <=> n = 0`];
      ASM_MESON_TAC [PDI_DEF;PDI_POLY_DIFF_COMM;POLY_DIFF_LENGTH_LE_SUC] ]
)
let PDI_LENGTH_NIL =  PROVE(
    `! p . poly_diff_iter p (LENGTH p) = []`,
    SIMP_TAC [PDI_LENGTH_AUX;LE_REFL]
)
let SOD_POLYDIFF_THEOREM = PROVE(
    `!f .(SOD (poly_diff f)) = (poly_diff (SOD f))`,
    let lemmmag = PROVE(
        `0 INSERT (0..0) = (0..0)`,
        (SIMP_TAC [NUMSEG_SING]) THEN
        (SIMP_TAC [INSERT_DEF;NOT_IN_EMPTY;IN])) in
    let SUC_LENGTH_CONS = PROVE(
        `SUC (LENGTH (t:(real)list)) = (LENGTH (CONS h t))`,
        (SIMP_TAC [LENGTH])) in
    (ONCE_REWRITE_TAC [SOD]) THEN
    (ONCE_REWRITE_TAC [SODN_POLY_DIFF_COMM]) THEN
    (ONCE_REWRITE_TAC [SODN]) THEN
    (STRIP_TAC) THEN
    (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [NUMSEG_LENGTH_POLYDIFF_LEMMA]))) THEN
    (SPEC_TAC (`f:(real)list`,`f:(real)list`)) THEN
    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [poly_diff]) THEN
      (SIMP_TAC [LENGTH]) THEN
      (SIMP_TAC [SUM_SING_NUMSEG ]) THEN
      (SIMP_TAC [lemmmag])
      ;
       (SIMP_TAC [LENGTH_POLY_DIFF]) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (CONV_TAC (RAND_CONV (ONCE_REWRITE_CONV [SUC_ITERATE_POLYADD_LEMMA]))) THEN
       (SIMP_TAC [LENGTH;PRE]) THEN
       (SIMP_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [GSYM SODN]) THEN
       (ONCE_REWRITE_TAC [SUC_LENGTH_CONS]) THEN
       (ONCE_REWRITE_TAC [PDI_LENGTH_NIL]) THEN
       (SIMP_TAC [POLY_ADD_CLAUSES ]);
    ]
)
let SOD_SOD_DIFF_LEMMA = PROVE(
    `!f x.(poly (SOD f) x) - (poly (poly_diff (SOD f)) x) = poly f x`,
    MESON_TAC [SOD_SOD_POLYDIFF; POLY_ADD ; POLY_SUB;SOD_POLYDIFF_THEOREM;
               REAL_ARITH `((x:real) + y) -y = x`]
)

let PLANETMATH_EQN_1_1_2 = PROVE(
    `!f x.
        ((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))
        = (-- (exp (--x))) * (poly f x)`,
    let lem17 = PROVE(`!x y.(x - y) = (-- (y - x))`,REAL_ARITH_TAC) in
    (REPEAT STRIP_TAC) THEN
    (ONCE_REWRITE_TAC [lem17]) THEN (ONCE_REWRITE_TAC [SOD_SOD_DIFF_LEMMA])
    THEN REAL_ARITH_TAC
)

let PLANETMATH_EQN_1_1_3 = PROVE(
    `! x f.((Phi f) diffl (-- (exp (--x)) * (poly f x)))(x)`,
    (ONCE_REWRITE_TAC [GSYM PLANETMATH_EQN_1_1_2]) THEN (ACCEPT_TAC PLANETMATH_EQN_1_1_1)
)
let PHI_CONTL =
   let lem0 = SPECL [`Phi f`;`-- (exp (--x)) * (poly f x)`;`x:real`] DIFF_CONT in
   GEN_ALL (MP lem0 (SPEC_ALL PLANETMATH_EQN_1_1_3))

let PHI_DIFFERENTIABLE = PROVE(
    `!f x.(Phi f) differentiable x`,
    (SIMP_TAC [differentiable]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((exp (--x)) * ((poly (poly_diff (SOD f)) x) - (poly (SOD f) x)))`)
    THEN (SIMP_TAC [PLANETMATH_EQN_1_1_1])
)
let PLANETMATH_EQN_1_2 =
   (* this one's a bit nasty *)
   let FO_LEMMA2 = GEN_ALL (PROVE(
         `((! l z. (C (l:real) (z:real)) ==> l = (l' z))) ==> ((? (l:real) (z:real) .(A z) /\ (B  z) /\ (C l z) /\ (D l) ) ==> (? (z:real).((A z) /\ (B z) /\ (D (l' z)))))`,
       let lem0 = PROVE(`(! (l:real) z.(C l (z:real)) ==> l = (l' z)) ==> ((C l z) = ((C l z) /\ l = (l' z)))`, MESON_TAC[]) in
       let lem1 = UNDISCH lem0 in
        (STRIP_TAC THEN (ONCE_REWRITE_TAC [lem1]) THEN (MESON_TAC[]))
   )) in
    let PROP_LEMMA = TAUT `! a b c d.((a /\ b /\ c) ==> d) = (b ==> c ==> a ==> d)` in
    let MVT_SPEC = SPECL [`Phi f`;`&0`;`x:real`] MVT in
    let MVT_SPEC2 = ONCE_REWRITE_RULE [PROP_LEMMA] MVT_SPEC in
    let MVT_SPEC3 = UNDISCH MVT_SPEC2 in
    let MVT_SPEC4 = UNDISCH MVT_SPEC3 in
    let MVT_SPEC5 = UNDISCH MVT_SPEC4 in
    let lem0 = PROVE(`! x. x - &0 = x`,REAL_ARITH_TAC) in
    let MVT_SPEC6 = ONCE_REWRITE_RULE [lem0] MVT_SPEC5 in
    let DIFF_UNIQ_SPEC1 = SPEC `Phi f` DIFF_UNIQ in
    let DIFF_UNIQ_SPEC2 = SPEC `l:real` DIFF_UNIQ_SPEC1 in
    let DIFF_UNIQ_SPEC3 = SPEC ` (-- (exp (--x)) * (poly f x)) ` DIFF_UNIQ_SPEC2 in
    let DIFF_UNIQ_SPEC4 = SPEC `x:real` DIFF_UNIQ_SPEC3 in
    let lem8 = SIMP_RULE [PLANETMATH_EQN_1_1_3] DIFF_UNIQ_SPEC4 in
    let lem9 = GENL [`l:real`;`x:real`] lem8 in
    let lem10 = SPECL [`\l x.((Phi f diffl l) x)`;`\z.(&0)<z`;`\z.z < (x:real)`;`\l. (Phi f x) - (Phi f (&0)) = x * l`] FO_LEMMA2  in
    let lem12 = SPEC `\x.(--(exp (--x))) * (poly f x)` lem10 in
    let lem13 = BETA_RULE lem12 in
    let lem14 = MP lem13 lem9 in
    let lem15 = MP lem14 MVT_SPEC6  in
    let lem70 = SPECL [`f:(real)list`;`x':real`] PHI_DIFFERENTIABLE  in
    let lem71 = ADD_ASSUM `(&0) < x' /\ x' < x` lem70 in
    let lem72 = GEN `x':real` (DISCH_ALL lem71) in
    let lem73 = MP (DISCH (concl lem72) lem15) lem72 in
    let lem80 = SPECL [`f:(real)list`;`x':real`] PHI_CONTL  in
    let lem81 = ADD_ASSUM `(&0) <= x' /\ x' <= x` lem80 in
    let lem82 = GEN `x':real` (DISCH_ALL lem81) in
    let lem83 = MP (DISCH (concl lem82) lem73) lem82 in
    lem83

let xi_DEF  = new_specification ["xi"]
    (let FO_LEM = PROVE(
         `  (! x f.(P x) ==> ? z. (Q z x f))
          = (! (x:real) (f:(real)list). ? (z:real). (P x) ==> (Q z x f))`,
         MESON_TAC []) in
    ((CONV_RULE SKOLEM_CONV)
      (ONCE_REWRITE_RULE [FO_LEM]
        (GEN_ALL (DISCH_ALL PLANETMATH_EQN_1_2)))))

let PLANETMATH_LEMMA_1 = PROVE(
    `!x f.  &0 < x
            ==> poly (SOD f) (&0) * exp x =
                poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`,
    let lemA = CONJUNCT2 (CONJUNCT2 (UNDISCH (SPEC_ALL xi_DEF))) in
    let lemB = ONCE_REWRITE_RULE [PHI] lemA in
    let lemC = ONCE_REWRITE_RULE [REAL_ARITH `((A:real) - B = C) = (B = A - C)`] lemB in
    let lemD = SIMP_RULE [REAL_NEG_0;REAL_EXP_0;REAL_MUL_LID] lemC in
    let lem01 =  ASSUME `A = ((exp (-- x))*B - (C *( -- (exp (-- y))) * D))` in
    let lem02 = DISJ2 `exp x = &0` lem01 in
    let lem03 = REWRITE_RULE [GSYM (SPEC `exp x` REAL_EQ_MUL_LCANCEL)] lem02 in
    let lem04 = SIMP_RULE [REAL_EXP_NEG_MUL;REAL_EXP_ADD_MUL] lem03 in
    let lem05 = SIMP_RULE [REAL_SUB_LDISTRIB] lem04 in
    let lem07 = SIMP_RULE [REAL_MUL_ASSOC;REAL_EXP_NEG_MUL;REAL_MUL_LID] lem05 in
    let fact00 = REAL_ARITH `(B:real) - ((expx * C) * (--expy))  * D = B + C * (expx * expy) * D` in
    let lem08 = ONCE_REWRITE_RULE [fact00] lem07 in
    let lem09 = SIMP_RULE [GSYM REAL_EXP_ADD] lem08 in
    let lem10 = SIMP_RULE [PROVE(`(x:real) + -- y =  x - y`, REAL_ARITH_TAC)] lem09 in
    let lem11 = GEN_ALL (DISCH_ALL lem10) in
    let lem12 = SPECL [`poly (SOD f) (&0)`;
                       `poly (SOD f) x`;
                       `x:real`;
                       `x:real`;
                       `xi x f`;
                       `poly f (xi x f)`] lem11 in
    let lem13 = MP lem12 lemD  in
    let lem14 = SPECL [`exp x`;`poly (SOD f) (&0)`] REAL_MUL_SYM in
    ACCEPT_TAC (GEN_ALL (DISCH_ALL (ONCE_REWRITE_RULE [lem14] lem13)))
)

end;;
```
### Informal statement
For all real numbers `x` and polynomials `f`, if `x` is greater than 0, then `poly (SOD f) (&0) * exp x = poly (SOD f) x + x * exp (x - xi x f) * poly f (xi x f)`.

### Informal sketch
The proof proceeds as follows:
- Extract the definition of `xi` ( `xi_DEF`) obtained from `PLANETMATH_EQN_1_2`, and apply definitions `PHI`, `REAL_ARITH`.
- Simplify by exploiting expression cancellations and identities from `REAL_ARITH` tactics.

### Mathematical insight
This lemma relates the value of `poly (SOD f)` at `0` (multiplied by `exp x`) to the value of `poly (SOD f)` at `x`, together with an error term involving `xi x f` and `poly f (xi x f)`. It represents an important relationship useful to connect the values of the sum of derivatives at two points

### Dependencies
- Definitions: `PHI`
- Theorems: `xi_DEF`


---

## POLY_MCLAURIN

### Name of formal statement
POLY_MCLAURIN

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For any polynomial `p` and any real number `x`, the polynomial `p` evaluated at `x` is equal to the sum from `m = 0` to `LENGTH p` of `(poly (poly_diff_iter p m) 0) / (FACT m) * x pow m`.

### Informal sketch
The proof proceeds as follows:
- Specialize `MCLAURIN_ALL_LE` with `poly p` and `\n.poly (poly_diff_iter p n)`.
- Simplify using `Pm_lemma1.PDI_DEF` and `POLY_DIFF`.
- Rewrite `POLY_DIFF` using ETA_CONV `(\x.poly l x)`.
- Use the simplified result to derive a more specific lemma.
- Specialize this lemma with `x:real` and `LENGTH (p:(real)list)`.
- Rewrite using `Pm_lemma1.PDI_LENGTH_NIL` and `poly`.
- Simplify using `REAL_ARITH \`!x. ((&0)/x) = &0\``, `REAL_MUL_LZERO`, and `REAL_ADD_RID`.
- Prove a simple existential elimination lemma.
- Apply this lemma and generalize the result.

### Mathematical insight
This theorem expresses a polynomial in terms of its derivatives evaluated at zero. It corresponds to the Maclaurin series expansion of a polynomial. The sum represents the Taylor expansion of the polynomial `poly p` around the point `0`.

### Dependencies
- Theorem: `MCLAURIN_ALL_LE`
- Definition: `Pm_lemma1.PDI_DEF`
- Theorem: `POLY_DIFF`
- Theorem: `REAL_ARITH`

### Name of formal statement
DIFF_ADD_CONST_COMMUTE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For any function `f` from real to real, any real numbers `a` and `l`, and any real number `x`, if `f` is differentiable with derivative `l` at `x + a`, then the function `g` defined as `g(x) = f(x + a)` is differentiable with derivative `l` at `x`.

### Informal sketch
- Specialize `DIFF_X` and `DIFF_CONST` and combine them.
- Apply BETA_RULE.
- Rewrite using `REAL_ARITH \`&1 + &0 = &1\``.
- Specialize `DIFF_CHAIN`.
- Rewrite using `REAL_ARITH \`! x.(&1) * x = x /\ x * (&1) = x\`` and apply BETA_RULE
- Simplify & generalize the result.

### Mathematical insight
This theorem states that the derivative of a shifted function `f(x+a)` is equal to the derivative of `f` evaluated at `x+a`. This basically says that differentiation is translation invariant.

### Dependencies
- Theorem: `DIFF_X`
- Theorem: `DIFF_CONST`
- Theorem: `DIFF_ADD`
- Theorem: `DIFF_CHAIN`

### Name of formal statement
POLY_DIFF_ADD_CONST_COMMUTE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For all polynomials `p1` and `p2`, and for any real number `a`, if for all real numbers `x`, `poly p2 x = poly p1 (x - a)`, then for all real numbers `x`, `poly (poly_diff p2) x = poly (poly_diff p1) (x - a)`.

### Informal sketch
- Specialize `DIFF_ADD_CONST_COMMUTE`.
- Rewrite using `REAL_ARITH \`w + --v = w - v\`` and apply `BETA_RULE`.
- Specialize `POLY_DIFF`.
- Use the specialized lemma to construct the proof by rewriting using the assumption `!x.poly p2 x = poly p1 (x - a)`.
- Specialize `POLY_DIFF` again.
- Apply `DIFF_UNIQ`.

### Mathematical insight
If a polynomial `p2` is a shifted version of a polynomial `p1` (shifted by `a`), then the derivative of `p2` is the same shifted version of the derivative of `p1`. This is consistent with the translation invariance of differentiation.

### Dependencies
- Theorem: `DIFF_ADD_CONST_COMMUTE`
- Theorem: `POLY_DIFF`
- Theorem: `DIFF_UNIQ`

### Name of formal statement
HARD_WON

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For all polynomials `p1` and `p2`, all real numbers `a`, and any natural number `n`, if for all real numbers `x`, `poly p2 x = poly p1 (x - a)`, then for all real numbers `x`, the function mapping `x` to `poly (poly_diff_iter p2 n) x` is equal to the function mapping `x` to `poly (poly_diff_iter p1 n) (x - a)`.

### Informal sketch
- Specialize with `POLY_DIFF_ADD_CONST_COMMUTE`.
- Perform induction on `n`.
    - Base case: Use `Pm_lemma1.PDI_DEF` to simplify the goal.
    - Inductive step: Rewrite using `Pm_lemma1.PDI_DEF`, discharge assumptions, rewrite using function equality, and apply the specialized `POLY_DIFF_ADD_CONST_COMMUTE`.

### Mathematical insight
This theorem generalizes `POLY_DIFF_ADD_CONST_COMMUTE` to the `n`-th derivative. If a polynomial `p2` is a shifted version of a polynomial `p1`, then the `n`-th derivative of `p2` is the same shifted version of the `n`-th derivative of `p1`.

### Dependencies
- Theorem: `POLY_DIFF_ADD_CONST_COMMUTE`
- Definition: `Pm_lemma1.PDI_DEF`
- Theorem: `FUN_EQ_THM`

### Name of formal statement
POLY_SHIFT_DEF

### Type of the formal statement
new_recursive_definition

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
The function `poly_shift`, which takes a list of reals (representing a polynomial) and a real number `a` as arguments, is defined recursively as follows:
- `poly_shift [] a = []`
- `poly_shift (CONS c t) a = (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a))`
   where `++` is list concatenation and `##` is scalar multiplication of a list by a real number.

### Informal sketch
This is a recursive definition of a function `poly_shift`. The base case handles the empty list (the zero polynomial). The recursive case expresses the polynomial shift in terms of list operations (cons, concatenation, scalar multiplication).

### Mathematical insight
This definition provides a way to compute the coefficients of the polynomial `p(x+a)` given the coefficients of `p(x)` and the shift amount `a`. This is a key component for Taylor series expansion.

### Dependencies
- `list_RECURSION` (HOL Light's standard list recursion principle)

### Porting notes (optional)
In other proof assistants, ensure that the definition is accepted by the system's termination checker.

### Name of formal statement
POLY_SHIFT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For any polynomial `p`, any real number `a` and any real number `x`,  `poly p (x + a)` is equal to `poly (poly_shift p a) x`.

### Informal sketch
- Performs list induction.
  - Inductive Hypothesis: `! a x . poly t (x + a) = poly (poly_shift t a ) x`
  - Base Case: Simplify using `POLY_SHIFT_DEF` and `poly`.
  - Inductive Step: Rewrite using `POLY_SHIFT_DEF`, `POLY_ADD`, `POLY_CMUL`, `poly` and the Inductive Hypothesis. Then use `REAL_ARITH_TAC`.

### Mathematical insight
This result confirms that `poly_shift` correctly implements the polynomial shift operation.  That is, evaluating the original polynomial `p` at `x+a` gives the same result as evaluating `poly_shift p a` at `x`.

### Dependencies
- Definition: `POLY_SHIFT_DEF`
- Theorem: `POLY_ADD`
- Theorem: `POLY_CMUL`
- Theorem: `poly`

### Name of formal statement
POLY_SHIFT_LENGTH

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For any polynomial `p` and any real number `a`, the length of the list representing the shifted polynomial `poly_shift p a` is equal to the length of the list representing the original polynomial `p`.

### Informal sketch
- Performs list induction.
 - Base Case: Simplify using `POLY_SHIFT_DEF`.
 - Inductive Step: Simplify using `POLY_SHIFT_DEF`, `LENGTH`, `POLY_CMUL_LENGTH`, `POLY_ADD_LENGTH`, and arithmetic simplification.

### Mathematical insight
This lemma establishes that shifting a polynomial (via `poly_shift`) does not change its degree (which is one less than the length of the coefficient list).

### Dependencies
- Definition: `POLY_SHIFT_DEF`
- Theorem: `LENGTH`
- Theorem: `POLY_CMUL_LENGTH`
- Theorem: `POLY_ADD_LENGTH`
- Arithmetic rules

### Name of formal statement
POLY_TAYLOR

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For all polynomials `p`, and any real numbers `x` and `a`, `poly p x` is equal to the sum from `m = 0` to `LENGTH p` of `(poly (poly_diff_iter p m) a)/ (FACT m) * ((x - a) pow m)`.

### Informal sketch
- Specialize `POLY_MCLAURIN`.
- Specialize `HARD_WON`.
- Use `POLY_SHIFT` to rewrite the expression, then simplify using real arithmetic to express `x` as `(x+a) - a`.

### Mathematical insight
This is the Taylor expansion of a polynomial `p` around the point `a`. It expresses the value of `p(x)` in terms of the derivatives of `p` evaluated at `a`. The `poly_diff_iter p m` term represents the `m`-th derivative, evaluated using the term `a`.

### Dependencies
- Theorem: `POLY_MCLAURIN`
- Theorem: `HARD_WON`
- Theorem: `POLY_SHIFT`
- Theorem: `POLY_SHIFT_LENGTH`

### Name of formal statement
PLANETMATH_LEMMA_2_A

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For any polynomial `p` and for any real numbers `a` and `x`, `poly p x` is equal to the result of applying the function `\s . psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m)))` to the function `\m.(x - a) pow m`.

### Informal sketch
- Apply `BETA_TAC` and then `MATCH_ACCEPT_TAC` with `POLY_TAYLOR`. Essentially applies beta reduction to the right-hand side of the equality and then uses the POLY_TAYLOR theorem to prove.

### Mathematical insight
This is a restatement of `POLY_TAYLOR`, presented in a slightly different form using a lambda abstraction. It prepares the way to work with particular summations and applications of the Taylor series.

### Dependencies
- Theorem: `POLY_TAYLOR`

### Name of formal statement
ITERATE_SUC_REC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let POLY_MCLAURIN =  PROVE(
    `! p x. poly p x =
            psum (0, LENGTH p) (\m.poly (poly_diff_iter p m) (&0) / &(FACT m) * x pow m)`,
    let lem002 = SPECL [`poly p`;`\n.poly (poly_diff_iter p n)`] MCLAURIN_ALL_LE in
    let lem003 = SIMP_RULE [Pm_lemma1.PDI_DEF;POLY_DIFF] lem002 in
    let lem004 = REWRITE_RULE [ETA_CONV `(\x.poly l x)`] POLY_DIFF in
    let lem005 = MATCH_MP lem003 (GEN `m:num` (SPECL [`poly_diff_iter p m`] lem004)) in
    let lem007 = SPECL [`x:real`;`LENGTH (p:(real)list)`] lem005 in
    let lem008 = ONCE_REWRITE_RULE [Pm_lemma1.PDI_LENGTH_NIL] lem007 in
    let lem009 = ONCE_REWRITE_RULE [poly] lem008 in
    let lem010 = SIMP_RULE [REAL_ARITH `!x. ((&0)/x) = &0`] lem009 in
    let lem011 = SIMP_RULE [REAL_MUL_LZERO;REAL_ADD_RID] lem010 in
    let lem012 = PROVE(`(? t . (A t) /\ B) ==> B`, MESON_TAC []) in
    ACCEPT_TAC (GEN_ALL (MATCH_MP lem012 lem011))
)
let DIFF_ADD_CONST_COMMUTE = PROVE(
    `!f a l x . (f diffl l) (x + a) ==> ((\x. f (x + a)) diffl l) x`,
    let lem01 = CONJ (SPEC_ALL DIFF_X) (SPECL [`a:real`;`x:real`] DIFF_CONST) in
    let lem02 = BETA_RULE (MATCH_MP DIFF_ADD lem01) in
    let lem03 = ONCE_REWRITE_RULE [REAL_ARITH `&1 + &0 = &1`] lem02 in
    let lem04 = SPECL [`f:real->real`;`\(x:real).((x + a)):real`;`l:real`;`&1`] DIFF_CHAIN  in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lem05 = ONCE_REWRITE_RULE [MUL_ONE] (BETA_RULE lem04) in
    let lem06 = GEN_ALL (SIMP_RULE [lem03] lem05) in
    ACCEPT_TAC lem06
)
let POLY_DIFF_ADD_CONST_COMMUTE = PROVE(
    `! p1 p2 a.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> (!x . ((poly (poly_diff p2) x) = (poly (poly_diff p1) (x-a))))`,
    let lem01 = SPECL
                  [`\x.poly p1 x`;`-- a:real`;`l:real`;`x:real`]
                  DIFF_ADD_CONST_COMMUTE in
    let lem02 = ONCE_REWRITE_RULE [REAL_ARITH `w + --v = w - v`] (BETA_RULE lem01) in
    let lem03 = SPECL [`p1:(real)list`;`(x:real) -a`] POLY_DIFF in
    let lem04 = MATCH_MP lem02 lem03 in
    let lem05 = ASSUME `!x.poly p2 x = poly p1 (x - a)` in
    let lem06 = ONCE_REWRITE_RULE [GSYM lem05] lem04 in
    let lem07 = SPECL [`p2:(real)list`;`x:real`] POLY_DIFF in
    let lem08 = MATCH_MP DIFF_UNIQ (CONJ lem07 lem06)  in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem08)
)

let HARD_WON = PROVE(
    `! p1 p2 a n.(!x.(poly p2 x) = (poly p1 (x-a)))
            ==> ((\x.poly (poly_diff_iter p2 n) x) = (\x.(poly (poly_diff_iter p1 n) (x - a)))) `,
    let lem = SPECL [`poly_diff_iter p1 n`;`poly_diff_iter p2 n`;`a:real`] POLY_DIFF_ADD_CONST_COMMUTE in
    let tm = `(!x . poly p2 x = poly p1 (x -a )) ==>
                   (\x.poly (poly_diff_iter p2 n) x) = (\x. poly (poly_diff_iter p1 n) (x - a))` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THEN
    (INDUCT_TAC) THENL
    [ SIMP_TAC [Pm_lemma1.PDI_DEF] ;
      STRIP_TAC THEN (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (UNDISCH_TAC tm) THEN
      (ASM_REWRITE_TAC[FUN_EQ_THM]) THEN (ACCEPT_TAC lem)
    ]
)
(* if f:real->real is a function, let us call the function g x = f (x+a),
 * where a is a constant, a "shifting" of f by a.  if f is defined by a poly,
 * i.e. a (real)list, then (poly_shift f a) is the (real)list defining
 * the shifting of f by a.
 *)
let POLY_SHIFT_DEF = new_recursive_definition list_RECURSION
               `   (poly_shift [] a = [])
                /\ (poly_shift (CONS c t) a =
                   (CONS c (poly_shift t a)) ++ (a ## (poly_shift t a)))`

(* POLY_SHIFT simply says that poly_shift does what is supposed to do
 *)
let POLY_SHIFT = PROVE(
    `! p a x .(poly p (x + a)) = (poly (poly_shift p a) x)`,
    let lem01 = ASSUME `! a x . poly  t (x + a) = poly (poly_shift t a ) x` in
    LIST_INDUCT_TAC THENL
    [
     (ONCE_REWRITE_TAC [POLY_SHIFT_DEF;poly]) THEN (SIMP_TAC [poly]);
     (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [POLY_SHIFT_DEF]) THEN
     (ONCE_REWRITE_TAC [POLY_ADD]) THEN (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
     (ONCE_REWRITE_TAC [poly;GSYM lem01]) THEN
     (ONCE_REWRITE_TAC [GSYM lem01]) THEN (REAL_ARITH_TAC)
    ]
)
let POLY_SHIFT_LENGTH = PROVE(
    `! p a . (LENGTH (poly_shift p a)) = (LENGTH p)`,

    (LIST_INDUCT_TAC) THENL
    [ (SIMP_TAC [POLY_SHIFT_DEF]);
      (SIMP_TAC [POLY_SHIFT_DEF]) THEN
      (ASM_SIMP_TAC
        [LENGTH;POLY_CMUL_LENGTH;POLY_ADD_LENGTH;
         ARITH_RULE `MAX (x:num) y = if (x > y) then x else y`;
         ARITH_RULE `! n. SUC n >n`])
    ]
)
let POLY_TAYLOR = PROVE(
    `! p x a. poly p x =
              psum (0,LENGTH p) (\m.poly (poly_diff_iter p m) a/ &(FACT m) * (x - a) pow m)`,
    let lem01 = SPEC `poly_shift p a` POLY_MCLAURIN in
    let lem02 = SPECL [`p:(real)list`;`poly_shift p a`;`-- a:real`;`n:num`] HARD_WON in
    let lem03 = GSYM ( SPECL [`p:(real)list`;`a:real`] POLY_SHIFT) in
    let lem04 = SIMP_RULE [REAL_ARITH `a - --b = a + b`] lem02 in
    let lem05 = ONCE_REWRITE_RULE [ETA_AX] (MP lem04 lem03) in
    let lem06 = BETA_RULE (ONCE_REWRITE_RULE [lem05] lem01) in
    let lem07 = ONCE_REWRITE_RULE [REAL_ARITH `&0 + a = a`] lem06 in
    let lem08 = ONCE_REWRITE_RULE [GSYM POLY_SHIFT] lem07 in
    let lem09 = ONCE_REWRITE_RULE [POLY_SHIFT_LENGTH] lem08 in
    let lem10 = RATOR_CONV (ONCE_REWRITE_CONV [REAL_ARITH `(x:real) = (x + a) - a`]) `x pow m` in
    let lem11 = ONCE_REWRITE_RULE [lem10] lem09 in
    let lem12 = SPEC `(x - a):real` lem11 in
    let lem13 = ONCE_REWRITE_RULE [REAL_ARITH `(x:real) - a + a = x`] lem12 in
    ACCEPT_TAC (GEN_ALL lem13 )
)
let PLANETMATH_LEMMA_2_A = PROVE(
    `! p a x . poly p x =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m.(x - a) pow m))`,
    BETA_TAC THEN (MATCH_ACCEPT_TAC POLY_TAYLOR)
)
let ITERATE_SUC_REC = PROVE(
    `!(op:D -> D -> D) m n (f:num -> D) .
              monoidal op ==>
              (m <= SUC n) ==>
              iterate op (m..(SUC n)) f
               = op (f (SUC n)) (iterate op (m..n) f)`,
    let lem0 = UNDISCH_ALL (SPEC_ALL (GSYM NUMSEG_REC)) in
    let lem1 = ISPEC `op:D -> D -> D` ITERATE_CLAUSES_GEN in
    let lem2 = CONJUNCT2 (UNDISCH lem1) in
    let lem3 = ISPECL [`f:(num -> D)`;`SUC n`;`m..n`] lem2 in
    let lem4 = SIMP_RULE [] (DISCH_ALL lem3) in
    let lem50 = PROVE(
        `!m n. ~((SUC n) IN (m..n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [IN_NUMSEG]) THEN ARITH_TAC) in
    let lem5 = SIMP_RULE [lem50;FINITE_SUPPORT;FINITE_NUMSEG] lem4 in
    let lem6 = ADD_ASSUM `m <= SUC n` lem5 in
    let lem7 = ONCE_REWRITE_RULE [lem0] lem6 in
    SIMP_TAC [lem7]
);;
```
### Informal statement
For any binary operation `op` from `D` to `D` to `D`, any natural numbers `m` and `n`, and any function `f` from natural numbers to `D`, if `op` is monoidal, then if `m <= SUC n`, then `iterate op (m..(SUC n)) f = op (f (SUC n)) (iterate op (m..n) f)`.

### Informal sketch
- Un-discharge all assumptions and specialize `NUMSEG_REC`.
- Instantiate ITERATE_CLAUSES_GEN.
- Extract the second conjunct and fully discharge it. The application of DISCH_ALL moves all assumptions to the assumptions list.
- Simplify using the fact that `~((SUC n) IN (m..n))` and finiteness properties.
- Add the assumption `m <= SUC n` and simplify.

### Mathematical insight
This theorem provides a recursive decomposition of the `iterate` function (a generalization of summation/product) when applied to a segment of natural numbers ending at a successor. It effectively separates the last element of the segment from the rest. The monoidal property ensures the associativity required for the iteration to be well-defined.

### Dependencies
- Theorem: `NUMSEG_REC`
- Theorem: `ITERATE_CLAUSES_GEN`
- Theorem: `FINITE_SUPPORT`
- Theorem: `FINITE_NUMSEG`


---

## ITERATE_POLY_ADD_PRE_REC

### Name of formal statement
ITERATE_POLY_ADD_PRE_REC

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ITERATE_POLY_ADD_PRE_REC = PROVE(
    `!f n . n > 0
        ==> iterate (++) (0..n) f = (f n) ++ (iterate (++) (0..n-1) f)`,
    MESON_TAC [ITERATE_CLAUSES_NUMSEG; MONOIDAL_POLY_ADD; POLY_ADD_SYM;
               ARITH_RULE `0 <= x`; ARITH_RULE `n > 0 ==> n = SUC (n - 1)`]
);;
```
### Informal statement
For all functions `f` and natural numbers `n`, if `n` is greater than 0, then the iteration of the function `(++)` (list concatenation) over the range of natural numbers from 0 to `n` applied to `f` is equal to the concatenation of `(f n)` with the iteration of the function `(++)` over the range of natural numbers from 0 to `n-1` applied to `f`.

### Informal sketch
The proof proceeds by induction on `n`.
- Base case: `n = 1`. Here `iterate (++) (0..1) f` reduces to `(f 1) ++ (f 0)`, which is same as `(f n) ++ (iterate (++) (0..n-1) f)` when `n = 1`.
- Inductive step: Assume `iterate (++) (0..n) f = (f n) ++ (iterate (++) (0..n-1) f)` for some `n > 0`. We need to show that `iterate (++) (0..(n+1)) f = (f (n+1)) ++ (iterate (++) (0..n) f)`. This leverages the decomposition of the range `0..(n+1)` into `(0..n)` concatenated with `[n+1]`.

The proof utilizes `MESON_TAC` to automatically resolve the theorem using the following facts:
- `ITERATE_CLAUSES_NUMSEG`: Rules about how the `iterate` function interacts with indexed lists.
- `MONOIDAL_POLY_ADD`: Properties of concatenation.
- `POLY_ADD_SYM`: Symmetry property regarding concatenation and addition.
- `ARITH_RULE \`0 <= x\``: Elementary arithmetic facts.
- `ARITH_RULE \`n > 0 ==> n = SUC (n - 1)\``: Expresses the fact that n is the successor of n-1, if n > 0.

### Mathematical insight
This theorem provides a recursive decomposition of the iteration of (++) over a range. It is a common pattern when dealing with manipulations of sums represented as iterated concatenations. This is especially useful in contexts where the result of the iteration is built up one element at a time and a recursive definition is convenient.

### Dependencies
- `ITERATE_CLAUSES_NUMSEG`
- `MONOIDAL_POLY_ADD`
- `POLY_ADD_SYM`
- `ARITH_RULE \`0 <= x\``
- `ARITH_RULE \`n > 0 ==> n = SUC (n - 1)\``


---

## PSUM_ITERATE

### Name of formal statement
PSUM_ITERATE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
);;
```

### Informal statement
For all natural numbers `n` and `m`, and for all functions `f` from natural numbers to real numbers, the partial sum from `m` to `n` of `f` is equal to the iteration of addition over the numbered set from `m` to `(n + m) - 1` applied to `f` if `n` is greater than 0, and is equal to 0 otherwise.

### Informal sketch
The proof proceeds by induction on `n`.

- Base case: `n = 0`.
  The goal simplifies, using the definition of `psum` and the arithmetic fact that `~(0 > 0)`, to showing that `&0 = if (0 > 0) then ... else &0`, which is trivial.

- Inductive step: Assume the theorem holds for `n`. We must prove it for `SUC n`.
  - The goal is `psum (m, SUC n) f = if (SUC n > 0) then (iterate (+) (m..((SUC n + m) - 1)) f) else &0`.
  - Simplify using `(SUC n) > 0`.
  - Perform case split on `n + m = 0`.
    - Case 1: `n + m = 0`. In this case, we must show that `f m = iterate (+) (m..m) f`. By simplification and rewriting using the fact that `n + m = 0 ==> n = 0` and several arithmetic simplification rules, this follows immediately.
    - Case 2: `~(n + m = 0)`.  First, rewrite `psum` using its definition.  Then, rewrite the `iterate` term, splitting off the last element using `iterate (+) (m..SUC ((n + m) - 1)) f = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`. Then, perform a case split on `n = 0`.  Using the inductive hypothesis and various arithmetic simplifications, the goal is proved.

### Mathematical insight
This theorem connects the `psum` function, which defines a partial sum, to the more general `iterate` function, which applies an operator repeatedly over a range. This allows expressing partial sums in terms of iteration.

### Dependencies
- `psum` (Definition of partial sum)
- `iterate` (Definition of iterate)
- `MONOIDAL_REAL_ADD` (Monoidal property of real addition)
- `NUMSEG_EMPTY`
- `NUMSEG_SING`
- `ITERATE_CLAUSES_NUMSEG`
- `ITERATE_CLAUSES_GEN`
- `ADD_CLAUSES`
- `REAL_ADD_LID`
- `REAL_ADD_RID`
- `REAL_ADD_SYM`
- `NEUTRAL_REAL_ADD`
- `ADD_SYM`


---

## FACT_DIV_RCANCELS

### Name of formal statement
FACT_DIV_RCANCELS

### Type of the formal statement
theorem

### Formal Content
```ocaml
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)
```
### Informal statement
For any natural number `n` and any real number `x`, `x / (real(FACT n)) * (real(FACT n)) = x`.

### Informal sketch
The proof uses the `MESON_TAC` tactic with a collection of supporting lemmas. The key lemmas are:
- `!x. &0 < x ==> ~(x = &0)` from `REAL_ARITH` which asserts that if a real number `x` is greater than zero, it's not equal to zero.
- `REAL_DIV_RMUL`, which likely deals with the properties of real division and multiplication.  It's being used to cancel the `&(FACT n)` term.
- `FACT_LT`, likely a theorem ensuring that the factorial is always positive for natural numbers, so `&(FACT n) > &0`.
- `REAL_OF_NUM_LT`, which is likely used to convert the natural number `n` to a real number and preserve the less-than relationship.

The proof establishes that dividing `x` by the real representation of `FACT n` and then multiplying by the real representation of `FACT n` gives `x` back.
The condition `&(FACT n)` not equal to zero is crucial here, which follows from `FACT_LT` which states `!n. 0 < FACT n`.

### Mathematical insight
This theorem simply states that multiplication and division are inverse operations (under the condition that we don't divide by zero). Since the factorial function always results in a positive number for natural numbers (and thus its real representation is also positive), we can cancel out the `&(FACT n)` term. This lemma appears to be useful for simplifying expressions that involve factorials and polynomials.

### Dependencies
- `REAL_ARITH`
- `REAL_DIV_RMUL`
- `FACT_LT`
- `REAL_OF_NUM_LT`

---
### Name of formal statement
PLANETMATH_LEMMA_2_B

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_LEMMA_2_B = PROVE(
    `! p (x:real) a . poly (SOD p) a =
       ((\s .psum (0,LENGTH p) ((\m.poly (poly_diff_iter p m) a/ &(FACT m) * (s m))))
         (\m. &(FACT m)))`,
    let lem6 = ISPECL [`(\i.poly_diff_iter p i)`;`LENGTH (p:(real)list)`]
                ITERATE_POLY_ADD_PRE_REC in
    let lem7 = UNDISCH lem6 in
    let lem8 = UNDISCH (ARITH_RULE `~(LENGTH (p:(real)list) > 0) ==> (LENGTH p = 0)`) in
    let lem9 = ONCE_REWRITE_RULE [LENGTH_EQ_NIL] lem8 in
    BETA_TAC THEN (REPEAT STRIP_TAC) THEN (ONCE_REWRITE_TAC [FACT_DIV_RCANCELS]) THEN
    (ONCE_REWRITE_TAC [PSUM_ITERATE]) THEN (ASM_CASES_TAC `LENGTH (p:(real)list) > 0`) THENL
    [ (ASM_SIMP_TAC [Pm_lemma1.SOD;Pm_lemma1.SODN;ITERATE_RADD_POLYADD;ARITH_RULE `x + 0 = x`]) THEN
      (AP_THM_TAC) THEN (AP_TERM_TAC) THEN (SIMP_TAC [lem7;Pm_lemma1.PDI_LENGTH_NIL;POLY_ADD_CLAUSES]);
      (ASM_SIMP_TAC []) THEN
      (SIMP_TAC
      [lem9;poly;Pm_lemma1.SOD;Pm_lemma1.SODN;NUMSEG_SING;MONOIDAL_POLY_ADD;ITERATE_SING;LENGTH;Pm_lemma1.PDI_DEF])
    ]
)
```
### Informal statement
For any polynomial `p`, any real number `x`, and any real number `a`, `poly (SOD p) a` is equal to the sum from 0 to `LENGTH p` of `poly (poly_diff_iter p m) a / real(FACT m) * real(FACT m)`, where `SOD p` is some transformation of the polynomial p, `poly_diff_iter p m` is the `m`-th derivative of the polynomial `p`, `LENGTH p` is the number of coefficients of `p`, and `FACT m` is the factorial of `m`. The summation is effectively a psum expression over the length of the polynomial `p`.

### Informal sketch
The proof proceeds as follows:
- The proof first introduces some lemmas related to `ITERATE_POLY_ADD_PRE_REC` using `ISPECL` and `UNDISCH`. It introduces `lem6`, `lem7`, `lem8` and `lem9` to help rewrite the goal into a simpler form. `LENGTH_EQ_NIL` theorem is used in `lem9`.
- It then applies `BETA_TAC`, `REPEAT STRIP_TAC`, and `ONCE_REWRITE_TAC` with `FACT_DIV_RCANCELS`, and `PSUM_ITERATE`.
- The proof splits into two cases based on whether `LENGTH p > 0` using `ASM_CASES_TAC`.
  - Case 1: `LENGTH p > 0`. Uses simplification with `Pm_lemma1.SOD`, `Pm_lemma1.SODN`, `ITERATE_RADD_POLYADD`, `ARITH_RULE x + 0 = x`. It then applies `AP_THM_TAC`, `AP_TERM_TAC` and `SIMP_TAC` with intermediate lemmas, `Pm_lemma1.PDI_LENGTH_NIL` and `POLY_ADD_CLAUSES` to get the result.
  - Case 2: `~(LENGTH p > 0)`. Uses simplification with lemmas including `LENGTH_EQ_NIL`, `poly`, `Pm_lemma1.SOD`, `Pm_lemma1.SODN`, `NUMSEG_SING`, `MONOIDAL_POLY_ADD`, `ITERATE_SING`, `LENGTH`, `Pm_lemma1.PDI_DEF` for this case.

The identity `poly (SOD p) a = (\s. psum (0,LENGTH p) (\m. poly (poly_diff_iter p m) a / &(FACT m) * (s m))) (\m. &(FACT m))` appears related to a form of Taylor expansion, where `SOD` is the sum of derivatives. The proof hinges on simplifying the psum expression and then doing case analysis on the length of the polynomial being positive or zero.

### Mathematical insight
This theorem relates a polynomial `p` (transformed by some operation `SOD`) to a summation involving its iterated derivatives. `poly_diff_iter p m` represents the m-th derivative of `p`, and the summation appears to be a variant of Taylor expansion. The equality effectively states that the polynomial's value can be recovered from the values of its derivatives at a point, which is a defining characteristic of Taylor series.

### Dependencies
- `FACT_DIV_RCANCELS`
- `PSUM_ITERATE`
- `Pm_lemma1.SOD`
- `Pm_lemma1.SODN`
- `ITERATE_RADD_POLYADD`
- `Pm_lemma1.PDI_LENGTH_NIL`
- `POLY_ADD_CLAUSES`
- `LENGTH_EQ_NIL`
- `poly`
- `NUMSEG_SING`
- `MONOIDAL_POLY_ADD`
- `ITERATE_SING`
- `LENGTH`
- `Pm_lemma1.PDI_DEF`

### Porting notes (optional)
The main challenges will likely relate to porting the polynomial representation, differentiation (`poly_diff_iter`), and series summation (`psum`). The `SOD` operation is also an important dependency that must be defined. The automation relies heavily on simplification using various lemmas about lists, polynomials and factorials. The case split on `LENGTH p > 0 ` suggests that different representations and algorithmic approaches may be required depending on whether empty or zero-length polynomials are allowed.


---

## N_IS_INT

### Name of formal statement
N_IS_INT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
```

### Informal statement
For all natural numbers `n`, the real number representation of `n` is an integer.

### Informal sketch
The proof relies on the theorem `is_int`. The tactic `MESON_TAC [is_int]` applies this existing theorem directly to prove the goal.

### Mathematical insight
This theorem states a fundamental property: that natural numbers, when viewed as real numbers via the embedding `&`, are integers. This is a basic fact about the relationship between natural numbers, integers, and real numbers, and the construction of the reals from the naturals.

### Dependencies
- Theorems: `is_int`

---
### Name of formal statement
NEG_N_IS_INT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
);;
```

### Informal statement
For all natural numbers `n`, the negation of the real number representation of `n` is an integer.

### Informal sketch
The proof relies on the theorem `is_int`. The tactic `MESON_TAC [is_int]` applies this existing theorem directly to prove the goal. This works because negating an integer results in another integer, and `is_int` likely encompasses this fact.

### Mathematical insight
This theorem states that the negation of a natural number (when coerced to a real number) is an integer.  This relies on the fact that the integers are closed under negation.

### Dependencies
- Theorems: `is_int`


---

## PLANETMATH_EQN_3

### Name of formal statement
PLANETMATH_EQN_3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all functions f, if 0 is less than `nu`, then `poly (SOD f) (&0) * exp (&nu)` equals `poly (SOD f) (&nu) + &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`.

### Informal sketch
The proof uses `Pm_lemma1.PLANETMATH_LEMMA_1` from the file `Pm_lemma1.ml`. It involves specializing `REAL_OF_NUM_LT` with `0` and `nu` and then using `ONCE_REWRITE_RULE` with the specialized `REAL_OF_NUM_LT` on `Pm_lemma1.PLANETMATH_LEMMA_1` specialized on `&nu`.

### Mathematical insight
This theorem establishes a relationship between the polynomial of the derivative of a function `f` evaluated at 0, the exponential function, and the polynomial of `f` evaluated at `xi (&nu) f`. It is one of the key equations leading to PLANETMATH_EQN_4.

### Dependencies
- Theorems:
  - `Pm_lemma1.PLANETMATH_LEMMA_1`
- Definitions:
  - `SOD` (likely the derivative function)
  - `poly` (polynomial evaluation)
  - `exp` (exponential function)
  - `xi` (likely a function related to the roots of the polynomial)

### Name of formal statement
LHS

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
`LHS c f` is defined as the sum from 0 to `PRE (LENGTH c)` of `(EL i c) * (poly (SOD f) (&i))` over the index `i`.

### Informal sketch
This is a definition of a sum, where the terms are the elements of the list `c` at index `i` multiplied by the polynomial of derivative of the function `f`, evaluated at `i`.

### Mathematical insight
The `LHS` definition computes a weighted sum involving the coefficients of the list `c` and the polynomial `poly (SOD f)` evaluated at integer values. This seems to be related to a Taylor series expansion.

### Dependencies
- Definitions:
  - `sum` (summation over a range)
  - `PRE` (predecessor function)
  - `LENGTH` (length of a list)
  - `EL` (element at index in a list)
  - `poly` (polynomial evaluation)
  - `SOD` (derivative function)

### Name of formal statement
RHS

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
`RHS c f` is defined as the negative of the sum from 1 to `PRE (LENGTH c)` of `(&i) * (EL i c) * (exp ((&i) - (xi (&i) f))) * (poly f (xi (&i) f))` over the index `i`.

### Informal sketch
This defines a sum with terms that depend on the index `i`, elements from the list `c`, the exponential function, and the polynomial `poly f` evaluated at `xi (&i) f`.

### Mathematical insight
The `RHS` definition calculates a weighted sum, where the weights involve the coefficients from the list `c`, exponential functions, and the polynomial of `f` evaluated at `xi (&i) f`. It appears to be related to the terms that arise when computing Taylor expansions and comparing them against a function.

### Dependencies
- Definitions:
  - `sum` (summation over a range)
  - `PRE` (predecessor function)
  - `LENGTH` (length of a list)
  - `EL` (element at index in a list)
  - `exp` (exponential function)
  - `poly` (polynomial evaluation)
  - `xi` (likely a function related to the roots of the polynomial)

### Name of formal statement
E_POW_N

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `n`, `(exp (real_of_num 1))` raised to the power of `n` is equal to `exp(&n)`.

### Informal sketch
The proof uses simplification with the theorem `GSYM REAL_EXP_N` and `REAL_MUL_RID`.

### Mathematical insight
This theorem states a basic property of the exponential function, connecting exponentiation of the constant `e` with the exponential of the number `n`, where `e` is the base of the natural logarithm and `exp` is the exponential function.

### Dependencies
- Theorems:
  - `REAL_EXP_N`
  - `REAL_MUL_RID`
- Definitions:
  - `exp`
  - `real_of_num`
  - `pow`

### Name of formal statement
NO_CONST_TERM_POLY_ROOT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, if `x` is not equal to 0, the head of `p` is 0, `poly p x` equals 0, and `p` is not the empty list, then `poly (TL p) x` equals 0.

### Informal sketch
Proof is by induction on lists, simplifying with `HD`, `TL`, `NOT_CONS_NIL`, and `poly`, then using `MESON_TAC` with a real arithmetic result and `REAL_ENTIRE`.

### Mathematical insight
If a polynomial `p` has no constant term (i.e., its leading coefficient is 0) and `x` is a non-zero root of `p`, then `x` is also a root of the polynomial obtained by removing the constant term of `p`.

### Dependencies
- Theorems:
  - `REAL_ARITH`
  - `REAL_ENTIRE`
- Definitions:
  - `HD` (head of a list)
  - `TL` (tail of a list)
  - `poly` (polynomial evaluation)
  - `NOT_CONS_NIL`

### Name of formal statement
NEGATED_POLY_ROOT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, if `poly p x` equals 0, then `poly ((-- &1) ## p) x` equals 0.

### Informal sketch
The proof employs `MESON_TAC` with theorems `POLY_CMUL` and a real arithmetic result.

### Mathematical insight
If `x` is a root of a polynomial `p`, then `x` is also a root of the polynomial obtained by multiplying `p` by -1.

### Dependencies
- Theorems:
  - `POLY_CMUL`
  - `REAL_ARITH`
- Definitions:
  - `poly`

### Name of formal statement
POLY_NUKE

### Type of the formal statement
new_recursive_definition

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
`poly_nuk p` is defined recursively as follows:
- If `p` is the empty list, then `poly_nuk p` is the empty list.
- If `p` is a list `CONS c t`, then `poly_nuk p` is `poly_nuk t` if `c` is `&0`, and `CONS c t` otherwise.

### Informal sketch
This definition recursively removes leading zero coefficients from a polynomial represented as a list of coefficients until the list is empty or the first coefficient is non-zero.

### Mathematical insight
`poly_nuk` effectively "normalizes" a polynomial by removing any leading zero coefficients, such as changing [0, 0, 1, 2] to [1, 2].

### Dependencies
- None

### Name of formal statement
POLY_NUKE_ROOT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, if x is not equal to 0 and `poly p x` equals 0, then `poly (poly_nuk p) x` equals 0.

### Informal sketch
Proof is by list induction, simplifying with `POLY_NUKE`. If the head of the list is zero, use `NO_CONST_TERM_POLY_ROOT` to eliminate the head.

### Mathematical insight
If `x` is a non-zero root of a polynomial `p`, then `x` is also a root of the normalized polynomial `poly_nuk p`.

### Dependencies
- Theorems:
  - `HD`
  - `TL`
  - `POLY_NUKE`
  - `NOT_CONS_NIL`
  - `NO_CONST_TERM_POLY_ROOT`
- Definitions:
  - `poly`
  - `poly_nuk`

### Name of formal statement
POLY_NUKE_ZERO

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, `poly p` is equal to `poly []` if and only if `poly (poly_nuk p)` is equal to `poly []`.

### Informal sketch
Proof is by list induction and using `ASM_MESON_TAC` with `POLY_ZERO`, `ALL` and `POLY_NUKE`.

### Mathematical insight
A polynomial `p` represents the zero polynomial if and only if its normalized version `poly_nuk p` represents the zero polynomial.

### Dependencies
- Theorems:
  - `POLY_ZERO`
  - `ALL`
  - `POLY_NUKE`
- Definitions:
  - `poly`
  - `poly_nuk`

### Name of formal statement
POLY_CONST_NO_ROOTS

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `c`, if `poly [c]` is not equal to `poly []`, then `poly [c] x` is not equal to 0.

### Informal sketch
Proof by `MESON_TAC` using `poly`, `REAL_ENTIRE`, `POLY_ZERO`, `ALL`, and real arithmetic.

### Mathematical insight
A non-zero constant polynomial has no roots.

### Dependencies
- Theorems:
  - `poly`
  - `REAL_ENTIRE`
  - `POLY_ZERO`
  - `ALL`
  - `REAL_ARITH`
- Definitions:
  - `poly`

### Name of formal statement
LENGTH_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all lists `lst`, the length of `lst` is 1 if and only if there exists an `x` such that `lst` is equal to `[x]`.

### Informal sketch
Proof is by list induction and using `MESON_TAC` with `LENGTH`, an arithmetic rule, `NOT_CONS_NIL`, and `LENGTH_EQ_NIL`.

### Mathematical insight
A list has length 1 if and only if it consists of a single element.

### Dependencies
- Theorems:
  - `LENGTH`
  - `ARITH_RULE`
  - `NOT_CONS_NIL`
  - `LENGTH_EQ_NIL`

### Name of formal statement
SOUP_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, if `x` is not equal to 0, `poly p` is not equal to `poly []`, and `poly p x` equals 0, then the length of `poly_nuk p` is greater than 1.

### Informal sketch
The proof starts by rewriting with an arithmetic rule. The goal is split using `STRIP_TAC`. The first subgoal is proven using `LENGTH`, `LENGTH_EQ_NIL`, and `POLY_NUKE_ZERO`. The second subgoal utilizes `POLY_NUKE_ROOT`, `POLY_CONST_NO_ROOTS`, `LENGTH_1`, `LENGTH`, and `POLY_NUKE_ZERO`.

### Mathematical insight
If `x` is a non-zero root of a non-zero polynomial `p`, then the normalized polynomial `poly_nuk p` must have degree at least 1 (i.e., its list of coefficients will have length greater than 1).

### Dependencies
- Theorems:
  - `LENGTH`
  - `LENGTH_EQ_NIL`
  - `POLY_NUKE_ZERO`
  - `POLY_NUKE_ROOT`
  - `POLY_CONST_NO_ROOTS`
  - `LENGTH_1`
  - `POLY_NUKE`
- Definitions:
  - `poly`
  - `poly_nuk`

### Name of formal statement
POLY_NUKE_HD_NONZERO

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, if `poly p` is not equal to `poly []`, then the head of `poly_nuk p` is not equal to 0.

### Informal sketch
The proof proceeds by list induction and case splitting on whether the head of the list is equal to 0. It simplifies using rules for `HD`, `POLY_ZERO`, `ALL`, and `POLY_NUKE`.

### Mathematical insight
If a polynomial `p` is not the zero polynomial, then the leading coefficient of its normalized form `poly_nuk p` is non-zero.

### Dependencies
- Theorems:
  - `HD`
  - `POLY_ZERO`
  - `ALL`
  - `POLY_NUKE`
- Definitions:
  - `poly`
  - `poly_nuk`

### Name of formal statement
IS_INT_POLY_NUKE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p`, if all elements of `p` are integers, then all elements of `poly_nuk p` are integers.

### Informal sketch
Proof by list induction with `ASM_MESON_TAC` and theorems on `ALL`, `POLY_NUKE`, and `N_IS_INT`.

### Mathematical insight
If the coefficients of a polynomial `p` are all integers, then the coefficients of the normalized polynomial `poly_nuk p` are also all integers.

### Dependencies
- Theorems:
  - `ALL`
  - `POLY_NUKE`
  - `N_IS_INT`
- Definitions:
  - `poly_nuk`
  - `integer`

### Name of formal statement
POLY_X_NOT_POLY_NIL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
`poly [&0; &1]` is not equal to `poly []`.

### Informal sketch
The proof uses simplification with theorems `FUN_EQ_THM`, `POLY_X`, `poly`, and a tautology. It then uses existential introduction with `real_of_num 1` and real arithmetic.

### Mathematical insight
The polynomial `x` (represented as the list [0, 1]) is not the zero polynomial.

### Dependencies
- Theorems:
  - `FUN_EQ_THM`
  - `POLY_X`
- Definitions:
  - `poly`

### Name of formal statement
NOT_TRANSCENDENTAL_ZERO

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
0 is not transcendental.

### Informal sketch
The proof rewrites with the definitions of `transcendental` and `algebraic`. It then uses existential introduction with `[&0 ; &1]` and `MESON_TAC` along with `POLY_X`, `POLY_X_NOT_POLY_NIL`, `ALL`, and `N_IS_INT`.

### Mathematical insight
The number 0 is not transcendental, because it is the root of the polynomial `x` (or [0, 1] in list representation).

### Dependencies
- Theorems:
  - `POLY_X`
  - `POLY_X_NOT_POLY_NIL`
  - `ALL`
  - `N_IS_INT`
- Definitions:
  - `transcendental`
  - `algebraic`

### Name of formal statement
ALL_IS_INT_POLY_CMUL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `p` and `c`, if `c` is an integer and all elements of `p` are integers, then all elements of `c ## p` are integers.

### Informal sketch
Proof by list induction, simplifying with `poly_cmul`, `ALL`, and `INTEGER_MUL`.

### Mathematical insight
If a polynomial's coefficients are all integers, multiplying by a constant integer yields another polynomial whose coefficients are all integers.

### Dependencies
- Theorems:
  - `ALL`
  - `INTEGER_MUL`
- Definitions:
  - `poly_cmul`
  - `integer`

### Name of formal statement
TRANSCENDENTAL_MY_TRANSCENDENTAL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
For all `x`, `x` is transcendental if and only if `x` is not 0 and there does not exist a list `c` such that all elements of `c` are integers, the length of `c` is greater than 1, `poly c x` equals 0, and the head of `c` is greater than 0.

### Informal sketch
The proof rewrites with the definition of transcendental and algebraic. It uses a contrapositive tautology to reorganize the theorem. It considers the cases `x = &0` and `x != &0` separately. The implication from left to right is demonstrated using `NOT_TRANSCENDENTAL_ZERO`.
For the reverse direction, it considers witnesses based on the sign of the head of `poly_nuk p` utilizing `IS_INT_POLY_NUKE`, `ALL_IS_INT_POLY_CMUL`, `NEG_N_IS_INT`, `POLY_NUKE_HD_NONZERO`, `NEGATED_POLY_ROOT`, `SOUP_LEMMA`, `POLY_NUKE_ROOT`, `POLY_NUKE_ZERO`, `POLY_CMUL_HD` and real arithmetic.

### Mathematical insight
This theorem establishes the equivalence between Harrison's definition of a transcendental number and an alternative definition. It states that a number is transcendental if and only if it is non-zero and is not the root of any integer polynomial (with length > 1) with a positive leading coefficient. This equivalence allows the file to prove `E_TRANSCENDENTAL_EQUIV` without including the alternative definition of transcendental from the beginning.

### Dependencies
- Theorems:
  - `NOT_TRANSCENDENTAL_ZERO`
  - `IS_INT_POLY_NUKE`
  - `ALL_IS_INT_POLY_CMUL`
  - `NEG_N_IS_INT`
  - `POLY_NUKE_HD_NONZERO`
  - `NEGATED_POLY_ROOT`
  - `SOUP_LEMMA`
  - `POLY_NUKE_ROOT`
  - `POLY_NUKE_ZERO`
  - `POLY_CMUL_HD`
- Definitions
  - `transcendental`
  - `algebraic`
  - `poly`
  - `poly_nuk`

### Name of formal statement
E_TRANSCENDENTAL_EQUIV

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
`(exp (&1))` is transcendental if and only if there does not exist a list `c` such that all elements of `c` are integers, the length of `c` is greater than 1, `poly c (exp (&1))` equals 0, and the head of `c` is greater than 0.

### Informal sketch
Proof uses  `TRANSCENDENTAL_MY_TRANSCENDENTAL`, `REAL_EXP_POS_LT`, and real arithmetic to connect `transcendental (exp (&1))` with the equivalent statement using Harrison's transcendental predicate.

### Mathematical insight
This theorem directly uses the theorem `TRANSCENDENTAL_MY_TRANSCENDENTAL` to establish that `exp(1)`, or `e`, is transcendental if and only if it is not the root of any integer polynomial (with length > 1) that has a positive leading coefficient.

### Dependencies
- Theorems:
  - `TRANSCENDENTAL_MY_TRANSCENDENTAL`
  - `REAL_EXP_POS_LT`
  - `REAL_ARITH`
- Definitions:
  - `transcendental`
  - `poly`
  - `exp`

### Name of formal statement
PLANETMATH_EQN_4

### Type of the formal statement
theorem

### Formal Content
```ocaml
let PLANETMATH_EQN_3 = PROVE(
    `!f. 0 < nu
          ==> poly (SOD f) (&0) * exp (&nu) =
              poly (SOD f) (&nu) +
              &nu * exp (&nu - xi (&nu) f) * poly f (xi (&nu) f)`,
    let RW = SPECL [`0`;`nu:num`] REAL_OF_NUM_LT in
    ACCEPT_TAC (ONCE_REWRITE_RULE [RW] (SPEC `(&nu):real` Pm_lemma1.PLANETMATH_LEMMA_1))
)
(* the RHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let LHS = new_definition
        `LHS c f = sum (0..(PRE (LENGTH c))) (\i.(EL i c)*(poly (SOD f) (&i)))`

(* the LHS of PLANETMATH_EQN_4
 *  TBD: mentioned in paper
 *)
let RHS = new_definition
        `RHS  c f = -- sum (1..(PRE (LENGTH c)) )
                          (\i.  (&i)
                              * (EL i c)
                              * (exp ((&i) - (xi (&i) f)))
                              * (poly f (xi (&i) f))
                          )`

let E_POW_N = PROVE(
    `!n.(exp (real_of_num 1)) pow n = exp(&n)`,
    SIMP_TAC [GSYM REAL_EXP_N;REAL_MUL_RID])


(*  The proof was originally done with a slightly different transcendental
 *  predicate than found in Harrison's 100/liouville.ml it turns out the difference
 *  is that &0 satisfies my transcendental!  Thankfully, it is easy to show that
 *  e != 0, and hence the two notions of transcendence are equivalent for e.
 *  So that I could eliminate even brining my muddled definition of
 *  transcendental into the proof, this file ultimately proves
 *  E_TRANSCENDENTAL_EQUIV, which allows the main proof to only mention
 *  Harrison's transcendental predicate.
 *)

let NO_CONST_TERM_POLY_ROOT = PROVE(
    `!p . (~(x = &0) /\ ((HD p) = &0) /\ (poly p x = &0) /\ ~(p = []))
           ==> ((poly (TL p) x) = &0)`,
    LIST_INDUCT_TAC THEN
    (ASM_SIMP_TAC [HD;TL;NOT_CONS_NIL;poly]) THEN
    (MESON_TAC [REAL_ARITH `((&0):real) + x = x`;REAL_ENTIRE])
)

let NEGATED_POLY_ROOT = PROVE(
    `!p . (poly p x = &0) ==> (poly ((-- &1) ## p) x = &0)`,
    MESON_TAC [POLY_CMUL;REAL_ARITH `(-- &1) * ((&0):real) = &0`]
)

(*  changes a polynomial p to p/x^k, where k is the lowest power
 *  of x where p has a non-zero coefficient.  This amounts to
 *  just stripping off all leading zeros from the head of the list p.
 *)
let POLY_NUKE = new_recursive_definition list_RECURSION
               `   (poly_nuk [] = [])
                /\ (poly_nuk (CONS (c:real) t) =
                   (if (c = &0) then (poly_nuk t) else (CONS c t)))`

let POLY_NUKE_ROOT = PROVE(
    `!p . ((~(x = &0)) /\ (poly p x = &0)) ==> (poly (poly_nuk p) x = &0)`,
    LIST_INDUCT_TAC THENL
    [ SIMP_TAC[POLY_NUKE];
      (ASM_CASES_TAC `(h:real) = &0`) THEN
      (ASM_MESON_TAC [HD;TL;POLY_NUKE;NOT_CONS_NIL;NO_CONST_TERM_POLY_ROOT])
    ]
)
let POLY_NUKE_ZERO = PROVE(
    `!p . (poly p = poly []) <=> (poly (poly_nuk p) = poly [])`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [POLY_ZERO;ALL;POLY_NUKE])
)
let POLY_CONST_NO_ROOTS = PROVE(
    `! c.  ~(poly [c] = poly []) ==> ~(poly [c] x = &0)`,
    (MESON_TAC [poly;REAL_ENTIRE;POLY_ZERO;ALL;
                REAL_ARITH `(x:real) + &0 = x`;
                REAL_ARITH `(x:real) * &0 = &0`])
)
let LENGTH_1 = PROVE(
    `! lst . (LENGTH lst = 1) <=> (? x. lst = [x])`,
    LIST_INDUCT_TAC THEN
    (MESON_TAC [LENGTH;ARITH_RULE `SUC x = 1 <=> x = 0`;NOT_CONS_NIL;LENGTH_EQ_NIL])
)
let SOUP_LEMMA = PROVE(
    `!p . ~(x = &0) /\ ~(poly p = poly []) /\ (poly p x = &0)
            ==> LENGTH (poly_nuk p) > 1`,
    let l0 = ARITH_RULE `(~(n = 0) /\ ~(n = 1)) <=> n > 1` in
    let l1 = UNDISCH (UNDISCH (BRW1 (SPEC_ALL POLY_NUKE_ROOT))) in
    (ONCE_REWRITE_TAC [GSYM l0]) THEN (REPEAT STRIP_TAC) THENL
    [ (ASM_MESON_TAC [LENGTH;LENGTH_EQ_NIL;POLY_NUKE_ZERO]);
      (ASM_MESON_TAC [l1;POLY_CONST_NO_ROOTS;LENGTH_1;LENGTH;POLY_NUKE_ZERO]) ]
)

let POLY_NUKE_HD_NONZERO = PROVE(
    `!p . ~(poly p = poly []) ==> ~((HD (poly_nuk p)) = &0)`,
    LIST_INDUCT_TAC THEN (ASM_CASES_TAC `(h:real) = &0`) THEN
    (ASM_SIMP_TAC [HD;POLY_ZERO;ALL;POLY_NUKE])
)

let IS_INT_POLY_NUKE = PROVE(
    `!p . (ALL integer p) ==> (ALL integer (poly_nuk p))`,
    LIST_INDUCT_TAC THEN (ASM_MESON_TAC [ALL;POLY_NUKE;N_IS_INT])
)

let POLY_X_NOT_POLY_NIL = PROVE(
    `~(poly [&0;&1] = poly [])`,
    (SIMP_TAC [FUN_EQ_THM;POLY_X;poly;PROVE(`(~ ! x .P x) <=> (? x. ~ P x)`,MESON_TAC[])] )
    THEN (EXISTS_TAC `real_of_num 1`) THEN (REAL_ARITH_TAC)
)

let NOT_TRANSCENDENTAL_ZERO = PROVE(
      `~ (transcendental (&0))`,
      (REWRITE_TAC [transcendental;algebraic]) THEN
      (EXISTS_TAC `[&0 ; &1]:(real)list`) THEN
      (MESON_TAC [POLY_X;POLY_X_NOT_POLY_NIL;ALL;N_IS_INT])
)

let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

(*
 * Harrison's transcendental predicate from 100/liouville.ml is equivalent
 * to my predicate conjoined with x != 0.
 *)
let TRANSCENDENTAL_MY_TRANSCENDENTAL = PROVE(
    `!x. transcendental x <=>
         (~(x = &0) /\
             ~ ? c.     (ALL integer c)
                     /\ ((LENGTH c) > 1)
                     /\ ((poly c x) = &0)
                     /\ (HD c) > &0 )`,
    let contra_pos = TAUT `(~X ==> ~Y /\ ~Z) <=> ((Y \/ Z) ==> X)` in
    let contra_pos2 = TAUT `((~X /\ ~Y) ==> ~Z) <=> (Z ==> ~X ==> Y)` in
    let l0 = PROVE(`!c . LENGTH c > 1 ==> HD c > &0 ==> ~(poly c = poly [])`,
                   LIST_INDUCT_TAC THEN
                   (ASM_MESON_TAC [LENGTH_EQ_NIL;ARITH_RULE `n > 1 ==> ~(n = 0)`;
                                   REAL_ARITH `(x:real) > &0 ==> ~(x = &0)`;
                                   HD;ALL;POLY_ZERO])) in
    let witness = `if ((&0) <= (HD (poly_nuk p)))
                   then (poly_nuk p)
                   else ((-- &1) ## (poly_nuk p))` in
    let l2 = REAL_ARITH `!(x:real). (&0 <= x) /\ ~(x = &0) ==> x > &0` in
    let l3 = PROVE( `! c p. LENGTH (c ## p) =  LENGTH p`,
                    STRIP_TAC THEN LIST_INDUCT_TAC THEN
                    (ASM_SIMP_TAC [poly_cmul;LENGTH])) in
    let POLY_CMUL_HD = PROVE(
        `! x p . (~(p = [])) ==> HD (x ## p) = x * (HD p)`,
        STRIP_TAC THEN LIST_INDUCT_TAC THEN (SIMP_TAC [NOT_CONS_NIL;poly_cmul;HD])
    ) in
    (REWRITE_TAC [transcendental;algebraic]) THEN
    (STRIP_TAC THEN EQ_TAC) THENL
    [ (ONCE_REWRITE_TAC [contra_pos]) THEN STRIP_TAC THENL
      [ASM_MESON_TAC [transcendental;algebraic; NOT_TRANSCENDENTAL_ZERO];
      (EXISTS_TAC `c:(real)list`) THEN
      (ASM_MESON_TAC [l0; NOT_TRANSCENDENTAL_ZERO  ])];
      (REWRITE_TAC [contra_pos2]) THEN
      (STRIP_TAC THEN STRIP_TAC) THEN (ASM_SIMP_TAC [IS_INT_POLY_NUKE]) THEN
      (EXISTS_TAC witness) THEN
      (ASM_CASES_TAC `((&0) <= (HD (poly_nuk p)))`) THEN
      (ASM_MESON_TAC [ IS_INT_POLY_NUKE;ALL_IS_INT_POLY_CMUL;NEG_N_IS_INT;
                       l2;POLY_NUKE_HD_NONZERO;NEGATED_POLY_ROOT;SOUP_LEMMA;
                       l3;POLY_NUKE_ROOT;POLY_NUKE_ZERO;POLY_CMUL_HD;
                       REAL_ARITH `~(&0 <= (x:real)) <=> ((-- &1) * x) > &0`])
    ]
)

let E_TRANSCENDENTAL_EQUIV = PROVE(
    `(transcendental (exp (&1))) <=>
     (~ ? c.  (ALL integer c)
           /\ ((LENGTH c) > 1)
           /\ ((poly c (exp (&1))) = &0)
           /\ (HD c) > &0 )`,
    MESON_TAC[TRANSCENDENTAL_MY_TRANSCENDENTAL;
              REAL_EXP_POS_LT; REAL_ARITH `&0 < (x:real) ==> ~(&0 = x)`]
)

(* TBD mentionedin paper *)
let PLANETMATH_EQN_4 =  PROVE(
    `(~ (transcendental (exp (&1)))) ==> ? c .
          ((ALL integer c) /\ ((LENGTH c) > 1) /\ ((EL 0 c) > &0) /\ (! f .((LHS c f) = (RHS c f))))`,
     let foo2 = PROVE( `(HD c) > (real_of_num 0) ==> EL 0 c > &0`,SIMP_TAC [EL]) in
     let lem01 = SPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R in
     let lem02 = ARITH_RULE `(0 <= 0 + 1 /\ 0 <= (PRE (LENGTH (c:(real)list))))` in
     let lem03 = GSYM (MP lem01 (lem02) ) in
     let lem06 = ISPECL [`f1:num->real`;
                         `f2:num->real`;
                         `1`;`(PRE (LENGTH (c:(real)list)))`] SUM_ADD in
     let new0 = SPECL [`f:num->real`;`1`;`PRE (LENGTH (c:(real)list))`] PSUM_SUM_NUMSEG in
     let new1 = SIMP_RULE [ARITH_RULE `~(1 = 0)`;ARITH_RULE `(1 + x) -1 = x`] new0 in
     let new2 = ONCE_REWRITE_RULE [new1] lem06 in
     let lem001 = REAL_ARITH `((A:real) * B * C * D + B * E) = (B * (A * C * D + E))` in
     let lem0 = REAL_ARITH `(x:real) =  x * (&1) - (&0) * y` in
     let lem1 = GEN_ALL (ONCE_REWRITE_RULE [GSYM REAL_EXP_0] lem0) in
     let lem2 = SPECL [`poly (SOD f) (&0)`;
                       ` exp (&0 - xi (&0) f) * poly f (xi (&0) f)`] lem1 in
     let PLANETMATH_EQN_3_TWEAKED =
         REWRITE_RULE
           [REAL_ARITH `((A:real) = B+C) <=> (B = A -C)`]
           PLANETMATH_EQN_3
     in
     let lem21 = GEN `nu:num` (SPEC_ALL PLANETMATH_EQN_3_TWEAKED) in
     let lem3 = CONJ lem21 lem2 in
     let NUM_CASES_LEMMA = PROVE(
         ` !P .((! n .(0 < n) ==> (P n)) /\ (P 0) ==> ! n . P n)`,
         (REPEAT STRIP_TAC) THEN (SPEC_TAC (`n:num`,`n:num`)) THEN
         INDUCT_TAC THEN (ASM_SIMP_TAC[]) THEN
         (ASM_SIMP_TAC [ARITH_RULE `0 < (SUC n)`])) in
     let lem4 = SPEC `(\nu.poly (SOD f) (&nu) = poly (SOD f) (&0) * exp (&nu) - &nu * (exp ((&nu) - xi (&nu) f)) * poly f (xi (&nu) f))` NUM_CASES_LEMMA in
     let lem5 = BETA_RULE lem4 in
     let lem6 = MP lem5 lem3 in
     let lem100 =
         SIMP_RULE
           [ARITH_RULE `!n.0 <= n`;ARITH_RULE `(0:num) + 1 = 1`]
           (ISPECL [`f:num->real`;`0`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_COMBINE_R) in
     let lem0001 = ASSUME `LENGTH (c:(real)list) > 1` in
     let lem0002 = MATCH_MP (ARITH_RULE `(x:num) > 1 ==> ~(x=0)`) lem0001 in
     let lem0003 =  REWRITE_RULE [LENGTH_EQ_NIL] lem0002 in
     let lem0004 = MATCH_MP  POLY_SUM_EQUIV lem0003 in
     let SUM_LMUL_NUMSEG = GEN_ALL (ISPECL [`f:num->real`;`c:real`;`n..m`] SUM_LMUL) in
     (ONCE_REWRITE_TAC [E_TRANSCENDENTAL_EQUIV]) THEN
     (ONCE_REWRITE_TAC [LHS;RHS]) THEN
     (REPEAT STRIP_TAC) THEN
     (EXISTS_TAC `c:(real)list`) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_RNEG_UNIQ]) THEN
     (ONCE_REWRITE_TAC [lem03]) THEN
     (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
     (ONCE_REWRITE_TAC [SUM_SING] ) THEN
     (ASM_SIMP_TAC[foo2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [ARITH_RULE `0 + 1 = 1`] ) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B + C = (A + C) + B`] ) THEN
     (ONCE_REWRITE_TAC [GSYM new2]) THEN
     (BETA_TAC) THEN
     (ONCE_REWRITE_TAC [lem001]) THEN
     (CONV_TAC ((RAND_CONV o ABS_CONV o RATOR_CONV o RAND_CONV o RATOR_CONV) (PURE_ONCE_REWRITE_CONV [lem6]))) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) + B - A = B`]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(EL 0 c) * (poly (SOD f) (&0))  = (EL 0 c) * (poly (SOD f) (&0)) * (&1)`]) THEN
     (ONCE_REWRITE_TAC [GSYM REAL_EXP_0]) THEN
     (ONCE_REWRITE_TAC [GSYM (BETA_CONV `(\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)) (0)`)]) THEN
     (ONCE_REWRITE_TAC [GSYM (ISPEC `\x.(EL x c) * (poly (SOD f) (&0)) * exp (&x)` SUM_SING)]) THEN
     (ONCE_REWRITE_TAC [GSYM (NUMSEG_CONV `0..0`)]) THEN
     (ONCE_REWRITE_TAC [REAL_ADD_AC]) THEN
     (ONCE_REWRITE_TAC [lem100]) THEN
     (ONCE_REWRITE_TAC [REAL_ARITH `(A:real) * B * C = B * A * C`]) THEN
     (ONCE_REWRITE_TAC [ SUM_LMUL_NUMSEG ]) THEN
     (ONCE_REWRITE_TAC [GSYM E_POW_N]) THEN
     (ONCE_REWRITE_TAC [GSYM lem0004]) THEN
     (ASM_SIMP_TAC[]) THEN
     (REAL_ARITH_TAC)
     )

end;;
```
### Informal statement
If `exp (&1)` is not transcendental, then there exists a list `c` such that all elements of `c` are integers, the length of `c` is greater than 1, the element at index 0 of `c` is greater than 0, and for all `f`, `LHS c f` equals `RHS c f`.

### Informal sketch
The proof starts by rewriting with `E_TRANSCENDENTAL_EQUIV`, `LHS`, and `RHS`. It then strips the antecedent and exists a list `c`. It then performs various manipulations and rewrites with `REAL_RNEG_UNIQ`, `lem03`, `NUMSEG_CONV`, `SUM_SING`, `foo2`, arithmetic rules, `REAL_ADD_AC`, `GSYM new2`, `lem001`, `REAL_EXP_0`, `SUM_LMUL_NUMSEG`, `E_POW_N`, `GSYM lem0004`, and `lem100`. It uses conversions combined with PURE_ONCE_REWRITE_CONV. Finally, it finishes with `REAL_ARITH_TAC`.

### Mathematical insight
This theorem, along with PlanetMath Eqn 3, describes the result that if `e` is not transcendental, there exist integers, called `c` in the formal statement, s.t. `LHS c f` is equal to `RHS c f` for all `f`.

### Dependencies
- Theorems:
  - `E_TRANSCENDENTAL_EQUIV`
  - the `num_CASES_LEMMA`
  - `E_POW_N`
  - A large collection of theorems about arithmetic and lists such as `LENGTH_EQ_NIL`,`REAL_RNEG_UNIQ`
- Definitions:
  - `LHS`
  - `RHS`
  - `transcendental`
  - `poly`
  - `exp`
  - `SOD`
  - `xi`


---

## POLY_MUL_ITER

### Name of formal statement
POLY_MUL_ITER

### Type of the formal statement
new_recursive_definition

### Formal Content
```ocaml
let POLY_MUL_ITER = new_recursive_definition num_RECURSION
    `(poly_mul_iter f 0 = [&1]) /\
     (!n . poly_mul_iter f (SUC n) = (f (SUC n)) ** (poly_mul_iter f n))`
```

### Informal statement
The function `poly_mul_iter` from natural numbers to lists of real numbers is defined recursively such that:
- `poly_mul_iter f 0` is equal to the list containing only the real number 1, which represents the constant polynomial 1.
- For all natural numbers `n`, `poly_mul_iter f (SUC n)` is equal to the polynomial resulting from the multiplication of `f (SUC n)` and `poly_mul_iter f n`.

### Informal sketch
The definition of the function `poly_mul_iter` is given recursively. The recursion is on the natural number argument.
- Base case: When the argument is 0, the result is the constant polynomial 1, represented by the list `[&1]`.
- Recursive step: When the argument is the successor of `n` (i.e., `SUC n`), the result is obtained by multiplying the polynomial `f (SUC n)` with the polynomial `poly_mul_iter f n`.
The recursion is justified by `num_RECURSION`, which is likely an automation that handles recursion over natural numbers.

### Mathematical insight
This function iteratively multiplies polynomials generated by `f` based on the input natural number. It computes the "product" of the sequence `f 1`, `f 2`, ..., `f n` using polynomial multiplication, where the initial value is 1. `poly_mul_iter` can be seen as a fold operation on polynomials using polynomial multiplication as the combining operator and 1 as the initial value.

### Dependencies
- `num_RECURSION`
- `FACT`

---
### Name of formal statement
PLANETMATH_EQN_5

### Type of the formal statement
new_definition

### Formal Content
```ocaml
let PLANETMATH_EQN_5 =
    new_definition
      `g n p  = (&1/(&(FACT (p  -1)))) ##
                   ((poly_exp [&0;&1] (p-1)) **
                       (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`
```

### Informal statement
The function `g` from natural numbers and real numbers to lists of real numbers is defined such that for all natural numbers `n` and real numbers `p`, `g n p` is equal to the list concatenation of:
- The list containing only the real number `1 / (FACT (p - 1))`.
- With, the polynomial resulting from the multiplication of `(poly_exp [&0;&1] (p-1))` with `poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`.

### Informal sketch
The definition consists of two parts that are concatenated.
- A constant real number `1 / (FACT (p - 1))` which is converted into a list containing a single element.
- A more complex component that results from repeated polynomial multiplications of `(poly_mul_iter (\i.[-- &i; &1]) n)` raised to the power of `p` and multiplied with `(poly_exp [&0;&1] (p-1))`.

### Mathematical insight
This definition appear to be constructing a specific polynomial. `poly_mul_iter` is used to construct a polynomial from a sequence of other polynomials. It raises the resulting polynomial to the power `p`, then multiplies it by `(poly_exp [&0;&1] (p-1))`. Finally, it prepends `1 / (FACT (p - 1))` to the list representation of the resulting polynomial.

### Dependencies
- `FACT`
- `poly_exp`
- `poly_mul_iter`


---

## ABS_LE_MUL2

### Name of formal statement
ABS_LE_MUL2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
For all real numbers `w`, `x`, `y`, and `z`, if the absolute value of `w` is less than or equal to `y` and the absolute value of `x` is less than or equal to `z`, then the absolute value of `w` times `x` is less than or equal to `y` times `z`.

### Informal sketch
The proof proceeds by:
- Discharging the assumptions using `DISCH_TAC`.
- Rewriting using the theorem `ABS_MUL`, which states `abs(x * y) = abs x * abs y`.
- Applying `REAL_LE_MUL2`, which states that if `0 <= a <= b` and `0 <= c <= d` then `a * c <= b * d`.
- Rewriting using `ABS_POS`, which states that `0 <= abs x` for all real numbers `x`.

### Mathematical insight
This theorem formalizes the intuition that bounding the absolute values of two numbers bounds the absolute value of their product. It's a fundamental result for real analysis and is used for bounding errors and proving convergence.

### Dependencies
- `ABS_MUL`
- `REAL_LE_MUL2`
- `ABS_POS`

---
### Name of formal statement
SEPTEMBER_2009_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
For all `x`, `f`, `n`, and `n'`, if for all `i` such that `0 <= i` and `i <= n`, the absolute value of the polynomial `poly (f i) x` is less than or equal to `&n'`, then the absolute value of the polynomial `poly (poly_mul_iter f n) x` is less than or equal to `&n'` raised to the power of `n`.

### Informal sketch
The proof proceeds by induction on `n`.
- **Base case:** The base case follows by rewriting the definition of `poly_mul_iter` for `n = 0`.
- **Inductive step:** Assuming the result holds for `n`, we need to show it holds for `SUC n`. We use the definition of `poly_mul_iter` to rewrite the expression `poly (poly_mul_iter f (SUC n)) x` as `poly ((poly_mul_iter f n) MUL (f (SUC n))) x`, where `MUL` denotes polynomial multiplication.
Then we apply `ABS_LE_MUL2` to bound the absolute value of the product of `poly (poly_mul_iter f n) x` and `poly (f (SUC n)) x`.
We apply the inductive hypothesis to bound `abs (poly (poly_mul_iter f n) x)` by `&n' pow n`, and the assumption (provided by `lem2`) that `abs (poly (f (SUC n)) x)` is bounded by `&n'`.
Finally, we use the fact that `(&n' pow n) * (&n') = &n' pow (SUC n)` to complete the inductive step.

### Mathematical insight
This lemma provides a bound on the absolute value of a polynomial formed by iteratively multiplying polynomials `f i`.
The condition `!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')` says the absolute values of polynomials `f i` are bounded by `n'`.
This result is used to control the growth of the polynomial as the number of iterations increases.

### Dependencies
- `Pm_eqn5.POLY_MUL_ITER` (definition of `poly_mul_iter`)
- `poly` (polynomial evaluation function)
- `real_pow` (real number power)
- `ABS_LE_MUL2`
- `POLY_MUL`
- `REAL_POW_ADD`

---
### Name of formal statement
SEPTEMBER_2009_LEMMA_2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
For all `x` and `n`, if `&0 < x` and `x < &n`, then for all `i` such that `0 <= i` and `i <= n`, the absolute value of the polynomial `poly [-- &i; &1] x` is less than or equal to `&n`.  Here, `poly [-- &i; &1] x` represents the polynomial `x - i`.

### Informal sketch
The proof proceeds by:
- Rewriting `poly [-- &i; &1] x` into `x - &i`.
- Performing a case split on whether `&i <= x`.
  - If `&i <= x`, then `abs (x - &i) = x - &i <= x < &n`, using the assumption that `x < &n`.
  - If `~( &i <= x)`, then `abs (x - &i) = &i - x`. We want to show that `&i - x < &n`.
    From the hypothesis `&0 < x < &n` we have `&0 < x` and `x < &n` .  The theorem follows by real arithmetic.

### Mathematical insight
This lemma gives a bound on the absolute value of a simple linear polynomial `x - i` given that `x` lies in the interval `(0, n)`.

### Dependencies
- `REAL_LE`
- `poly`
- `REAL_ARITH`
- `real_abs`

---
### Name of formal statement
FACT_DIV_LCANCELS

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
For all natural numbers `n` and real numbers `x`, `&(FACT n) * x / &(FACT n) = x`.

### Informal sketch
The proof uses the following steps:
- Instantiate `REAL_OF_NUM_LT` which guarantees that `0 < &(FACT 0)`.
- Rewrite with the above instantiated lemma and the corresponding `FACT_LT` to show that `&0 < &(FACT n)` where `n` has been substituted for zero in the original instantiations.
- Apply `REAL_DIV_LMUL`, which states that `!x y. ~(y = &0) ==> y * x / y = x` where y is instantiated at `&(FACT n)`. Note that the hypothesis `~(y = &0)` is discharged in the next step.
- Use `REAL_ARITH` to show that `0 < x ==> ~(x = 0)` and then combine this theorems with the previous fact `&0 < &(FACT n)` to show that `~(&(FACT n) = 0)` holds by specializing `x` to `&(FACT n)`.
- Apply universal generalization and Modus Ponens to complete the proof.

### Mathematical insight
This theorem shows that multiplication by the real representation of the factorial of `n`, followed by division by same value, cancels out. This relies on the fact that `FACT n` is always greater than zero for natural numbers `n`, so the division is valid.

### Dependencies
- `REAL_OF_NUM_LT`
- `FACT_LT`
- `REAL_DIV_LMUL`
- `REAL_ARITH`

---
### Name of formal statement
NOVEMBER_LEMMA_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
If `p > 1`, then for all `x` and `n`, if `&0 < x` and `x < &n`, then `abs (poly (g n p) x)` is less than or equal to `(&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`.

### Informal sketch
The proof proceeds as follows:
- Establish that `&0 < &(FACT (p - 1))` given `p > 1` using `REAL_OF_NUM_LT` and `FACT_LT`.
- Use this to establish `&1 / &(FACT (p - 1)) <= &1` using `REAL_LE_LCANCEL_IMP` and simplification.
- Establish that `&0 <= x` given `&0 < x`.
- Use `REAL_POW_LE2` to establish `x pow (p - 1) <= (&n) pow (p - 1)` given `&0 < x < &n`.
- Establish that `abs x pow p <= (abs (&n pow n)) pow p` given that `n > 1` by use of `REAL_POW_LE`
- Use SEPTEMBER_2009_LEMMA_2 to show that `abs (poly (g n p) x)` is bounded by `&n`.
- Apply SEPTEMBER_2009_LEMMA to establish a bound on `abs (poly (g n p) x)`.
- Combine all of these results, and the property that abs(x*y) = abs(x) * abs(y) to get the stated inequality.

### Mathematical insight
This lemma provides an upper bound for the absolute value of the polynomial `poly (g n p) x`, where `g n p` is a function that generates a polynomial based on `n` and `p`, and `x` lies in the interval `(0, n)`.  The bound is expressed in terms of factorials, powers, and `n`. This is a crucial step in bounding the error in a polynomial approximation.

### Dependencies
- `REAL_OF_NUM_LT`
- `REAL_LE_LCANCEL_IMP`
- `FACT_LT`
- `REAL_ABS_REFL`
- `REAL_ARITH`
- `REAL_POW_LE2`
- `REAL_LE_MUL2`
- `REAL_POW_LE`
- `REAL_ABS_POS`
- `SEPTEMBER_2009_LEMMA_2`
- `SEPTEMBER_2009_LEMMA`
- `FACT_DIV_LCANCELS`
- several polynomial theorems (`Pm_eqn5.PLANETMATH_EQN_5`, `POLY_CMUL`, `POLY_MUL`, `POLY_EXP`, `poly`)

---
### Name of formal statement
NOVEMBER_LEMMA_2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
If `1 <= v` and `v <= n`, then `&0 < xi (&v) f` and `xi (&v) f < &n`.  Here `xi` is a function denoting an element chosen from the list `f`.

### Informal sketch
- The proof unfolds the definition of `xi (&v) f` and then uses real arithmetic and the given assumption to show that `0 < xi (&v) f < &n`.

### Mathematical insight
This lemma shows that `xi (&v) f` which is a function denoting an element chosen from the list `f`, lies in the interval `(0, n)` where 1 <= v <=n.
### Dependencies
- `Pm_lemma1.xi_DEF`: Definition of the `xi` function.
- `REAL_OF_NUM_LE`
- `REAL_OF_NUM_LT`
- `REAL_ARITH`

---
### Name of formal statement
REAL_LE_MUL3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
For all real numbers `w0`, `x0`, `y0`, `w1`, `x1`, and `y1`, if `0 <= w0`, `0 <= x0`, `0 <= y0`, `w0 <= w1`, `x0 <= x1`, and `y0 <= y1`, then `w0 * x0 * y0 <= w1 * x1 * y1`.

### Informal sketch
The proof proceeds by applying `REAL_LE_MUL2` to show that `(w0 * x0) <= (w1 * x1)`, and then applying `REAL_LE_MUL2` again with `(w0 * x0)`, `y0`, `(w1 * x1)`, and `y1`, to achieve the final result.

### Mathematical insight
This theorem extends the `REAL_LE_MUL2` result to three real numbers. It formalizes the intuition that if you have three non-negative numbers, and each is less than or equal to another corresponding non-negative number, then the product of the first three is less than or equal to the product of the second three.

### Dependencies
- `REAL_LE_MUL2`
- `REAL_LE_MUL`
- `REAL_LE_TRANS`

---
### Name of formal statement
MAX_ABS_DEF

### Type of the formal statement
new_recursive_definition

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
The function `max_abs` is recursively defined such that `max_abs [] = &0` and `max_abs (CONS h t) = real_max (real_abs h) (max_abs t)`. This function takes a list of real numbers as input and returns the maximum of the absolute values of the elements in the list, using `&0` as the maximum for an empty list.

### Informal sketch
This is a recursive definition:
- The base case defines the maximum absolute value of an empty list as 0.
- The recursive case defines the maximum absolute value of a list `CONS h t` as the maximum of the absolute value of the head element `h` and the maximum absolute value of the tail `t`. The recursion is based on the length of the input list.

### Mathematical insight
This definition provides a way to compute the maximum absolute value of a list of real numbers. This is useful for bounding the elements of the list. This definition closely relates to the standard recursive definition of `max` over the natural numbers, generalized to real absolute values.

### Dependencies
- `list_RECURSION` (HOL Light primitive for defining recursive functions over lists)
- `real_max`
- `real_abs`

---
### Name of formal statement
MAX_ABS_LE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
For all lists of real numbers `cs` and indices `i`, if `0 <= i` and `i < LENGTH cs`, then `abs (EL i cs) <= max_abs cs`.

### Informal sketch
The proof uses list induction.
- **Base Case:** For an empty list, the condition `0 <= i /\ i < LENGTH cs` is always false so the theorem holds vacuously.
- **Inductive Step:** Assume the theorem holds for list `t`. Then we show that the theorem holds for `CONS h t`. The proof involves a case split on `abs h <= max_abs t`.

### Mathematical insight
This theorem states that the absolute value of any element in a list is less than or equal to the maximum absolute value of the elements in the list. `EL i cs` denotes the element at index `i` in list `cs` and `max_abs cs` is defined as the maximum of the absolute values of the list `cs`.

### Dependencies
- `LENGTH`
- `EL`
- `MAX_ABS_DEF`
- `REAL_MAX_MAX`
- `LT_SUC`
- `REAL_ARITH`

---
### Name of formal statement
KEATS_PART_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
If `1 <= i` and `i <= PRE (LENGTH c)` where `c` is a list of real numbers, then `&i * abs (EL i c) <= &i * max_abs c`. Here `i` is a natural number, `EL i c` denotes the `i`-th element of list `c`, and `max_abs c` denotes the maximum of the absolute values of the elements in list `c`.

### Informal sketch
The proof proceeds as follows:
- It first establishes that `0 <= i /\ i < LENGTH c` using the assumption `1 <= i /\ i <= (PRE (LENGTH c))`.
- Next, it leverages `MAX_ABS_LE` to show that `abs (EL i c) <= max_abs c`.
- Finally, it multiplies both sides of the inequality `abs (EL i c) <= max_abs c` by `real_of_num i`. This is valid as `real_of_num` casts to a real number, and REAL_LE_LMUL can be applied given that `0 <= real_of_num i`.

### Mathematical insight
This theorem states that each element's absolute value multiplied by its index is less than or equal to the maximum absolute value multiplied by the index.

### Dependencies
- `MAX_ABS_LE`
- `REAL_LE_LMUL`
- `REAL_ARITH`

---
### Name of formal statement
KEATS_PART_2

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
If `1 <= v` and `v <= PRE (LENGTH (c:(real)list)))`, then `abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`. Here `c` is a list of real numbers, `v` is a natural number, `exp` is the exponential function, `xi` is a selection function, and `g` is a polynomial generating function.

### Informal sketch
The proof proceeds by:
- Establishing the assumption and converting some arithmetic to real numbers.
- Showing that `(&v) - xi (&v) (g (PRE (LENGTH c)) p)  < &PRE (LENGTH (c:(real)list)))` given the assumptions and some arithmetic reasoning using `NOVEMBER_LEMMA_2` to demonstrate `&0 < --xi (&v) (g n p)`.
- Applying `REAL_EXP_MONO_LE` to establish that `exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <=  exp (&(PRE (LENGTH (c:(real)list)))))` and finally uses `REAL_EXP_POS_LE` and `REAL_ABS_REFL` to eliminate the absolute values.

### Mathematical insight
This theorem offers a bound on the exponential of a difference involving the `xi` function. The function `xi` effectively picks an element from a list, and the theorem states that the absolute value of the exponential of a certain difference involving this element is bounded above by the exponential of a related expression.

### Dependencies
- `REAL_OF_NUM_LE`
- `NOVEMBER_LEMMA_2`
- `REAL_ARITH`
- `REAL_EXP_MONO_LE`
- `REAL_ABS_REFL`
- `REAL_EXP_POS_LE`

---
### Name of formal statement
KEATS_PART_3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
If `p > 1`, then for all `i` if `1 <= i` and `i <= PRE (LENGTH (c:(real)list)))`, then `abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p)))` is less than or equal to `&1 / &(FACT (p - 1)) * &(PRE (LENGTH c)) pow (p - 1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`. Here `poly` is the polynomial evaluation function, `g` is a function that returns a list of coefficients of a polynomial, `xi` picks an element of by index from a given list of real numbers `c` is a list of coefficients, LENGTH is the length of a list, and `PRE` is the predecessor function on natural numbers.

### Informal sketch
The proof relies on `NOVEMBER_LEMMA_1` and `NOVEMBER_LEMMA_2` and proceeds as follows:

- Use `NOVEMBER_LEMMA_2` to show that `0 < v` given the assumptions
- Specialize `NOVEMBER_LEMMA_1` and then use `MATCH_MP` to combine the result with the earlier results using `NOVEMBER_LEMMA_2`.

### Mathematical insight
This theorem states that the absolute value of the polynomial evaluated at `xi` lies below a bound that depends on the length of `c` and `p`, relating polynomial magnitude to list length.

### Dependencies
- `NOVEMBER_LEMMA_2`
- `NOVEMBER_LEMMA_1`
- `REAL_ARITH`

---
### Name of formal statement
RHS_4_F5_LE_SUM

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
`abs (RHS c (g (PRE (LENGTH c)) p)) <= sum (1..PRE (LENGTH c)) (\i. &i * abs (EL i c) * abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) * abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`.  This theorem states that the absolute value of the function `RHS` applied to argument `c` and `g (PRE (LENGTH c)) p` is less than or equal to the sum from 1 to the predecessor of the length of `c` of the expression `&i * abs (EL i c) * abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) * abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`.

### Informal sketch
The proof proceeds by:
- Expanding the definition of RHS using `Pm_eqn4.RHS`.
- Applying `SUM_ABS_NUMSEG` to bring the absolute value inside the sum.
- Using the properties that real number absolute values and multiplication are absolute values to complete the rewrite using real polynomials.

### Mathematical insight
This gives an upper bound of a rather complicated quantity, `RHS`, representing an error bound. `RHS` uses polynomial evaluation `poly`, the list accessor `EL`, an "iterator" `g`, and `xi` which represents choices made within the list. The `SUM` gives an upper bound on the absolute value of `RHS` in terms of a summation.

### Dependencies
- `Pm_eqn4.RHS`: Definition of `RHS`.
- `SUM_ABS_NUMSEG`
- `REAL_ABS_NUM`
- `REAL_ABS_MUL`

---
### Name of formal statement
RHS_4_BOUND_PRE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
`abs (RHS c (g (PRE (LENGTH c)) p)) <= (sum (1..PRE (LENGTH c)) &) * (max_abs c * abs (exp (&(PRE (LENGTH c))))) * &1 / &(FACT (p - 1)) * &(PRE (LENGTH c)) pow (p - 1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`.  This theorem provides an upper bound for the function `abs (RHS c (g (PRE (LENGTH c)) p))` in terms of `(sum (1..PRE (LENGTH c)) &)`, `(max_abs c * abs (exp (&(PRE (LENGTH c)))))`, and `&1 / &(FACT (p - 1)) * &(PRE (LENGTH c)) pow (p - 1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`.

### Informal sketch

The proof proceeds by:
- Applying `REAL_LE_MUL3`, with the appropriate arguments to the theorem statement.
- Using previously proven theorems `KEATS_PART_1`, `KEATS_PART_2`, and `KEATS_PART_3`.
- Applying `SUM_LE_NUMSEG` to bound the summation by the sum of maximal elements.
- Rewriting the final result.

### Mathematical insight
This theorem bounds `RHS` with a formula that separates the contributions of list `c`, factorials involving `p`, other bounds.

### Dependencies
- `REAL_LE_MUL3`
- `KEATS_PART_1`
- `KEATS_PART_2`
- `KEATS_PART_3`
- `SUM_LE_NUMSEG`
- `REAL_MUL_ASSOC`
- `RHS_4_F5_LE_SUM`
- `REAL_LE_TRANS`
- `SUM_RMUL`

---
### Name of formal statement
RHS_4_BOUND

### Type of the formal statement
theorem

### Formal Content
```ocaml
let ABS_LE_MUL2 = PROVE(
  `!(w:real) x y z. abs(w) <= y /\ abs(x) <= z ==> abs(w * x) <= (y * z)`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_REWRITE_TAC[ABS_POS])

let SEPTEMBER_2009_LEMMA = PROVE(
    `!x f n n'.
    (!i.(0 <= i /\ i <= n) ==> (abs (poly (f i) x)) <= &(n')) ==>
    (abs (poly (poly_mul_iter f n) x)) <= (&(n') pow n)`,
    let lem0 = ASSUME `!i. 0 <= i /\ i <= SUC n ==> abs (poly (f i) x) <= &n'` in
    let lem1 = SPEC `SUC n` lem0 in
    let lem2 = SIMP_RULE [ARITH_RULE `0 <= SUC n /\ SUC n <= SUC n`] lem1 in
    let lem3 = PROVE(`(!i:num.(P0 i) ==> (P1 i)) ==> (!i:num.((P1 i) ==> (Q i))) ==> (!i:num.((P0 i) ==> (Q i)))`, MESON_TAC[]) in
    let lem4 = ARITH_RULE `!i.(0 <= i /\ i <= n) ==> (0 <= i /\ i <= SUC n)` in
    let lem5 = GEN `Q:num->bool` (MATCH_MP lem3 lem4) in
    let lem6 = ASSUME `!n'. (!i. 0 <= i /\ i <= n ==> abs (poly (f i) x) <= &n') ==> abs (poly (poly_mul_iter f n) x) <= &n' pow n` in
    let lem7 = SPEC `n':num` lem6 in
    let lem9 = UNDISCH (BETA_RULE (SPEC `\i. abs (poly (f (i:num)) x) <= &n'` lem5)) in
    let lem11 = MP (lem7) (lem9) in
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
    [ (REWRITE_TAC ([Pm_eqn5.POLY_MUL_ITER;poly;real_pow]@rewrites0))
      THEN (REAL_ARITH_TAC);
      (STRIP_TAC) THEN (STRIP_TAC) THEN
      (REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER;POLY_MUL;real_pow]) THEN
      (MATCH_MP_TAC ABS_LE_MUL2) THEN
      (SIMP_TAC [lem2;lem11])
    ]
)
let SEPTEMBER_2009_LEMMA_2 = PROVE(
    `&0 < x /\ x < &n
      ==> (!i. 0 <= i /\ i <= n ==> abs(poly [-- &i; &1] x) <= &n)`,
    (REWRITE_TAC [GSYM REAL_LE]) THEN (REPEAT STRIP_TAC) THEN
    (REWRITE_TAC ([poly]@rewrites0)) THEN
    (REWRITE_TAC [REAL_ARITH `&0 <= -- &i + (x:real) <=>  &i <= x`;real_abs]) THEN (ASM_CASES_TAC `&i <= (x:real)`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `-- &i + (x:real) =  x - &i `]) THEN
      (ASM_REAL_ARITH_TAC);
      (ASM_SIMP_TAC []) THEN
      (REWRITE_TAC [REAL_ARITH `--(-- &i + (x:real)) =  &i - x `]) THEN
      (ASM_REAL_ARITH_TAC)
    ]
)

let FACT_DIV_LCANCELS = PROVE(
    `!n x.  &(FACT n) * x / &(FACT n)  = x`,
    let lem0 = SPECL [`0`;`FACT n`] REAL_OF_NUM_LT in
    let lem1 = ONCE_REWRITE_RULE [GSYM lem0] FACT_LT in
    let lem2 = SPECL [`x:real`;`(&(FACT n)):real`] REAL_DIV_LMUL in
    let lem3 = REAL_ARITH `!x:real. &0 < x ==> ~(x = &0)` in
    let lem4 = MATCH_MP lem3 (SPEC_ALL lem1) in
    ACCEPT_TAC (GEN_ALL (MP lem2 lem4))
)
let NOVEMBER_LEMMA_1 = PROVE(
    `p > 1 ==>
      &0 < x /\ x < &n ==>
       (abs(poly (g n p) x)) <=
           (&1/(&(FACT (p  -1)))) * ((&n) pow (p - 1)) * ((&n pow n) pow p)`,
   let l0 = SPECL [`0`;`FACT (p-1)`] REAL_OF_NUM_LT in
   let l2 = snd (EQ_IMP_RULE l0) in
   let l3 = MP l2 (SPEC `(p:num) - 1` FACT_LT)  in
   let l4 = SPEC `(&(FACT (p - 1))):real` REAL_LE_LCANCEL_IMP in
   let l5 = SIMP_RULE [l3] l4 in
   let ll0 = snd (EQ_IMP_RULE (SPEC_ALL REAL_ABS_REFL)) in
   let ll1 = IMP_TRANS (REAL_ARITH `(&0):real < x ==> &0 <= x`) ll0 in
   let ll2 = UNDISCH ll1 in
   let asses = [`(p:num) > 1`;`&0 < (x:real)`; `(x:real) < &n`] in
   let j0 = SPECL [`p - 1`;`x:real`;`(&n):real`] REAL_POW_LE2 in
   let j1 = REAL_ARITH `(&0) < (x:real) /\ x < (&n) ==> (&0 <=x /\ x <= (&n))` in
   let j2 = UNDISCH_ALL (BRW1 (IMP_TRANS j1 j0)) in
   let ll4 = SPECL [`(x:real) pow (p - 1)`;`((&n):real) pow (p - 1)`;`(abs (r:real)) pow p`] REAL_LE_MUL2 in
   let ll5 = (SPECL [`x:real`;`(p:num) - 1`] REAL_POW_LE) in
   let ll50 = UNDISCH (IMP_TRANS (REAL_ARITH `&0 < x ==> (&0) <= (x:real)`) ll5;) in
   let ll6  = ADD_ASSUMS asses ll4 in
   let ll7 = REAL_ARITH `(x:real) < y ==> x <= y` in
   let ll8 = SIMP_RULE [j2;ll50;ll7;REAL_POW_LE;REAL_ABS_POS] ll6 in
   let ll9 = ADD_ASSUM `p > 1` (SPEC `p:num` REAL_POW_LE2) in
   let ll10 = UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`) in
   let ll11 = SIMP_RULE [ll10] ll9 in
   let ll12 = SPEC `abs (r:real)` ll11 in
   let ll13 = SIMP_RULE [REAL_ABS_POS] ll12 in
   let lem0 = UNDISCH (UNDISCH (BRW1 SEPTEMBER_2009_LEMMA_2)) in
   let lem1 = MATCH_MP SEPTEMBER_2009_LEMMA lem0 in
   let lem2 = DISCH_ALL (DISCH `(&0) < (x:real)` lem1) in
   let lem3 = SPEC `SUC n` (GEN (`n:num`) lem2) in
   (STRIP_TAC) THEN (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN
   (ONCE_REWRITE_TAC [POLY_CMUL]) THEN
   (ONCE_REWRITE_TAC [POLY_MUL]) THEN
   (ONCE_REWRITE_TAC [POLY_EXP]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (ONCE_REWRITE_TAC [poly]) THEN
   (REWRITE_TAC rewrites0) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_MUL]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_POW]) THEN
   (ONCE_REWRITE_TAC [REAL_ABS_DIV]) THEN
   (ONCE_REWRITE_TAC [ABS_N]) THEN
   (MATCH_MP_TAC l5) THEN
   (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
   (SIMP_TAC [FACT_DIV_LCANCELS;REAL_ARITH `&1 * (x:real) = x`]) THEN
   (SIMP_TAC [ll2]) THEN
   (MATCH_MP_TAC ll8) THEN
   (MATCH_MP_TAC ll13) THEN
   (UNDISCH_TAC `&0 < (x:real)`) THEN
   (UNDISCH_TAC `(x:real) < &n`) THEN
   (SPEC_TAC (`n:num`,`n:num`)) THEN
   INDUCT_TAC THENL [(REAL_ARITH_TAC); (ACCEPT_TAC lem3)]
)

let NOVEMBER_LEMMA_2 = PROVE(
    ` 1 <= v /\ v <= n
       ==> ((&0) < ( xi (&v) f)  /\ (xi (&v) f) < (&n))`,
    let l0 = SPECL [`(&v):real`;`f:(real)list`] Pm_lemma1.xi_DEF in
    let l1 = UNDISCH (ONCE_REWRITE_RULE [REAL_OF_NUM_LT] l0) in
    let [l2;l3;_] = CONJUNCTS l1 in
    let l4 = GEN_ALL (REAL_ARITH `(&v) <= y ==> z < (&v) ==> (z:real) < y`) in
    let l6 = SPECL [`v:num`;`z:real`;`(&n):real`] l4 in
    let l7 = UNDISCH  l6 in
    (ONCE_REWRITE_TAC [ TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`;ARITH_RULE `1 <= v <=> 0 < v` ]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_LE;GSYM REAL_OF_NUM_LT]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THEN (SIMP_TAC [l2]) THEN
    (MATCH_MP_TAC l7) THEN (ACCEPT_TAC  l3)
)

let REAL_LE_MUL3 = PROVE(
    `! w0 x0 y0 w1 x1 (y1:real).
     (&0 <= w0) ==> (&0 <= x0) ==> (&0 <= y0) ==>
     (w0 <= w1) ==> (x0 <= x1) ==> (y0 <= y1) ==>
     (w0 * x0 * y0) <= (w1 * x1 * y1)`,
     let lst = [`w0:real`;`w1:real`;`(x0 * y0):real`;`(x1 * y1):real`] in
     let c0 = SPECL lst REAL_LE_MUL2 in
     MESON_TAC [c0;REAL_LE_MUL2;REAL_LE_MUL]
)

let MAX_ABS_DEF =
    new_recursive_definition list_RECURSION
       `    (max_abs [] = &0)
        /\  (max_abs (CONS h t) = real_max (real_abs h) (max_abs t))`

let MAX_ABS_LE = PROVE(
    `! cs i.
     (0 <= i /\ i < (LENGTH cs) ==>
       (real_abs (EL i cs)) <= (max_abs cs))`,
    let l0 = UNDISCH (REAL_ARITH `~((abs h) <= max_abs t) ==> x <= (max_abs t) ==> x <= (abs h)`) in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
      INDUCT_TAC THENL
      [ (SIMP_TAC [HD;EL;MAX_ABS_DEF;REAL_MAX_MAX]);
        (SIMP_TAC [TL;EL;MAX_ABS_DEF;REAL_MAX_MAX;LENGTH;LT_SUC]) THEN
        (ASM_CASES_TAC `(real_abs h) <= (max_abs t)`) THEN
        (ASM_SIMP_TAC [real_max;ARITH_RULE `0 <= y`;l0])
      ]
    ]
)
let KEATS_PART_1 = PROVE(
    `1 <= i /\ i <= PRE (LENGTH c) ==> ( &i * abs (EL i c) <= &i * max_abs c)`,
    let keats12 = ARITH_RULE `1 <= i /\ i <= (PRE (LENGTH (c:(real)list))) ==> (0 <= i /\ i < LENGTH c)` in
    let keats13 = IMP_TRANS keats12 (SPECL [`c:(real)list`;`i:num`] MAX_ABS_LE) in
    let keats14 = SPECL [`real_of_num i`] REAL_LE_LMUL in
    let keats15 = ARITH_RULE `(&0) <= (real_of_num i)` in
    let keats16 = SIMP_RULE [keats15] keats14 in
    let keats17 = UNDISCH keats13 in
    let keats18 = MATCH_MP keats16 keats17 in
    ACCEPT_TAC (DISCH_ALL keats18)
)
let KEATS_PART_2 = PROVE(
    `(1 <= v /\ v <= PRE (LENGTH (c:(real)list))) ==>
       abs (exp ((&v) - xi (&v) (g (PRE (LENGTH c)) p))) <= abs (exp (&(PRE (LENGTH (c:(real)list)))))`,
    let j0 = ASSUME `1 <= v /\ (v:num) <= (PRE (LENGTH (c:(real)list)))` in
    let j00 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LE] (CONJUNCT2 j0) in
    let j1 = REAL_ARITH `!n .(real_of_num v <= &n) ==> (&0 > --xi (&v) (g n p)) ==> (&n) > (&v) - (xi (&v) (g n p))` in
let j2 = MP (SPEC `PRE (LENGTH (c:(real)list))` j1) j00 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k33 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` NOVEMBER_LEMMA_2) in
    let k34 = SPEC g_term (GEN `f:(real)list` k33) in
    let k35 = DISCH `1 <= v /\ v <= (PRE (LENGTH (c:(real)list)))` (CONJUNCT1 (UNDISCH k34)) in
    let k36 = UNDISCH (SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` k35)) in
    let k37 = REAL_ARITH `!x. (real_of_num 0) < x ==> (real_of_num 0) > -- x` in
    let k38 = MATCH_MP k37 k36 in
    let k40 = MP j2 k38 in
    let k41 = REAL_ARITH `!x (y:real).x > y ==> y <= x` in
    let k42 = MATCH_MP k41 k40 in
    let k42 = ONCE_REWRITE_RULE [GSYM REAL_EXP_MONO_LE] k42 in
    let k43 = REAL_ARITH `!(x:real) . (&0) <= x ==> abs x = x` in
    let k44 = GEN `x:real` (MATCH_MP k43 (SPEC `x:real` REAL_EXP_POS_LE)) in
    let k45 = ONCE_REWRITE_RULE [GSYM k44] k42 in
    let k46 = DISCH_ALL k45 in
    let k47 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k46) in
    ACCEPT_TAC k47
)
let KEATS_PART_3 =
    UNDISCH
    (PROVE(
    `p > 1 ==> (1 <= i /\ i <= PRE (LENGTH (c:(real)list)))
     ==> abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))) <=
         &1 / &(FACT (p - 1)) *
         &(PRE (LENGTH c)) pow (p - 1) *
         &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p`,
    let k0 = UNDISCH NOVEMBER_LEMMA_2 in
    let k1 = UNDISCH NOVEMBER_LEMMA_1 in
    let k2 = GEN `x:real` k1 in
    let k3 = SPEC `xi (real_of_num i) f` k2 in
    let k5 = MATCH_MP k3 k0 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let k6 = SPEC g_term (GEN `f:(real)list` k5) in
    let k7 = SPEC `PRE (LENGTH (c:(real)list))` (GEN `n:num` (DISCH `1 <= v /\ v <= n` k6)) in
    let k8 = DISCH `0 < v` k7 in
    let k9 = BRW0 (SIMP_RULE [ARITH_RULE `0 < v <=> 1 <= v`] k8) in
    MATCH_ACCEPT_TAC (DISCH_ALL k9)
))

let RHS_4_F5_LE_SUM = PROVE(
    `abs (RHS c (g (PRE (LENGTH c)) p)) <=
     sum (1..PRE (LENGTH c))
     (\i. &i *
          abs (EL i c) *
          abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
          abs
          (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c)) p))))`,
    let keats4 = REFL `abs (RHS c f)` in
    let keats5 = (CONV_RULE (RAND_CONV (REWRITE_CONV [Pm_eqn4.RHS]))) keats4 in
    let keats6 = REWRITE_RULE [REAL_ABS_NEG] keats5 in
    let keats7 =
        SPECL [`(\i.(&i) * (EL i c) * (exp (&i - (xi (&i) f))) * (poly f (xi
        (&i) f)))`;`1`;`PRE (LENGTH (c:(real)list))`] SUM_ABS_NUMSEG in
    let keats8 = ONCE_REWRITE_RULE  [GSYM keats6] keats7 in
    let keats9 = REWRITE_RULE  [REAL_ABS_NUM;REAL_ABS_MUL] keats8 in
    let g_term = `g (PRE (LENGTH (c:(real)list))) p` in
    let keats10 = SPEC g_term (GEN `f:(real)list` keats9) in
    ACCEPT_TAC  keats10
)


let RHS_4_BOUND_PRE = PROVE(
        `abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               abs (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`,
      let w0 = `(real_of_num i) * (real_abs (EL i c))` in
      let w1 = `(real_of_num i) * (max_abs c)` in
      let x0 = `abs (exp (&v - xi (&v) (g (PRE (LENGTH (c:(real)list))) p)))`
      in
      let x1 = `abs (exp (&(PRE (LENGTH (c:(real)list)))))` in
      let y0 = `abs (poly (g (PRE (LENGTH (c:(real)list))) p) (xi (&i) (g (PRE
      (LENGTH c)) p)))` in
      let y1 = ` &1 / &(FACT (p - 1)) * &(PRE (LENGTH (c:(real)list))) pow (p -
      1) * &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p` in
      let rename_free_var oo nn tt = SPEC nn (GEN oo tt) in
      let v2i tt = rename_free_var `v:num` `i:num` tt in
      let josh0  = SPECL [w0;x0;y0;w1;x1;y1] REAL_LE_MUL3 in
      let josh2 = SPECL [`real_of_num i`;`real_abs (EL i c)`] REAL_LE_MUL in
      let josh3 = SIMP_RULE [REAL_ABS_POS;REAL_ARITH `(real_of_num 0) <= &i`] josh2
      in
      let josh4 = v2i (SIMP_RULE [josh3;REAL_ABS_POS] josh0) in
      let josh5 = SIMP_RULE [UNDISCH KEATS_PART_1] josh4 in
      let josh6 = SIMP_RULE [UNDISCH (v2i KEATS_PART_2)] josh5 in
      let josh7 = SIMP_RULE [UNDISCH KEATS_PART_3] josh6 in
      let josh8 = DISCH `1 <= i /\ i <= (PRE (LENGTH (c:(real)list)))` josh7 in
      let f0 = `(\i.
             &i *
             abs (EL i c) *
             abs (exp (&i - xi (&i) (g (PRE (LENGTH c)) p))) *
             abs (poly (g (PRE (LENGTH c)) p) (xi (&i) (g (PRE (LENGTH c))
             p))))` in
      let f1 = `(\i.
                 (&i * max_abs c) *
                 abs (exp (&(PRE (LENGTH c)))) *
                 &1 / &(FACT (p - 1)) *
                 &(PRE (LENGTH c)) pow (p - 1) *
                 &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)` in
      let josh9 = SPECL [f0;f1;`1`;`PRE (LENGTH (c:(real)list))`] SUM_LE_NUMSEG
      in
      let josh10 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (BETA_RULE josh9) in
      let josh11 = REWRITE_RULE [GSYM REAL_MUL_ASSOC] (GEN `i:num` josh8) in
      let josh12 = MP josh10 josh11 in
      let josh13 = CONJ RHS_4_F5_LE_SUM josh12 in
      let josh14 = MATCH_MP REAL_LE_TRANS josh13 in
      let josh15 = ONCE_REWRITE_RULE [SUM_RMUL] josh14 in
      ACCEPT_TAC josh15
)

(* A reviewer of the Journal of Formalized Reasoning paper for this proof
 * pointed out that the "abs" in "abs (exp (&(PRE (LENGTH c))))" of
 * RHS_4_BOUND_PRE is redundant.  So here that theorem is rewritten to
 * remove that abs.
 *)
let RHS_4_BOUND =
    let l1 = MATCH_MP (SPEC `&0:real` REAL_LT_IMP_LE)
                      (SPEC `x:real` REAL_EXP_POS_LT) in
    let l2 = REWRITE_RULE [GSYM REAL_ABS_REFL] l1 in
    ONCE_REWRITE_RULE [l2] RHS_4_BOUND_PRE
;;
```

### Informal statement
`abs (RHS c (g (PRE (LENGTH c)) p)) <=
          (sum (1..PRE (LENGTH c)) &) *
               (max_abs c *
               (exp (&(PRE (LENGTH c)))) *
               &1 / &(FACT (p - 1)) *
               &(PRE (LENGTH c)) pow (p - 1) *
               &(PRE (LENGTH c)) pow PRE (LENGTH c) pow p)`

### Informal sketch
The proof starts with the theorem `RHS_4_BOUND_PRE`. The absolute value operation around `exp (&(PRE (LENGTH c)))` is then removed, by showing that `exp` is always positive and hence `abs (exp x) = exp x` and simplifying.

### Mathematical insight
This theorem is a refinement of `RHS_4_BOUND_PRE`, removing a redundant absolute value around an exponential. The exponential function always returns a positive number, so the absolute value is unnecessary which provides a tighter bound.

### Dependencies
- `RHS_4_BOUND_PRE`
- `REAL_LT_IMP_LE`
- `REAL_EXP_POS_LT`
- `REAL_ABS_REFL`


---

## JESSE_POW_LEMMA

### Name of formal statement
JESSE_POW_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let JESSE_POW_LEMMA = PROVE(
     `(p:num) > 1 ==> !x.real_pow x p = x * (real_pow x (p-1))`,
     let c0 = UNDISCH (ARITH_RULE `(p:num) > 1 ==> p = SUC (p - 1) `) in
     STRIP_TAC THEN STRIP_TAC THEN
     (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [c0]))) THEN
     (SIMP_TAC [real_pow])
)
let JESSE_REAL_ABS_LE = PROVE(
    `!(x:real) y.(abs x) <= y ==> (abs x) <= (abs y)`,
    let int10 = UNDISCH (REAL_ARITH `(real_abs x) <= y ==>  y = real_abs y`) in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [GSYM int10])
)
let OLDGERMAN_LEMMA = PROVE(
  ` !C2 C e.
        &0 < e
        ==> (?N . !n. n >= N ==>
        abs (C2 * inv (&(FACT n)) * C pow n - &0) < e)`,
   let w0 = MATCH_MP SUM_SUMMABLE (SPEC `C:real` REAL_EXP_CONVERGES) in
   let w1 = MATCH_MP SER_ZERO w0 in
   let w2 = BETA_RULE w1 in
   let w3 = SPEC `C2:real` SEQ_CONST in
   let w4 = CONJ w3 w2 in
   let w5 = BETA_RULE (MATCH_MP SEQ_MUL w4) in
   let w6 = ONCE_REWRITE_RULE [REAL_ARITH `(C2:real) * (&0) = &0`] w5 in
   let w7 = ONCE_REWRITE_RULE [SEQ] w6 in
   let w8 = GEN_ALL (BETA_RULE w7) in
   (REPEAT STRIP_TAC) THEN
   (CHOOSE_TAC (UNDISCH (SPEC_ALL w8))) THEN
   (EXISTS_TAC `SUC N`) THEN
   (ASM_SIMP_TAC [ARITH_RULE `n' >= SUC n ==> n' >= n`])
)

let RHS_4_LT_ONE_MESSY = PROVE(
   `?p0. !p. p > 1 ==> p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
   let c1 = ONCE_REWRITE_RULE [ UNDISCH JESSE_POW_LEMMA ] RHS_4_BOUND in
   let c2 = SPECL [`real_pow (&(PRE (LENGTH (c:(real)list)))) (p-1)`]
   REAL_MUL_SYM in
   let c3 = ONCE_REWRITE_RULE [ c2] c1 in
   let c4 = ONCE_REWRITE_RULE [ GSYM REAL_MUL_ASSOC ] c3 in
   let c5 = ONCE_REWRITE_RULE [ GSYM REAL_POW_MUL ] c4 in
   let c6 = ONCE_REWRITE_RULE [REAL_MUL_SYM] (CONJUNCT2 real_pow) in
   let c7 = ONCE_REWRITE_RULE [GSYM c6] c5 in
   let c8 = REAL_ARITH `!x. (real_of_num 1)/x = inv x` in
   let c9 = ONCE_REWRITE_RULE [c8] c7 in
   let c10 = REAL_ARITH `!x y z.(inv x) * y * z = y * inv x * z` in
   let c11 = ONCE_REWRITE_RULE [c10] c9 in
   let t0 =
    `sum (1..PRE (LENGTH c)) & *
     max_abs c *
     (exp (&(PRE (LENGTH c)))) *
     &(PRE (LENGTH c)) pow PRE (LENGTH c)` in
   let t1 = `real_of_num (PRE (LENGTH (c:(real)list))) pow SUC (PRE (LENGTH c))`
   in
   let int0 = SPECL [t0;t1;`real_of_num 1`]  OLDGERMAN_LEMMA in
   let int1 = SIMP_RULE [REAL_ARITH `(real_of_num 0) < &1`] int0 in
   let int2 = SIMP_RULE [REAL_ARITH `x - (real_of_num 0) = x`] int1 in
   let t8 = `!n. n >= N
        ==> abs
            ((sum (1..PRE (LENGTH c)) & *
              max_abs c *
              (exp (&(PRE (LENGTH c)))) *
              &(PRE (LENGTH c)) pow PRE (LENGTH c)) *
             inv (&(FACT n)) *
             &(PRE (LENGTH c)) pow SUC (PRE (LENGTH c)) pow n) <
            &1` in
   let int5 = ASSUME t8 in
   let int50 = REAL_ARITH `((x:real) * y * z * w) * (a * b) = x * y * z * w * a *
   b` in
   let int51 = ONCE_REWRITE_RULE [int50] int5 in
   let int6 = SPEC `p - 1` int51 in
   let int7 = ARITH_RULE ` (p > N ==> p - 1 >= N)` in
   let int8 = UNDISCH (IMP_TRANS int7 int6) in
   let int9 = ARITH_RULE `(x:real) <= y ==> y < (real_of_num 1) ==> x < (&1)` in
   let int10 = MATCH_MP JESSE_REAL_ABS_LE c11 in
   let int11 = MATCH_MP int9 int10 in
   let int12 = MP int11 int8 in
   (CHOOSE_TAC int2) THEN
   (EXISTS_TAC `N:num`) THEN
   (STRIP_TAC) THEN
   (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [ARITH_RULE `p > 0 ==> ((p:num)  > N <=> p - 1 >= N)`]) THEN
   (DISCH_TAC) THEN
   (MATCH_ACCEPT_TAC int12)
)
let LT_ONE = PROVE(
        `!c. ?p0. !p. p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
    STRIP_TAC THEN (CHOOSE_TAC RHS_4_LT_ONE_MESSY) THEN (EXISTS_TAC `SUC p0`) THEN
    (ASM_MESON_TAC [ARITH_RULE `p > SUC p0 ==> (p > p0 /\ p > 1)`])
)
end;;
```
### Informal statement
For any natural number `p` greater than 1, for all real numbers `x`, `real_pow x p` is equal to `x * (real_pow x (p-1))`.

### Informal sketch
- The proof starts by rewriting `p` as `SUC (p - 1)` using `ARITH_RULE \`(p:num) > 1 ==> p = SUC (p - 1) \``.
- Then, the theorem is proved by simplifying with the definition of `real_pow`.

### Mathematical insight
This lemma expresses a fundamental property of exponentiation, specifically how `x^p` can be recursively defined in terms of `x^(p-1)` when `p > 1`. It's a basic identity enabling simplification and expansion of power expressions.

### Dependencies
- Definition: `real_pow`

### Name of formal statement
JESSE_REAL_ABS_LE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let JESSE_POW_LEMMA = PROVE(
     `(p:num) > 1 ==> !x.real_pow x p = x * (real_pow x (p-1))`,
     let c0 = UNDISCH (ARITH_RULE `(p:num) > 1 ==> p = SUC (p - 1) `) in
     STRIP_TAC THEN STRIP_TAC THEN
     (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [c0]))) THEN
     (SIMP_TAC [real_pow])
)
let JESSE_REAL_ABS_LE = PROVE(
    `!(x:real) y.(abs x) <= y ==> (abs x) <= (abs y)`,
    let int10 = UNDISCH (REAL_ARITH `(real_abs x) <= y ==>  y = real_abs y`) in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [GSYM int10])
)
let OLDGERMAN_LEMMA = PROVE(
  ` !C2 C e.
        &0 < e
        ==> (?N . !n. n >= N ==>
        abs (C2 * inv (&(FACT n)) * C pow n - &0) < e)`,
   let w0 = MATCH_MP SUM_SUMMABLE (SPEC `C:real` REAL_EXP_CONVERGES) in
   let w1 = MATCH_MP SER_ZERO w0 in
   let w2 = BETA_RULE w1 in
   let w3 = SPEC `C2:real` SEQ_CONST in
   let w4 = CONJ w3 w2 in
   let w5 = BETA_RULE (MATCH_MP SEQ_MUL w4) in
   let w6 = ONCE_REWRITE_RULE [REAL_ARITH `(C2:real) * (&0) = &0`] w5 in
   let w7 = ONCE_REWRITE_RULE [SEQ] w6 in
   let w8 = GEN_ALL (BETA_RULE w7) in
   (REPEAT STRIP_TAC) THEN
   (CHOOSE_TAC (UNDISCH (SPEC_ALL w8))) THEN
   (EXISTS_TAC `SUC N`) THEN
   (ASM_SIMP_TAC [ARITH_RULE `n' >= SUC n ==> n' >= n`])
)

let RHS_4_LT_ONE_MESSY = PROVE(
   `?p0. !p. p > 1 ==> p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
   let c1 = ONCE_REWRITE_RULE [ UNDISCH JESSE_POW_LEMMA ] RHS_4_BOUND in
   let c2 = SPECL [`real_pow (&(PRE (LENGTH (c:(real)list)))) (p-1)`]
   REAL_MUL_SYM in
   let c3 = ONCE_REWRITE_RULE [ c2] c1 in
   let c4 = ONCE_REWRITE_RULE [ GSYM REAL_MUL_ASSOC ] c3 in
   let c5 = ONCE_REWRITE_RULE [ GSYM REAL_POW_MUL ] c4 in
   let c6 = ONCE_REWRITE_RULE [REAL_MUL_SYM] (CONJUNCT2 real_pow) in
   let c7 = ONCE_REWRITE_RULE [GSYM c6] c5 in
   let c8 = REAL_ARITH `!x. (real_of_num 1)/x = inv x` in
   let c9 = ONCE_REWRITE_RULE [c8] c7 in
   let c10 = REAL_ARITH `!x y z.(inv x) * y * z = y * inv x * z` in
   let c11 = ONCE_REWRITE_RULE [c10] c9 in
   let t0 =
    `sum (1..PRE (LENGTH c)) & *
     max_abs c *
     (exp (&(PRE (LENGTH c)))) *
     &(PRE (LENGTH c)) pow PRE (LENGTH c)` in
   let t1 = `real_of_num (PRE (LENGTH (c:(real)list))) pow SUC (PRE (LENGTH c))`
   in
   let int0 = SPECL [t0;t1;`real_of_num 1`]  OLDGERMAN_LEMMA in
   let int1 = SIMP_RULE [REAL_ARITH `(real_of_num 0) < &1`] int0 in
   let int2 = SIMP_RULE [REAL_ARITH `x - (real_of_num 0) = x`] int1 in
   let t8 = `!n. n >= N
        ==> abs
            ((sum (1..PRE (LENGTH c)) & *
              max_abs c *
              (exp (&(PRE (LENGTH c)))) *
              &(PRE (LENGTH c)) pow PRE (LENGTH c)) *
             inv (&(FACT n)) *
             &(PRE (LENGTH c)) pow SUC (PRE (LENGTH c)) pow n) <
            &1` in
   let int5 = ASSUME t8 in
   let int50 = REAL_ARITH `((x:real) * y * z * w) * (a * b) = x * y * z * w * a *
   b` in
   let int51 = ONCE_REWRITE_RULE [int50] int5 in
   let int6 = SPEC `p - 1` int51 in
   let int7 = ARITH_RULE ` (p > N ==> p - 1 >= N)` in
   let int8 = UNDISCH (IMP_TRANS int7 int6) in
   let int9 = ARITH_RULE `(x:real) <= y ==> y < (real_of_num 1) ==> x < (&1)` in
   let int10 = MATCH_MP JESSE_REAL_ABS_LE c11 in
   let int11 = MATCH_MP int9 int10 in
   let int12 = MP int11 int8 in
   (CHOOSE_TAC int2) THEN
   (EXISTS_TAC `N:num`) THEN
   (STRIP_TAC) THEN
   (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [ARITH_RULE `p > 0 ==> ((p:num)  > N <=> p - 1 >= N)`]) THEN
   (DISCH_TAC) THEN
   (MATCH_ACCEPT_TAC int12)
)
let LT_ONE = PROVE(
        `!c. ?p0. !p. p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
    STRIP_TAC THEN (CHOOSE_TAC RHS_4_LT_ONE_MESSY) THEN (EXISTS_TAC `SUC p0`) THEN
    (ASM_MESON_TAC [ARITH_RULE `p > SUC p0 ==> (p > p0 /\ p > 1)`])
)
end;;
```
### Informal statement
For all real numbers `x` and `y`, if `abs x` is less than or equal to `y`, then `abs x` is less than or equal to `abs y`.

### Informal sketch
- The proof starts by using the theorem `REAL_ARITH \`(real_abs x) <= y ==>  y = real_abs y\`` to rewrite `y` to `real_abs y` in the assumption `abs x <= y`.
- Then it simplifies the goal using the rewritten assumption.

### Mathematical insight
This theorem states that if the absolute value of `x` is less than or equal to `y`, then it is also less than or equal to the absolute value of `y`. It's a basic property related to absolute values, stating that absolute values are non-negative and any number greater than them must have an absolute value also greater or equal.

### Dependencies
- Theorem: `REAL_ARITH \`(real_abs x) <= y ==>  y = real_abs y\``

### Name of formal statement
OLDGERMAN_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let JESSE_POW_LEMMA = PROVE(
     `(p:num) > 1 ==> !x.real_pow x p = x * (real_pow x (p-1))`,
     let c0 = UNDISCH (ARITH_RULE `(p:num) > 1 ==> p = SUC (p - 1) `) in
     STRIP_TAC THEN STRIP_TAC THEN
     (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [c0]))) THEN
     (SIMP_TAC [real_pow])
)
let JESSE_REAL_ABS_LE = PROVE(
    `!(x:real) y.(abs x) <= y ==> (abs x) <= (abs y)`,
    let int10 = UNDISCH (REAL_ARITH `(real_abs x) <= y ==>  y = real_abs y`) in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [GSYM int10])
)
let OLDGERMAN_LEMMA = PROVE(
  ` !C2 C e.
        &0 < e
        ==> (?N . !n. n >= N ==>
        abs (C2 * inv (&(FACT n)) * C pow n - &0) < e)`,
   let w0 = MATCH_MP SUM_SUMMABLE (SPEC `C:real` REAL_EXP_CONVERGES) in
   let w1 = MATCH_MP SER_ZERO w0 in
   let w2 = BETA_RULE w1 in
   let w3 = SPEC `C2:real` SEQ_CONST in
   let w4 = CONJ w3 w2 in
   let w5 = BETA_RULE (MATCH_MP SEQ_MUL w4) in
   let w6 = ONCE_REWRITE_RULE [REAL_ARITH `(C2:real) * (&0) = &0`] w5 in
   let w7 = ONCE_REWRITE_RULE [SEQ] w6 in
   let w8 = GEN_ALL (BETA_RULE w7) in
   (REPEAT STRIP_TAC) THEN
   (CHOOSE_TAC (UNDISCH (SPEC_ALL w8))) THEN
   (EXISTS_TAC `SUC N`) THEN
   (ASM_SIMP_TAC [ARITH_RULE `n' >= SUC n ==> n' >= n`])
)

let RHS_4_LT_ONE_MESSY = PROVE(
   `?p0. !p. p > 1 ==> p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
   let c1 = ONCE_REWRITE_RULE [ UNDISCH JESSE_POW_LEMMA ] RHS_4_BOUND in
   let c2 = SPECL [`real_pow (&(PRE (LENGTH (c:(real)list)))) (p-1)`]
   REAL_MUL_SYM in
   let c3 = ONCE_REWRITE_RULE [ c2] c1 in
   let c4 = ONCE_REWRITE_RULE [ GSYM REAL_MUL_ASSOC ] c3 in
   let c5 = ONCE_REWRITE_RULE [ GSYM REAL_POW_MUL ] c4 in
   let c6 = ONCE_REWRITE_RULE [REAL_MUL_SYM] (CONJUNCT2 real_pow) in
   let c7 = ONCE_REWRITE_RULE [GSYM c6] c5 in
   let c8 = REAL_ARITH `!x. (real_of_num 1)/x = inv x` in
   let c9 = ONCE_REWRITE_RULE [c8] c7 in
   let c10 = REAL_ARITH `!x y z.(inv x) * y * z = y * inv x * z` in
   let c11 = ONCE_REWRITE_RULE [c10] c9 in
   let t0 =
    `sum (1..PRE (LENGTH c)) & *
     max_abs c *
     (exp (&(PRE (LENGTH c)))) *
     &(PRE (LENGTH c)) pow PRE (LENGTH c)` in
   let t1 = `real_of_num (PRE (LENGTH (c:(real)list))) pow SUC (PRE (LENGTH c))`
   in
   let int0 = SPECL [t0;t1;`real_of_num 1`]  OLDGERMAN_LEMMA in
   let int1 = SIMP_RULE [REAL_ARITH `(real_of_num 0) < &1`] int0 in
   let int2 = SIMP_RULE [REAL_ARITH `x - (real_of_num 0) = x`] int1 in
   let t8 = `!n. n >= N
        ==> abs
            ((sum (1..PRE (LENGTH c)) & *
              max_abs c *
              (exp (&(PRE (LENGTH c)))) *
              &(PRE (LENGTH c)) pow PRE (LENGTH c)) *
             inv (&(FACT n)) *
             &(PRE (LENGTH c)) pow SUC (PRE (LENGTH c)) pow n) <
            &1` in
   let int5 = ASSUME t8 in
   let int50 = REAL_ARITH `((x:real) * y * z * w) * (a * b) = x * y * z * w * a *
   b` in
   let int51 = ONCE_REWRITE_RULE [int50] int5 in
   let int6 = SPEC `p - 1` int51 in
   let int7 = ARITH_RULE ` (p > N ==> p - 1 >= N)` in
   let int8 = UNDISCH (IMP_TRANS int7 int6) in
   let int9 = ARITH_RULE `(x:real) <= y ==> y < (real_of_num 1) ==> x < (&1)` in
   let int10 = MATCH_MP JESSE_REAL_ABS_LE c11 in
   let int11 = MATCH_MP int9 int10 in
   let int12 = MP int11 int8 in
   (CHOOSE_TAC int2) THEN
   (EXISTS_TAC `N:num`) THEN
   (STRIP_TAC) THEN
   (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [ARITH_RULE `p > 0 ==> ((p:num)  > N <=> p - 1 >= N)`]) THEN
   (DISCH_TAC) THEN
   (MATCH_ACCEPT_TAC int12)
)
let LT_ONE = PROVE(
        `!c. ?p0. !p. p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
    STRIP_TAC THEN (CHOOSE_TAC RHS_4_LT_ONE_MESSY) THEN (EXISTS_TAC `SUC p0`) THEN
    (ASM_MESON_TAC [ARITH_RULE `p > SUC p0 ==> (p > p0 /\ p > 1)`])
)
end;;
```
### Informal statement
For all real numbers `C2` and `C` and for all positive real numbers `e`, there exists a natural number `N` such that for all natural numbers `n`, if `n` is greater than or equal to `N`, then the absolute value of `C2 * inv (&(FACT n)) * C pow n - &0` is less than `e`.

### Informal sketch
- The proof uses the theorem `REAL_EXP_CONVERGES` stating that the exponential series converges. It instantiates this theorem with `C:real`, multiplies by `C2`, uses the fact that `C2 * 0 = 0`, and obtains a universally quantified statement.
- It introduces the existential `SUC N`, where `N` is obtained from specializing the universally quantified statement, generated by `REAL_EXP_CONVERGES`.
- Simplifies the goal using the assumption `n' >= SUC n ==> n' >= n`.

### Mathematical insight
The theorem states that the series `C2 * C^n / n!` converges to zero as `n` approaches infinity. The formalization uses `FACT n` to denote the factorial of `n`, `inv` to denote the inverse, and `pow` to denote exponentiation. This is a direct application of the convergence of the Taylor series of the exponential function.

### Dependencies
- Theorem: `REAL_EXP_CONVERGES`
- Theorem: `SER_ZERO`
- Theorem: `SEQ_CONST`
- Theorem: `SEQ_MUL`
- Theorem: `REAL_ARITH \`(C2:real) * (&0) = &0\``
- Theorem: `SEQ`

### Name of formal statement
RHS_4_LT_ONE_MESSY

### Type of the formal statement
theorem

### Formal Content
```ocaml
let JESSE_POW_LEMMA = PROVE(
     `(p:num) > 1 ==> !x.real_pow x p = x * (real_pow x (p-1))`,
     let c0 = UNDISCH (ARITH_RULE `(p:num) > 1 ==> p = SUC (p - 1) `) in
     STRIP_TAC THEN STRIP_TAC THEN
     (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [c0]))) THEN
     (SIMP_TAC [real_pow])
)
let JESSE_REAL_ABS_LE = PROVE(
    `!(x:real) y.(abs x) <= y ==> (abs x) <= (abs y)`,
    let int10 = UNDISCH (REAL_ARITH `(real_abs x) <= y ==>  y = real_abs y`) in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [GSYM int10])
)
let OLDGERMAN_LEMMA = PROVE(
  ` !C2 C e.
        &0 < e
        ==> (?N . !n. n >= N ==>
        abs (C2 * inv (&(FACT n)) * C pow n - &0) < e)`,
   let w0 = MATCH_MP SUM_SUMMABLE (SPEC `C:real` REAL_EXP_CONVERGES) in
   let w1 = MATCH_MP SER_ZERO w0 in
   let w2 = BETA_RULE w1 in
   let w3 = SPEC `C2:real` SEQ_CONST in
   let w4 = CONJ w3 w2 in
   let w5 = BETA_RULE (MATCH_MP SEQ_MUL w4) in
   let w6 = ONCE_REWRITE_RULE [REAL_ARITH `(C2:real) * (&0) = &0`] w5 in
   let w7 = ONCE_REWRITE_RULE [SEQ] w6 in
   let w8 = GEN_ALL (BETA_RULE w7) in
   (REPEAT STRIP_TAC) THEN
   (CHOOSE_TAC (UNDISCH (SPEC_ALL w8))) THEN
   (EXISTS_TAC `SUC N`) THEN
   (ASM_SIMP_TAC [ARITH_RULE `n' >= SUC n ==> n' >= n`])
)

let RHS_4_LT_ONE_MESSY = PROVE(
   `?p0. !p. p > 1 ==> p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
   let c1 = ONCE_REWRITE_RULE [ UNDISCH JESSE_POW_LEMMA ] RHS_4_BOUND in
   let c2 = SPECL [`real_pow (&(PRE (LENGTH (c:(real)list)))) (p-1)`]
   REAL_MUL_SYM in
   let c3 = ONCE_REWRITE_RULE [ c2] c1 in
   let c4 = ONCE_REWRITE_RULE [ GSYM REAL_MUL_ASSOC ] c3 in
   let c5 = ONCE_REWRITE_RULE [ GSYM REAL_POW_MUL ] c4 in
   let c6 = ONCE_REWRITE_RULE [REAL_MUL_SYM] (CONJUNCT2 real_pow) in
   let c7 = ONCE_REWRITE_RULE [GSYM c6] c5 in
   let c8 = REAL_ARITH `!x. (real_of_num 1)/x = inv x` in
   let c9 = ONCE_REWRITE_RULE [c8] c7 in
   let c10 = REAL_ARITH `!x y z.(inv x) * y * z = y * inv x * z` in
   let c11 = ONCE_REWRITE_RULE [c10] c9 in
   let t0 =
    `sum (1..PRE (LENGTH c)) & *
     max_abs c *
     (exp (&(PRE (LENGTH c)))) *
     &(PRE (LENGTH c)) pow PRE (LENGTH c)` in
   let t1 = `real_of_num (PRE (LENGTH (c:(real)list))) pow SUC (PRE (LENGTH c))`
   in
   let int0 = SPECL [t0;t1;`real_of_num 1`]  OLDGERMAN_LEMMA in
   let int1 = SIMP_RULE [REAL_ARITH `(real_of_num 0) < &1`] int0 in
   let int2 = SIMP_RULE [REAL_ARITH `x - (real_of_num 0) = x`] int1 in
   let t8 = `!n. n >= N
        ==> abs
            ((sum (1..PRE (LENGTH c)) & *
              max_abs c *
              (exp (&(PRE (LENGTH c)))) *
              &(PRE (LENGTH c)) pow PRE (LENGTH c)) *
             inv (&(FACT n)) *
             &(PRE (LENGTH c)) pow SUC (PRE (LENGTH c)) pow n) <
            &1` in
   let int5 = ASSUME t8 in
   let int50 = REAL_ARITH `((x:real) * y * z * w) * (a * b) = x * y * z * w * a *
   b` in
   let int51 = ONCE_REWRITE_RULE [int50] int5 in
   let int6 = SPEC `p - 1` int51 in
   let int7 = ARITH_RULE ` (p > N ==> p - 1 >= N)` in
   let int8 = UNDISCH (IMP_TRANS int7 int6) in
   let int9 = ARITH_RULE `(x:real) <= y ==> y < (real_of_num 1) ==> x < (&1)` in
   let int10 = MATCH_MP JESSE_REAL_ABS_LE c11 in
   let int11 = MATCH_MP int9 int10 in
   let int12 = MP int11 int8 in
   (CHOOSE_TAC int2) THEN
   (EXISTS_TAC `N:num`) THEN
   (STRIP_TAC) THEN
   (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [ARITH_RULE `p > 0 ==> ((p:num)  > N <=> p - 1 >= N)`]) THEN
   (DISCH_TAC) THEN
   (MATCH_ACCEPT_TAC int12)
)
let LT_ONE = PROVE(
        `!c. ?p0. !p. p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
    STRIP_TAC THEN (CHOOSE_TAC RHS_4_LT_ONE_MESSY) THEN (EXISTS_TAC `SUC p0`) THEN
    (ASM_MESON_TAC [ARITH_RULE `p > SUC p0 ==> (p > p0 /\ p > 1)`])
)
end;;
```
### Informal statement
There exists a natural number `p0` such that for all natural numbers `p`, if `p` is greater than 1 and `p` is greater than `p0`, then the absolute value of `RHS c (g (PRE (LENGTH c)) p)` is less than 1.

### Informal sketch
- Starts by rewriting the goal using `JESSE_POW_LEMMA` and several algebraic manipulations to rearrange terms inside the absolute value. The goal is rewritten using a constant `t0` and `t1`. It also instantiates `OLDGERMAN_LEMMA`.
- Chooses an `N` from `int2`, and shows that `abs (RHS c (g (PRE (LENGTH c)) p)` is less than one, using the previously instantiated `OLDGERMAN_LEMMA` and several `REAL_ARITH` rules.
- The proof involves rewriting using lemmas such as `JESSE_POW_LEMMA` and `OLDGERMAN_LEMMA`.
- Finally, some arithmetic reasoning finishes the proof.

### Mathematical insight
This theorem is complex and context-dependent, related to bounding the absolute value of a certain function `RHS` under specific conditions.

### Dependencies
- Theorem: `JESSE_POW_LEMMA`
- Theorem: `OLDGERMAN_LEMMA`
- Theorem: `JESSE_REAL_ABS_LE`
- Definition/Theorem: `RHS`
- Definition/Theorem: `g`
- Theorem: `REAL_MUL_SYM`
- Theorem: `REAL_MUL_ASSOC`
- Theorem: `REAL_POW_MUL`
- Theorem: `real_pow`
- Theorem: `REAL_ARITH \`!x. (real_of_num 1)/x = inv x\``
- Theorem: `REAL_ARITH \`!x y z.(inv x) * y * z = y * inv x * z\``
- Theorem: `sum`
- Theorem: `FACT`

### Name of formal statement
LT_ONE

### Type of the formal statement
theorem

### Formal Content
```ocaml
let JESSE_POW_LEMMA = PROVE(
     `(p:num) > 1 ==> !x.real_pow x p = x * (real_pow x (p-1))`,
     let c0 = UNDISCH (ARITH_RULE `(p:num) > 1 ==> p = SUC (p - 1) `) in
     STRIP_TAC THEN STRIP_TAC THEN
     (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [c0]))) THEN
     (SIMP_TAC [real_pow])
)
let JESSE_REAL_ABS_LE = PROVE(
    `!(x:real) y.(abs x) <= y ==> (abs x) <= (abs y)`,
    let int10 = UNDISCH (REAL_ARITH `(real_abs x) <= y ==>  y = real_abs y`) in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [GSYM int10])
)
let OLDGERMAN_LEMMA = PROVE(
  ` !C2 C e.
        &0 < e
        ==> (?N . !n. n >= N ==>
        abs (C2 * inv (&(FACT n)) * C pow n - &0) < e)`,
   let w0 = MATCH_MP SUM_SUMMABLE (SPEC `C:real` REAL_EXP_CONVERGES) in
   let w1 = MATCH_MP SER_ZERO w0 in
   let w2 = BETA_RULE w1 in
   let w3 = SPEC `C2:real` SEQ_CONST in
   let w4 = CONJ w3 w2 in
   let w5 = BETA_RULE (MATCH_MP SEQ_MUL w4) in
   let w6 = ONCE_REWRITE_RULE [REAL_ARITH `(C2:real) * (&0) = &0`] w5 in
   let w7 = ONCE_REWRITE_RULE [SEQ] w6 in
   let w8 = GEN_ALL (BETA_RULE w7) in
   (REPEAT STRIP_TAC) THEN
   (CHOOSE_TAC (UNDISCH (SPEC_ALL w8))) THEN
   (EXISTS_TAC `SUC N`) THEN
   (ASM_SIMP_TAC [ARITH_RULE `n' >= SUC n ==> n' >= n`])
)

let RHS_4_LT_ONE_MESSY = PROVE(
   `?p0. !p. p > 1 ==> p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
   let c1 = ONCE_REWRITE_RULE [ UNDISCH JESSE_POW_LEMMA ] RHS_4_BOUND in
   let c2 = SPECL [`real_pow (&(PRE (LENGTH (c:(real)list)))) (p-1)`]
   REAL_MUL_SYM in
   let c3 = ONCE_REWRITE_RULE [ c2] c1 in
   let c4 = ONCE_REWRITE_RULE [ GSYM REAL_MUL_ASSOC ] c3 in
   let c5 = ONCE_REWRITE_RULE [ GSYM REAL_POW_MUL ] c4 in
   let c6 = ONCE_REWRITE_RULE [REAL_MUL_SYM] (CONJUNCT2 real_pow) in
   let c7 = ONCE_REWRITE_RULE [GSYM c6] c5 in
   let c8 = REAL_ARITH `!x. (real_of_num 1)/x = inv x` in
   let c9 = ONCE_REWRITE_RULE [c8] c7 in
   let c10 = REAL_ARITH `!x y z.(inv x) * y * z = y * inv x * z` in
   let c11 = ONCE_REWRITE_RULE [c10] c9 in
   let t0 =
    `sum (1..PRE (LENGTH c)) & *
     max_abs c *
     (exp (&(PRE (LENGTH c)))) *
     &(PRE (LENGTH c)) pow PRE (LENGTH c)` in
   let t1 = `real_of_num (PRE (LENGTH (c:(real)list))) pow SUC (PRE (LENGTH c))`
   in
   let int0 = SPECL [t0;t1;`real_of_num 1`]  OLDGERMAN_LEMMA in
   let int1 = SIMP_RULE [REAL_ARITH `(real_of_num 0) < &1`] int0 in
   let int2 = SIMP_RULE [REAL_ARITH `x - (real_of_num 0) = x`] int1 in
   let t8 = `!n. n >= N
        ==> abs
            ((sum (1..PRE (LENGTH c)) & *
              max_abs c *
              (exp (&(PRE (LENGTH c)))) *
              &(PRE (LENGTH c)) pow PRE (LENGTH c)) *
             inv (&(FACT n)) *
             &(PRE (LENGTH c)) pow SUC (PRE (LENGTH c)) pow n) <
            &1` in
   let int5 = ASSUME t8 in
   let int50 = REAL_ARITH `((x:real) * y * z * w) * (a * b) = x * y * z * w * a *
   b` in
   let int51 = ONCE_REWRITE_RULE [int50] int5 in
   let int6 = SPEC `p - 1` int51 in
   let int7 = ARITH_RULE ` (p > N ==> p - 1 >= N)` in
   let int8 = UNDISCH (IMP_TRANS int7 int6) in
   let int9 = ARITH_RULE `(x:real) <= y ==> y < (real_of_num 1) ==> x < (&1)` in
   let int10 = MATCH_MP JESSE_REAL_ABS_LE c11 in
   let int11 = MATCH_MP int9 int10 in
   let int12 = MP int11 int8 in
   (CHOOSE_TAC int2) THEN
   (EXISTS_TAC `N:num`) THEN
   (STRIP_TAC) THEN
   (STRIP_TAC) THEN
   (ONCE_REWRITE_TAC [ARITH_RULE `p > 0 ==> ((p:num)  > N <=> p - 1 >= N)`]) THEN
   (DISCH_TAC) THEN
   (MATCH_ACCEPT_TAC int12)
)
let LT_ONE = PROVE(
        `!c. ?p0. !p. p> p0 ==> abs (RHS c (g (PRE (LENGTH c)) p)) < &1`,
    STRIP_TAC THEN (CHOOSE_TAC RHS_4_LT_ONE_MESSY) THEN (EXISTS_TAC `SUC p0`) THEN
    (ASM_MESON_TAC [ARITH_RULE `p > SUC p0 ==> (p > p0 /\ p > 1)`])
)
end;;
```
### Informal statement
For all `c`, there exists a natural number `p0` such that for all natural numbers `p`, if `p` is greater than `p0`, then the absolute value of `RHS c (g (PRE (LENGTH c)) p)` is less than 1.

### Informal sketch
- The proof involves choosing a `p0` based on `RHS_4_LT_ONE_MESSY` and uses arithmetic reasoning, specifically `ARITH_RULE \`p > SUC p0 ==> (p > p0 /\ p > 1)\`` to discharge the condition.

### Mathematical insight
This theorem states that for any `c`, the expression `abs (RHS c (g (PRE (LENGTH c)) p))` becomes less than 1 when `p` is sufficiently large.

### Dependencies
- Theorem: `RHS_4_LT_ONE_MESSY`


---

## N_IS_INT

### Name of formal statement
N_IS_INT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all real numbers `n`, `n` is an integer.

### Informal sketch
The proof uses `MESON_TAC` with the single assumption `is_int`.

### Mathematical insight
This theorem states a foundational property: all real numbers represented in HOL Light are integers. This depends on the underlying representation of real numbers and integers in HOL Light.

### Dependencies
- Theorems:
  - `is_int`

---
### Name of formal statement
NEG_N_IS_INT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all real numbers `n`, `--(&n)` is an integer.

### Informal sketch
The proof uses `MESON_TAC` with the single assumption `is_int`.

### Mathematical insight
This theorem states a foundational property, related to `N_IS_INT` that the negative of any real number in HOL Light, represented as `--(&n)`, is an integer. This is tightly linked to how real numbers and integers, as well as negation, are represented in HOL Light.

### Dependencies
- Theorems:
  - `is_int`

---
### Name of formal statement
INT_OF_REAL_ADD

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all real numbers `x` and `y`, if `x` is an integer and `y` is an integer, then `int_of_real (x + y)` equals `(int_of_real x) + (int_of_real y)`.

### Informal sketch
The proof uses `SIMP_TAC` with a list of theorems related to integers, addition, and representation: `integer`, `int_add`, `int_rep`, `N_IS_INT`, and `NEG_N_IS_INT`. The tactic likely simplifies the expression using the given theorems to arrive at the desired equality.

### Mathematical insight
This theorem asserts that the `int_of_real` function, when applied to the sum of two integers represented as real numbers, is equivalent to the sum of the `int_of_real` values of each number. This expresses a homomorphism property of `int_of_real` over addition, critical for reasoning about integer arithmetic within the real number system.

### Dependencies
- Theorems:
  - `integer`
  - `int_add`
  - `int_rep`
  - `N_IS_INT`
  - `NEG_N_IS_INT`

---
### Name of formal statement
INT_OF_REAL_MUL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all real numbers `x` and `y`, if `x` is an integer and `y` is an integer, then `int_of_real (x * y)` equals `(int_of_real x) * (int_of_real y)`.

### Informal sketch
The proof uses `SIMP_TAC` with a curated list of simplifications related to integers and multiplication: `is_int`, `int_mul`, `int_rep`, `N_IS_INT`, and `NEG_N_IS_INT`. The intention is to reduce the initial expression to the final equation via simplification.

### Mathematical insight
This theorem, mirroring `INT_OF_REAL_ADD`, establishes that the `int_of_real` function preserves multiplication across integers. This is another key homomorphism property, guaranteeing that integer multiplication behaves consistently when viewed through the lens of real number representations and conversions.

### Dependencies
- Theorems:
  - `is_int`
  - `int_mul`
  - `int_rep`
  - `N_IS_INT`
  - `NEG_N_IS_INT`

---
### Name of formal statement
INT_OF_REAL_CONV_helper

### Type of the formal statement
recursive function definition

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
The recursive function `INT_OF_REAL_CONV_helper` takes a term `t` as input and returns a triple consisting of:
  - an expression,
  - a list of real sub-terms, and
  - a list of variable terms.

The function recursively traverses the term `t`:
  - If `t` is a variable, it returns (`int_of_real t`, [], [`t`]).
  - If the operator of `t` is `real_of_num`, it returns (`int_of_real t`, [`t`], []).
  - If the operator of `t` is `real_neg`, it recursively processes the operand `rand1` of `t`, and returns (`int_neg expr1`, `lst1 @ [t]`, `lst2`), where `expr1`, `lst1`, and `lst2` are the results of processing `rand1`.
  - If the operator of `t` is `real_pow`, it recursively processes the base `rand1` of `t`, and returns (`int_pow expr1 exponent`, `lst1 @ [t]`, `lst2`), where `expr1`, `lst1`, and `lst2` are the results of processing `rand1`, and `exponent` is the exponent of the power operation.
  - If the operator of `t` is `real_add`, `real_mul`, or `real_sub`, it recursively processes both operands `rand1` and `rand2` of `t`, transforms the operator to its integer counterpart `int_op`, and returns (`int_op expr1 expr2`, `lst11 @ lst21 @ [t]`, `lst12 @ lst22`), where `expr1`, `lst11`, `lst12` are results of processing `rand1`, and `expr2`, `lst21`, `lst22` are results of processing `rand2`.
  - Otherwise, it returns (`t`, [], [`t`]).

### Informal sketch
The function `INT_OF_REAL_CONV_helper` recursively descends into a real-valued term, converting it to an equivalent term that expresses the computation using integer operations instead of real operations. It also collects real sub-terms and unmatched variable terms encountered during the traversal.

  - The base case for variables creates an application term `int_of_real t` and places `t` in the unmatched list.
  - Another base case, when the operator is `real_of_num`, creates an application term `int_of_real t` and places the term `t` in the real sub-terms.
  - When encountering negation (`real_neg t`), recursively process the argument, then applies the `int_neg` operation.
  - When encountering `real_pow t`, recursively process the base, then applies the `int_pow` operation, keeping the exponent.
  - When encountering binary operations like `real_add`, `real_mul`, and `real_sub`, recursively process both operands, finds the matching integer operation (e.g., `int_add` for `real_add`), and uses this for recursive construction.
  - If none of the above conditions are matched, then the term `t` is returned, untouched, along with empty sub-list of real sub-terms and the term `t` in the "unmatched" list.

### Mathematical insight
This function systematically transforms real expressions into integer expressions, which is a critical step for proving theorems relating real and integer arithmetic. The collection of sub-terms provides information needed by the main conversion function.

### Dependencies
- None

---
### Name of formal statement
INT_OF_REAL_CONV

### Type of the formal statement
function definition

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
The function `INT_OF_REAL_CONV` takes a term `t` and returns a theorem of the form `assumptions |- t = t'`, where `t'` is an integer term derived from `t`.

The function first uses `INT_OF_REAL_CONV_helper` to obtain an initial expression `exp`, a list of real sub-terms `real_sub_terms`, and a list of variable terms `is_int_assumpts`. It converts the variable terms into assumptions of the form `integer x`. It then rewrites the initial expression `exp` using `int_of_num`, converts the rewritten expression to an equivalent expressed using `real_of_int`, simplifies the expression with a list of theorems like `int_pow_th`, `int_add_th`, and `int_of_num_th`, discharging the created assumptions about the contained variable terms. The final result of this process has a `final_tweak` applied before it is returned.

### Informal sketch
The function `INT_OF_REAL_CONV` performs a conversion from a real-valued term to an integer-valued term, and proves the equivalence between the original and converted terms.

- It begins by using `INT_OF_REAL_CONV_helper` which recursively descends into the term, converting each real operation to an integer operation, generating a term `exp`, a list of real sub-terms and a list of "is_int" assumptions about the "unconverted" part of the term.
- It then converts the `is_int_assumpts` variable terms into assumptions, using `integer x`.
- It then rewrites `exp` using `int_of_num` to simplify its form, resulting in `fexp`, and converts it to an expression with `real_of_int`, named `rexp`.
- The core of the proof involves rewriting `rexp` using simplification theorems for integer arithmetic (`int_pow_th`, `int_add_th`, etc.) to establish a clean relationship between the original real expression and its integer counterpart, discharging generated assumptions about the integer status of the involved variable terms.
- It applies a final rewrite related to `real_of_int x = y ==> int_of_real y = x`.

### Mathematical insight
This function automates a significant aspect of reasoning about the relationship between real and integer arithmetic, by providing a mechanism to convert and prove the equivalence of related expressions.

### Dependencies
- Theorems:
  - `int_tybij`
  - `int_pow_th`
  - `int_add_th`
  - `int_mul_th`
  - `int_sub_th`
  - `int_neg_th`
  - `int_of_num_th`
- Functions:
  - `INT_OF_REAL_CONV_helper`

### Porting notes
The `MATCH_MP` step might be complex.

---
### Name of formal statement
ALL_IS_INT

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `h` and `t`, where `t` is a list, if all elements in the list constructed by adding `h` to the head of `t` are integers, then `h` is an integer and all elements in `t` are integers.

### Informal sketch
The proof uses `SIMP_TAC` with the single assumption `ALL`. This probably unfolds the definition of `ALL` for lists.

### Mathematical insight
This theorem decomposes the `ALL integer` predicate over list constructed by `CONS`, providing a way to reason about integer properties of lists in a structural, inductive manner.

### Dependencies
- Theorems:
  - `ALL`

---
### Name of formal statement
ALL_IS_INT_POLY_ADD

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `p1` and `p2`, where `p1` and `p2` are lists of real numbers, if all elements in `p1` are integers and all elements in `p2` are integers, then all elements in the list resulting from appending `p1` and `p2` are integers.

### Informal sketch
The proof uses list induction and simplification, along with a lemma INTEGER_ADD that states integers are closed under addition..

- First, lemmas lem01 and lem04 are created that specialize the theorem ALL_IS_INT with specific values.
- From lem01 and lem04, the theorems lem07 (expressing h is an integer and h' is an integer) is built and passed to INTEGER_ADD resulting in `h + h'` is an integer.
- To proceed with list induction, we need to prove the property holds when a list `t` is appended to another list `p2`, so the lemma expressing this is assumed and specialized. Base and inductive cases for list induction apply similarly.
- Several rewrites with `poly_add`, `NOT_CONS_NIL`, `HD`, `TL` are applied to arrive at a state where `ACCEPT_TAC` can be used to accept the result.
- `STRIP_TAC`, `ALL`, and `CONJ_TAC` are also used to manipulate the goal configurations towards the final result.

### Mathematical insight
This theorem states that if all elements of two lists are integers, then all elements of their concatenation are also integers. This is a fundamental property when reasoning about lists of integers and their manipulation.

### Dependencies
- Theorems:
  - `ALL_IS_INT`
  - `INTEGER_ADD`
  - `poly_add`
  - `HD`
  - `TL`
  - `NOT_CONS_NIL`
  - `ALL`

---
### Name of formal statement
ALL_IS_INT_POLY_CMUL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `p` and `c`, where `p` is a list of real numbers and `c` is a real number, if `c` is an integer and all elements in `p` are integers, then all elements in the list resulting from scalar multiplication of `c` with `p` are integers. Here the scalar multiplication of `c` and `[a; b; ...]` results in `[c*a; c*b; ...]`.

### Informal sketch
The proof proceeds by list induction. The base case is handled directly. In the inductive case, it uses the assumption that the elements of the list are integers, the fact that `c` is an integer, and applies `INTEGER_MUL` to show that the scaled list also contains only integers. Simplification using `poly_cmul` and `ALL` are also applied.

### Mathematical insight
This theorem states that scalar multiplication of a list of integers by an integer results in another list of integers. This captures the closure property of integer lists under scalar multiplication.

### Dependencies
- Theorems:
  - `INTEGER_MUL`
  - `poly_cmul`
  - `ALL`

---
### Name of formal statement
ALL_IS_INT_POLY_MUL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `p1` and `p2`, where `p1` and `p2` are lists of real numbers, if all elements in `p1` are integers and all elements in `p2` are integers, then all elements in the list resulting from multiplying `p1` and `p2` as polynomials (i.e., the convolution of the two lists) are integers.

### Informal sketch
The proof utilizes list induction and simplification tactics, along with the theorems `INTEGER_MUL`, `ALL_IS_INT_POLY_CMUL`, and `ALL_IS_INT_POLY_ADD`. Several lemmas concerning properties of `ALL integer` and `CONS` are constructed and applied.
- Induct on the polynomial `p1`, considering cases `[]` and `CONS h t`.
- The base case is handled, where `poly_mul` is zero, so integers is trivial.
- The inductive step inducts with the argument list, `p2`.

### Mathematical insight
This theorem expresses that the polynomial multiplication of two lists of integers results in a list that only contains integers.

### Dependencies
- Theorems:
  - `ALL_IS_INT`
  - `INTEGER_MUL`
  - `ALL_IS_INT_POLY_CMUL`
  - `ALL_IS_INT_POLY_ADD`
  - `poly_mul`
  - `poly_cmul`
  - `HD`
  - `TL`
  - `N_IS_INT`
  - `ALL`

---
### Name of formal statement
NOT_POLY_MUL_ITER_NIL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural numbers `n`, the polynomial generated by `poly_mul_iter (\i. [-- &i; &1]) n` is not the empty list.

### Informal sketch
The proof is by induction on `n`. It rewrites the goal using `Pm_eqn5.POLY_MUL_ITER` and `NOT_CONS_NIL` for the base case, and uses a derived lemma `lem04` in the inductive step with the same `POLY_MUL_ITER` rewrite. `SIMP_TAC` is used extensively to simplify the goal, and the inductive step is simplified using `lem04`.
NOT_POLY_MUL_NIL states that `~([-- &(SUC n); &1] = [])`

### Mathematical insight
This theorem establishes that the polynomial resulting from iterating a polynomial multiplication is never empty. This is likely used to avoid cases where polynomial operations are undefined for empty polynomials.

### Dependencies
- Theorems:
  - `Pm_eqn5.POLY_MUL_ITER`
  - `NOT_CONS_NIL`
  - `NOT_POLY_MUL_NIL`

---
### Name of formal statement
ALL_IS_INT_POLY_MUL_ITER

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural numbers `n`, every element in the list created by `poly_mul_iter (\i. [-- &i; &1]) n` is an integer.

### Informal sketch
The proof is by induction on `n`.

- The base case rewrites the goal with `Pm_eqn5.POLY_MUL_ITER` and then uses `ALL`, `N_IS_INT` to show elements are integers.
- In the inductive step, rewrites with `Pm_eqn5.POLY_MUL_ITER` (followed by `BETA_TAC`), then applies `ALL_IS_INT_POLY_MUL`, and utilizes a helper lemma that `ALL integer [-- &(SUC n); &1]` along the way for integer typing.

### Mathematical insight
This theorem is important because it asserts that the `poly_mul_iter` function, with the given lambda expression, always generates a list of integers, provided it starts with integers. This provides strong typing guarantees for subsequent operations on the resulting polynomial.

### Dependencies
- Theorems:
  - `Pm_eqn5.POLY_MUL_ITER`
  - `ALL`
  - `N_IS_INT`
  - `ALL_IS_INT_POLY_MUL`
- Auxiliary lemmas:
  - `ALL integer [-- &(SUC n); &1]`

---
### Name of formal statement
ALL_IS_INT_POLY_EXP

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural numbers `n` and any list of real numbers `p`, if every element in `p` is an integer, then every element in `poly_exp p n` is also an integer.

### Informal sketch
The proof is by induction on `n`. It uses lemmas about `ALL integer` and `poly_exp`, relies on `ALL_IS_INT_POLY_MUL`. Simplification tactics and rewriting are used to massage the goal into a form where `ACCEPT_TAC` can be used.

### Mathematical insight
This asserts that if a polynomial has integer coefficients then raising that polynomial to the non-negative power `n` will also result in a polynomial with integer coefficients.

### Dependencies
- Theorems:
  - `ALL_IS_INT_POLY_MUL`
  - `poly_exp`
  - `ALL`
  - `N_IS_INT`

---
### Name of formal statement
BLAHBLAH

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all lists `p1` and `p2` of real numbers, if the length of `p1` is less than or equal to the length of `p2`, then the polynomial `&0 ## p1 ++ p2` is equal to `p2`, where `&0 ## p1` is the scalar multiplication of `p1` by `&0`, the `++` symbols denotes list append, and polynomial denotes the polynomial as mathematical object.

### Informal sketch
Proof by list induction. List inductions are applied twice, and simplified by `LENGTH;poly_cmul;poly_add`,`REAL_ARITH` rewriting of `&0 * h + h' = h'`, and `ARITH_RULE` rewriting of `(SUC x) <= (SUC y) <=> x <= y`.

### Mathematical insight
Prepending a polynomial with zero coefficients does not change the value of the original polynomial.

### Dependencies
- Theorems:
  - `LENGTH`
  - `poly_cmul`
  - `poly_add`
  - `NOT_CONS_NIL`
  - `REAL_ARITH` applied to `&0 * h + h' = h'`
  - `ARITH_RULE` applied to `(SUC x) <= (SUC y) <=> x <= y`

---
### Name of formal statement
BLAHBLAH3

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural number `n`, real number `h` and a list of real numbers `t`, the length of `t` is less than or equal to the length of the polynomial `poly_exp [&0;&1] n ** CONS h t`.

### Informal sketch
The proof is by induction on `n`.
- The base case simplifies using facts about `poly_exp`, `poly_mul`, `poly_cmul`, `POLY_CMUL_LID`, and `LENGTH`, followed by `ARITH_TAC`.
- The inductive step transforms the goal using `POLY_EXP_X_REC`,`poly_mul`,`NOT_POLY_EXP_X_NIL`,`poly_cmul`,`poly_add`,`NOT_CONS_NIL`,`LENGTH`,`TL`. Then, the theorem `BLAHBLAH` is applied by `ASM_SIMP_TAC` and accepted with `ACCEPT_TAC lem08`.

### Mathematical insight
The length of the list `t` is dominated by the polynomial expression.

### Dependencies
- Theorems:
  - `POLY_EXP_X_REC`
  - `poly_mul`
  - `NOT_POLY_EXP_X_NIL`
  - `poly_cmul`
  - `poly_add`
  - `NOT_CONS_NIL`
  - `LENGTH`
  - `TL`
  - `BLAHBLAH`

---
### Name of formal statement
TELEVISION

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural number `n` and a list of real number `p`, if `p` is not an empty list, then the element at index `n` within the polynomial `poly_exp [&0;&1] n ** p` is equal to the head of `p`.

### Informal sketch
- `(SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES])` Simplifies the base-case by using the definition of `EL` and `poly_exp` to reduce the goal.
- `(LIST_INDUCT_TAC) THENL [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])]` Handles the case for when `n=0`.
The inductive step is handled with
- `(SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL])` reduces the goal
and then by applying the definition `El n`, `poly_mul` recursively.
- `LIST_INDUCT_TAC THENL[ (SIMP_TAC []); (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])` handles the recursive applications of the goal, with the critical lemma being the application of`lem` which is result of unifying the lemma on the polynomial with `BLAHBLAH3`, and the base case when `p` is a list.

### Mathematical insight
The theorem states that the `n`th coefficient of the polynomial can be determined by the coefficients of its component.

### Dependencies
- Theorems:
  - `EL`
  - `poly_exp`
  - `POLY_MUL_CLAUSES`
  - `NOT_CONS_NIL`
  - `POLY_CMUL_LID`
  - `POLY_EXP_X_REC`
  - `poly_mul`
  - `NOT_POLY_EXP_X_NIL`
  - `poly_cmul`
  - `poly_add`
  - `TL`
  - `HD`
  - `BLAHBLAH3`

---
### Name of formal statement
JOSHUA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural numbers `i` and `n`, and a list of real numbers `p`, if `p` is not empty and `i < n`, then the element at index `i` in the polynomial `poly_exp [&0;&1] n ** p` is `&0`.

### Informal sketch
The proof proceeds by induction on `n`.

- It begins with a base case when `n = 0`. After simplification, this case relies on the fact that all coefficients of the polynomial `p` are zero because all elements can be paired by `HD`.
- The inductive step utilizes a case split. `POLY_EXP_X_REC; EL; HD; poly_mul; NOT_POLY_EXP_NIL; NOT_CONS_NIL; HD_POLY_ADD;poly_cmul` and then `REAL_ARITH_TAC`.
- In the innermost induction, the step case proceeds is simplified using `lem0000; BLAHBLAH3` to prove the list length dominance, which allows cases to decide to simplify it further and uses `lem0003`.

### Mathematical insight
This theorem implies that several of the leading coefficients of the polynomial are zero under polynomial `poly_exp [&0;&1] n`.

### Dependencies
- Theorems:
  - `BLAHBLAH3`
  - `BLAHBLAH`
  - `EL`
  - `POLY_EXP_X_REC`
  - `poly_mul`
  - `NOT_POLY_EXP_NIL`
  - `NOT_CONS_NIL`
  - `HD_POLY_ADD`
  - `poly_cmul`

---
### Name of formal statement
POLY_MUL_HD

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all lists `p1` and `p2` of real numbers, if `p1` is not empty and `p2` is not empty, then the head of the polynomial multiplication of `p1` and `p2` is equal to the product of the heads of `p1` and `p2`.

### Informal sketch
The proof is by list induction.

1.  It inducts on `p1`, where the base case with `[]` is trivial due to condition that `p1` is not empty.
2.  In the inductive step, proceed on `p2`, where base case of `[]` is also trivially avoided.
3.  The proof completes with several applications of the case analysis on whether `t` is empty.

### Mathematical insight
The head of a polynomial multiplication is the product of its coefficient, likely used to reason about leading non-zero coefficients.

### Dependencies
- Theorems:
  - `poly_mul`
  - `HD`
  - `poly_cmul`
  - `poly_add`
  - `NOT_CONS_NIL`

---
### Name of formal statement
POLY_MUL_ITER_HD_FACTORIAL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all natural numbers `n`, the head of the polynomial resulting from `poly_mul_iter (\i. [-- &i; &1]) n` is equal to `(-- &1) pow n * (&(FACT n))`.

### Informal sketch
The proof proceeds by induction.

- It starts defining local `lem01` to simplify with `NOT_CONS_NIL`. The lemma `lem02` expresses `HD (p1 ** p2) = (HD p1) * (HD p2)`
- The base case `n = 0` simplifies with `Pm_eqn5.POLY_MUL_ITER`, `HD`, `FACT`, and `REAL_ARITH_TAC`.
- Inductive step also relies on `Pm_eqn5.POLY_MUL_ITER`, a case result `lem04`, `FACT`.

### Mathematical insight
The theorem determines the leading coefficient of the polynomial `poly_mul_iter (\i. [-- &i; &1]) n`.

### Dependencies
- Theorems:
  - `Pm_eqn5.POLY_MUL_ITER`
  - `NOT_CONS_NIL`
  - `POLY_MUL_HD`
  - `HD`
  - `FACT`
  - `REAL_OF_NUM_MUL`

---
### Name of formal statement
PLANETMATH_THM_5_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `n` and `p`, if `p > 0` and `n > 0`, then there exists a list `As` such that the following conditions hold:
1.  `(g n p) = (&1/(&(FACT (p  - 1)))) ## As`
2.  For all `i`, if `i< (p-1)`, then `(EL i As) = &0`
3.  `(EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p)`
4.  all elements of `As` are integers.

### Informal sketch
The tactic flow focuses on the goal state, decomposing it into its respective conjoints.
A key step is to define `As` as `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`, and `(REPEAT STRIP_TAC)` to rewrite to focus on inner goals.
- The proof defines `As` and focuses on satisfying its conditions, namely rewriting expressions to equate it with goal state, or proving typing constraints that contain integer. It also uses several cases related to simplification about polynomial expressions and the index within its polynomials
1.  The rewriting to satisfy initial polynomial constraint is performed by `(ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5])`. The second goal is further split in subsequent tactics. This reduces the goal to proving properties about the proposed `As` listed above.
2.  The element less than polynomial properties is dealt with `JOSHUA` and `TELEVISION`, which provide the relationship of the polynomials indexes from `As` and used in simplifying and rewriting expression related to the target index.
3.  The integer constraint rewriting relies on the fact that `[0; 1], poly_mul_iter, and poly_exp` preserve integers, and the component being applied `ALL_IS_INT_POLY_MUL`,`ALL_IS_INT_POLY_EXP`.
From here, simplification by `SIMP_TAC` and peeling via `STRIP_TAC` reveals the rest to be automatically handled.
### Mathematical insight
The significance of this theorem lies in its construction of a polynomial `g n p` from components that are carefully constructed, resulting in the polynomial having structural properties over indexes that are known and understood and are of a fixed type. Namely, `As` is a polynomial constructed of integer indices `where `0 <= i < p-1`.

### Dependencies
- Theorems:
  - `ALL_IS_INT_POLY_MUL`
  - `ALL_IS_INT_POLY_EXP`
  - `TELEVISION`
  - `JOSHUA`
  - `ALL_IS_INT_POLY_MUL_ITER`
  - `NOT_POLY_EXP_NIL`
  - `NOT_POLY_MUL_ITER_NIL`
  - `Pm_eqn5.PLANETMATH_EQN_5`

---
### Name of formal statement
as_def

### Type of the formal statement
new specification

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
Introduce a function `As` of type `num -> num -> (real)list`, such that `PLANETMATH_THM_5_1` holds with `As` being the witness of the existential quantifier in `PLANETMATH_THM_5_1`.

### Informal sketch
Use `new_specification` to create the function `As`.
1.  Specialize and rewrite `PLANETMATH_THM_5_1` based on the definitions of `C p n z`
2.  Apply skolemization to the conclusion.
This yields a definition of `As` satisfying `PLANETMATH_THM_5_1`.

### Mathematical insight
This is a definitional axiom that introduces `As` satisfying `PLANETMATH_THM_5_1`.

### Dependencies
- Theorems:
  - `PLANETMATH_THM_5_1`
  - created theorems: `FO_LEMMA1

---
### Name of formal statement
g_eq_As

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `p` and `n`, if `p > 0` and `n > 0`, then `(g n p) = (&1 / (&(FACT (p - 1)))) ## (As n p)`.

### Informal sketch
The proof extracts a conjunct from the definition of `as_def`, specifically the equation relating `g n p` to `As n p`, discharging assumptions.

### Mathematical insight
This theorem gives the explicit relationship between the polynomials defined by `g n p` and the `As` function introduced in `as_def`.

### Dependencies
- Theorems:
  - `as_def`

---
### Name of formal statement
prefix_As_zero

### Type of the formal statement
theorem

### Formal Content
```ocaml
let N_IS_INT = PROVE(
    `!n . integer (&n)`,
    MESON_TAC [is_int]
)
let NEG_N_IS_INT = PROVE(
    `!n . integer (--(&n))`,
    MESON_TAC [is_int]
)
let INT_OF_REAL_ADD = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x + y)) =
               (int_of_real x) + (int_of_real y)`,
    SIMP_TAC[integer;int_add;int_rep;N_IS_INT;NEG_N_IS_INT]
)
let INT_OF_REAL_MUL = PROVE(
    `!x y.(integer x) /\ (integer y)
           ==> (int_of_real (x * y)) =
               (int_of_real x) * (int_of_real y)`,
    SIMP_TAC[is_int;int_mul;int_rep;N_IS_INT;NEG_N_IS_INT]
)

let rec INT_OF_REAL_CONV_helper t =
    let real_op_2_int_op t =
        if (t = `real_add`) then `int_add`
        else if (t = `real_sub`) then `int_sub`
        else if (t = `real_mul`) then `int_mul`
        else if (t = `real_pow`) then `int_pow`
        else if (t = `real_neg`) then `int_neg`
        else t
    in
    if (is_var t) then (mk_comb (`int_of_real`,t),[],[t])
    else if ((rator t) = `real_of_num`) then
      (mk_comb (`int_of_real`, t),[t],[])
    else if ((rator t) = `real_neg`) then
      let rand1 = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (`int_neg`, expr1) in
      (expr,lst,lst2)
    else if ((rator (rator t)) = `real_pow`) then
      let rand1 = rand (rator t) in
      let exponent = rand t in
      let (expr1,lst1,lst2) = INT_OF_REAL_CONV_helper rand1 in
      let lst = lst1 @ [t] in
      let expr = mk_comb (mk_comb (`int_pow`,expr1),exponent) in
      (expr,lst,lst2)
    else if (   ((rator (rator t)) = `real_add`)
             || ((rator (rator t)) = `real_mul`)
             || ((rator (rator t)) = `real_sub`)  ) then
      let int_op = real_op_2_int_op (rator (rator t)) in
      let rand1 = rand (rator t) in
      let rand2 = rand t in
      let (expr1,lst11,lst12) = INT_OF_REAL_CONV_helper rand1 in
      let (expr2,lst21,lst22) = INT_OF_REAL_CONV_helper rand2 in
      let lst1 = lst11 @ lst21 @ [t] in
      let lst2 = lst12 @ lst22 in
      let expr = mk_comb (mk_comb (int_op,expr1),expr2) in
      (expr,lst1,lst2)
    else (t,[],[t])


(* ------------------------------------------------------------------------- *)
(* I wrote an initial version of this, but John Harrison proposed this       *)
(* version which is faster and also requires less theorems.                  *)
(* ------------------------------------------------------------------------- *)
let INT_OF_REAL_CONV =
  let final_tweak = MATCH_MP(MESON[int_tybij] `real_of_int x = y ==> int_of_real y = x`) in
  fun t ->
    let (exp,real_sub_terms,is_int_assumpts) = INT_OF_REAL_CONV_helper t in
    let is_int_assumpts = List.map (fun x -> mk_comb (`integer`,x)) is_int_assumpts in
    let fexp = rand(concl(PURE_REWRITE_CONV[GSYM int_of_num] exp)) in
    let rexp = mk_comb(`real_of_int`,fexp)
    and ths = map (GEN_REWRITE_RULE I [CONJUNCT2 int_tybij] o ASSUME) is_int_assumpts in
    let th3 = PURE_REWRITE_CONV(ths @ [int_pow_th; int_add_th; int_mul_th; int_sub_th; int_neg_th; int_of_num_th]) rexp in
    itlist DISCH is_int_assumpts (final_tweak th3)

let ALL_IS_INT = PROVE(
    `! h t . (ALL integer (CONS h t)) ==> (integer h)  /\ (ALL integer t)`,
    SIMP_TAC [ALL]
)

let ALL_IS_INT_POLY_ADD = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ++ p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let [lem02;lem03] = CONJUNCTS lem01 in
    let lem04 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem05;lem06] = CONJUNCTS lem04 in
    let lem07 = CONJ lem02 lem05 in
    let lem08 = MATCH_MP INTEGER_ADD lem07 in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ++ p2)` in
    let lem10 = SPEC `t':(real)list` lem09 in
    let lem11 = CONJ lem03 lem06 in
    let lem12 = MP lem10 lem11 in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [poly_add]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_add]);
        (SIMP_TAC [poly_add]) THEN (ONCE_REWRITE_TAC [NOT_CONS_NIL]) THEN
        (SIMP_TAC []) THEN (SIMP_TAC [HD;TL]) THEN (STRIP_TAC) THEN
        (SIMP_TAC [ALL]) THEN
        (CONJ_TAC) THENL [(ACCEPT_TAC lem08); (ACCEPT_TAC lem12)]
      ]
    ]
)
let ALL_IS_INT_POLY_CMUL = PROVE(
    `! p c. (integer c) /\ (ALL integer p) ==> (ALL integer (c ## p))`,
    (LIST_INDUCT_TAC) THEN (ASM_SIMP_TAC [poly_cmul;ALL;INTEGER_MUL])
)

let ALL_IS_INT_POLY_MUL = PROVE(
    `! p1 p2 . (ALL integer p1) /\ (ALL integer p2) ==> (ALL integer (p1 ** p2))`,
    let lem01 = UNDISCH (SPECL [`h:real`;`t:(real)list`] ALL_IS_INT) in
    let lem02 = UNDISCH (SPECL [`h':real`;`t':(real)list`] ALL_IS_INT) in
    let [lem03;lem04] = CONJUNCTS lem01 in
    let [lem05;lem06] = CONJUNCTS lem02 in
    let lem07 = MATCH_MP INTEGER_MUL (CONJ lem03 lem05) in
    let lem08 = MATCH_MP ALL_IS_INT_POLY_CMUL (CONJ lem03 lem06) in
    let lem09 = ASSUME `! p2. ALL integer t /\ ALL integer p2 ==> ALL integer (t ** p2)` in
    let lem10 = SPEC `(CONS h' t'):(real)list` lem09 in
    LIST_INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL [(SIMP_TAC [ALL;poly_mul]);(SIMP_TAC [poly_mul])]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_mul]) THEN
        ((ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN (SIMP_TAC [poly_cmul]);
          (ASM_SIMP_TAC [ALL;poly_cmul;poly_add]) THEN (SIMP_TAC [SPEC `0` N_IS_INT])
        ]);
        (STRIP_TAC) THEN (ONCE_REWRITE_TAC [poly_mul] ) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [ALL;poly_cmul]) THEN STRIP_TAC THENL
          [(ACCEPT_TAC lem07) ;(ACCEPT_TAC lem08)];
          (ASM_SIMP_TAC []) THEN (MATCH_MP_TAC ALL_IS_INT_POLY_ADD) THEN
          (CONJ_TAC) THENL
          [ (MATCH_MP_TAC ALL_IS_INT_POLY_CMUL) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC lem03) ; (ASM_SIMP_TAC[])];
            (SIMP_TAC [ALL]) THEN (CONJ_TAC) THENL
            [(ACCEPT_TAC (SPEC `0` N_IS_INT)); (ASM_SIMP_TAC [lem04;lem10])]
          ]
        ]
      ]
    ]
)
let NOT_POLY_MUL_ITER_NIL = PROVE(
    `! n . ~((poly_mul_iter (\i.[ -- &i; &1]) n) = [])`,
    let lem02 = SIMP_RULE [NOT_CONS_NIL] (ISPEC `[ -- &(SUC n); &1]` NOT_POLY_MUL_NIL ) in
    let lem03 = ISPEC `(poly_mul_iter (\i.[ -- &i; &1]) n)` lem02 in
    let lem04 = UNDISCH  lem03 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;NOT_CONS_NIL]);
      (SIMP_TAC [Pm_eqn5.POLY_MUL_ITER;lem04])
    ]
)

let ALL_IS_INT_POLY_MUL_ITER = PROVE(
    `! n. (ALL integer (poly_mul_iter (\i.[-- &i; &1]) n))`,
    let FOOBAR_LEMMA =  PROVE(
        `ALL integer [-- &(SUC n); &1]`,
        (SIMP_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT;NEG_N_IS_INT])) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [ALL;N_IS_INT]);
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (BETA_TAC) THEN
      (MATCH_MP_TAC ALL_IS_INT_POLY_MUL) THEN (CONJ_TAC) THENL
      [(ACCEPT_TAC (FOOBAR_LEMMA)); (ASM_SIMP_TAC [])]
    ]
)

let ALL_IS_INT_POLY_EXP = PROVE(
    `!n p. (ALL integer p) ==> (ALL integer (poly_exp p n))`,
    let lem01 = ASSUME `! p. ALL integer p ==> ALL integer (poly_exp p n)` in
    let lem02 = ASSUME ` ALL integer p` in
    let lem03 = MP (SPEC_ALL lem01) lem02 in
    let lem04 = CONJ lem02 lem03 in
    let lem05 = MATCH_MP ALL_IS_INT_POLY_MUL lem04 in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [poly_exp]) THEN (ONCE_REWRITE_TAC [ALL]) THEN
      (ONCE_REWRITE_TAC [ALL]) THEN (SIMP_TAC [SPEC `1` N_IS_INT]);
      (ONCE_REWRITE_TAC [poly_exp]) THEN (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
   ]
)

let BLAHBLAH = PROVE(
    `! p1 p2. (LENGTH p1 <= LENGTH p2) ==> (&0 ## p1 ++ p2) = p2`,
     LIST_INDUCT_TAC THENL
     [ (SIMP_TAC [LENGTH;poly_cmul;poly_add]);
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
         (ASM_SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;HD;TL;
                        REAL_ARITH `&0 * h + h' = h'`;LENGTH;
                        ARITH_RULE `(SUC x) <= (SUC y) <=> x <= y`]) ]
     ]
)

let BLAHBLAH3 = PROVE(
    `! n h t. (LENGTH t) <= LENGTH (poly_exp [&0;&1] n ** CONS h t)`,
    let lem04 = ASSUME `! h t . LENGTH t <= LENGTH (poly_exp [&0;&1] n ** CONS h t)` in
    let lem05 = SPECL [`h:real`;`t:(real)list`] lem04  in
    let lem06 = ARITH_RULE `!(x:num) y . x <= y ==> x <= SUC y` in
    let lem07 = MATCH_MP lem06 lem05   in
    let lem08 = GEN_ALL lem07  in
     INDUCT_TAC THENL
     [ (SIMP_TAC [poly_exp;poly_mul;poly_cmul;POLY_CMUL_LID;LENGTH]) THEN ARITH_TAC;
       (SIMP_TAC [POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL;poly_cmul;poly_add;NOT_CONS_NIL;LENGTH;TL]) THEN
       (ASM_SIMP_TAC [BLAHBLAH]) THEN (ACCEPT_TAC lem08)
    ]
)
let TELEVISION = PROVE (
    `!n p.(~ (p = [])) ==>  EL n (poly_exp [&0;&1] n ** p) = HD p`,
    let lem = MATCH_MP BLAHBLAH (SPEC_ALL BLAHBLAH3) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [EL;poly_exp;POLY_MUL_CLAUSES]) THEN (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]); (SIMP_TAC [NOT_CONS_NIL;POLY_CMUL_LID])];
        (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_X_NIL]) THEN
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC []);
          (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;HD]) THEN
          (ASM_SIMP_TAC [lem;NOT_CONS_NIL;HD])
        ]
    ]
)
let JOSHUA = PROVE(
    `!i n p.(~ (p = [])) /\ (i < n) ==>  EL i (poly_exp [&0;&1] n ** p) = &0`,
    let lem0000 = SPECL [`t:(real)list`;`poly_exp [&0;&1] n ** (CONS h t)`] BLAHBLAH in
    let lem0001 = MATCH_MP lem0000 (SPEC_ALL BLAHBLAH3)  in
    let lem0002 = ASSUME `! n p . ~(p = []) /\ i < n ==> EL i (poly_exp [&0;&1] n ** p) = &0` in
    let lem0003 = SIMP_RULE [NOT_CONS_NIL] (SPECL [`n:num`;`(CONS (h:real) t)`] lem0002) in
    INDUCT_TAC THENL
    [ INDUCT_TAC THENL
      [ ARITH_TAC ;
        LIST_INDUCT_TAC THENL
        [ (SIMP_TAC[]);
          (SIMP_TAC [POLY_EXP_X_REC;EL;HD;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL;HD_POLY_ADD;poly_cmul]) THEN
           REAL_ARITH_TAC
        ]
      ];
      INDUCT_TAC THENL
      [ ARITH_TAC;
       (SIMP_TAC [EL;POLY_EXP_X_REC;poly_mul;NOT_POLY_EXP_NIL;NOT_CONS_NIL]) THEN
       LIST_INDUCT_TAC THENL
       [ (SIMP_TAC[]);
         (SIMP_TAC [poly_cmul;poly_add;NOT_CONS_NIL;TL;lem0001]) THEN
         (SIMP_TAC [ARITH_RULE `(SUC i) < (SUC n) <=> i < n`;lem0003])
       ]
      ]
    ]
)
let POLY_MUL_HD = PROVE(
    `! p1 p2. (~(p1 = []) /\ ~(p2 = [])) ==> (HD (p1 ** p2)) = (HD p1) * (HD p2)`,
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC[]);
      (LIST_INDUCT_TAC) THENL
      [ (SIMP_TAC[]);
        (SIMP_TAC [NOT_CONS_NIL]) THEN (ONCE_REWRITE_TAC [poly_mul]) THEN
        (ASM_CASES_TAC `(t:(real)list) = []`) THENL
        [ (ASM_SIMP_TAC [HD;poly_cmul]);
          (ASM_SIMP_TAC [HD;poly_cmul;poly_add]) THEN
          (SIMP_TAC [NOT_CONS_NIL;HD]) THEN (REAL_ARITH_TAC)
        ]
      ]
    ]
)
let POLY_MUL_ITER_HD_FACTORIAL = PROVE(
    `! n. (HD (poly_mul_iter (\i.[-- &i; &1]) n)) = ((-- &1) pow n) * (&(FACT n))`,
    let lem01 = PROVE(`~([-- &(SUC n); &1] = [])`,SIMP_TAC [NOT_CONS_NIL]) in
    let lem02 = ISPECL
                  [`[-- &(SUC n); &1]`;`poly_mul_iter (\i.[-- &i; &1]) n`]
                  POLY_MUL_HD in
    let lem03 = CONJ lem01 (SPEC_ALL NOT_POLY_MUL_ITER_NIL) in
    let lem04 = MP lem02 lem03 in
    let lem05 = PROVE(
        `!n. ((-- &1) pow n) = -- ((-- &1) pow (SUC n))`,
        STRIP_TAC THEN (ONCE_REWRITE_TAC [pow]) THEN REAL_ARITH_TAC
    ) in
    INDUCT_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN (SIMP_TAC [HD;FACT]) THEN REAL_ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN BETA_TAC THEN
      (ONCE_REWRITE_TAC [lem04]) THEN (ONCE_REWRITE_TAC [HD]) THEN
      (ASM_SIMP_TAC []) THEN (ONCE_REWRITE_TAC [FACT]) THEN
      (ONCE_REWRITE_TAC [GSYM REAL_OF_NUM_MUL]) THEN
      (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [lem05]))) THEN REAL_ARITH_TAC
    ]
)
let PLANETMATH_THM_5_1 =  PROVE(
    `! n p.
       p > 0 ==>
       n > 0 ==>
       ? As .
          ((g n p) = (&1/(&(FACT (p  - 1)))) ## As)
       /\ (! i. i< (p-1) ==> (EL i As) = &0)
       /\ ((EL (p-1) As) = ((-- &1) pow (n * p)) * ((&(FACT n)) pow p))
       /\ (ALL integer As)`,
    let lem01 = SPECL [`poly_exp [&0;&1] (p - 1)`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] ALL_IS_INT_POLY_MUL in
    let lem02 = SPECL [`p-1`;`[&0;&1]`] ALL_IS_INT_POLY_EXP in
    let lem03 = PROVE(`ALL integer [&0;&1]`, (REWRITE_TAC [ALL]) THEN (SIMP_TAC [N_IS_INT])) in
    let lem04 = MP lem02 lem03 in
    let lem05 = SPECL [`p:num`;`poly_mul_iter (\i.[-- &i; &1]) n`] ALL_IS_INT_POLY_EXP in
    let lem06 = MP lem05 (SPEC_ALL ALL_IS_INT_POLY_MUL_ITER)  in
    let lem07 = MP lem01 (CONJ lem04 lem06)  in
    let lem08 = SPECL [`p-1`;`poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p`] TELEVISION in
    let lem09 = SIMP_RULE [ NOT_POLY_EXP_NIL;NOT_POLY_MUL_ITER_NIL] lem08 in
    let lem10 = SPECL [`i:num`;`p - 1`;`poly_exp (poly_mul_iter (\i. [ -- &i; &1]) n ) p`] JOSHUA in
    let lem11 = SIMP_RULE [NOT_POLY_MUL_ITER_NIL;NOT_POLY_EXP_NIL] lem10 in
    (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `((poly_exp [&0;&1] (p-1)) ** (poly_exp (poly_mul_iter (\i.[-- &i; &1]) n) p))`) THEN
    CONJ_TAC THENL
    [ (ONCE_REWRITE_TAC [Pm_eqn5.PLANETMATH_EQN_5]) THEN (SIMP_TAC[]);
      CONJ_TAC THENL
      [ (SIMP_TAC [lem11]);
        CONJ_TAC THENL
        [ (ONCE_REWRITE_TAC [lem09]) THEN
          (SPEC_TAC (`n:num`,`n:num`)) THEN
          (INDUCT_TAC) THENL
          [ (SIMP_TAC [NOT_CONS_NIL;HD_POLY_EXP;HD;Pm_eqn5.POLY_MUL_ITER;FACT;pow;
                       REAL_POW_ONE;ARITH_RULE `0 * p = 0`;REAL_ARITH `&1 * &1 = &1`]);
            (SIMP_TAC [HD_POLY_EXP; NOT_POLY_MUL_ITER_NIL; POLY_MUL_ITER_HD_FACTORIAL]) THEN
            (SIMP_TAC [REAL_POW_MUL;REAL_POW_POW;BLAHBLAH3]) ];
          ACCEPT_TAC lem07 ]
      ]
    ]
)
let as_def =
    let ll01 = SPEC_ALL PLANETMATH_THM_5_1 in
    let FO_LEMMA1 = PROVE(`((p > 0) ==> (n > 0) ==> (? z. C p n z))
                            <=> (? z. (p > 0) ==> (n > 0) ==> C p n z)`,MESON_TAC[]) in
    let ll02 = GEN_ALL (SIMP_RULE [FO_LEMMA1] ll01) in
    let ll03 = ONCE_REWRITE_RULE [SKOLEM_CONV (concl ll02)] ll02 in
    new_specification ["As"] ll03
(* split up def of As into its four conjuncts *)
let g_eq_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let prefix_As_zero
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let fact_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT1 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def
let ALL_integer_As
    = (GEN_ALL o DISCH_ALL o CONJUNCT2 o CONJUNCT2 o CONJUNCT2 o  UNDISCH o UNDISCH o SPEC_ALL) as_def

let POLY_DIFF_AUX_LEM1 = PROVE(
    `! i p k. i < (LENGTH p) ==> EL i (poly_diff_aux k p) = (EL i p) * &(i + k)`,
    let lem0001 = ASSUME `! p k . i < LENGTH p ==> EL i (poly_diff_aux k p ) = EL i p * &(i + k)` in
    let lem0002 = SPECL [` t:(real)list`;`SUC k`] lem0001 in
    let lem0003 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [poly_diff_aux;LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;ARITH_RULE `0 + k = k`;poly_diff;LENGTH;EL;HD;TL]) THEN REAL_ARITH_TAC ];
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff_aux;EL;TL]) THEN STRIP_TAC THEN
        (SIMP_TAC [lem0003;lem0002;ARITH_RULE `i + SUC k = SUC i + k`]) ]
    ]
)
let EL_POLY_DIFF = PROVE(
    `! i p. i < (LENGTH (poly_diff p)) ==> EL i (poly_diff p) = (EL (SUC i) p) * &(SUC i)`,
    let lem01 =  SPECL [`SUC i`;`t:(real)list`;`1`] POLY_DIFF_AUX_LEM1  in
    INDUCT_TAC THENL
    [ LIST_INDUCT_TAC THENL
      [ ((SIMP_TAC [LENGTH;poly_diff]) THEN ARITH_TAC);
        (SIMP_TAC [LENGTH;PRE;EL;HD;TL;ARITH_RULE `SUC 0 = 1`;REAL_ARITH `x * &1 = x`;poly_diff;NOT_CONS_NIL]) THEN
        (SPEC_TAC (`t:(real)list`,`t:(real)list`)) THEN
        LIST_INDUCT_TAC THENL [(SIMP_TAC [LENGTH;poly_diff_aux]) THEN ARITH_TAC;
                               (SIMP_TAC [HD;poly_diff_aux;REAL_ARITH `&1 * h = h`])]
     ];
     LIST_INDUCT_TAC THENL
     [ ((SIMP_TAC [LENGTH;HD;poly_diff;REAL_ARITH `&1 * h = h`])) THEN ARITH_TAC;
        (SIMP_TAC [poly_diff;NOT_CONS_NIL;TL;LENGTH_POLY_DIFF_AUX ]) THEN (SIMP_TAC [lem01;EL;TL]) THEN ARITH_TAC ]
     ]
)
let POLY_AT_ZERO = PROVE(
    `!p .(~(p = [])) ==> poly p (&0) = HD p`,
    LIST_INDUCT_TAC THENL [ SIMP_TAC []; (SIMP_TAC [poly;HD]) THEN REAL_ARITH_TAC ]
)
let PDI_POLY_DIFF_COMM = PROVE(
    `! p n.(poly_diff_iter (poly_diff p) n) = (poly_diff (poly_diff_iter p n))`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [(SIMP_TAC [Pm_lemma1.PDI_DEF]);
     (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (ASM_SIMP_TAC [])]
)
let EL_PDI_AT_ZERO = PROVE(
     `!i p. (i < (LENGTH p))
         ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    let lem03 = PROVE(`SUC i < LENGTH (CONS (h:real) t) <=> i < LENGTH t`,(SIMP_TAC [LENGTH]) THEN ARITH_TAC) in
    let lem04 = ASSUME `!p . i < LENGTH p ==> poly (poly_diff_iter p i) (&0) = EL i p * &(FACT i)` in
    let lem05 = SIMP_RULE [LENGTH_POLY_DIFF;LENGTH;PRE] (SPEC `poly_diff (CONS h t)` lem04) in
    let lem06 = PROVE(`i < LENGTH t ==> i < LENGTH (poly_diff (CONS h t))`,SIMP_TAC [LENGTH_POLY_DIFF;PRE;LENGTH]) in
    INDUCT_TAC THENL
    [ (LIST_INDUCT_TAC THENL
      [(SIMP_TAC [LENGTH]) THEN ARITH_TAC; (SIMP_TAC [Pm_lemma1.PDI_DEF;FACT;EL;NOT_CONS_NIL;POLY_AT_ZERO]) THEN REAL_ARITH_TAC]);
      LIST_INDUCT_TAC THENL
      [ (SIMP_TAC [LENGTH]) THEN ARITH_TAC;
        (SIMP_TAC [Pm_lemma1.PDI_DEF;GSYM PDI_POLY_DIFF_COMM;lem03;lem05]) THEN
        (SIMP_TAC [lem06;EL_POLY_DIFF;FACT;REAL_OF_NUM_MUL;GSYM REAL_MUL_ASSOC])
      ]
    ]
)
let EL_PDI_AT_ZERO2 = PROVE(
    `!i p. ((~ (p = [])) /\ (i <= (LENGTH p) - 1)) ==> ( poly (poly_diff_iter p i) (&0)) = ((EL i p) * (&(FACT i)))`,
    STRIP_TAC THEN LIST_INDUCT_TAC THEN
    (SIMP_TAC [NOT_CONS_NIL;LENGTH;ARITH_RULE `(i <= (SUC x) -1) <=> (i < (SUC x))`;EL_PDI_AT_ZERO])
)
let POLY_CMUL_PDI = PROVE(
    `!p c i. (poly_diff_iter (c ## p) i) = c ##(poly_diff_iter p i)`,
    STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THEN (ASM_SIMP_TAC [Pm_lemma1.PDI_DEF;POLY_CMUL_POLY_DIFF])
)
let LENGTH_g = PROVE(
    `! n p . (LENGTH (g n p)) >= p `,
    let lem00 = ARITH_RULE `SUC ((SUC p ) - 1) = SUC p` in
    let lem01 = PROVE(`! n p. ~((poly_exp (poly_mul_iter (\i.[-- &i; &1]) n ) (SUC p)) = [])`,
                       SIMP_TAC [NOT_POLY_EXP_NIL; NOT_POLY_MUL_ITER_NIL]) in
    let lem02 = MATCH_MP POLY_MUL_LENGTH2 (SPEC_ALL lem01) in
    let lem03 = SPECL [`poly_exp [&0;&1] (SUC p - 1)`] lem02 in
    let lem04 = SIMP_RULE [POLY_EXP_X_LENGTH] lem03 in
    let lem05 = SIMP_RULE [lem00] lem04 in
     (SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5;POLY_CMUL_LENGTH]) THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ ARITH_TAC; SIMP_TAC [lem05]]
)
let LENGTH_As = PROVE(
    `! n p . p > 0 ==> n > 0 ==> LENGTH (As n p) >= p`,
    let lem50 = ADD_ASSUM `p > 0` (ADD_ASSUM `n > 0` (SPEC_ALL LENGTH_g)) in
    let lem51 = ONCE_REWRITE_RULE [UNDISCH_ALL (SPEC_ALL g_eq_As)] lem50 in
    let lem52 = ONCE_REWRITE_RULE [POLY_CMUL_LENGTH] lem51 in
    SIMP_TAC [lem52]
)
let REAL_MUL_RDIV = PROVE(
    `!x y. ~(y = &0) ==> ((x * y) / y = x)`,
    SIMP_TAC[real_div; GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]
)
let REAL_MUL_DIV_ASSOC = PROVE(
    `!x y z.((x * z) / y = x * (z / y))`,
    SIMP_TAC [real_div;GSYM REAL_MUL_ASSOC]
)
let IS_INT_FACT_DIV = PROVE(
    `! n m. n >= m ==> integer ( (&(FACT n))/(&(FACT m)) )`,
    let lem0 = SPEC_ALL (ONCE_REWRITE_RULE [GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ)] FACT_NZ) in
    let lem1 = SPECL [`&(SUC n)`;`&(FACT n)`]  REAL_MUL_RDIV in
    let lem2 = MP lem1 lem0 in
    let lem4 = ASSUME `! m. n >= m ==> integer (&(FACT n)/ &(FACT m))` in
    let lem5 = UNDISCH (SPEC_ALL lem4) in
    let lem6 = PROVE(`integer(&(SUC n))`,SIMP_TAC [N_IS_INT]) in
    let lem7 = CONJ lem6 lem5 in
    let lem8 = MATCH_MP INTEGER_MUL lem7  in
    let lem9 = UNDISCH_ALL (ARITH_RULE `(~(n >= m)) ==> (SUC n >= m) ==>  m = SUC n`) in
    INDUCT_TAC THENL
    [ (SIMP_TAC [ARITH_RULE `0 >= m ==> m = 0`;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT]);
      (STRIP_TAC) THEN (ASM_CASES_TAC `(n:num) >= m`) THENL
      [ (ASM_SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;lem2;N_IS_INT]) THEN
        (SIMP_TAC [FACT;GSYM REAL_OF_NUM_MUL;REAL_MUL_DIV_ASSOC;lem8]);
        (STRIP_TAC) THEN
        (SIMP_TAC [lem9;FACT_NZ;REAL_OF_NUM_EQ;REAL_DIV_REFL;N_IS_INT])
      ]
    ]
)
let SATURDAY_LEMMA = PROVE(
    `!x. p > 1 ==> m >= p ==> x * ((&(FACT m))/(&(FACT (p-1)))) = x * (&p) * ((&(FACT m))/(&(FACT p)))`,
    let lem01 = UNDISCH (ARITH_RULE `p > 1 ==> SUC (p -1) = p`) in
    let lem02 = ADD_ASSUM `p > 1` (SPEC `p - 1` (CONJUNCT2 FACT)) in
    let lem03 = GSYM (ONCE_REWRITE_RULE [lem01] lem02) in
    let lem04 =  SPEC `&p` REAL_DIV_REFL in
    let lem05 = ADD_ASSUM `p > 1` (SPECL [`p:num`;`0`] REAL_OF_NUM_EQ) in
    let lem06 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> ~(p = 0)`)] lem05 in
    let lem07 = GSYM (MP lem04 lem06) in
    (REPEAT STRIP_TAC) THEN
    (CONV_TAC (RATOR_CONV (ONCE_REWRITE_CONV [GSYM REAL_MUL_LID]))) THEN
    (ONCE_REWRITE_TAC [lem07]) THEN
    (ONCE_REWRITE_TAC [real_div]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `((x1:real) * x2) * x * (x3 * x4) = x * x1 * (x3 * (x2 * x4))`]) THEN
    (ONCE_REWRITE_TAC [GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [REAL_OF_NUM_MUL]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_INV_MUL]) THEN
    (ONCE_REWRITE_TAC [lem03]) THEN
    (SIMP_TAC [REAL_MUL_ASSOC;GSYM REAL_OF_NUM_MUL])
)
let SHRIVER = PROVE(
    `!f0. (!i. m <= i /\ i <= SUC n ==> (f0 i))
       ==> (!i. m <= i /\ i <= n ==> (f0 i)) `,
    let lem01 = UNDISCH_ALL (ARITH_RULE `i <= n ==> i <= SUC n`) in
    let lem02 = CONJ (ASSUME `(m:num) <= (i:num)`) lem01  in
    let lem03 = ASSUME `!i. m <= i /\ i <= SUC n ==> (f0 i)` in
    let lem04 = SPEC_ALL lem03 in
    let lem05 = MP lem04 lem02 in
    (REPEAT STRIP_TAC) THEN (ACCEPT_TAC lem05)
)
let IS_INT_SUM = PROVE(
 `!f n m.(!i.m <= i /\  i <= n ==> integer (f i)) ==> integer (sum (m..n) f)`,
  let l0 = SPECL [`m:num`;`n:num`;`i:num`] IN_NUMSEG in
  let l1 = SPECL [`m:num`;`SUC n`] NUMSEG_EMPTY in
  let l2 = ADD_ASSUM `SUC n < m` l1 in
  let l3 = ASM_REWRITE_RULE [] l2 in
  let l4 = (UNDISCH o ARITH_RULE) `~(SUC n < m) ==> m <= SUC n` in
  let l5 = ONCE_REWRITE_RULE [GSYM IN_NUMSEG] SHRIVER in
  let l6 = SPEC `\(i:num).(integer (f i))` l5 in
  let l7 = BETA_RULE l6 in
  let l8 = ASSUME `! m. (!i. i IN m..n ==> integer (f i)) ==> integer (sum (m..n) f)` in
  let l9 = SPEC_ALL l8 in
  let l10 = UNDISCH (IMP_TRANS l7 l9) in
  let jj0 = ARITH_RULE `(~(SUC n < m)) ==> m <= SUC n /\ (SUC n) <= SUC n` in
  let jj1 = UNDISCH (ONCE_REWRITE_RULE [GSYM IN_NUMSEG] jj0) in
  let jj2 = SPEC `SUC n` (ASSUME `!i. i IN m.. SUC n ==> integer (f i)`) in
  let jj3 = (MP jj2 jj1) in
  let l18 = CONJ l10 jj3 in
  let l19 = MATCH_MP INTEGER_ADD l18 in
  let l20 = DISCH `!i. i IN m..SUC n ==> integer (f i)` l19 in
  let l21 = ASSUME `!i . i = 0 ==> integer (f 0)` in
  let l22 = SIMP_RULE [] (SPEC `0` l21) in
  (ONCE_REWRITE_TAC [GSYM l0]) THEN STRIP_TAC THEN
  INDUCT_TAC THENL
  [ STRIP_TAC THEN
    (ASM_CASES_TAC `m = 0`) THENL
    [ (ASM_SIMP_TAC []) THEN
      (ONCE_REWRITE_TAC [NUMSEG_CONV `0..0`]) THEN
      (ONCE_REWRITE_TAC [ SUM_SING]) THEN
      (SIMP_TAC [IN_SING]) THEN (DISCH_TAC) THEN (SIMP_TAC [l22]);
      (ASM_SIMP_TAC [NUMSEG_CLAUSES;SUM_CLAUSES;N_IS_INT])
    ];
    STRIP_TAC THEN (ASM_CASES_TAC `SUC n < m`) THENL
    [ (ASM_SIMP_TAC [l3;SUM_CLAUSES;N_IS_INT]);
      (ASM_SIMP_TAC [l4;SUM_CLAUSES_NUMSEG]) THEN
      (ACCEPT_TAC l20)
    ]
  ]
)
let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)
let KEY_LEMMA = PROVE(
    `n > 0 ==>
     p > 0 ==>
    ! i . p <= i /\ i <= (LENGTH (As n p) - 1) ==> integer ((&(FACT i)/ &(FACT p)) * (EL i (As n p)))`,
    let jem0 = ISPECL [`(As n p)`;`i:num`;`integer`] ALL_IMP_EL in
    let jem1 = MP jem0 (UNDISCH (UNDISCH (SPEC_ALL ALL_integer_As)))  in
    let jem3 = ARITH_RULE `LENGTH (As n p) > 0 ==> ((i < LENGTH (As n p)) <=> i <= LENGTH (As n p) - 1)` in
    let jem4 = UNDISCH_ALL ((SPEC_ALL LENGTH_As)) in
    let jem5 = UNDISCH (ARITH_RULE `p > 0 ==> (LENGTH (As n p) >= p) ==> (LENGTH (As n p) > 0)`) in
    let jem6 = MP jem5 jem4 in
    let jem7 = MP jem3 jem6 in
    let jem8 = ONCE_REWRITE_RULE [jem7] jem1 in
    let kem0 = SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV in
    let kem1 = ADD_ASSUM  `p <= (i:num)` (ADD_ASSUM `i <= (LENGTH (As n p) - 1)` kem0) in
    let kem2 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p <= i ==> i <= LENGTH (As n p) -1 ==> i >= p`)] kem1 in
    (REPEAT STRIP_TAC) THEN (SIMP_TAC[UNDISCH jem8;kem2;INTEGER_MUL])
)

let KEY_LEMMA2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     ? K0 .   integer K0
           /\ (&1 / &(FACT ( p - 1))) * (sum (p.. LENGTH (As n p) -1) (\m. EL m (As n p) * &(FACT m))) = (&p) * K0`,
    let lem0000 = SPEC `EL m (As n p)` SATURDAY_LEMMA in
    let lem1000 = DISCH `m <= LENGTH (As n p) -1` (ADD_ASSUM `m <= LENGTH (As n p) -1` (UNDISCH_ALL lem0000)) in
    let lem2000 = DISCH `(m:num) >= p` lem1000 in
    let lem3000 = ONCE_REWRITE_RULE [ARITH_RULE `(m:num) >= p <=> p <= m`] lem2000 in
    let lem4000 = ONCE_REWRITE_RULE [TAUT `(a ==> b ==> c) <=> ((a  /\ b) ==> c)`] (GEN `m:num` lem3000) in
    let lem5000 = MATCH_MP SUM_EQ_NUMSEG lem4000 in
    let nem2 = SPECL [`\x.(&(FACT x)/ &(FACT p)) * (EL x (As n p))`;`LENGTH (As n p) - 1`;`p:num`] IS_INT_SUM in
    let nem3 = BETA_RULE nem2 in
    let nem4 = SIMP_RULE [UNDISCH (UNDISCH KEY_LEMMA)] nem3 in
    let nem5 = ADD_ASSUM `p > 1` (DISCH `p > 0` nem4) in
    let nem6 = SIMP_RULE [(UNDISCH o ARITH_RULE) `(p:num) > 1 ==> p > 0`] nem5 in
    STRIP_TAC THEN STRIP_TAC THEN (ONCE_REWRITE_TAC [GSYM SUM_LMUL]) THEN
    (BETA_TAC) THEN (ONCE_REWRITE_TAC [real_div]) THEN (ONCE_REWRITE_TAC [REAL_MUL_LID]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [GSYM real_div]) THEN (ONCE_REWRITE_TAC [lem5000]) THEN
    (ONCE_REWRITE_TAC [REAL_ARITH `(x1:real) * x2 * x3 = x2 * (x3 * x1)`]) THEN
    (ONCE_REWRITE_TAC [SUM_LMUL]) THEN
    (EXISTS_TAC `sum (p .. LENGTH (As n p) -1) (\x. &(FACT x) / &(FACT p) * EL x (As n p))`) THEN
    (SIMP_TAC [nem6])
)
let NOT_g_NIL = PROVE(
    `!n p . ~ ((g n p ) = [])`,
     SIMP_TAC [Pm_eqn5.PLANETMATH_EQN_5; NOT_CONS_NIL; NOT_POLY_EXP_NIL; NOT_POLY_CMUL_NIL;
               NOT_POLY_MUL_NIL;NOT_POLY_MUL_ITER_NIL]
)
let FACT_DIV_RCANCELS = PROVE(
    `!n x. x / &(FACT n) * &(FACT n) = x`,
    MESON_TAC [REAL_ARITH `!x. &0 < x ==> ~(x = &0)`;
               REAL_DIV_RMUL;FACT_LT;REAL_OF_NUM_LT]
)

let PSUM_ITERATE = PROVE(
    `! n m f. psum (m,n) f
              = if (n > 0) then (iterate (+) (m..((n+m)-1)) f) else &0`,
    let lem01 = ARITH_RULE `~(n+m=0) ==> (SUC n + m) -1 = SUC ((n + m) -1)` in
    let lem02 = MP (ISPEC `(+)` ITERATE_SING) MONOIDAL_REAL_ADD in
    let lem03 = PROVE(
          `iterate (+) (m..SUC ((n + m) - 1)) f
           = f (SUC ((n+m)-1)) + iterate (+) (m..(n+m)-1) f`,
           MESON_TAC [ARITH_RULE `m <= SUC ((n+m)-1)`;ITERATE_CLAUSES_NUMSEG;
                      MONOIDAL_REAL_ADD;REAL_ADD_SYM]) in
    let lem04 = UNDISCH (UNDISCH (ARITH_RULE `~(n+m=0) ==> n=0 ==> m-1 < m`)) in
    let lem05 = SIMP_RULE [lem04] (SPECL [`m:num`;`m-1`] NUMSEG_EMPTY) in
    INDUCT_TAC THENL
    [ SIMP_TAC [ARITH_RULE `~(0 > 0)`;sum_DEF];
      (SIMP_TAC [ARITH_RULE `(SUC n) > 0`]) THEN (REPEAT STRIP_TAC) THEN
      (ASM_CASES_TAC `n + m =0`) THENL
      [ (REWRITE_TAC [UNDISCH (ARITH_RULE `n + m = 0 ==> n = 0`)]) THEN
        (REWRITE_TAC [lem02;NUMSEG_SING;ARITH_RULE `(SUC 0 +m) -1 = m`]) THEN
        (MESON_TAC [sum_DEF; ADD_CLAUSES;REAL_ARITH `&0 + x = x`]) ;
        (ONCE_REWRITE_TAC [sum_DEF;UNDISCH lem01]) THEN
        (REWRITE_TAC [lem03]) THEN (ASM_CASES_TAC `n = 0`) THEN
        (ASM_SIMP_TAC
          [ARITH_RULE `~(0 > 0)`;ADD_CLAUSES;REAL_ADD_LID;REAL_ADD_RID;
           lem05;ITERATE_CLAUSES_GEN; MONOIDAL_REAL_ADD;NEUTRAL_REAL_ADD;
           REAL_ADD_SYM;ADD_SYM;ARITH_RULE `~(n=0) ==> n>0 /\ SUC (n-1) = n`])
      ]
    ]
)


let PLANETMATH_EQN_5_2 = PROVE(
    `p > 1 ==>
     n > 0 ==>
     (? K0.   integer K0
           /\ poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0)`,
    let lem01 = SPECL [`g n p`;`x:real`;`(&0):real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lem02 = GEN_ALL lem01 in
    let lem03 = SPEC_ALL (BETA_RULE lem02) in
    let lem04 = SIMP_RULE [FACT_DIV_RCANCELS] lem03 in
    let lem05 = SIMP_RULE [PSUM_ITERATE] lem04 in
    let lem06 = SIMP_RULE [ARITH_RULE `(n:num) + 0 = n`] lem05 in
    let lem07 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 0` lem06) in
    let lem08 = REWRITE_RULE [GSYM LENGTH_EQ_NIL;ARITH_RULE `~(x = 0) <=> x > 0`] NOT_g_NIL in
    let lem09 = SIMP_RULE [lem08] lem07 in
    let lem10 = CONV_RULE (RAND_CONV (REWRITE_CONV [UNDISCH_ALL (SPEC_ALL g_eq_As)])) lem09 in
    let lem11 = SIMP_RULE [POLY_CMUL_LENGTH] lem10 in
    let lem12 = SPECL [`m:num`;`(As n p)`] EL_PDI_AT_ZERO in
    let lem13 = SIMP_RULE [POLY_CMUL_PDI;POLY_CMUL;lem12] lem11 in
    let lem14 = GSYM (BETA `(\m. poly (poly_diff_iter (As n p) m) (&0)) m`) in
    let lem15 = ISPECL [`(\m. poly (poly_diff_iter (As n p) m) (&0))`;`&1/ &(FACT (p - 1))`;`0..LENGTH (As n p) -1`] SUM_LMUL in
    let lem16 = ONCE_REWRITE_RULE [lem14] lem13 in
    let lem17 = ONCE_REWRITE_RULE [GSYM sum] lem16 in
    let lem18 = SIMP_RULE [GSYM lem17] lem15 in
    let lem20 = SPECL [`(\m.  poly (poly_diff_iter (As n p) m) (&0))`;`(\m. EL m (As n p) * &(FACT m))`;`0`;`LENGTH (As n p) - 1`] SUM_EQ_NUMSEG in
    let lem21 = ONCE_REWRITE_RULE [ARITH_RULE `0 <= i`] (BETA_RULE lem20) in
    let lem22 = ADD_ASSUM `~(As n p = [])` (ONCE_REWRITE_RULE [EL_PDI_AT_ZERO2] lem21) in
    let lem30 = SPECL [`i:num`;`As n p`] EL_PDI_AT_ZERO2 in
    let lem31 = ASM_REWRITE_RULE [] (ADD_ASSUM `~(As n p = [])` lem30) in
    let lem23 = ONCE_REWRITE_RULE [lem31] lem22 in
    let lem24 = REWRITE_RULE [GSYM lem16] lem23 in
    let lem25 = ONCE_REWRITE_RULE [lem24] lem18 in
    let lem30 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-1`;`(LENGTH (As n p) - 1) - (p - 1)`] SUM_ADD_SPLIT in
    let lem31 = SIMP_RULE [ARITH_RULE `0 <= x`] lem30 in
    let lem32 = UNDISCH_ALL (ARITH_RULE `! x. x  >= p ==> (p - 1) + (x - 1) - (p -1)=  x - 1`) in
    let lem33 = UNDISCH_ALL (SPEC_ALL LENGTH_As) in
    let lem34 = SPEC `LENGTH (As n p)` lem32 in
    let lem35 = MP lem34 lem33 in
    let lem36 = ONCE_REWRITE_RULE [UNDISCH (ARITH_RULE `p > 1 ==> (p - 1) + 1 = p`);lem35] lem31 in
    let lem37 = ONCE_REWRITE_RULE [lem36] lem25 in
    let lem38 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (DISCH `p > 0` lem37) in
    let lem39 = ISPECL [`\m. EL m (As n p) * &(FACT m)`;`0`;`p-2`;`1`] SUM_ADD_SPLIT in
    let lem40 = ADD_ASSUM `n > 0` (ADD_ASSUM `p > 1` lem39) in
    let lem41 = SIMP_RULE (map (UNDISCH o ARITH_RULE) [`p > 1 ==> p - 2 + 1 = p-1`;`p > 1 ==> (p - 2) + 1 = p - 1`]) lem40 in
    let lem42 = SIMP_RULE [SUM_SING_NUMSEG;ARITH_RULE `0 <= x`] lem41 in
    let lem45 = ADD_ASSUM `p > 1` (SPEC_ALL prefix_As_zero) in
    let lem46 = SIMP_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> p > 0`)] lem45 in
    let lem47 = UNDISCH (ONCE_REWRITE_RULE [UNDISCH_ALL (ARITH_RULE `p > 1 ==> (i < p-1 <=> i <= p-2)`)] lem46) in
    let lem48 = SIMP_RULE [REAL_ARITH `((&0):real) + x = x`; SUM_EQ_0_NUMSEG;REAL_ARITH `((&0):real) * x = &0`;lem47] lem42 in
    let lem49 = SIMP_RULE [UNDISCH (ARITH_RULE `p > 1 ==> p > 0`)] (ADD_ASSUM `p > 1` (SPEC_ALL fact_As)) in
    let lem50 = SIMP_RULE [UNDISCH lem49] lem48 in
    let lem51 = ONCE_REWRITE_RULE [lem50] lem38 in
    let lem52 = SPECL [`p - 1`;`(&1):real`] FACT_DIV_RCANCELS in
    let lem53 = SIMP_RULE [REAL_ARITH `(x:real) * (y * z) = (x * z) * y`;lem52;REAL_ARITH `(x:real) * (y + z) = (x * y) + (x * z)`] lem51 in
    let lem54 = SIMP_RULE [REAL_ARITH `&1 * x = (x:real)`] lem53 in
    let josh0 = UNDISCH_ALL KEY_LEMMA2 in
    let josh1 = REAL_ARITH `!(y:real) x1 x2 . x1  = x2 <=> y + x1 = y + x2` in
    let josh2 = SPEC `(&(FACT n) pow p * -- &1 pow (n * p)):real` josh1 in
    let josh3 = ONCE_REWRITE_RULE [josh2] josh0 in
    let josh4 = ONCE_REWRITE_RULE [GSYM lem54] josh3 in
    let josh5 = DISCH `~ (As n p = [])` josh4 in
    let jem4 = ADD_ASSUM `p > 1` ((SPEC_ALL LENGTH_As)) in
    (* JOHN: the UNDISCH here is necessary... i don't think it should be *)
    let jem5 = UNDISCH (SIMP_RULE [UNDISCH (ARITH_RULE `(p:num) > 1 ==> p > 0`)] jem4) in
    let jem6 = UNDISCH (ARITH_RULE `p > 1 ==> (LENGTH (As n p) >= p) ==> ~((LENGTH (As n p) = 0))`)  in
    let jem7 = MP jem6 jem5  in
    let jem8 = SIMP_RULE [LENGTH_EQ_NIL] jem7 in
    let josh6 = MP josh5 jem8 in
    let josh7 = DISCH_ALL josh6 in
    let josh11 = ONCE_REWRITE_RULE [GSYM OLD_SUM] lem17 in
    let josh12 = REWRITE_RULE [GSYM josh11] josh7 in
    let josh13 =  SIMP_RULE [] (DISCH_ALL josh12) in
    let josh14 = BRW `(X ==> Y ==> Z ==> W) <=> ((X /\ Y /\ Z) ==> W)` josh13 in
    let josh15 = ONCE_REWRITE_RULE [ARITH_RULE `(p > 0 /\ n > 0 /\ p > 1) <=> (p > 1 /\ n > 0)`] (DISCH_ALL josh14) in
    let josh16 = BRW1 josh15 in
    let josh17 = SIMP_RULE [PSUM_ITERATE;ARITH_RULE `~(0 > 0)`] josh16 in
    ACCEPT_TAC josh17
)
let PLANETMATH_DIVIDES_FACT_PRIME_1 = PROVE (
    `!p n. (prime p) /\ p > n ==> ~(num_divides p (FACT n))`,
    (SIMP_TAC [DIVIDES_FACT_PRIME]) THEN ARITH_TAC
)
let INT_OF_REAL_NEG_NUM = PROVE(
    `!(n:num).int_of_real (-- (real_of_num n)) = -- (int_of_real (real_of_num n))`,
    SIMP_TAC [GSYM int_of_num;GSYM int_of_num_th;GSYM int_neg]
)
let ABS_EQ_ONE = PROVE(
    `!(x:real) .((abs x) = &1) ==> ((x = &1) \/ (x = -- &1))`,
    ARITH_TAC
)
let POW_NEG_1 = PROVE(
   `!(x:num). (((-- (&1 :real)) pow x) = -- &1) \/  (((-- (&1 : real)) pow x) = &1)`,
    let lem00 = ONCE_REWRITE_RULE [TAUT `x \/ y <=> y \/ x`] ABS_EQ_ONE in
    let lem01 = (SPEC `(-- (&1 :real)) pow x` lem00) in
    let lem02 = (SPEC `x:num` POW_M1) in
    let lem03 = MP lem01 lem02 in
    STRIP_TAC THEN (ACCEPT_TAC lem03)
)
let NUM_DIVIDES_INT_DIVIDES = PROVE(
    `!(x:num) (y:num).(x divides y) <=> ((&x):int divides ((&y):int))`,
    (ONCE_REWRITE_TAC [num_divides])  THEN (SIMP_TAC [])
)
let SON_OF_A_GUN = PROVE(
    `! (p:num) (n:num) .
     p > n
     ==> (prime p)
     ==> ~(int_divides (& p) (&(FACT n) pow p * -- &1 pow (n * p) ))`,
    let POW_INT_NEG_1 = INT_OF_REAL_THM POW_NEG_1 in
    let lem0000 = TAUT `(A /\ B ==> C) <=> (A ==> B ==> C)` in
    let lem0001 = ONCE_REWRITE_RULE [lem0000] PLANETMATH_DIVIDES_FACT_PRIME_1 in
    let lem0002 = UNDISCH_ALL (SPEC_ALL lem0001) in
    let lem0008 = ONCE_REWRITE_RULE [TAUT `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)`]  PRIME_DIVEXP in
    let lem0009 = SPECL [`p:num`;`p:num`;`FACT n`] lem0008 in
    let lem0010 = UNDISCH lem0009 in
    let lem0011 = MP lem0010 lem0002 in
     STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN
     (DISJ_CASES_TAC (SPEC `(n * p):num` POW_INT_NEG_1))  THENL
     [ (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM INT_DIVIDES_RNEG]) THEN
       (ONCE_REWRITE_TAC [ARITH_RULE `-- -- (x:int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011);
       (ASM_SIMP_TAC [INT_OF_NUM_POW; ARITH_RULE `x * (--(&1):int) = -- x`;ARITH_RULE `x * ((&1):int) = x`]) THEN
       (ONCE_REWRITE_TAC [GSYM NUM_DIVIDES_INT_DIVIDES]) THEN
       (ACCEPT_TAC lem0011)
     ]
)
let MAY_LEMMA = PROVE(
    `(p:num) > (n:num)
      ==> (prime p)
      ==> ~(int_divides (& p) ((int_of_num (FACT n)) pow p * -- &1 pow (n * p) + &p * K0))`,
      let lem00 = BRW `(x /\ y ==> z) <=> (x ==> ~z ==> ~y)` INT_DIVIDES_ADD_REVR in
      let lem0 = PROVE(`int_divides ((&p):int) (&p * K0)`,INTEGER_TAC) in
      let lem1 = (UNDISCH_ALL o SPEC_ALL) SON_OF_A_GUN in
      let lem2 = SPECL [`(&p):int`;`((&p):int) * K0`; `(&(FACT n) pow p):int *
      -- &1 pow (n * p)` ] lem00 in
      let lem3 = MP (MP lem2 lem0) lem1 in
      let lem4 = (DISCH_ALL lem3) in
      let lem5 = ONCE_REWRITE_RULE [ARITH_RULE `(x:int) + y = y + x`] lem4 in
      (ACCEPT_TAC lem5)
)
let PLANET_MATH_alpha_1 = PROVE(
    `n > 0 ==> p > n ==> prime p ==> (integer (poly (SOD (g n p )) (&0)))`,
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC) THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_REWRITE_TAC[]) THEN
    (ASM_SIMP_TAC [N_IS_INT;INTEGER_ADD;NEG_N_IS_INT;INTEGER_POW;INTEGER_MUL])
)
let PLANET_MATH_alpha_2 = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     ( ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0)))))`,
    let t1 = `integer K0 /\
              poly (SOD (g n p)) (&0) =
              &(FACT n) pow p * -- &1 pow (n * p) + &p * K0` in
    let t = `((real_of_num (FACT n)) pow p) * (-- &1 pow (n * p)) + (&p * K0)` in
    let arch0 = INT_OF_REAL_CONV t in
    let a1 = UNDISCH (UNDISCH (ARITH_RULE `n > 0 ==> p > n ==> p > 1`)) in
    let a2 = UNDISCH (SIMP_RULE [] (DISCH `n > 0` (MP PLANETMATH_EQN_5_2 a1))) in
    let a3 = SPEC `int_of_real K0` (GEN `K0:int` MAY_LEMMA) in
    let a4 = GSYM (UNDISCH arch0) in
    let a5 = ONCE_REWRITE_RULE [a4] a3 in
    STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC THEN (CHOOSE_TAC a2) THEN
    (SPLIT_CONJOINED_ASSUMPT_TAC t1) THEN (ASM_SIMP_TAC [a5])
)
let INT_OF_REAL_NEG_INT_OF_NUM = PROVE(
    `!n. int_of_real(-- (real_of_num n)) = -- int_of_num n`,
    SIMP_TAC [int_of_num;INT_OF_REAL_NEG_NUM]
)
let PLANET_MATH_alpha_3 = PROVE(
     `n > 0 ==> p > n ==> prime p ==>
      (~((poly (SOD (g n p)) (&0)) = &0))`,
      let lem0 = PROVE(
            `!(x:num) (y:real).
               (x > 0) ==>
               (integer y) ==>
               (~(&x divides (int_of_real y))) ==>
               ~(y = &0)`,
              MESON_TAC [is_int;INT_OF_NUM_GT;INT_DIVIDES_RNEG;REAL_OF_NUM_EQ;int_of_num;INT_OF_REAL_NEG_INT_OF_NUM;INT_OF_NUM_EQ;INT_DIVIDES_0]) in
      let lem1 = ARITH_RULE `n > 0 ==> p > n ==> p > 0` in
      MESON_TAC [lem0;lem1; PLANET_MATH_alpha_1; PLANET_MATH_alpha_2]
)
let PLANET_MATH_alpha = PROVE(
    `n > 0 ==> p > n ==> prime p ==>
     (     (integer (poly (SOD (g n p )) (&0)))
       /\ ~((&p) divides (int_of_real (poly (SOD (g n p )) (&0))))
       /\ ~((poly (SOD (g n p)) (&0)) = &0))`,
     SIMP_TAC [PLANET_MATH_alpha_1; PLANET_MATH_alpha_2; PLANET_MATH_alpha_3]
)
let REAL_FACT_NZ = PROVE(
    `~((&(FACT n)) = (real_of_num 0))`,
    let l0 = GSYM (SPECL [`FACT n`;`0`] REAL_OF_NUM_EQ) in
    ACCEPT_TAC (SPEC_ALL (ONCE_REWRITE_RULE [l0] FACT_NZ))
)

let IS_INT_FACT_DIV_FACT_DIV_FACT = PROVE(
    `! i k.integer ((&(FACT (i+k)))/(&(FACT i))/(&(FACT k)))`,
    let l0 = MATCH_MP (ARITH_RULE `(~(x=0)) ==> 0 < x`) (SPEC `k:num` FACT_NZ) in
    let l1 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] l0 in
    let l2 = MATCH_MP REAL_EQ_LDIV_EQ l1 in
    (REPEAT STRIP_TAC) THEN (REWRITE_TAC [is_int;l2]) THEN
    (EXISTS_TAC ` (binom(i+k,k))`) THEN DISJ1_TAC THEN
    (MESON_TAC [BINOM_FACT;MULT_SYM;MULT_ASSOC;REAL_OF_NUM_MUL;REAL_OF_NUM_EQ])
)

(*  if you replace the second SIMP_TAC with MESON_TAC, it fails!!
 *  (i alwasy thought MESON_TAC was strictly stronger than SIMP_TAC
 *)
let POLY_CMUL_EL = PROVE(
    `!p c i.(i < (LENGTH p)) ==> (EL i (c ## p)) = c * (EL i p)`,
    let l0 = ARITH_RULE `(SUC i) < (SUC j) <=> i < j` in
    LIST_INDUCT_TAC THENL
    [ (SIMP_TAC [LENGTH;ARITH_RULE `~(n < (0:num))`]);
      STRIP_TAC THEN INDUCT_TAC THENL
      [ (SIMP_TAC [poly_cmul;HD;EL]);
        (ASM_SIMP_TAC [LENGTH;poly_cmul;TL;EL;l0])
      ]
    ]
)
let PDI_COEFF_FACT = PROVE(
    `! k q i.(i < LENGTH (poly_diff_iter q k)) ==>
            (EL i (poly_diff_iter q k)) = ((&(FACT (i+k)))/(&(FACT i))) * (EL (i+k) q)`,
    let t0 = `!q i.  i < LENGTH (poly_diff_iter q k)
                  ==> EL i (poly_diff_iter q k) = &(FACT (i + k)) / &(FACT i) * EL (i + k) q` in
    let l0 = SPECL [`q:(real)list`;`SUC i`] ( ASSUME t0) in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `(SUC i) < x <=> i < (PRE x)`] l0 in
    let l2 = ONCE_REWRITE_RULE [GSYM LENGTH_POLY_DIFF] l1 in
    let l3 = ONCE_REWRITE_RULE [FACT;GSYM REAL_OF_NUM_MUL] l2 in
    let l4 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_MUL] l3 in
    let l5 =  REWRITE_RULE [real_div;REAL_INV_MUL] l4 in
    let l6 = REAL_ARITH `(w * (inv x) * y ) * z = (w * y * z) * (inv x)` in
    let l9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_LT] (ARITH_RULE `0 < SUC i`) in
    let l10 = MATCH_MP REAL_EQ_RDIV_EQ l9 in
    let l11 = ONCE_REWRITE_RULE [l6] l5 in
    let l12 = ONCE_REWRITE_RULE [real_div] l10 in
    let l13 = ONCE_REWRITE_RULE [l12] l11 in
    INDUCT_TAC THENL
    [ (REWRITE_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `i + 0 = i`]) THEN
      (MESON_TAC [REAL_DIV_REFL;FACT_NZ;REAL_OF_NUM_EQ;REAL_ARITH `(real_of_num 1) * x = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN (SIMP_TAC [EL_POLY_DIFF]) THEN
      (ONCE_REWRITE_TAC [ARITH_RULE `i + (SUC k) = (SUC i) + k`]) THEN
      (ONCE_REWRITE_TAC [FACT]) THEN (ONCE_REWRITE_TAC [real_div]) THEN
      (SIMP_TAC [l13;real_div;REAL_MUL_ASSOC])
    ]
)
(* I think this should hold if we replace [--a;&1] with an arbitrary polynomial q,
 * however the existing ORDER* theorems would not be sufficient to prove it and
 * I don't feel like putting in the effort right now
 *)
let POLY_DIVIDES_POLY_DIFF = PROVE(
    `!p n a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides (poly_exp [--a;&1] n) (poly_diff p))`,
    let l0 = ARITH_RULE `op = SUC odp ==> SUC n <= op ==> n <= odp` in
    let l1 = ARITH_RULE `(SUC n <= m ) ==> ~(m = 0)` in
    MESON_TAC [l0;l1;POLY_DIFF_ZERO;ORDER_DIVIDES;ORDER_DIFF]
)
let POLY_DIVIDES_MUL = PROVE(
    `!p1 p2 p3.poly_divides p1 p2 ==> poly_divides p1 (p2 ** p3)`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `q ** p3`) THEN
    (ASM_MESON_TAC [FUN_EQ_THM;POLY_MUL;POLY_MUL_ASSOC])
)
let POLY_DIVIDES_MUL3 = PROVE(
    `!p1 p2 p3.(poly_divides p1 p2) ==> (poly_divides p1 (p3 ** p2))`,
    (ONCE_REWRITE_TAC [divides]) THEN (REPEAT STRIP_TAC) THEN
    (EXISTS_TAC `p3 ** q`) THEN (UNDISCH_TAC `poly (p2) = poly (p1 ** q)`) THEN
    (ONCE_REWRITE_TAC [FUN_EQ_THM]) THEN (REWRITE_TAC [POLY_MUL]) THEN
    (MESON_TAC [REAL_MUL_ASSOC;REAL_MUL_SYM])
)
let POLY_DIVIDES_POLY_MUL_ITER = PROVE(
    `!f n v. 1 <= v ==> v <= n ==> poly_divides (f v) (poly_mul_iter f n)`,
    let l1 = ARITH_RULE `~(v <= n) ==> (v <= SUC n) ==> v = SUC n` in
    let l2 = UNDISCH (UNDISCH l1) in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ ARITH_TAC;
      (ONCE_REWRITE_TAC [Pm_eqn5.POLY_MUL_ITER]) THEN STRIP_TAC THEN
      (ASM_CASES_TAC `v <= (n:num)`) THENL
      [ ASM_MESON_TAC [POLY_DIVIDES_MUL3];
        STRIP_TAC THEN STRIP_TAC THEN
        (MESON_TAC [l2;POLY_DIVIDES_MUL;POLY_DIVIDES_REFL]) ]
    ]
)
(*
 *  This one was suprisingly tricky to prove...
 *)
let POLY_DIVIDES_POLY_EXP2 = PROVE(
    `!n p1 p2.(poly_divides p1 p2) ==> poly_divides (poly_exp p1 n) (poly_exp p2 n)`,
    let t0 = `!p1 p2.
                (?q. poly p2 = poly (p1 ** q))
                ==> (?q. poly (poly_exp p2 n) = poly (poly_exp p1 n ** q))` in
    let l0 = ASSUME t0 in
    let l1 = UNDISCH (REWRITE_RULE [divides] (SPEC_ALL l0)) in
    let l3 = PROVE(
        `(x2 = x5 * x6 /\ x1 = x4 * x7) ==> (x1:real) * x2 = (x4 * x5) * x6 * x7`,
         MESON_TAC [REAL_MUL_SYM;REAL_MUL_ASSOC]) in
   (ONCE_REWRITE_TAC [divides]) THEN INDUCT_TAC THENL
   [ (MESON_TAC [divides;poly_exp;POLY_DIVIDES_REFL]);
     (STRIP_TAC THEN STRIP_TAC THEN DISCH_TAC) THEN (CHOOSE_TAC l1) THEN
     (UNDISCH_TAC `?q. poly p2 = poly (p1 ** q)`) THEN STRIP_TAC THEN
     (ONCE_REWRITE_TAC [poly_exp]) THEN (EXISTS_TAC `q ** q'`) THEN
     (REWRITE_TAC [poly_exp;FUN_EQ_THM;POLY_MUL]) THEN
     (ASM_MESON_TAC [l3;FUN_EQ_THM;POLY_MUL])
   ]
)
let POLY_EXP_ONE = PROVE(
    `!p .p = poly_exp p 1`,
    MESON_TAC [poly_exp;ARITH_RULE `1 = SUC 0`;POLY_MUL_RID]
)
let POLY_DIVIDES_ROOT = PROVE(
    `!p a.poly_divides [--a;&1] p ==> (poly p a) = &0`,
    MESON_TAC [ORDER_ROOT;ORDER_DIVIDES;POLY_EXP_ONE;
               ARITH_RULE `1 <= ord ==> ~(ord = 0)`]
)

let POLY_DIVIDES_PDI = PROVE(
    `!n p a.
         (poly_divides (poly_exp [--a;&1] (SUC n)) p)
         ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
    let t0 = `!p a.  poly_divides (poly_exp [--a; &1] (SUC n)) p
                     ==> poly_divides [--a; &1] (poly_diff_iter p n)` in
    let l0 = ASSUME t0 in
    let l1 = SPEC `poly_diff p` l0 in
    let l2 = SPECL [`p:(real)list`;`SUC n`;`a:real`] POLY_DIVIDES_POLY_DIFF in
    let l3 = UNDISCH l2 in
    let l4 = MATCH_MP l1 l3 in
    INDUCT_TAC THENL
    [ (SIMP_TAC [poly_exp;POLY_MUL_RID;Pm_lemma1.PDI_DEF]);
      (REPEAT STRIP_TAC) THEN (ASM_MESON_TAC [l4;Pm_lemma1.PDI_DEF;PDI_POLY_DIFF_COMM])
    ]
)
let POLY_DIVIDES_PDI2 = PROVE(
     `!n m p a.
          m > n
          ==> (poly_divides (poly_exp [--a;&1] m) p)
          ==> (poly_divides [--a;&1] (poly_diff_iter p n))`,
     MESON_TAC [POLY_EXP_DIVIDES;POLY_DIVIDES_PDI;
                ARITH_RULE `m > n <=> (SUC n) <= m`]
)
let TAIL_GUNNER = PROVE(
    ` x < p ==> 1 <= v ==> v <= n ==>
      poly (poly_diff_iter
           (poly_exp [&0; &1] (p - 1) **
            poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
          x)
          (&v)
       = &0 `,
     MESON_TAC [POLY_DIVIDES_ROOT; ARITH_RULE `x < p <=> (p:num) > x`;
                POLY_DIVIDES_PDI2; POLY_DIVIDES_MUL3; POLY_DIVIDES_POLY_EXP2;
                POLY_DIVIDES_POLY_MUL_ITER]
)

let IS_INT_POLY = PROVE(
    `!p x.(integer x) ==> (ALL integer p) ==> integer (poly p x)`,
    LIST_INDUCT_TAC THEN
    (ASM_MESON_TAC [N_IS_INT;ALL;poly;INTEGER_ADD;INTEGER_MUL])
)
(*  surprising the MESON needs so much help with the rewrites here
 *  (i.e. i though i could just hit it with ASM_MESON_TAC with all four thms
 *)
let INV_POLY_CMUL = PROVE(
    `!y x . (~(x = &0)) ==> (x) ## (inv x) ## y = y`,
    LIST_INDUCT_TAC THENL
    [ ASM_MESON_TAC [poly_cmul];
      (REPEAT STRIP_TAC) THEN
      (REWRITE_TAC [poly_cmul;REAL_MUL_ASSOC]) THEN
      (ASM_MESON_TAC [REAL_MUL_RINV;REAL_MUL_LID])
    ]
)
let INV_POLY_CMUL2 = PROVE(
    `!y x . (~(x = &0)) ==> (inv x) ## (x) ## y = y`,
    MESON_TAC [INV_POLY_CMUL;REAL_INV_INV;REAL_INV_EQ_0]
)
(* the final ASM_MESON_TAC fails if poly_cmul is rolled into the thm list *)
let POLY_CMUL_EQUALS = PROVE(
    `!z x y. (~(z = &0)) ==> ((x = y) <=> (z ## x = z ## y))`,
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (SIMP_TAC[]);
      (SPEC_TAC (`x:(real)list`,`x:(real)list`)) THEN
      (SPEC_TAC (`y:(real)list`,`y:(real)list`)) THEN
      (LIST_INDUCT_TAC) THENL
      [ LIST_INDUCT_TAC THENL
        [ (SIMP_TAC [POLY_CMUL_CLAUSES]);
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL])];
        LIST_INDUCT_TAC THENL [
          (ASM_MESON_TAC [POLY_CMUL_CLAUSES;NOT_CONS_NIL]);
          (ONCE_REWRITE_TAC [poly_cmul]) THEN
          (ASM_MESON_TAC [REAL_EQ_LCANCEL_IMP;CONS_11])]
      ]
    ]
)
let PDI_LENGTH_THM = PROVE(
    `!f n. LENGTH(poly_diff_iter f n) = (LENGTH f) - n`,
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (SIMP_TAC [Pm_lemma1.PDI_DEF;ARITH_RULE `(x:num) - 0 = x`]);
      (ONCE_REWRITE_TAC [Pm_lemma1.PDI_DEF]) THEN
      (ONCE_REWRITE_TAC [LENGTH_POLY_DIFF]) THEN ASM_ARITH_TAC ]
)
let CAPTAINS_CLOTHES = PROVE(
    `! k q.
     (ALL integer q) ==>
     ? r .(ALL integer r) /\ r = (inv (&(FACT k))) ## (poly_diff_iter q k)`
    ,
    let e0 = `(inv (&(FACT k))) ## (poly_diff_iter q k)` in
    let l1 = ONCE_REWRITE_RULE [GSYM (SPEC `inv (&(FACT k))` POLY_CMUL_LENGTH)]
                               PDI_COEFF_FACT in
    let l2 = UNDISCH (SPEC_ALL l1) in
    let l3 = PROVE(`i < LENGTH( inv (&(FACT k)) ## poly_diff_iter q k)
                     ==> (i + k) < LENGTH q`,
                    MESON_TAC [PDI_LENGTH_THM;POLY_CMUL_LENGTH;
                               ARITH_RULE `(i:num) < f -k ==> (i+k) < f`]) in
    (REPEAT STRIP_TAC) THEN (EXISTS_TAC e0) THEN (SIMP_TAC []) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [GSYM ALL_EL]) THEN (REPEAT STRIP_TAC) THEN
    (ASM_SIMP_TAC [ONCE_REWRITE_RULE [GSYM POLY_CMUL_LENGTH] POLY_CMUL_EL]) THEN
    (ONCE_REWRITE_TAC [l2]) THEN (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
    (MATCH_MP_TAC INTEGER_MUL) THEN STRIP_TAC THENL
    [ (MESON_TAC [IS_INT_FACT_DIV_FACT_DIV_FACT;REAL_MUL_SYM;real_div;REAL_MUL_ASSOC]);
      (ASM_MESON_TAC  [l3;ALL_IMP_EL]) ]
)
let MESSY_JESSE2 = PROVE(
  `n > 0 ==> p > n ==>
     (? (Bs:num->num->real). ! v .
         (1 <= v) ==> (v <= n) ==>
         (    (! i . (integer (Bs v i)))
           /\ (poly (SOD (g n p)) (&v)) =
                 ((real_of_num 1) / (&(FACT (p - 1)))) *
                   (psum (0,LENGTH (g n p))
                      (\i. (&(FACT i)) * (Bs v i)))
           /\ (! i. (i < p) ==> (Bs v i) = &0)  ))`,
    let root_canal = REAL_ARITH `(x:real) * (&0) = &0` in
    let bs = `\(v:num) . \(x:num).
               if (x <= (LENGTH (g n p)) ) then
                    (poly
                       ((inv (&(FACT x))) ##
                        (poly_diff_iter
                        (poly_exp [&0; &1] (p - 1) **
                         poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)
                        x))
                       (&v))
               else (&0)` in
    let l0 = PROVE(`ALL integer [&0;&1]`,MESON_TAC [ALL;N_IS_INT]) in
    let t0 = `(poly_exp [&0; &1] (p - 1) **
              poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)` in
    let l2 = SPECL [`i:num`;t0] CAPTAINS_CLOTHES in
    let l3 = PROVE(`ALL integer (poly_exp [&0; &1] (p - 1) ** poly_exp (poly_mul_iter (\i. [-- &i; &1]) n) p)`,MESON_TAC[l0;ALL_IS_INT_POLY_MUL;ALL_IS_INT_POLY_EXP;ALL_IS_INT_POLY_MUL_ITER]) in
    let l4 = MP l2 l3 in
    let l7 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] FACT_NZ in
    let l8 = (SIMP_RULE [l7]) (SPEC `(&(FACT i)):real` POLY_CMUL_EQUALS) in
    (* these are not true for x =0, however we only use it for x= &(FACT i) *)
    let l10_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL in
    let l12_0 = SPECL [`y:(real)list`;`(real_of_num (FACT i))`] INV_POLY_CMUL2 in
    let l10 = SIMP_RULE [REAL_FACT_NZ] l10_0 in
    let l12 = SIMP_RULE [REAL_FACT_NZ] l12_0 in
    let l9 = ONCE_REWRITE_RULE [l8] l4 in
    let l11 = GSYM (ONCE_REWRITE_RULE [l10] l9) in
    let l133 = PROVE(`
      (psum (0,m) (\i.(x i) * (if i <= m then (y i) else c))) =
      (psum (0,m) (\i.(x i) * (y i)))`,
      MESON_TAC [SUM_EQ;ARITH_RULE `(0 <= i /\ i < (m:num) + 0) ==> i <= m`]) in
    let l18 = MATCH_MP REAL_MUL_RINV (SPEC `i:num` l7) in
    let lass2 = SPECL [`g n p`;`x:real`;`v:real`] Pm_lemma2.PLANETMATH_LEMMA_2_B in
    let lass3 = BETA_RULE lass2 in
    let lass4 = CONV_RULE (RAND_CONV (RAND_CONV (REWRITE_CONV [Pm_eqn5.PLANETMATH_EQN_5]))) lass3 in
    let lass5 = REWRITE_RULE [POLY_CMUL;POLY_CMUL_PDI] lass4 in
    let lass6 = CONV_RULE (RAND_CONV (ONCE_REWRITE_CONV [GSYM (ISPEC `f:num->real` ETA_AX)])) (SPEC_ALL SUM_CMUL) in
    let lass7 = ONCE_REWRITE_RULE [GSYM REAL_MUL_ASSOC] lass5 in
    let lass8 = REWRITE_RULE [lass6] lass7 in
    let lass10 = ONCE_REWRITE_RULE [REAL_MUL_DIV_ASSOC] lass8 in
    let lass11 =  ONCE_REWRITE_RULE [real_div] lass10 in
    let lass12 = REAL_ARITH `((w:real) * x * y) * z = w * x * y * z` in
    let lass13 = ONCE_REWRITE_RULE [lass12] lass11 in
    let lass14 = REWRITE_RULE [lass6] lass13 in
    let MUL_ONE = REAL_ARITH `! x.(&1) * x = x /\ x * (&1) = x` in
    let lass15 = SIMP_RULE [REAL_MUL_LINV;REAL_FACT_NZ;MUL_ONE] lass14 in
    STRIP_TAC THEN STRIP_TAC THEN (EXISTS_TAC bs) THEN (REPEAT STRIP_TAC) THENL
    [
      (BETA_TAC THEN BETA_TAC) THEN (ASM_CASES_TAC `(i <= LENGTH (g n p))`) THENL
      [ (ASM_SIMP_TAC[]) THEN (ASM_CASES_TAC `((i:num) < p)`) THENL
        [ (ASM_MESON_TAC [POLY_CMUL;TAIL_GUNNER;
                          N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `~(i < (p:num)) ==> (p <= i)`))) THEN
          (CHOOSE_TAC l11) THEN
          (SPLIT_CONJOINED_ASSUMPT_TAC (snd (dest_exists (concl l11)))) THEN
          (ASM_REWRITE_TAC[l12]) THEN
          (ASM_MESON_TAC [N_IS_INT;IS_INT_POLY])
        ];
        (ASM_MESON_TAC [N_IS_INT])
      ];
      (BETA_TAC) THEN (SIMP_TAC [l133]) THEN
      (SIMP_TAC [POLY_CMUL;l18;REAL_MUL_ASSOC;REAL_MUL_LID]) THEN
      (SIMP_TAC [lass15;REAL_INV_1OVER]);
      BETA_TAC THEN (ASM_MESON_TAC [TAIL_GUNNER;POLY_CMUL;root_canal])
    ]
)
let INTEGER_PSUM = PROVE(
    `!f m.(! i . i < m ==> integer (f i)) ==> (integer (psum (0,m) f))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;N_IS_INT]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (STRIP_TAC) THEN (MATCH_MP_TAC INTEGER_ADD) THEN
      (ASM_MESON_TAC[l2;ARITH_RULE `(i:num) < m ==> i < SUC m`])
    ]
)
let INT_DIVIDES_PSUM = PROVE(
    `!f m p.(! i . i < m ==>
             ((integer (f i)) /\ (int_divides p (int_of_real (f i)))))
                ==> (int_divides p (int_of_real (psum (0,m) f)))`,
    let l0 = ASSUME `!i. i < SUC m ==> integer (f i) /\ p divides int_of_real (f i)` in
    let l1 = SPEC `m:num` l0 in
    let l2 = SIMP_RULE [ARITH_RULE `m < SUC m`] l1 in
    let l3 = ASSUME `(!i. i < m ==> integer (f i)) ==> integer (psum (0,m) f)` in
    let l4 = SPEC `i:num` l0 in
    let l5 = DISCH `i < SUC m` ((CONJUNCT1 (UNDISCH l4))) in
    let l8 = PROVE(`(!i.i < SUC m
                         ==> (integer (f i))) ==> (!i.i < m ==> (integer (f i)))`,
                   MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]) in
    let ll1 = MP l8 (GEN_ALL l5) in
    let ll2 = MP l3 ll1 in
    let ll3 = MATCH_MP INT_OF_REAL_ADD (CONJ ll2 (CONJUNCT1 l2))  in
    STRIP_TAC THEN INDUCT_TAC THENL
    [ (MESON_TAC [sum;int_of_num;int_of_num_th;INT_DIVIDES_0]);
      (SIMP_TAC [sum;ARITH_RULE `0 + (x:num) = x`]) THEN
      (ASSUME_TAC (SPECL [`f:num->real`;`m:num`] INTEGER_PSUM)) THEN
      (STRIP_TAC) THEN
      (STRIP_TAC) THEN
      (ONCE_REWRITE_TAC [ll3]) THEN
      (MATCH_MP_TAC INT_DIVIDES_ADD) THEN
      (CONJ_TAC) THENL
      [ (ASM_MESON_TAC [ARITH_RULE `i < m ==> i < SUC m`]);
        (ASM_MESON_TAC [ARITH_RULE `m < SUC m`])
      ]
    ]
)
let PLANET_MATH_beta = PROVE(
    `p > n ==>
     n > 0 ==>
     (! v.
       (1 <= v /\ v <= n) ==>
       (   (integer (poly (SOD (g n p )) (&v)))
        /\ ((&p) divides (int_of_real (poly (SOD (g n p )) (&v))))
       )
     )`,
    let l2 = GSYM (ONCE_REWRITE_RULE [REAL_MUL_SYM] real_div) in
    let ll3 = ARITH_RULE `(int_of_num p) * &0 = &0` in
    let l7 = UNDISCH (SPECL [`i:num`;`p:num`] IS_INT_FACT_DIV) in
    let l11 = PROVE(`p > 0 ==> FACT p = p * (FACT (p-1))`,
                    MESON_TAC [FACT; ARITH_RULE `p > 0 ==> SUC (p -1) = p `]) in
    let l12 = UNDISCH (UNDISCH (ARITH_RULE `(p:num) > n ==> n > 0 ==> p > 0`)) in
    let l13 = MP l11 l12 in
    let t9 =
      `1 <= (v:num) ==>
       v <= (n:num) ==>
       (!v. 1 <= v
              ==> v <= n
              ==> (!i. integer (Bs v i)) /\
                  poly (SOD (g n p)) (&v) =
                  &1 / &(FACT (p - 1)) *
                  psum (0,LENGTH (g n p)) (\i. &(FACT i) * Bs v i) /\
                  (!i. i < p ==> Bs v i = &0)) ==>
        (integer (Bs v i))` in
    let lll0 = UNDISCH (UNDISCH (UNDISCH (PROVE(t9,MESON_TAC[])))) in
    let l8 = REWRITE_RULE [l13;real_div;REAL_INV_MUL] l7 in
    let l9 = REWRITE_RULE [N_IS_INT;GSYM REAL_OF_NUM_MUL] l8 in
    let l10 = REWRITE_RULE [REAL_INV_MUL] l9 in
    let l11 = MATCH_MP (INTEGER_MUL) (CONJ l10 lll0) in
    let l12 = MATCH_MP INT_OF_REAL_MUL (CONJ (SPEC `p:num` N_IS_INT) l11) in
    let l15 = GSYM l12 in
    let lll8 = ARITH_RULE `p > n ==> n > 0 ==> ~(p = 0)` in
    let lll9 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_EQ] lll8 in
    let lll10 = UNDISCH (UNDISCH lll9) in

    let sc1 = PROVE (`(~((x:real) = &0)) ==> (x * y * inv x) = y`,
                      MESON_TAC [REAL_MUL_RID;REAL_MUL_ASSOC;
                                 REAL_MUL_SYM;REAL_MUL_LINV;REAL_MUL_LID]) in
    let sc2 = PROVE (`(~((x:real) = &0)) ==> (x * y * (inv x) * z) = y * z`,
                      MESON_TAC [sc1;REAL_MUL_ASSOC]) in
    (REPEAT STRIP_TAC) THENL
      [ (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INTEGER_PSUM) THEN
        (REPEAT STRIP_TAC) THEN
        BETA_TAC THEN
        (ASM_CASES_TAC `i < (p:num)`) THENL
        [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
          (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
          (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                          IS_INT_FACT_DIV; l2;INTEGER_MUL])
        ];
        (CHOOSE_TAC (UNDISCH (UNDISCH MESSY_JESSE2))) THEN
        (ASM_SIMP_TAC []) THEN
        (ONCE_REWRITE_TAC [GSYM SUM_CMUL]) THEN
        (MATCH_MP_TAC INT_DIVIDES_PSUM) THEN
        (REPEAT STRIP_TAC) THENL
        [ BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p-1`))) THEN
            (ASM_MESON_TAC [REAL_INV_1OVER;REAL_MUL_ASSOC;
                            IS_INT_FACT_DIV; l2;INTEGER_MUL])
          ];
          (ONCE_REWRITE_TAC [int_divides]) THEN BETA_TAC THEN
          (ASM_CASES_TAC `i < (p:num)`) THENL
          [ (ASM_SIMP_TAC [N_IS_INT;REAL_ARITH `(x:real) * (&0) = &0`]) THEN
            (EXISTS_TAC `int_of_num 0`) THEN
            (MESON_TAC [ll3;int_of_num_th;int_of_num]);
            (ASSUME_TAC (UNDISCH (ARITH_RULE `(~((i:num) < p)) ==> i >= p`))) THEN
            (EXISTS_TAC `int_of_real (((&(FACT i))/(&(FACT p))) * (Bs (v:num) i))`) THEN
            (ONCE_REWRITE_TAC [int_of_num]) THEN
            (ONCE_REWRITE_TAC [l13]) THEN
            (ONCE_REWRITE_TAC [N_IS_INT;GSYM REAL_OF_NUM_MUL]) THEN
            (SIMP_TAC [ real_div]) THEN
            (ONCE_REWRITE_TAC [ REAL_INV_MUL]) THEN
            (ONCE_REWRITE_TAC [ REAL_MUL_LID]) THEN
            (ONCE_REWRITE_TAC [l15]) THEN
            (ASSUME_TAC lll10) THEN
            (ONCE_REWRITE_TAC [REAL_MUL_ASSOC]) THEN
            (ASM_MESON_TAC [sc2;REAL_MUL_SYM])
          ]
        ]
      ]
)

let JUNE_LEMMA = PROVE(
    `n > 0 ==> p > n ==> v <= n ==> integer (poly (SOD (g n p)) (&v))`,
    let lem0 = CONJUNCT1 (UNDISCH_ALL PLANET_MATH_alpha) in
    let lem1 = UNDISCH_ALL (SPEC_ALL (UNDISCH_ALL PLANET_MATH_beta)) in
    let lem2 = DISCH `1 <= v /\ v <= n` (CONJUNCT1 lem1) in
    let lem3 = SPEC `SUC v` (GEN `v:num` lem2) in
    let lem4 = SIMP_RULE [ARITH_RULE `1 <= SUC v`] lem3 in
    (STRIP_TAC THEN STRIP_TAC) THEN
    (SPEC_TAC (`v:num`,`v:num`)) THEN
    (INDUCT_TAC THENL [(SIMP_TAC [lem0]);(ACCEPT_TAC lem4)])
)
let DIVIDES_SUM_NOT_ZERO = PROVE(
    `!(x:int) (y:int) (z:int).
         (~(z divides x)) /\  (z divides y) ==> ~(x + y = &0)`,
    let l0 = ASSUME `(x:int) + y = &0` in
    let l1 = ONCE_REWRITE_RULE [ARITH_RULE `((x:int) + y = &0) <=> (x = --y)`] l0 in
    (REPEAT STRIP_TAC) THEN (UNDISCH_TAC `~((z:int) divides x)`) THEN
    (REWRITE_TAC [l1]) THEN (UNDISCH_TAC `((z:int) divides y)`) THEN
    (INTEGER_TAC)
)
let NUM_OF_INT_ABS = PROVE(
    `!(x:num) (y:int).num_of_int (abs y)  = x <=> abs y = &x`,
(* stupid... *)
    let j0 = UNDISCH (PROVE(`(num_of_int (abs y) = x) ==> x = num_of_int (abs y)`,MESON_TAC [])) in
    let j1 = ARITH_RULE `&0 <= ((abs y):int)` in
    let j2 = MATCH_MP INT_OF_NUM_OF_INT j1 in
    (REPEAT STRIP_TAC) THEN EQ_TAC THENL
    [ (STRIP_TAC THEN SIMP_TAC [j0;j2]);
      (ASM_SIMP_TAC [NUM_OF_INT_OF_NUM])]
)
let INT_DIVIDES_IMP_ABS_NUM_DIVIDES = PROVE(
    `! (x:int) (y:num).
       (x divides (&y)) ==> ((num_of_int (abs x)) divides y)`,
    let w0 = ARITH_RULE `((&0):int) <= abs x` in
    let w1 = fst (EQ_IMP_RULE (SPEC `abs (x:int)` NUM_OF_INT)) in
    let w2 = MP w1 w0 in
    let w3 = ARITH_RULE `((&0):int) <= x ==> abs x = x` in
    let w4 = ARITH_RULE `(~(((&0):int) <= x)) ==> abs x = -- x` in
    (REWRITE_TAC [int_divides;num_divides]) THEN
    (REPEAT STRIP_TAC) THEN (ASM_REWRITE_TAC [w2]) THEN
    (ASM_CASES_TAC `((&0):int) <= x`) THENL
    [ (ONCE_REWRITE_TAC [UNDISCH w3]) THEN
      (EXISTS_TAC `x':int`) THEN (REFL_TAC);
      (ONCE_REWRITE_TAC [UNDISCH w4]) THEN
      (EXISTS_TAC `--x':int`) THEN (ARITH_TAC)
    ]
)
let INT_PRIME_NUM_PRIME = PROVE(
    `!p. int_prime (&p) <=> prime p`,
    (ONCE_REWRITE_TAC [int_prime;prime]) THEN
    (MESON_TAC [divides;num_divides;
                INT_ABS;INT_POS;INT_OF_NUM_EQ;INT_LT_IMP_NE;INT_GT;
                ARITH_RULE `2 <= p ==> abs((&p):int) > &1`;
                INT_DIVIDES_IMP_ABS_NUM_DIVIDES;NUM_OF_INT_ABS;PRIME_GE_2;
                prime;int_prime ])
)

let DIVIDES_INT_OF_REAL_ADD = PROVE(
         `!x y p.integer x /\
                 integer y /\
                 p divides (int_of_real x) /\
                 p divides (int_of_real y)
                 ==> p divides (int_of_real (x + y))`,
         SIMP_TAC [INT_OF_REAL_ADD;INT_DIVIDES_ADD]
)
let ITCHY_LEMMA = PROVE(
    `! f p n.
       (!v.1<= v /\ v <=  n ==>
        integer (f v) /\
        &p divides int_of_real (f v)) ==>
        (&p divides int_of_real (sum (1..n) f))`,
    let l0 = fst (EQ_IMP_RULE (SPECL [`1`;`0`] (GSYM NUMSEG_EMPTY))) in
    let l1 = INTEGER_RULE `&p divides ((&0))` in
    let l2 = SPEC `0` (GEN_ALL int_of_num) in
    let l3 = ONCE_REWRITE_RULE [l2] l1 in
    let l4 = SPECL [`f:num->real`;`n:num`;`1`] IS_INT_SUM in
    let l5 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> (!i. 1 <= i /\ i <= n ==> integer (f i))`,MESON_TAC [ARITH_RULE `v <= n ==> v <= SUC n`]) in
    let l6 = IMP_TRANS l5 l4 in
    let l7 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> (integer (f v)) /\  (&p) divides int_of_real (f v)) ==> (&p) divides int_of_real (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= (SUC n) /\ SUC n <= SUC n`]) in
    let l9 = PROVE(`(!v. 1 <= v /\ v <= SUC n ==> integer (f v)) ==> integer (f (SUC n))`,MESON_TAC [ARITH_RULE `1 <= SUC n /\ SUC n <= SUC n`]) in
    let tm = `\(v:num).integer (f v) /\ (&p) divides int_of_real (f v)` in
    let l10 = BETA_RULE (SPEC tm SHRIVER) in
    let l11 = UNDISCH (SPEC `1` (GEN `m:num` l10)) in
     STRIP_TAC THEN STRIP_TAC THEN INDUCT_TAC THENL
     [ SIMP_TAC  [ARITH_RULE `0 < 1`;l0;SUM_CLAUSES;l3];
       DISCH_TAC THEN
       (SIMP_TAC [SUM_CLAUSES_NUMSEG;ARITH_RULE `1 <= SUC n`]) THEN
       (MATCH_MP_TAC DIVIDES_INT_OF_REAL_ADD) THEN (CONJ_TAC) THENL
       [ ASM_SIMP_TAC [l6];
         CONJ_TAC THENL
         [ ASM_SIMP_TAC [l9];
           CONJ_TAC THENL
           [ ASM_SIMP_TAC [l11];
             ASM_SIMP_TAC [l7] ]]]]
)
let GOTTA_DO_DISHES_LEMMA = PROVE(
    `!(x:real) (y:real).
       (integer x) /\ (integer y) ==>
       (?(z:int).(~(z divides (int_of_real x)))
           /\ (z divides (int_of_real y)))
       ==> ~(x + y = &0)`,
    let mk_lemma x y =
        let lem0 = SPECL [x;y;`z:int`] DIVIDES_SUM_NOT_ZERO in
        let lem1 = TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)` in
        UNDISCH (UNDISCH (ONCE_REWRITE_RULE [lem1] lem0))
    in
    let mk_tac x y =
        (ASM_REWRITE_TAC [GSYM int_of_num;INT_OF_REAL_NEG_INT_OF_NUM]) THEN
        (STRIP_TAC) THEN
        (REWRITE_TAC [GSYM int_neg_th;GSYM int_eq; GSYM int_add_th;GSYM int_of_num_th]) THEN
        (ACCEPT_TAC (mk_lemma  x y))
    in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (STRIP_TAC THEN STRIP_TAC THEN STRIP_TAC ) THENL
    [ mk_tac `(&n):int` `(&n'):int` ;
      mk_tac `(&n):int` `--(&n'):int` ;
      mk_tac `--(&n):int` `(&n'):int` ;
      mk_tac `--(&n):int` `--(&n'):int`
     ]
)

let RAINY_DAY = PROVE(
    `! p x y.
       prime p ==>
       (&p) > x ==>
       integer x ==>
       x > (&0) ==>
       integer y ==>
       (((&p) divides (int_of_real (x * y)))
        <=> ((&p) divides int_of_real y))`,
    let ss3 = SPECL [`int_of_num n`;`(&p):int`] INT_PRIME_COPRIME_LT in
    let ss4 = ONCE_REWRITE_RULE [ARITH_RULE `abs ((&x):int) = &x`] ss3 in
    let ss40 = PROVE(`!(x:num) (y:num).  (int_of_num x) < (int_of_num y) <=> (real_of_num x) < (real_of_num y)`,SIMP_TAC [INT_OF_NUM_LT;REAL_OF_NUM_LT]) in
    let ss5 = ONCE_REWRITE_RULE [ss40;INT_COPRIME_SYM;INT_PRIME_NUM_PRIME] ss4 in
    let ss6 = SPECL [`(&p):int`;`(&n):int`;`int_of_real y`] INT_COPRIME_DIVPROD in
    let ss7 = ONCE_REWRITE_RULE [TAUT `(X /\ Y ==> Z) <=> (Y ==> X ==> Z)`] ss6 in
    let ss8 = IMP_TRANS ss5 ss7 in
    let ss9 = ONCE_REWRITE_RULE [TAUT `(A /\ B /\ C ==> D ==> E) <=> (A ==> B ==> C ==> D ==> E)`] ss8 in
    let ss10 = UNDISCH ss9 in
    (REPEAT STRIP_TAC) THEN (ASM_SIMP_TAC [INT_OF_REAL_MUL]) THEN
    (EQ_TAC) THENL
    [ (SIMP_TAC [INT_DIVIDES_LMUL]) THEN
      (UNDISCH_TAC `integer x`) THEN
      (ONCE_REWRITE_TAC [is_int]) THEN
      (STRIP_TAC) THENL
      [ (ASM_REWRITE_TAC[]) THEN
        (ONCE_REWRITE_TAC [GSYM int_of_num]) THEN
        (UNDISCH_TAC `(&(p:num)) > (x:real)`) THEN
        (UNDISCH_TAC `(x:real) > &0`) THEN
        (ASM_REWRITE_TAC []) THEN
        (ONCE_REWRITE_TAC [REAL_ARITH `(y:real) > z <=> z < y`]) THEN
        (ACCEPT_TAC ss10);
        (ASM_ARITH_TAC)
      ];
      (SIMP_TAC [INT_DIVIDES_LMUL])
    ]
)
let PLANET_MATH_gamma = PROVE(
    `n > 0 ==>
     p > n ==>
     prime p ==>
     &p > (EL 0 c) ==>
     (EL 0 c) > (&0) ==>
     n = PRE (LENGTH (c)) ==>
     (ALL integer c) ==>
     ( (integer (LHS c (g n p))) /\ ~((LHS c (g n p)) = &0))`,
     let lemma01 = SPECL [`\i. EL i c * poly (SOD (g n p)) (&i)`;`n:num`;`k:num` ] IS_INT_SUM in
     let lemma02 = BETA_RULE lemma01 in
     let lemma021 = UNDISCH JUNE_LEMMA in
     let lemma022 = UNDISCH_ALL (ARITH_RULE `n > 0 ==> p > n ==> p > 1`) in
     let lemma023 = DISCH_ALL (SIMP_RULE [lemma022] lemma021) in
     let lemma04 = UNDISCH (UNDISCH lemma023) in
     let lemma08 = ISPECL [`c:(real)list`;`v:num`;`integer`] ALL_IMP_EL in
     let lemma09 = ADD_ASSUM `n > 0` (UNDISCH lemma08) in
     let lemma10 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma09 in
     let lemma11 = ARITH_RULE `n > 0 ==> (n = PRE (LENGTH (c:(real)list))) ==> ((v < LENGTH c) <=> (v <= n))` in
     let lemma12 = UNDISCH (UNDISCH lemma11) in
     let lemma13 = ONCE_REWRITE_RULE [lemma12] lemma10 in
     let lemma15 = CONJ (UNDISCH (UNDISCH lemma04)) (UNDISCH lemma13) in
     let lemma16 = MATCH_MP INTEGER_MUL (ONCE_REWRITE_RULE [CONJ_SYM] lemma15) in
     let lemma17 = DISCH `v <= (n:num)` lemma16 in
     let lemma18 = ADD_ASSUM_DISCH `k <= (v:num)` lemma17 in
     let lemma19 = ONCE_REWRITE_RULE [TAUT `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)`] lemma18 in
     let lemma20 = GEN `v:num` lemma19 in
     let lemma21 = GEN `k:num` (MATCH_MP lemma02 lemma20) in
     let lemma29 = SPEC `0` lemma21 in
     let lemma30 = GSYM (ASSUME `n = PRE (LENGTH (c:(real)list))`) in
     let lemma300 = SPECL [`f:(num -> real)`;`0`;`PRE (LENGTH (c:(real)list))`] SUM_CLAUSES_LEFT in
     let lemma31 = ADD_ASSUM `n > 0` (ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` lemma300) in
     let lemma32 = MP lemma31 (ARITH_RULE `0 <= PRE (LENGTH (c:(real)list))`) in
     let lemma0000 = BRW `(X ==> Y ==> Z) <=> ((X /\ Y) ==> Z)` GOTTA_DO_DISHES_LEMMA in
     let lemmaa00 = UNDISCH PLANET_MATH_alpha in
     let lemmaa03 = ARITH_RULE `n >0 ==> ((n = PRE (LENGTH (c:(real)list))) ==> 0 < (LENGTH c))` in
     let lemmaa04 = ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL in
     let lemmaa05 = MP (UNDISCH lemmaa04) (UNDISCH (UNDISCH lemmaa03))  in
     let c1 = ARITH_RULE `n > 0 ==> n = PRE (LENGTH (c:(real)list)) ==> 0 < (LENGTH (c:(real)list))` in
     let c2 = UNDISCH (UNDISCH c1) in
     let c3 = MP (UNDISCH lemmaa04) c2 in
     let c4 = CONJUNCT1 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c40 = CONJUNCT2 (UNDISCH (UNDISCH (UNDISCH PLANET_MATH_alpha))) in
     let c5 = SPECL [`p:num`;`(EL 0 c):real`;`poly (SOD (g n p)) (&0)`] RAINY_DAY in
     let c7 = ((UNDISCH (UNDISCH c5))) in
     let c8 = SIMP_RULE [c3] c7 in
     let c9 = UNDISCH c8 in
     let c10 = SIMP_RULE [c4] c9 in
     let d0 = UNDISCH PLANET_MATH_beta in
     let d1 = BRW `(X ==> Y ==> Z) <=> (Y ==> X ==> Z)` d0 in
     let d2 = SIMP_RULE [UNDISCH (ARITH_RULE `p > (n:num) ==> n > 0 ==> p > 1`)] d1 in
     let d3 = UNDISCH d2 in
     let d8 = CONJUNCT2 (UNDISCH (SPEC_ALL d3)) in
     let d9 = SPECL [`(&p):int`;`int_of_real (EL v c)`;`int_of_real (poly (SOD (g n p)) (&v))`] INT_DIVIDES_LMUL in
     let d10 = ADD_ASSUM `ALL integer c` d9 in
     let d11 = ADD_ASSUM `n = PRE (LENGTH (c:(real)list))` d10 in
     let d12 = ADD_ASSUM `1 <= v /\ v <= n` d11 in
     let d13 = CONJUNCT1 (UNDISCH (SPEC_ALL d3)) in
     let d14 = DISCH `1 <= v` (ADD_ASSUM `1 <= v` lemma13) in
     let d15 = BRW `(X ==> Y ==> Z) <=> (X /\ Y ==> Z)` d14 in
     let d16 = UNDISCH d15 in
     let d17 = CONJ d16 d13 in
     let d18 = GSYM (MATCH_MP INT_OF_REAL_MUL d17) in
     let d19 = ONCE_REWRITE_RULE [d18] d12 in
     let d20 = MP d19 d8 in
     let d21 = UNDISCH (SPECL [`1`;`v:num`] (GEN `k:num` lemma20)) in
     let d22 = CONJ d21 d20 in
     let d23 = DISCH `1 <=v /\ v <= n` d22 in
     let d24 = GEN `v:num` d23 in
     let d25 = MATCH_MP ITCHY_LEMMA d24 in
     ((REPEAT STRIP_TAC) THENL
      [ (ONCE_REWRITE_TAC [Pm_eqn4.LHS]) THEN (SIMP_TAC [lemma30;lemma29]);
        (UNDISCH_TAC `LHS c (g n p) = &0`) THEN
        (REWRITE_TAC [Pm_eqn4.LHS]) THEN
        (SIMP_TAC [lemma32;ARITH_RULE `0 + 1 = 1`]) THEN
        (ONCE_REWRITE_TAC [lemma30]) THEN
        (MATCH_MP_TAC lemma0000) THEN
        (CONJ_TAC) THENL
        [ (CONJ_TAC) THENL
          [ (MATCH_MP_TAC INTEGER_MUL) THEN (ASM_SIMP_TAC [lemmaa00;lemmaa05]);
            (ACCEPT_TAC (SPEC `1` lemma21))
          ];
          (EXISTS_TAC `(&p):int`) THEN (CONJ_TAC) THENL
          [(ONCE_REWRITE_TAC [c10]) THEN (ASM_SIMP_TAC [c40]);
           (ACCEPT_TAC d25)
          ]
        ]
      ] )
)
end;;
```
### Informal statement
For all `i`, `p`, and `n`, if `p > 0` and `n > 0`, then if `i < p - 1`, then `EL i (As n p) = &0`.

### Informal sketch
The proof extracts one of the conjuncts from the definition of `as_def`, specifically the property that `EL i (As n p

---

## IS_INT_NZ_ABS_GE_1

### Name of formal statement
IS_INT_NZ_ABS_GE_1

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
For all real numbers `x`, if `x` is an integer and `x` is not equal to 0, then the absolute value of `x` is not less than 1.

### Informal sketch
The proof splits into two cases based on the sign of `x`.
- Case 1: `x` is non-negative. We rewrite `abs x` to `x`. Then we rewrite `x < &1` to its negation `~(x >= &1)`. Using the assumption that x is an integer, we rewrite `x` to `real_of_num n`, where `n` is a natural number. Using `real_of_num`, convert the inequality `~(x >= &1)` to `n < 1`. Then, using arithmetic, we can show `n < 1` to be false, given that `x` is non-zero.
- Case 2: `x` is negative. We rewrite `abs x` to `-x`. We rewrite `x = &0` to `-x = 0`.  We rewrite `&0 <= -x` to `x <= 0`. Using the assumption that x is an integer, we rewrite `x` to `real_of_num n`, where `n` is a natural number. Using `real_of_num`, convert the inequality `-x < 1` to `real_neg (real_of_num n) < 1`, and using arithmetic, we can show `real_neg (real_of_num n) < 1` to be false, given that `x` is non-zero.

### Mathematical insight
This theorem states that the absolute value of a non-zero integer is greater than or equal to 1. This is a fundamental property of integers and is often used in number theory and real analysis.

### Dependencies
- `integer`
- `REAL_ABS_NUM`
- `REAL_OF_NUM_LT`
- `REAL_OF_NUM_EQ`
- `real_abs`
- `REAL_NEG_NEG`

---
### Name of formal statement
PBR_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
For all natural numbers `n1`, `n2`, `n3`, and `p`, if `p` is greater than the maximum of `n1` and the maximum of `n2` and `n3`, then `p` is greater than `n1`, `p` is greater than `n2`, and `p` is greater than `n3`.

### Informal sketch
The proof proceeds by rewriting the `MAX` terms, and then using `ARITH_TAC` to prove the arithmetic inequality.

### Mathematical insight
This lemma states that if a number `p` is greater than the maximum of three numbers `n1`, `n2`, and `n3`, then `p` is greater than each of the individual numbers. This is a basic property of the maximum function.

### Dependencies
- `MAX`

---
### Name of formal statement
BIGGER_PRIME_EXISTS

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
For every natural number `n`, there exists a prime number `p` such that `p` is greater than `n`.

### Informal sketch
The proof uses `PRIMES_INFINITE`, which asserts that there are infinitely many primes. By contradiction, it uses properties of finite sets to conclude that there must be a prime greater than `n`. More specifically, `MESON_TAC` is used with the theorem `PRIMES_INFINITE`, a lemma defining the set of primes, and a lemma stating that `p > n` is equivalent to `~(p <= n)`. This implicitly leverages the fact that if there were no prime greater than `n`, the set of primes would be finite and bounded by `n`, contradicting `PRIMES_INFINITE`.

### Mathematical insight
This theorem asserts that there are infinitely many prime numbers. This is a fundamental theorem in number theory.

### Dependencies
- `PRIMES_INFINITE`
- `IN_ELIM_THM`
- `num_FINITE`
- `INFINITE`

---
### Name of formal statement
BUD_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
For all functions `f` from natural numbers to booleans, and for all natural numbers `n1` and `n2`, if there exists a natural number `N` such that for all natural numbers `p`, if `p` is greater than `N` then `f p` holds, then there exists a natural number `p0` such that `p0` is prime, `p0` is greater than `n1`, `p0` is greater than `n2`, and `f p0` holds.

### Informal sketch
The proof proceeds by supposing that there exists an `N` such that for all `p > N`, `f p` holds. The goal is to show that there exists a prime `p0` such that `p0 > n1`, `p0 > n2`, and `f p0`. The proof uses `BIGGER_PRIME_EXISTS` to show that there exists a prime `p` greater than `MAX N (MAX n1 n2)`. Then, it uses `PBR_LEMMA` to show that `p > N`, `p > n1`, and `p > n2`.  Since `p > N`, `f p` holds by the initial assumption. Thus, `p` is the desired `p0`.

### Mathematical insight
This lemma combines the infinitude of primes with a conditional statement involving a function `f`. If `f p` holds for all sufficiently large `p`, then there exists a prime `p0` greater than `n1` and `n2` for which `f p0` holds. It essentially allows us to find a large prime satisfying a certain property `f`.

### Dependencies
- `BIGGER_PRIME_EXISTS`
- `PBR_LEMMA`

---
### Name of formal statement
ALL_IMP_EL

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
For all lists `l` of type `a`, for all natural numbers `i`, and for all predicates `P` on `a`, if `P` holds for all elements of `l`, then if `i` is less than the length of `l`, then `P` holds for the element at index `i` in `l`.

### Informal sketch
This proof uses `GSYM ALL_EL` and `SIMP_TAC` . In particular, `ALL_EL` states `!l i P. i < LENGTH l ==> ALL P l ==> P (EL i l)`. Therefore, transforming this theorem by using GSYM and applying simplifications proves this theorem.

### Mathematical insight
This theorem states that if a predicate `P` holds for all elements of a list `l`, and `i` is a valid index into the list `l`, then `P` holds for the element at index `i` of the list.

### Dependencies
- `ALL_EL`

---
### Name of formal statement
HAMMS_LEMMA

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
It is not the case that there exists a list `c` such that all elements of `c` are integers, the length of `c` is greater than 1, the element at index 0 of `c` is greater than 0, and for all functions `f`, `LHS c f` equals `RHS c f`.

### Informal sketch
The proof proceeds by contradiction, assuming the existence of such a list `c`. The proof leverages `Pm_eqn4.PLANETMATH_EQN_4` (presumably some equation involving `LHS`,  `RHS` and `gamma`), and then refines the conditions, using `BUD_LEMMA` to obtain a contradiction. Key steps include:

- Instantiate `Pm_eqn4.PLANET_MATH_gamma` which asserts existence of `c:(real)list` such that `gamma c = EL 0 c`. Rewriting the assumption `ALL integer c` which makes planetmath gamma true.
- Applying `IS_INT_NZ_ABS_GE_1` to `gamma c ==> ~(abs (gamma c) < &1)`.
- Then, we apply `BUD_LEMMA` to a specialization of `LT_ONE` (`!(x:real). x < &1 ==> F x`) which makes equation 4(`LHS c f = RHS c f`) to derive absurd conclusion.
- Use `ALL_IMP_EL` to establish that if `ALL integer c`, then the first element of `c` must be an integer since `0 < LENGTH c`.
- Derive a contradiction based on the properties of integers using facts established previously.

### Mathematical insight
This lemma is a crucial step in proving the transcendence of `e`. It shows that certain conditions related to the existence of a list `c` of integers cannot all be simultaneously satisfied. The conditions are related to a specific equation (presumably `LHS c f = RHS c f`) that appears in the proof of transcendence of `e`.

### Dependencies
- `IS_INT_NZ_ABS_GE_1`
- `BUD_LEMMA`
- `ALL_IMP_EL`
- `Pm_eqn4_lhs.PLANET_MATH_gamma`
- `Pm_eqn4_rhs.LT_ONE`

---
### Name of formal statement
TRANSCENDENTAL_E

### Type of the formal statement
theorem

### Formal Content
```ocaml
let IS_INT_NZ_ABS_GE_1 = PROVE (
    `!x. ((integer x) /\ ~(x = &0)) ==> ~(abs x < &1)`,
    let lemmy0 = REAL_ARITH `(x:real) < y <=> ~(y <= x)` in
    let lemmy1 = ONCE_REWRITE_RULE [lemmy0] REAL_NZ_IMP_LT in
    let lemmy2 = REAL_ARITH `(real_neg x) = &0 <=> x = &0` in
    let lemmy3 = REAL_ARITH `&0 <= (real_neg x) <=> x <= &0` in
    (ONCE_REWRITE_TAC [is_int]) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (STRIP_TAC) THEN (STRIP_TAC) THENL
    [ (ASM_REWRITE_TAC[]) THEN (SIMP_TAC [REAL_ABS_NUM] ) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT;REAL_OF_NUM_EQ]) THEN
      (ARITH_TAC);
      (ASM_REWRITE_TAC[]) THEN (ONCE_REWRITE_TAC [real_abs]) THEN
      (ONCE_REWRITE_TAC [lemmy2;lemmy3]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_EQ]) THEN
      (SIMP_TAC [lemmy1;REAL_NEG_NEG]) THEN
      (ONCE_REWRITE_TAC [REAL_OF_NUM_LT]) THEN (ARITH_TAC)
    ]
)
let PBR_LEMMA = PROVE(
    `!n1 n2 n3 p. p > MAX n1 (MAX n2 n3) ==> (p > n1 /\ p > n2 /\ p > n3)`,
    (REWRITE_TAC [MAX]) THEN ARITH_TAC

)
let BIGGER_PRIME_EXISTS = PROVE(
  `!(n:num). ?p. prime p /\ p > n`,
   let lem0 = PROVE(`{x | prime x} = prime`,SET_TAC[]) in
   let lem1 = ARITH_RULE `p > n <=> ~(p <= (n:num))` in
   MESON_TAC [PRIMES_INFINITE;lem0;lem1;IN_ELIM_THM;num_FINITE;INFINITE]
)
let BUD_LEMMA = PROVE(
    `!(f:num->bool) (n1:num) (n2:num).((?(N:num) . !(p:num).p > N ==> f p)
      ==> (? (p0:num).prime p0 /\ p0 > n1 /\ p0 > n2 /\ f p0))`,
    let amigo3 = SPECL [`N:num`;`n1:num`;`n2:num`;`p:num`] PBR_LEMMA in
    let amigo4 = UNDISCH amigo3  in
    (REPEAT STRIP_TAC) THEN
    (CHOOSE_TAC (SPEC  `MAX N (MAX n1 n2)` BIGGER_PRIME_EXISTS )) THEN
    (EXISTS_TAC `p:num`) THEN
    (UNDISCH_TAC `prime p /\ p > MAX N (MAX n1 n2)`) THEN
    (ONCE_REWRITE_TAC [TAUT `(X /\ Y ==> Z) <=> (X ==> Y ==> Z)`]) THEN
    (DISCH_TAC THEN DISCH_TAC) THEN
    (ASM_SIMP_TAC [amigo4])
)

let ALL_IMP_EL = PROVE(
    `! (l:(a)list) i P. (ALL P l) ==> (i < LENGTH l) ==> P (EL i l)`,
    SIMP_TAC[GSYM ALL_EL]
)

let HAMMS_LEMMA = PROVE(
     `~(?c. ALL integer c /\
            LENGTH c > 1 /\
            EL 0 c > &0 /\
            (!f. LHS c f = RHS c f))`,
     let erica0  = UNDISCH_ALL Pm_eqn4_lhs.PLANET_MATH_gamma in
     let erica1  = MATCH_MP IS_INT_NZ_ABS_GE_1 erica0  in
     let erica2  = ASM_REWRITE_RULE [] erica1 in
     let erica3 = SPEC_ALL Pm_eqn4_rhs.LT_ONE in
     let erica4 = MATCH_MP BUD_LEMMA erica3 in
     let erica5 = ADD_ASSUM `ALL integer c` erica4 in
     let erica8 = ARITH_RULE `(n = PRE (LENGTH (c:(real)list))) ==> n > 0 ==>
     0 < (LENGTH c) ` in
     let erica9 = UNDISCH (UNDISCH erica8) in
     let erica10 = UNDISCH (ISPECL [`c:(real)list`;`0`;`integer`] ALL_IMP_EL) in
     let erica11 = MP erica10 erica9 in
     let erica12 = ONCE_REWRITE_RULE [is_int] erica11 in
     let erica13 = ARITH_RULE `!n. ~(( -- (real_of_num n)) > &0)` in
     let erica14 = PROVE(
         `n = PRE (LENGTH c) ==>
          n > 0 ==>
          ALL integer c ==>
          (EL 0 c) > &0 ==>
          ?n. EL 0 c = &n`,
          MESON_TAC [DISCH_ALL erica12;erica13]
     ) in
     let erica15 = UNDISCH_ALL erica14 in
     let sim0 = SELECT_RULE (ASSUME (concl erica15)) in
     let sim1 = DISCH (concl erica15) sim0 in
     let sim2 = MP sim1 erica15 in
     let erica18 = SPECL [`n:num`;`@n. EL 0 c = (real_of_num n)`] erica5 in
     let erica19 = ONCE_REWRITE_RULE [GSYM REAL_OF_NUM_GT] erica18 in
     let erica20 =  ONCE_REWRITE_RULE [GSYM sim2] erica19 in
     let erica21 =  ONCE_REWRITE_RULE [REAL_OF_NUM_GT] erica20 in
     let erica22 = DISCH `(real_of_num p) > EL 0 c` erica2 in
     let erica23 = DISCH `(p:num) > n` erica22 in
     let erica24 = DISCH `prime (p:num)` erica23 in
     let erica25 = GEN `p:num` erica24 in
     let erica28 = UNDISCH (ARITH_RULE `n = PRE (LENGTH (c:(real)list)) ==> ((n > 0) <=> (LENGTH c) > 1)`) in
     let erica29 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica25))) in
     let erica30 = UNDISCH (ONCE_REWRITE_RULE [erica28] (DISCH `n > 0` (erica21))) in
      (CONV_TAC NNF_CONV) THEN
      (REPEAT STRIP_TAC) THEN
      (ASM_MESON_TAC [DISCH_ALL erica29;DISCH_ALL erica30])
)

let TRANSCENDENTAL_E = PROVE(
    `transcendental (exp (&1))`,
    MESON_TAC [HAMMS_LEMMA;Pm_eqn4.PLANETMATH_EQN_4]
)

end;;
```

### Informal statement
The real number `e` (represented by `exp (&1)`) is transcendental.

### Informal sketch
The proof uses `HAMMS_LEMMA` and `Pm_eqn4.PLANETMATH_EQN_4` to apply `MESON_TAC` derive that `exp (&1)` is a transcendental number. Essentially it uses equation 4 to claim that `exp (&1)` is root of such a polynomial.

### Mathematical insight
This theorem states that `e`, the base of the natural logarithm, is a transcendental number. This is a significant result in number theory.

### Dependencies
- `HAMMS_LEMMA`
- `Pm_eqn4.PLANETMATH_EQN_4`


---

